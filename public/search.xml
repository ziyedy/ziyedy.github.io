<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Blender使用Python脚本生成CV数据集</title>
    <url>/page/blender-render-cv-dataset.html</url>
    <content><![CDATA[<h2 id="获取相机内参、旋转平移等基本信息"><a href="#获取相机内参、旋转平移等基本信息" class="headerlink" title="获取相机内参、旋转平移等基本信息"></a>获取相机内参、旋转平移等基本信息</h2><p>参考：<a href="https://blender.stackexchange.com/questions/38009/3x4-camera-matrix-from-blender-camera" target="_blank" rel="noopener">https://blender.stackexchange.com/questions/38009/3x4-camera-matrix-from-blender-camera</a></p>
<p>这个应该是使用blender渲染数据集并获取相应GT信息的标准方法与代码了。</p>
<h3 id="获取相机内参"><a href="#获取相机内参" class="headerlink" title="获取相机内参"></a>获取相机内参</h3><p>主要可以通过在blender中对相机对象及渲染方面的设置得到，</p>
<ol>
<li>定义相机类（以blender中的相机对象作为输入）</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Camera</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, camera)</span>:</span><br>        self.camera = camera<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>获取相机内部传感器的模式与尺寸</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_sensor_size</span><span class="hljs-params">(sensor_fit, sensor_x, sensor_y)</span>:</span><br>    <span class="hljs-keyword">if</span> sensor_fit == <span class="hljs-string">'VERTICAL'</span>:<br>        <span class="hljs-keyword">return</span> sensor_y<br>    <span class="hljs-keyword">return</span> sensor_x<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_sensor_fit</span><span class="hljs-params">(sensor_fit, size_x, size_y)</span>:</span><br>    <span class="hljs-keyword">if</span> sensor_fit == <span class="hljs-string">'AUTO'</span>:<br>        <span class="hljs-keyword">if</span> size_x &gt;= size_y:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">'HORIZONTAL'</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">'VERTICAL'</span><br>    <span class="hljs-keyword">return</span> sensor_fit<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>计算得到相机内参</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_camera_intrinsic</span><span class="hljs-params">(self)</span>:</span><br>    camd = self.camera.data<br>    <span class="hljs-keyword">if</span> camd.type != <span class="hljs-string">'PERSP'</span>:<br>        <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">'Non-perspective cameras not supported'</span>)<br>    scene = bpy.context.scene<br>    f_in_mm = camd.lens<br>    scale = scene.render.resolution_percentage / <span class="hljs-number">100</span><br>    resolution_x_in_px = scale * scene.render.resolution_x<br>    resolution_y_in_px = scale * scene.render.resolution_y<br>    <span class="hljs-comment"># 获取传感器的最长边</span><br>    sensor_size_in_mm = get_sensor_size(camd.sensor_fit, camd.sensor_width, camd.sensor_height)<br>    <span class="hljs-comment"># 获取传感器模式</span><br>    sensor_fit = get_sensor_fit(<br>        camd.sensor_fit,<br>        scene.render.pixel_aspect_x * resolution_x_in_px,<br>        scene.render.pixel_aspect_y * resolution_y_in_px<br>    )<br>    pixel_aspect_ratio = scene.render.pixel_aspect_y / scene.render.pixel_aspect_x<br>    <span class="hljs-keyword">if</span> sensor_fit == <span class="hljs-string">'HORIZONTAL'</span>:<br>        view_fac_in_px = resolution_x_in_px<br>    <span class="hljs-keyword">else</span>:<br>        view_fac_in_px = pixel_aspect_ratio * resolution_y_in_px<br>    pixel_size_mm_per_px = sensor_size_in_mm / f_in_mm / view_fac_in_px<br>    s_u = <span class="hljs-number">1</span> / pixel_size_mm_per_px<br>    s_v = <span class="hljs-number">1</span> / pixel_size_mm_per_px / pixel_aspect_ratio<br><br>	<span class="hljs-comment"># Parameters of intrinsic calibration matrix K</span><br>    u_0 = resolution_x_in_px / <span class="hljs-number">2</span> - camd.shift_x * view_fac_in_px<br>    v_0 = resolution_y_in_px / <span class="hljs-number">2</span> + camd.shift_y * view_fac_in_px / pixel_aspect_ratio<br>    skew = <span class="hljs-number">0</span>  <span class="hljs-comment"># only use rectangular pixels</span><br><br>    K = Matrix(<br>        ((s_u, skew, u_0),<br>        (<span class="hljs-number">0</span>, s_v, v_0),<br>        (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)))<br>    <span class="hljs-keyword">return</span> K<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>根据获取相机内参中的逻辑可以编写通过内参矩阵设置相机内参的代码</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">set_camera_intrinsic</span><span class="hljs-params">(self, K)</span>:</span><br>    scene = bpy.context.scene<br>    camd = self.camera.data<br><br>    scale = scene.render.resolution_percentage / <span class="hljs-number">100</span><br>    resolution_x_in_px = scale * scene.render.resolution_x<br>    resolution_y_in_px = scale * scene.render.resolution_y<br><br>    <span class="hljs-comment"># 获取传感器的最长边</span><br>    sensor_size_in_mm = get_sensor_size(camd.sensor_fit, camd.sensor_width, camd.sensor_height)<br>    <span class="hljs-comment"># 获取传感器模式</span><br>    sensor_fit = get_sensor_fit(<br>        camd.sensor_fit,<br>        scene.render.pixel_aspect_x * resolution_x_in_px,<br>        scene.render.pixel_aspect_y * resolution_y_in_px<br>    )<br>    pixel_aspect_ratio = scene.render.pixel_aspect_y / scene.render.pixel_aspect_x<br>    <span class="hljs-keyword">if</span> sensor_fit == <span class="hljs-string">'HORIZONTAL'</span>:<br>        view_fac_in_px = resolution_x_in_px<br>        <span class="hljs-keyword">else</span>:<br>            view_fac_in_px = pixel_aspect_ratio * resolution_y_in_px<br><br>            camd.lens = K[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>] * sensor_size_in_mm / view_fac_in_px<br>            camd.shift_x = (resolution_x_in_px / <span class="hljs-number">2</span> - K[<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]) / view_fac_in_px<br>            camd.shift_y = ((K[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] - resolution_y_in_px / <span class="hljs-number">2</span>) * pixel_aspect_ratio) / view_fac_in_px<br></code></pre></td></tr></table></figure>

<h3 id="获取物体旋转平移矩阵"><a href="#获取物体旋转平移矩阵" class="headerlink" title="获取物体旋转平移矩阵"></a>获取物体旋转平移矩阵</h3><p>主要在于获取相机在世界坐标系的位置（经过转化后可以视为blender中内置的坐标）与旋转，以及目标物体在世界坐标系中的位置与旋转，之后可以根据定义计算得到。</p>
<ol>
<li>获取相机的外参矩阵（代码逻辑可以参考上述stackexchange中的内容）</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_camera_extrinsic</span><span class="hljs-params">(self)</span>:</span><br>    R_bcam2cv = Matrix(<br>        ((<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>         (<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>),<br>         (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">-1</span>)))<br><br>    location, rotation = self.camera.matrix_world.decompose()[<span class="hljs-number">0</span>: <span class="hljs-number">2</span>]<br><br>    R_world2bcam = rotation.to_matrix().transposed()<br>    T_world2bcam = <span class="hljs-number">-1</span> * R_world2bcam @ location<br><br>    R_world2cv = R_bcam2cv @ R_world2bcam<br>    T_world2cv = R_bcam2cv @ T_world2bcam<br><br>    RT = Matrix((<br>        R_world2cv[<span class="hljs-number">0</span>][:] + (T_world2cv[<span class="hljs-number">0</span>],),<br>        R_world2cv[<span class="hljs-number">1</span>][:] + (T_world2cv[<span class="hljs-number">1</span>],),<br>        R_world2cv[<span class="hljs-number">2</span>][:] + (T_world2cv[<span class="hljs-number">2</span>],),<br>        (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>)<br>    ))<br><br>    <span class="hljs-keyword">return</span> RT<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>获取物体相对于blender原点的旋转与平移</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">transform_matrix = obj.matrix_world.copy()	// obj为获得的物体<br>gt_rt = camera_param[<span class="hljs-string">'RT'</span>] @ obj_matrix		// 相机外参与获取物体相乘<br></code></pre></td></tr></table></figure>

<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>1、当物体相对原点有旋转与平移的情况</p>
<p>obj与ply的存储坐标有不同（没有详细查看文件格式，但经过实验应该是这样的，如下图所示，即obj在读入blender中时会在x轴自带90度的旋转）</p>
<p>所以如果使用obj文件进行渲染时，在获取目标平移旋转矩阵时不进行以上第2步，则不能得到正确的GT值，需要注意。</p>
<p><img src="http://cdn.ziyedy.top/Blender%E4%BD%BF%E7%94%A8Python%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90CV%E6%95%B0%E6%8D%AE%E9%9B%86/obj_and_ply.png" alt=""></p>
<p>2、对物体进行刚体运动后<code>matrix_world</code>没变</p>
<p>这是由于blender没有在物体转变后立刻重新计算，在blender2.8的版本下需要在刚体变化后加上如下代码，参考<a href="https://blender.stackexchange.com/questions/27667/incorrect-matrix-world-after-transformation" target="_blank" rel="noopener">https://blender.stackexchange.com/questions/27667/incorrect-matrix-world-after-transformation</a></p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">context.view_layer.update()<br></code></pre></td></tr></table></figure>



<h2 id="渲染背景图片"><a href="#渲染背景图片" class="headerlink" title="渲染背景图片"></a>渲染背景图片</h2><p>即让对应的模型带上背景图片，参考<a href="https://henryegloff.com/how-to-render-a-background-image-in-blender-2-8/" target="_blank" rel="noopener">https://henryegloff.com/how-to-render-a-background-image-in-blender-2-8/</a></p>
<p>在blender中的处理流程如下（在<code>Compositor</code>模式下）</p>
<p><img src="http://cdn.ziyedy.top/Blender%E4%BD%BF%E7%94%A8Python%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90CV%E6%95%B0%E6%8D%AE%E9%9B%86/bg_render.png" alt=""></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><ol>
<li>获取作为背景的图片</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">bg_img = bpy.data.images.load(filepath=<span class="hljs-string">"/path/to/bg_img.png"</span>)<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>传入背景图片，使用脚本完成节点的构建</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">render_rgb</span><span class="hljs-params">(bg_img)</span>:</span><br>    scene = bpy.context.scene<br>    scene.use_nodes = <span class="hljs-literal">True</span><br>    tree = scene.node_tree<br>    links = tree.links<br>    links.clear()<br><br>    <span class="hljs-comment"># 合成渲染</span><br>    composite_node = tree.nodes[<span class="hljs-string">"Composite"</span>]<br>    rl_node = tree.nodes[<span class="hljs-string">"Render Layers"</span>]<br><br>    img_node = tree.nodes.new(type=<span class="hljs-string">"CompositorNodeImage"</span>)<br>    scale_node = tree.nodes.new(type=<span class="hljs-string">"CompositorNodeScale"</span>)<br>    ao_node = tree.nodes.new(type=<span class="hljs-string">"CompositorNodeAlphaOver"</span>)<br><br>    img_node.image = bg_img<br><br>    scale_node.space = <span class="hljs-string">'RENDER_SIZE'</span><br>    scale_node.frame_method = <span class="hljs-string">'CROP'</span><br><br>    links.new(img_node.outputs[<span class="hljs-string">'Image'</span>], scale_node.inputs[<span class="hljs-string">'Image'</span>])<br>    links.new(scale_node.outputs[<span class="hljs-string">'Image'</span>], ao_node.inputs[<span class="hljs-number">1</span>])<br>    links.new(rl_node.outputs[<span class="hljs-string">'Image'</span>], ao_node.inputs[<span class="hljs-number">2</span>])<br><br>    links.new(ao_node.outputs[<span class="hljs-string">'Image'</span>], composite_node.inputs[<span class="hljs-string">'Image'</span>])<br><br>    scene.render.filepath = cfg.OUTPUT_DIR + <span class="hljs-string">'test.png'</span><br></code></pre></td></tr></table></figure>



<h3 id="为物体加上阴影"><a href="#为物体加上阴影" class="headerlink" title="为物体加上阴影"></a>为物体加上阴影</h3><p>添加plane在需要投影的位置并且合理设置灯光即可得到物体相对的投影，参考</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">bpy.ops.mesh.primitive_plane_add()	// 新建plane<br>bpy.context.object.cycles.is_shadow_catcher = <span class="hljs-literal">True</span>	// 设置相应的渲染属性<br></code></pre></td></tr></table></figure>

<h3 id="渲染结果"><a href="#渲染结果" class="headerlink" title="渲染结果"></a>渲染结果</h3><p><img src="http://cdn.ziyedy.top/Blender%E4%BD%BF%E7%94%A8Python%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90CV%E6%95%B0%E6%8D%AE%E9%9B%86/background.png" alt=""></p>
<h2 id="生成深度图"><a href="#生成深度图" class="headerlink" title="生成深度图"></a>生成深度图</h2><p>在blender中的处理流程如下（在<code>Compositor</code>模式下），其实就是在渲染背景图的基础上新添加了一个用于处理depth的节点与一个渲染输出节点</p>
<p><img src="http://cdn.ziyedy.top/Blender%E4%BD%BF%E7%94%A8Python%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90CV%E6%95%B0%E6%8D%AE%E9%9B%86/depth_render.png" alt=""></p>
<h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><ol>
<li>设置节点及连接渲染得到exr格式的深度图</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">render_depth</span><span class="hljs-params">()</span>:</span><br>    scene = bpy.context.scene<br>    tree = scene.node_tree<br>    links = tree.links<br><br>    rl_node = tree.nodes[<span class="hljs-string">"Render Layers"</span>]<br><br>    map_node = tree.nodes.new(type=<span class="hljs-string">"CompositorNodeMapRange"</span>)<br>    map_node.inputs[<span class="hljs-number">1</span>].default_value = <span class="hljs-number">0</span><br>    map_node.inputs[<span class="hljs-number">2</span>].default_value = <span class="hljs-number">2</span><br>    map_node.inputs[<span class="hljs-number">3</span>].default_value = <span class="hljs-number">0</span><br>    map_node.inputs[<span class="hljs-number">4</span>].default_value = <span class="hljs-number">1</span><br><br>    depth_file_output = tree.nodes.new(type=<span class="hljs-string">"CompositorNodeOutputFile"</span>)<br>    depth_file_output.base_path = <span class="hljs-string">''</span><br>    depth_file_output.format.file_format = <span class="hljs-string">'OPEN_EXR'</span><br>    depth_file_output.format.color_depth = <span class="hljs-string">'32'</span><br><br>    links.new(rl_node.outputs[<span class="hljs-string">'Depth'</span>], map_node.inputs[<span class="hljs-number">0</span>])<br>    links.new(map_node.outputs[<span class="hljs-number">0</span>], depth_file_output.inputs[<span class="hljs-number">0</span>])<br><br>    depth_file_output.file_slots[<span class="hljs-number">0</span>].path = cfg.OUTPUT_DIR + <span class="hljs-string">'depth_'</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>将渲染得到的exr格式的深度图转化为常用的png格式，需要安装<code>OpenEXR</code>库</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">// 先转化为png再删除exr文件<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exr_to_png</span><span class="hljs-params">(exr_path)</span>:</span><br>    depth_path = exr_path.replace(<span class="hljs-string">'.exr'</span>, <span class="hljs-string">'.png'</span>)<br>    exr_image = OpenEXR.InputFile(exr_path)<br>    dw = exr_image.header()[<span class="hljs-string">'dataWindow'</span>]<br>    (width, height) = (dw.max.x - dw.min.x + <span class="hljs-number">1</span>, dw.max.y - dw.min.y + <span class="hljs-number">1</span>)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_exr</span><span class="hljs-params">(s, width, height)</span>:</span><br>        mat = np.fromstring(s, dtype=np.float32)<br>        mat = mat.reshape(height, width)<br>        <span class="hljs-keyword">return</span> mat<br><br>    dmap, _, _ = [read_exr(s, width, height) <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span><br>                  exr_image.channels(<span class="hljs-string">'BGR'</span>, Imath.PixelType(Imath.PixelType.FLOAT))]<br>    dmap = Image.fromarray((dmap != <span class="hljs-number">1</span>).astype(np.int32))<br>    dmap.save(depth_path)<br>    exr_image.close()<br>    os.system(<span class="hljs-string">'rm &#123;&#125;'</span>.format(exr_path))<br></code></pre></td></tr></table></figure>





<h2 id="生成Mask"><a href="#生成Mask" class="headerlink" title="生成Mask"></a>生成Mask</h2><p>生成mask关键在于删除物体已有材质，之后将物体的材质设置成某颜色（或标准的数值），参考<a href="https://blender.stackexchange.com/questions/80906/create-a-segmentation-picture-with-each-object-class-rendered-in-different-color/80925#80925" target="_blank" rel="noopener">https://blender.stackexchange.com/questions/80906/create-a-segmentation-picture-with-each-object-class-rendered-in-different-color/80925#80925</a></p>
<p><img src="http://cdn.ziyedy.top/Blender%E4%BD%BF%E7%94%A8Python%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90CV%E6%95%B0%E6%8D%AE%E9%9B%86/mask_render.png" alt=""></p>
<h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">render_mask</span><span class="hljs-params">()</span>:</span><br>    scene = bpy.context.scene<br>    objs = [obj <span class="hljs-keyword">for</span> obj <span class="hljs-keyword">in</span> bpy.data.objects <span class="hljs-keyword">if</span> obj.type <span class="hljs-keyword">in</span> (<span class="hljs-string">"MESH"</span>, <span class="hljs-string">"CURVE"</span>)]<br>    <span class="hljs-keyword">for</span> obj_idx, obj <span class="hljs-keyword">in</span> enumerate(objs):<br>        color = cfg.colors[obj_idx] + (<span class="hljs-number">1</span>,)	<span class="hljs-comment"># 得到不同的颜色</span><br><br>        material_name = <span class="hljs-string">"auto.material."</span> + obj.name	<br>        material = bpy.data.materials.new(material_name)<br><br>        material[<span class="hljs-string">"is_auto"</span>] = <span class="hljs-literal">True</span><br>        material.use_nodes = <span class="hljs-literal">True</span><br>        material.node_tree.nodes.clear()<br><br>        emission = material.node_tree.nodes.new(type=<span class="hljs-string">"ShaderNodeEmission"</span>)<br>        emission.inputs[<span class="hljs-string">'Color'</span>].default_value = color	<span class="hljs-comment"># 给不同物体设置不同颜色</span><br><br>        output = material.node_tree.nodes.new(type=<span class="hljs-string">"ShaderNodeOutputMaterial"</span>)<br>        material.node_tree.links.new(emission.outputs[<span class="hljs-string">'Emission'</span>], output.inputs[<span class="hljs-string">'Surface'</span>])<br><br>        obj.data.materials.clear()	<span class="hljs-comment"># 删除物体之前的所有材质</span><br>        obj.data.materials.append(material)	<span class="hljs-comment"># 将刚刚创建并初始化颜色的材质加入物体</span><br><br>    scene.render.filepath = cfg.OUTPUT_DIR + <span class="hljs-string">'mask.png'</span><br></code></pre></td></tr></table></figure>

<h3 id="渲染结果-1"><a href="#渲染结果-1" class="headerlink" title="渲染结果"></a>渲染结果</h3><p><img src="http://cdn.ziyedy.top/Blender%E4%BD%BF%E7%94%A8Python%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90CV%E6%95%B0%E6%8D%AE%E9%9B%86/mask.png" alt=""></p>
<h2 id="为模型中每个点赋值并渲染"><a href="#为模型中每个点赋值并渲染" class="headerlink" title="为模型中每个点赋值并渲染"></a>为模型中每个点赋值并渲染</h2><p>由于渲染数据集时需要使用新数据集用nocs方法进行方法性能检验，所以必须要渲染得到nocs图（nocs相关见<a href="https://github.com/hughw19/NOCS_CVPR2019）" target="_blank" rel="noopener">https://github.com/hughw19/NOCS_CVPR2019）</a></p>
<p>参考<a href="https://blender.stackexchange.com/questions/2324/using-wrl-data-in-cycles/2325#2325" target="_blank" rel="noopener">https://blender.stackexchange.com/questions/2324/using-wrl-data-in-cycles/2325#2325</a></p>
<p><img src="http://cdn.ziyedy.top/Blender%E4%BD%BF%E7%94%A8Python%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90CV%E6%95%B0%E6%8D%AE%E9%9B%86/nocs_render.png" alt=""></p>
<h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">render_nocs</span><span class="hljs-params">()</span>:</span><br>    scene = bpy.context.scene<br>    objs = [obj <span class="hljs-keyword">for</span> obj <span class="hljs-keyword">in</span> bpy.data.objects <span class="hljs-keyword">if</span> obj.type <span class="hljs-keyword">in</span> (<span class="hljs-string">"MESH"</span>, <span class="hljs-string">"CURVE"</span>)]<br>    <span class="hljs-keyword">for</span> obj_idx, obj <span class="hljs-keyword">in</span> enumerate(objs):<br>        vcol_layer = obj.data.vertex_colors.new()<br>        <span class="hljs-keyword">for</span> loop_index, loop <span class="hljs-keyword">in</span> enumerate(obj.data.loops):<br>            loop_vert_index = loop.vertex_index<br>            scale = <span class="hljs-number">1</span><br>            color = scale * obj.data.vertices[loop_vert_index].co + Vector([<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])<br>            color = tuple(color) + (<span class="hljs-number">1</span>,)<br><br>            vcol_layer.data[loop_index].color = color<br>        obj.data.vertex_colors.active = vcol_layer<br>        obj.data.update()<br><br>        material = bpy.data.materials.new(<span class="hljs-string">'coord_color'</span>)<br><br>        material.alpha_threshold = <span class="hljs-number">1</span><br><br>        material[<span class="hljs-string">"is_auto"</span>] = <span class="hljs-literal">True</span><br>        material.use_nodes = <span class="hljs-literal">True</span><br>        material.node_tree.nodes.clear()<br><br>        attr = material.node_tree.nodes.new(type=<span class="hljs-string">"ShaderNodeAttribute"</span>)<br>        attr.attribute_name = <span class="hljs-string">"Col"</span><br><br>        output = material.node_tree.nodes.new(type=<span class="hljs-string">"ShaderNodeOutputMaterial"</span>)<br><br>        material.node_tree.links.new(attr.outputs[<span class="hljs-string">'Color'</span>], output.inputs[<span class="hljs-string">'Surface'</span>])<br><br>        obj.data.materials.clear()<br>        obj.data.materials.append(material)<br>        obj.active_material = material<br>    scene.render.filepath = cfg.OUTPUT_DIR + <span class="hljs-string">'nocs.png'</span><br></code></pre></td></tr></table></figure>

<h3 id="渲染结果-2"><a href="#渲染结果-2" class="headerlink" title="渲染结果"></a>渲染结果</h3><p><img src="http://cdn.ziyedy.top/Blender%E4%BD%BF%E7%94%A8Python%E8%84%9A%E6%9C%AC%E7%94%9F%E6%88%90CV%E6%95%B0%E6%8D%AE%E9%9B%86/nocs.png" alt=""></p>
<h2 id="判断两个模型有没有穿模"><a href="#判断两个模型有没有穿模" class="headerlink" title="判断两个模型有没有穿模"></a>判断两个模型有没有穿模</h2><p>实际上也就是判断两个模型有没有交集，参考：</p>
<p><a href="https://blender.stackexchange.com/questions/71289/using-overlap-to-check-if-two-meshes-are-intersecting" target="_blank" rel="noopener">https://blender.stackexchange.com/questions/71289/using-overlap-to-check-if-two-meshes-are-intersecting</a></p>
<p><a href="https://blender.stackexchange.com/questions/9073/how-to-check-if-two-meshes-intersect-in-python" target="_blank" rel="noopener">https://blender.stackexchange.com/questions/9073/how-to-check-if-two-meshes-intersect-in-python</a></p>
<h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">intersection_check</span><span class="hljs-params">(self, entered_model_list)</span>:</span><br>    <span class="hljs-string">"""<br>    Check if there some intersection between current model and the other model which has add into blender<br>    IF: EXIST intersection -&gt; False<br>    """</span><br>    bm1 = bmesh.new()<br>    bm1.from_mesh(self.model.data)<br>    bm1.transform(self.model.matrix_world)<br>    bvhTree1 = BVHTree.FromBMesh(bm1)<br><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> entered_model_list:<br>        bm2 = bmesh.new()<br>        bm2.from_mesh(item.model.data)<br>        bm2.transform(item.model.matrix_world)<br>        bvhTree2 = BVHTree.FromBMesh(bm2)<br><br>        inter = bvhTree1.overlap(bvhTree2)	<span class="hljs-comment"># 得到交集</span><br>        <span class="hljs-comment"># if there exists intersection -&gt; false</span><br>        <span class="hljs-keyword">if</span> inter:<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure>



<h2 id="不错的源码"><a href="#不错的源码" class="headerlink" title="不错的源码"></a>不错的源码</h2><p>blender中资源本身比较少，以下是我编写代码时找到的一个质量不错的源码，值得参考</p>
<p><a href="https://github.com/DIYer22/bpycv" target="_blank" rel="noopener">https://github.com/DIYer22/bpycv</a></p>
<p><a href="https://github.com/zju3dv/pvnet-rendering" target="_blank" rel="noopener">https://github.com/zju3dv/pvnet-rendering</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Blender</tag>
      </tags>
  </entry>
  <entry>
    <title>Blender使用Python脚本的基本渲染操作</title>
    <url>/page/blender-python-script-basic.html</url>
    <content><![CDATA[<blockquote>
<p>渲染可以简单理解为将3D场景转化为2D场景的过程</p>
</blockquote>
<h2 id="bpy模块"><a href="#bpy模块" class="headerlink" title="bpy模块"></a>bpy模块</h2><h3 id="bpy-ops"><a href="#bpy-ops" class="headerlink" title="bpy.ops"></a>bpy.ops</h3><blockquote>
<p>对于操纵3D对象，最重要的两个类是<code>bpy.ops.object</code>和<code>bpy.ops.mesh</code></p>
<p>Object类包含用于同时操作多个选定对象的函数以及许多常规实用程序。Mesh类包含用于一次操作一个对象的顶点、边和面的函数</p>
</blockquote>
<h3 id="bpy-context"><a href="#bpy-context" class="headerlink" title="bpy.context"></a>bpy.context</h3><blockquote>
<p>context（正文）是blender数据管理中的一个全局变量集合，它包含了目前被选择的和激活的（物体的两种属性状态）的物体的信息，还记录了当前物体的编辑模式<br>用于按各种状态条件访问 Blender 的对象和区域（如用户选定的对象），用于将我们指向对象组（即<code>bpy.context</code>类将生成对<code>bpy.data</code>类的数据块的引用）</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"># 访问选定对象的列表<br><span class="hljs-selector-tag">bpy</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.selected_objects</span><br><br># 访问目前激活的对象<br><span class="hljs-selector-tag">bpy</span><span class="hljs-selector-class">.context</span><span class="hljs-selector-class">.active_object</span><br></code></pre></td></tr></table></figure>

<h3 id="bpy-data"><a href="#bpy-data" class="headerlink" title="bpy.data"></a>bpy.data</h3><blockquote>
<p>blender界面上所有可使用调节的对象内容（包括mesh模型、lamp灯光、camera摄像机，material材质等）都在python中以特定的类型存储起来</p>
<p>用于访问Blender的内部数据，包含确定对象形状和位置的所有数据</p>
</blockquote>
<p>访问出现的对象</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">bpy</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.objects</span>  #访问场景内普通对象列表，包括<span class="hljs-selector-tag">lamp</span>、<span class="hljs-selector-tag">camera</span>以及<span class="hljs-selector-tag">mesh</span>模型的<br><span class="hljs-selector-tag">bpy</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.scenes</span>  #访问场景列表<br><span class="hljs-selector-tag">bpy</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.materials</span>  #访问材质对象列表<br></code></pre></td></tr></table></figure>

<p>访问具体的对象</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">bpy</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.objects</span><span class="hljs-selector-attr">[<span class="hljs-string">'Cube'</span>]</span>  #访问名为`<span class="hljs-selector-tag">Cube</span>`的对象<br><span class="hljs-selector-tag">bpy</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.objects</span><span class="hljs-selector-attr">[1]</span>  #访问列表中的第1个对象<br></code></pre></td></tr></table></figure>

<p>访问对象属性</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">bpy</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.objects</span><span class="hljs-selector-attr">[<span class="hljs-string">'Cube'</span>]</span><span class="hljs-selector-class">.name</span> #访问对象名称<br><span class="hljs-selector-tag">bpy</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.objects</span><span class="hljs-selector-attr">[<span class="hljs-string">'Cube'</span>]</span><span class="hljs-selector-class">.location</span> #访问对象的位置<br></code></pre></td></tr></table></figure>

<h2 id="常用基本操作"><a href="#常用基本操作" class="headerlink" title="常用基本操作"></a>常用基本操作</h2><h3 id="选择对象"><a href="#选择对象" class="headerlink" title="选择对象"></a>选择对象</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 选中所有</span><br>bpy.ops.object.select_all(<span class="hljs-attribute">action</span>=<span class="hljs-string">'SELECT'</span>)<br><br><span class="hljs-comment"># 取消所有选中</span><br>bpy.ops.object.select_all(<span class="hljs-attribute">action</span>=<span class="hljs-string">'DESELECT'</span>)<br><br><span class="hljs-comment">#通过select_pattern命令来按照物体命名查找选定物体，支持通配符*模糊匹配</span><br>bpy.ops.object.select_pattern(<span class="hljs-attribute">pattern</span>=<span class="hljs-string">"Cube"</span>, <span class="hljs-attribute">case_sensitive</span>=<span class="hljs-literal">False</span>, <span class="hljs-attribute">extend</span>=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 选中名为Cube的对象</span><br>bpy.data.objects[<span class="hljs-string">'Cube'</span>].select_set(<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>

<h3 id="对选中物体进行缩放"><a href="#对选中物体进行缩放" class="headerlink" title="对选中物体进行缩放"></a>对选中物体进行缩放</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"># 按 x y z 进行缩放<br>bpy.ops.transform.resize(value=(<span class="hljs-number">1.1</span>, <span class="hljs-number">1.2</span>, <span class="hljs-number">1.4</span>))<br></code></pre></td></tr></table></figure>

<h3 id="对选中物体进行旋转"><a href="#对选中物体进行旋转" class="headerlink" title="对选中物体进行旋转"></a>对选中物体进行旋转</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 绕 Z轴 旋转 3.14 弧度</span><br>bpy.ops.transform.rotate(<span class="hljs-attribute">value</span>=3.14, <span class="hljs-attribute">orient_axis</span>=<span class="hljs-string">'Z'</span>)<br></code></pre></td></tr></table></figure>

<h3 id="对选中物体进行平移操作"><a href="#对选中物体进行平移操作" class="headerlink" title="对选中物体进行平移操作"></a>对选中物体进行平移操作</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"># 按 x y z 方向平移物体<br>bpy.ops.transform.translate(value=(<span class="hljs-number">1</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">3</span>))<br><br># 设置位置<br>bpy.data.objects[<span class="hljs-string">'Cube'</span>].location = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br></code></pre></td></tr></table></figure>

<h2 id="灯光操作"><a href="#灯光操作" class="headerlink" title="灯光操作"></a>灯光操作</h2><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 新建一个点光源</span><br>light_data = bpy.data.lights.new(<span class="hljs-attribute">name</span>=<span class="hljs-string">'Light'</span>, <span class="hljs-attribute">type</span>=<span class="hljs-string">'POINT'</span>)<br><br><span class="hljs-comment"># 设置该光源的一些属性（具体属性可查看文档）</span><br>light_data.distance = 2400.<br>light_data.use_nodes = <span class="hljs-literal">True</span><br>light_data.energy = 5<br><br><span class="hljs-comment"># 激活灯光</span><br>light = bpy.data.objects.new(<span class="hljs-attribute">name</span>=<span class="hljs-string">"Light"</span>, <span class="hljs-attribute">object_data</span>=light_data)<br>scene.objects.link(light)<br>bpy.context.view_layer.objects.active = light<br><br><span class="hljs-comment"># 脚本使用完毕后删除灯光</span><br>bpy.data.objects[<span class="hljs-string">'Light'</span>+str(i)].select_set(<span class="hljs-literal">True</span>)<br>bpy.ops.object.delete()<br></code></pre></td></tr></table></figure>

<h2 id="相机操作"><a href="#相机操作" class="headerlink" title="相机操作"></a>相机操作</h2><h3 id="改变相机指向"><a href="#改变相机指向" class="headerlink" title="改变相机指向"></a>改变相机指向</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">look_at</span><span class="hljs-params">(obj_camera, point=Vector<span class="hljs-params">(<span class="hljs-params">(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)</span>)</span>)</span>:</span><br>	<span class="hljs-string">"""<br>	使相机指向point点<br>	"""</span><br>    loc_camera = obj_camera.location<br>    direction = point - loc_camera<br>    rot_quat = direction.to_track_quat(<span class="hljs-string">'-Z'</span>, <span class="hljs-string">'Y'</span>)<br>    obj_camera.rotation_euler = rot_quat.to_euler()<br></code></pre></td></tr></table></figure>

<h2 id="实现多角度渲染物体"><a href="#实现多角度渲染物体" class="headerlink" title="实现多角度渲染物体"></a>实现多角度渲染物体</h2><blockquote>
<p>实现多角度渲染物体生成物体模板主要需要进行以下工作</p>
<p>1、合理设置相机的位置（以LineMOD方法为例就利用球面的几何特征设置相机位置）</p>
<p>2、合理布局灯光（调整使得灯光能够覆盖）</p>
<p>3、得到此时相机的Rt变换矩阵用于标识该角度下物体的姿态</p>
<p>4、输入模型，进行渲染输出图片</p>
</blockquote>
<p>第1点和第2点其实就是之前的灯光操作与相机操作</p>
<h3 id="进行模型渲染"><a href="#进行模型渲染" class="headerlink" title="进行模型渲染"></a>进行模型渲染</h3><h4 id="导入模型"><a href="#导入模型" class="headerlink" title="导入模型"></a>导入模型</h4><p>以.obj文件为例，其余文件格式的导入方法可以查官方文档（导入的模型默认的位置为坐标原点）</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 导入.obj文件</span><br>bpy.ops.import_scene.obj(<span class="hljs-attribute">filepath</span>=obj_path)<br></code></pre></td></tr></table></figure>

<p>除导入模型外，就是合理设置输入路径和输出路径了，这个可以用os等模块进行处理</p>
<h4 id="设置渲染输出的基本信息"><a href="#设置渲染输出的基本信息" class="headerlink" title="设置渲染输出的基本信息"></a>设置渲染输出的基本信息</h4><p>根据官网可以设置输出分辨率等基本信息</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">context</span> = bpy.context<br><span class="hljs-attr">scene</span> = context.scene<br><br><span class="hljs-attr">scene.render.engine</span> = <span class="hljs-string">'CYCLES'</span><br><span class="hljs-attr">scene.render.film_transparent</span> = <span class="hljs-literal">True</span><br><span class="hljs-attr">scene.render.resolution_x</span> = <span class="hljs-number">360</span><br><span class="hljs-attr">scene.render.resolution_y</span> = <span class="hljs-number">360</span><br><span class="hljs-attr">scene.render.image_settings.file_format</span> = <span class="hljs-string">'PNG'</span><br></code></pre></td></tr></table></figure>

<h4 id="渲染输出"><a href="#渲染输出" class="headerlink" title="渲染输出"></a>渲染输出</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 设置输出路径</span><br>scene.render.filepath = output_path + <span class="hljs-string">"0"</span>.zfill(5) + <span class="hljs-string">".png"</span><br><br><span class="hljs-comment"># 渲染输出</span><br>bpy.ops.render.render(<span class="hljs-attribute">write_still</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">use_viewport</span>=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>

<h4 id="渲染结果"><a href="#渲染结果" class="headerlink" title="渲染结果"></a>渲染结果</h4><p>渲染结果如下，实现了<strong>模型的批量渲染处理</strong></p>
<p><img src="http://cdn.ziyedy.top/Blender%E7%89%A9%E4%BD%93%E6%B8%B2%E6%9F%93%E8%84%9A%E6%9C%AC/%E6%B8%B2%E6%9F%93%E7%BB%93%E6%9E%9C1.png" alt=""></p>
<p><img src="http://cdn.ziyedy.top/Blender%E7%89%A9%E4%BD%93%E6%B8%B2%E6%9F%93%E8%84%9A%E6%9C%AC/%E6%B8%B2%E6%9F%93%E7%BB%93%E6%9E%9C2.png" alt=""></p>
<h2 id="Blender脚本编写tips"><a href="#Blender脚本编写tips" class="headerlink" title="Blender脚本编写tips"></a>Blender脚本编写tips</h2><h3 id="根据软件操作获得代码"><a href="#根据软件操作获得代码" class="headerlink" title="根据软件操作获得代码"></a>根据软件操作获得代码</h3><p>对blender不熟悉的话很多操作不知道如何使用Python编写（官方文档是指望不上的），所以可以在软件内进行操作，然后在Script中即可以看到上次操作的代码，这样的话如果摸清楚了Blender中的操作流程的话，可以很方便的转化为代码</p>
<p><img src="http://cdn.ziyedy.top/Blender%E4%BD%BF%E7%94%A8Python%E8%84%9A%E6%9C%AC%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%B8%B2%E6%9F%93%E6%93%8D%E4%BD%9C/blender%E6%98%BE%E7%A4%BA%E6%93%8D%E4%BD%9C%E4%BB%A3%E7%A0%81.png" alt=""></p>
<h3 id="IDE开发"><a href="#IDE开发" class="headerlink" title="IDE开发"></a>IDE开发</h3><p>bpy模块是blender脚本插件核心库，封装在blender内置的Python库中，因此在外界要使用该库并不方便</p>
<p>为了能够在相关IDE中进行blender二次开发，可以使用<code>fake-bpy-module</code>这个包，该包是一套Blender API伪SDK库，能够用于blender二次开发的相关代码补全</p>
<p>安装<code>fake-bpy-module</code>只需要使用pip就可以了，如下就是安装2.83版本的 方法</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">pip install fake-bpy-<span class="hljs-class"><span class="hljs-keyword">module</span>-&lt;version&gt;</span><br>pip install fake-bpy-<span class="hljs-class"><span class="hljs-keyword">module</span>-2.83</span><br></code></pre></td></tr></table></figure>

<h3 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h3><p>blender插件脚本的python开发是一个文档相对欠缺（官方文档写的我个人认为很烂）而且不同版本之间差别较大。</p>
<p>因此建议初学者不要直接上官方文档，而应该面对具体问题在 <a href="https://blender.stackexchange.com/" target="_blank" rel="noopener">https://blender.stackexchange.com/</a> 上找到相应解决方案</p>
<p>或者可以面向软件，找到在软件中的操作手法，之后根据tip1完成代码的编写</p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Blender</tag>
      </tags>
  </entry>
  <entry>
    <title>锁</title>
    <url>/page/null.html</url>
    <content><![CDATA[<p>#</p>
<p>select 语句后面跟 for update ，表明这些条件上了行级锁（事务未结束时其他事务无法对这些记录进行修改）</p>
]]></content>
  </entry>
  <entry>
    <title>sql注入攻击</title>
    <url>/page/null.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>事务控制语言（TCL）</title>
    <url>/page/null.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据定义语言</title>
    <url>/page/null.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring基本思想与使用</title>
    <url>/page/Spring-basic-use.html</url>
    <content><![CDATA[<h2 id="Spring基本思想"><a href="#Spring基本思想" class="headerlink" title="Spring基本思想"></a>Spring基本思想</h2><ul>
<li>控制反转（IoC）：实现了代码的“解耦”，让对象与对象、模块与模块之间不使用代码关联，而是通过配置进行说明（不再需要在代码中手动的维护对象与模块之间的关系了）</li>
<li>面向切面编程（AOP）：使系统级服务得到了最大复用，实现了其与业务代码的解耦合，也降低了代码的冗余度</li>
</ul>
<h3 id="控制反转IoC"><a href="#控制反转IoC" class="headerlink" title="控制反转IoC"></a>控制反转IoC</h3><blockquote>
<p>即将传统上由程序代码直接操控的对象的创建、属性赋值、生命周期等对象控制权交给容器</p>
<p>通俗而言就是通过容器实现对象的创建、属性赋值、依赖管理等等</p>
</blockquote>
<p>IoC是一种思想，其有多种实现方式，<strong>Spring采用的实现方式是依赖注入（DI，Dependency Injection）</strong>的方式</p>
<h4 id="依赖注入DI"><a href="#依赖注入DI" class="headerlink" title="依赖注入DI"></a>依赖注入DI</h4><ul>
<li><p>依赖：classA 类中含有 classB 的实例，在 classA 中调用 classB 的方法完成功能，即 classA 对 classB 有依赖</p>
</li>
<li><p>依赖注入：指程序运行过程中，若需要调用另一个对象协助时，无须在代码中创建被调用者，而是依赖于外部容器，由外部容器创建后传递给程序（Spring的依赖注入对调用者与被调用者几乎没有任何要求，完全支持对象之间的依赖关系的管理，其底层处理了可能出现的循环依赖等问题）</p>
</li>
</ul>
<h3 id="面向切面编程AOP"><a href="#面向切面编程AOP" class="headerlink" title="面向切面编程AOP"></a>面向切面编程AOP</h3><blockquote>
<p>AOP（Aspect Orient Programming），即通过运行期间动态代理实现程序功能的一种技术</p>
<p>通俗而言就是将交叉业务逻辑（即通用的，与主业务无关的代码，如日志输出、安全检查等等）封装成切面，利用AOP技术将切面织入到主业务逻辑中</p>
</blockquote>
<p>通过使用AOP的思想，能够大大降低各业务之间的耦合度，提高程序的可重用性</p>
<h4 id="相关术语"><a href="#相关术语" class="headerlink" title="相关术语"></a>相关术语</h4><ul>
<li>切面（Aspect）：泛指交叉业务逻辑</li>
<li>连接点（JoinPoint）：指可以被切面织入的具体方法（需要使用切面的方法都是连接点）</li>
<li>切入点（Pointcut）：一个或多个连接点的集合（可以通过通配符等表明一组连接点）</li>
<li>通知（Advice）：表示切面的执行时间（比如之前、之后等等）</li>
</ul>
<h3 id="Spring的优势"><a href="#Spring的优势" class="headerlink" title="Spring的优势"></a>Spring的优势</h3><ul>
<li>轻量级，相关的jar包都比较小</li>
<li>针对接口编程，解耦合（IoC）</li>
<li>AOP编程的支持</li>
<li>方便集成各种优秀框架（Spring提供了对各类优秀框架如MyBatis的支持），简化了框架的使用</li>
</ul>
<h2 id="实现IoC"><a href="#实现IoC" class="headerlink" title="实现IoC"></a>实现IoC</h2><h3 id="基于XML配置文件"><a href="#基于XML配置文件" class="headerlink" title="基于XML配置文件"></a>基于XML配置文件</h3><h4 id="1、配置文件声明对象（Bean）"><a href="#1、配置文件声明对象（Bean）" class="headerlink" title="1、配置文件声明对象（Bean）"></a>1、配置文件声明对象（Bean）</h4><p>配置文件的根标签是 <code>&lt;beans&gt;</code> ，主要包括一些 <code>.xsd</code> 的约束文件说明。</p>
<p><code>&lt;beans&gt;</code> 中包含 <code>&lt;bean&gt;</code> 声明，<strong>Bean</strong>即为交由Spring容器管理的Java对象，其声明方式如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans"</span><br>       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">"http://www.w3.org/2001/XMLSchema-instance"</span><br>       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">"http://www.springframework.org/schema/beans <br>                           http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--声明对象<br>        id：标识对象的唯一值(Spring可以提供默认名称)<br>        class：类的全限定名称，用于通过反射机制创建对象，不能是接口<br>    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"ServiceImpl"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.example.impl.ServiceImpl"</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><em>注：Spring默认调用类的无参构造方法创建对象，同时读取完配置文件后，会一次性创建好所有的Bean对象，放入容器维护的相应map中</em></p>
<h4 id="2-1、利用set方法实现DI"><a href="#2-1、利用set方法实现DI" class="headerlink" title="2.1、利用set方法实现DI"></a>2.1、利用set方法实现DI</h4><blockquote>
<p>Spring调用类的<strong>无参构造方法</strong>创建对象实例后，调用类中的 <code>set</code> 方法，在set方法中可以完成属性赋值（set方法内部逻辑可以自己实现，Spring只负责调用相应set方法）</p>
</blockquote>
<p><em>当类中没有set方法时，直接使用set注入会报错</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"ServiceImpl"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.example.impl.ServiceImpl"</span> &gt;</span><br>    <span class="hljs-comment">&lt;!-- 简单类型赋值 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"str"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"ziye"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"num"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"10"</span> /&gt;</span><br>	<span class="hljs-comment">&lt;!-- 引用类型赋值, ref为对象对应的 bean 的 id --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"util"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"Util"</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"Util"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.example.impl.Util"</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"name"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"yezi"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"times"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"123"</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="2-2、利用构造方法实现DI"><a href="#2-2、利用构造方法实现DI" class="headerlink" title="2.2、利用构造方法实现DI"></a>2.2、利用构造方法实现DI</h4><blockquote>
<p>spring调用类中的<em>有参数构造方法</em>， 在创建对象的同时，给属性赋值</p>
</blockquote>
<p>可以使用 <code>name</code> 指定构造函数中形参的名称，也可以使用 <code>index</code> 来指定形参在方法中的位置，不使用的话则默认使用形参的排列顺序</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"ServiceImpl"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.example.impl.ServiceImpl"</span> &gt;</span><br>    <span class="hljs-comment">&lt;!-- 简单类型赋值 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"str"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"ziye"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"num"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"10"</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 引用类型赋值, ref为对象对应的 bean 的 id --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"util"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"Util"</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="2-3、引用类型的自动注入"><a href="#2-3、引用类型的自动注入" class="headerlink" title="2.3、引用类型的自动注入"></a>2.3、引用类型的自动注入</h4><blockquote>
<p>自动注入：Spring可以根据某些规则（byName，byType）给<strong>引用类型</strong>完成赋值。 </p>
</blockquote>
<ul>
<li><p>byName（按名称注入）： Java类中引用类型属性名称和Spring容器中bean的id名称一样的，且数据类型也是一样的。设置 <code>autowire=&quot;byName&quot;</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"ServiceImpl"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.example.impl.ServiceImpl"</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">"byName"</span> /&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>byType（按类型注入）：Java类中引用类型的数据类型和Spring容器中bean的class值是同源关系的，这样的bean赋值给引用类型。</p>
<p><em>注： 在xml配置文件中， 符合条件的对象，只能有一个。 多余一个是报错的</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"ServiceImpl"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"org.example.impl.ServiceImpl"</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">"byType"</span> /&gt;</span><br></code></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="基于注解"><a href="#基于注解" class="headerlink" title="基于注解"></a>基于注解</h3><p>使用注解完成DI，除去在相应位置加上对应注解外，必须在Spring的配置文件中加入<strong>组件扫描器</strong>，如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 使用注解必须加上组件扫描器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">"org.example"</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="定义Bean的注解（-Component）"><a href="#定义Bean的注解（-Component）" class="headerlink" title="定义Bean的注解（@Component）"></a>定义Bean的注解（@Component）</h4><p>在类名之上加上<code>@Component</code>注解，相当于在配置文件中使用<code>&lt;bean&gt;</code>对该类进行了声明，同时该注解中的value表示对象名称，相当于<code>&lt;bean&gt;</code>中的<code>id</code>值（如果不写的话默认id为类名的首字母小写）</p>
<p>此外，Spring还提供了3个创建对象的注解，这些注解还有其特定的含义</p>
<ul>
<li><code>@Repository</code>：通常放在dao接口的实现类上，表示创建持久层对象，能访问数据库</li>
<li><code>@Service</code>：通常放在业务层接口的实现类上，表示创建业务层对象，可以加入事务的功能</li>
<li><code>@Controller</code>：放在控制器类的上面，表示创建控制层对象</li>
</ul>
<h4 id="简单类型属性注入（-Value）"><a href="#简单类型属性注入（-Value）" class="headerlink" title="简单类型属性注入（@Value）"></a>简单类型属性注入（@Value）</h4><p>使用<code>@Value</code>注解完成，该注解可放置在属性定义的上面，也可以放置在set方法的上面，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value</span>(<span class="hljs-string">"ziye"</span>)<br><span class="hljs-keyword">private</span> String str;<br><br><span class="hljs-meta">@Value</span>(<span class="hljs-string">"10"</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;<br></code></pre></td></tr></table></figure>

<p>同时使用该注解可以<strong>从外部配置文件中得到相应的值进行注入</strong></p>
<ol>
<li><p>设置配置文件（<code>conf.properties</code>）示例如下：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">str</span>=ziye<br><span class="hljs-attr">num</span>=<span class="hljs-number">12</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>读取外部配置文件（根据其路径，如下为）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 读取外部属性配置文件（properties文件） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">"classpath:/conf.properties"</span> /&gt;</span><br></code></pre></td></tr></table></figure>
</li>
<li><p>使用对应语法进行属性注入（<code>&quot;${}&quot;</code>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;str&#125;"</span>)<br><span class="hljs-keyword">private</span> String str;<br><br><span class="hljs-meta">@Value</span>(<span class="hljs-string">"$&#123;num&#125;"</span>)<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;<br></code></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="引用类型注入（-Autowired）"><a href="#引用类型注入（-Autowired）" class="headerlink" title="引用类型注入（@Autowired）"></a>引用类型注入（@Autowired）</h4><p>在引用属性上使用<code>@Autowired</code>，该注解默认会使用<strong>按类型的自动注入（byType）</strong>的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> Util util;<br></code></pre></td></tr></table></figure>

<p>也可以联合使用<code>@Autowired</code>与<code>@Qualifier</code>两个注解，实现<strong>按名称的自动注入（byName），即对应bean的id</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@Qualifier</span>(<span class="hljs-string">"util"</span>)<br><span class="hljs-keyword">private</span> Util util;<br></code></pre></td></tr></table></figure>

<p>也可以使用JDK自带的<code>@Resource</code>注解实现注入，<em>该注解默认按名称注入，若按名称无法注入，则按照类型进行注入</em>。按照名称进行注入需要指定其<code>name</code>属性（即Bean的id），示例：<code>@Resource(name=&quot;util&quot;)</code></p>
<h3 id="Bean的使用"><a href="#Bean的使用" class="headerlink" title="Bean的使用"></a>Bean的使用</h3><p>Spring根据id，class创建对象， 把对象放入Spring的一个map对象，具体操作主要有以下四步：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 1、配置文件的路径</span><br>String config = <span class="hljs-string">"beans.xml"</span>;<br><span class="hljs-comment">// 2、读取配置文件,创建容器对象，ApplicationContext 表示 Spring 容器对象</span><br>ApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(config);<br><span class="hljs-comment">// 3、获取id名为ServiceImpl的对象</span><br>Service service = (Service) ctx.getBean(<span class="hljs-string">"ServiceImpl"</span>);<br><span class="hljs-comment">// 4、执行对象的方法</span><br>service.method();<br></code></pre></td></tr></table></figure>

<p>其中<code>ApplicationContext</code>接口（容器）默认为无参构造，同时创建容器对象时，<strong>默认会把配置文件中所有对象都创建出来</strong>（之后需要使用这些对象，只需要从内存中直接获取即可，执行效率高但占用内存）</p>
<p>利用<code>ApplicationContext</code>对象可以获取容器中对象的一些基本信息，常用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取容器中定义对象的数量</span><br><span class="hljs-keyword">int</span> nums = ctx.getBeanDefinitionCount();<br><br><span class="hljs-comment">// 获取容器中定义的对象名称</span><br>String names[] = ctx.getBeanDefinitionNames();<br></code></pre></td></tr></table></figure>



<h2 id="实现AOP"><a href="#实现AOP" class="headerlink" title="实现AOP"></a>实现AOP</h2><p>在Spring中使用AOP开发时，一般使用<strong>AspectJ</strong>的实现方式。其中AspectJ是一个优秀的面向切面的框架（Eclipse的开源项目）</p>
<h3 id="切入点表达式"><a href="#切入点表达式" class="headerlink" title="切入点表达式"></a>切入点表达式</h3><h4 id="切入点表达式-1"><a href="#切入点表达式-1" class="headerlink" title="切入点表达式"></a>切入点表达式</h4><p>AspectJ 定义了专门的表达式用于指定切入点，定义如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">execution</span><span class="hljs-params">(访问权限 方法返回值 方法声明(参数)</span></span> 异常类型)<br></code></pre></td></tr></table></figure>

<p>其中方法返回值、方法声明（参数）是不可省略的，方法声明可以用全限定名也可以不使用</p>
<p>除此之外，切入点表达式也可以使用一些通配符：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>0至多个任意字符</td>
</tr>
<tr>
<td>..</td>
<td>用在方法参数中，表示任意多个参数<br />用在包名后，表示当前包及其子包</td>
</tr>
<tr>
<td>+</td>
<td>用在类名后，表示当前类及其子类<br />用在接口后，表示当前接口及其实现类</td>
</tr>
</tbody></table>
<h4 id="共享切入点表达式"><a href="#共享切入点表达式" class="headerlink" title="共享切入点表达式"></a>共享切入点表达式</h4><p>如果多个切面通知方法所使用的切入点是一样的话，实现共享切入点表达式能够有效的解耦合。</p>
<p>可以使用<code>@Pointcut</code>注解实现定义和管理切入点。该注解可以放置在在一个自定义方法的上面，<strong>该方法名可以看做是切入点表达式的别名</strong>。具体使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@After</span>(value = <span class="hljs-string">"pt()"</span>)	<span class="hljs-comment">// 共享pt对应的切入点表达式</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">myAfter</span><span class="hljs-params">()</span></span>&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">// 自定义对应切入点的表达式，pt</span><br><span class="hljs-meta">@Pointcut</span>(<span class="hljs-string">"execution(* *..SomeServiceImpl.doThird(..))"</span>)<br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pt</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-comment">// 无需代码</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="通知类型"><a href="#通知类型" class="headerlink" title="通知类型"></a>通知类型</h3><h4 id="前置通知-Before"><a href="#前置通知-Before" class="headerlink" title="前置通知@Before"></a>前置通知@Before</h4><p>前置通知方法在目标方法之前执行，并且不会影响目标方法的执行，也不会修改目标方法的执行结果，使用<code>@Before</code>实现</p>
<p><code>@Before</code>注解放置在相应前置通知方法的上面，其中value为切入点表达式，用于需要执行相应切面方法的方法</p>
<p>前置方法主要有以下方面需要注意：</p>
<ol>
<li><p>方法是public，且返回值为void</p>
</li>
<li><p>方法可以有参数，若有的话第一个参数必须为<code>JoinPoint</code>（表示正在执行的业务方法，相当于反射中的 <code>Method</code>，可用于获取方法执行时的信息，如方法名称、参数集合等等）</p>
</li>
</ol>
<h4 id="后置通知-AfterReturning"><a href="#后置通知-AfterReturning" class="headerlink" title="后置通知@AfterReturning"></a>后置通知@AfterReturning</h4><p>后置通知方法在目标方法之后执行，<strong>能获取目标方法的执行结果，但不会影响目标方法的执行</strong>，使用<code>@AfterReturning</code>实现</p>
<p><code>@AfterReturning</code>放置在方法上面，其中value为切入点表达式，returning为自定义的变量，表示目标方法的返回值（<strong>自定义变量名称必须和通知方法的形参名一样</strong>）</p>
<ol>
<li>方法限定名public，返回值void</li>
<li>方法有参数（通常使用Object类型作为参数，用于表示目标方法的返回值）</li>
</ol>
<h4 id="环绕通知-Around"><a href="#环绕通知-Around" class="headerlink" title="环绕通知@Around"></a>环绕通知@Around</h4><p>环绕通知在目标方法的前后都能够插入功能，并且<strong>能够控制目标方法是否执行，也能够修改目标方法的执行结果</strong>，使用<code>@Around</code>实现</p>
<p><code>@Around</code>放置在方法之上，其中value为切入点表达式</p>
<ol>
<li>方法限定名public，且必须有返回值（通常定义为Object对象）</li>
<li>方法必须有<code>ProceedingJoinPoint</code>参数（继承自<code>JoinPoint</code>，可用于执行目标方法，相当于<code>Method.invoke()</code>），使用 <code>proceedingJoinPoint.proceed();</code> 可执行方法</li>
</ol>
<h4 id="异常通知-AfterThrowing"><a href="#异常通知-AfterThrowing" class="headerlink" title="异常通知@AfterThrowing"></a>异常通知@AfterThrowing</h4><p>异常通知用<code>@AfterThrowing</code>注解实现，异常通知方法使用public限定名，无返回值，具有<code>Exception</code>类型的参数。具有以下特征：</p>
<ol>
<li>在目标方法抛出异常后执行的，没有异常不执行</li>
<li>能获取到目标方法的异常信息</li>
<li>不是异常处理程序。可以得到发生异常的通知（常用作异常的监控程序）</li>
</ol>
<p>其处理流程相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	<span class="hljs-comment">// 业务方法</span><br>&#125; <span class="hljs-keyword">catch</span>(Exceptoin e) &#123;<br>	myAfterThrowing(e);	<span class="hljs-comment">// 切面方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>@AfterThrowing</code>注解中value为切入点表达式，throwing表示目标方法抛出的异常，其值必须与通知方法形参名一致</p>
<h4 id="最终通知-After"><a href="#最终通知-After" class="headerlink" title="最终通知@After"></a>最终通知@After</h4><p>最终通知方法在目标方法之后执行，且无论是否抛出异常都会继续执行，可以用来进行程序的收尾工作（如清除临时数据等）。该通知使用<code>@After</code>注解完成，其中value为切入点表达式。</p>
<p>其处理流程相当于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>	<span class="hljs-comment">// 业务方法</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>	myAfter();	<span class="hljs-comment">// 切面方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="AOP使用demo"><a href="#AOP使用demo" class="headerlink" title="AOP使用demo"></a>AOP使用demo</h3><p>1、加入相关依赖，主要是<code>spring-aspects</code>依赖</p>
<p>2、<strong>使用<code>@Aspect</code>注解，用于标识当前类是一个实现切面功能的类</strong>，该注解放置在类的上面</p>
<p>3、在配置文件中声明自动代理器，用于创建目标对象的代理，同时定义对应的业务类与切面类的Bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 声明自动代理生成器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p>4、根据需要编写相关代码</p>
<p>切面类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.aop.handle;<br><br><span class="hljs-keyword">import</span> org.aspectj.lang.JoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;<br><span class="hljs-keyword">import</span> org.aspectj.lang.annotation.*;<br><br><span class="hljs-meta">@Aspect</span> <span class="hljs-comment">// 表示该类为AOP类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAspect</span> </span>&#123;<br>    <span class="hljs-comment">// 前置通知示例</span><br>    <span class="hljs-meta">@Before</span>(<span class="hljs-string">"execution(public void org.example.aop.Service.doSome(String, int))"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before1</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"--------- 前置通知1"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// JoinPoint: 表示正在执行的业务方法， 相当于反射中的 Method</span><br>    <span class="hljs-meta">@Before</span>(<span class="hljs-string">"execution(public * org.example.aop.Service.doSome(..))"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before2</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"--------- 前置通知2，获取目标方法定义："</span> + joinPoint.getSignature());<br><br>    &#125;<br><br>    <span class="hljs-comment">// 后置通知示例 其中returning中的res必须 与 形参中的res 一致</span><br>    <span class="hljs-meta">@AfterReturning</span>(value = <span class="hljs-string">"execution(public int org.example.aop.Service.doSome2(..))"</span>,<br>            returning = <span class="hljs-string">"res"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturning</span><span class="hljs-params">(Object res)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"--------- 后置通知，拿到方法执行结果："</span> + res);<br>    &#125;<br><br>    <span class="hljs-comment">// 环绕通知示例</span><br>    <span class="hljs-meta">@Around</span>(<span class="hljs-string">"execution(public * doSome3(..))"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">"--------- 执行环绕通知around"</span>);<br>        <span class="hljs-keyword">int</span> res = (<span class="hljs-keyword">int</span>) proceedingJoinPoint.proceed();  <span class="hljs-comment">// 执行方法 并 得到执行结果</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span>;    <span class="hljs-comment">// 环绕通知修改方法调用结果</span><br>    &#125;<br><br>    <span class="hljs-comment">// 异常通知示例，其中throwing中的ex必须与形参名ex一致</span><br>    <span class="hljs-meta">@AfterThrowing</span>(value = <span class="hljs-string">"execution(public * doSome4(..))"</span>, throwing = <span class="hljs-string">"ex"</span>)<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">(Exception ex)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"异常通知，异常原因："</span> + ex.getMessage());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>业务类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example.aop;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doSome</span><span class="hljs-params">(String str, <span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"执行doSome1方法： "</span> + str + <span class="hljs-string">": "</span> + num);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doSome2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"执行doSome2方法，执行结果应为： "</span> + num * <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">return</span> num * <span class="hljs-number">2</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">doSome3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"执行doSome3方法，返回值应为："</span> + num);<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deSome4</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"执行方法测试异常："</span> + (<span class="hljs-number">1</span> / <span class="hljs-number">0</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>主函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> org.example;<br><br><span class="hljs-keyword">import</span> org.example.aop.Service;<br><span class="hljs-keyword">import</span> org.springframework.context.ApplicationContext;<br><span class="hljs-keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        String config = <span class="hljs-string">"beans.xml"</span>;<br>        ApplicationContext ctx = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(config);    <span class="hljs-comment">// 读取配置文件</span><br>        Service service = (Service) ctx.getBean(<span class="hljs-string">"aopService"</span>);<br><br>        <span class="hljs-comment">// 前置通知测试</span><br>        service.doSome(<span class="hljs-string">"ziye"</span>, <span class="hljs-number">22</span>);<br>        System.out.println();<br><br>        <span class="hljs-comment">// 后置通知测试</span><br>        service.doSome2(<span class="hljs-number">10</span>);<br>        System.out.println();<br><br>        <span class="hljs-comment">// 环绕通知测试</span><br>        <span class="hljs-keyword">int</span> res = service.doSome3(<span class="hljs-number">10</span>);<br>        System.out.println(<span class="hljs-string">"实际值为："</span> + res);<br>        System.out.println();<br><br>        <span class="hljs-comment">// 查看生成的代理类型</span><br>        System.out.println(service.getClass().getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="http://cdn.ziyedy.top/Spring%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3%E4%B8%8E%E4%BD%BF%E7%94%A8/AOP%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt=""></p>
<h2 id="数据库事务管理"><a href="#数据库事务管理" class="headerlink" title="数据库事务管理"></a>数据库事务管理</h2><p>通常情况下，需要在 service 层对事务进行管理，因此 Spring 也具备事务管理的能力</p>
<h3 id="Spring-事务管理器接口"><a href="#Spring-事务管理器接口" class="headerlink" title="Spring 事务管理器接口"></a>Spring 事务管理器接口</h3><blockquote>
<p>事务管理器是 <code>PlatformTransactionManager</code> 的接口对象，其主要用于完成事务的提交、回滚，及获取事务状态信息</p>
</blockquote>
<p>事务管理器接口针对不同的数据库操作方法有不同的实现类，这样可以<strong>实现 Spring 对数据库操作的统一管理</strong>。如 JDBC 与 mybatis 就有其自己的事务管理器实现类 <code>DataSourceTranactionManager</code>，而其他框架也有其相应的事务管理器实现类</p>
<h4 id="回滚方式"><a href="#回滚方式" class="headerlink" title="回滚方式"></a>回滚方式</h4><p>Spring 默认的回滚方式为：<strong>发生运行时异常与 error 时回滚，发生其他编译异常时提交</strong>（也可以手动指定相应编译异常回滚）</p>
<p>事务的实现使用的是 环绕通知</p>
<h3 id="Spring-事务定义接口"><a href="#Spring-事务定义接口" class="headerlink" title="Spring 事务定义接口"></a>Spring 事务定义接口</h3><p>事务定义接口 <code>TransactionDefinition</code> 中定义了事务描述相关的三类常量：</p>
<ul>
<li>事务隔离级别：5个值，4个隔离级别（即数据库相应的四大隔离级别），还有一个 <code>DEFAULT</code> 值表示对应数据库默认的隔离级别</li>
<li>事务传播行为：指处于不同事务中的方法在相互调用时，执行期间事务的维护情况。主要有三个值<ul>
<li>PROPAGATION_REQUIRED：指定的方法必须在事务内执行。若该方法被调用时存在事务，则加入当前事务；否则新建事务</li>
<li>PROPAGATION_SUPPORTS：指定的方法支持当前事务，但当前没有事务也可以非事务方式执行</li>
<li>PROPAGATION_REQUIRES_NEW：总是新建一个事务，若当前已经存在事务，则将当前事务挂起，直到新事物执行完毕</li>
</ul>
</li>
<li>事务默认超时时限：以秒为单位，表示一个业务方法的最长执行时间，默认为-1表示无限制</li>
</ul>
<h3 id="使用-Transactional-注解控制事务"><a href="#使用-Transactional-注解控制事务" class="headerlink" title="使用 @Transactional 注解控制事务"></a>使用 @Transactional 注解控制事务</h3><p><code>@Transactional</code> 注解是 Spring 自带的注解，可以将事务织入到相应的 <strong>public 方法中</strong>，实现事务管理</p>
<p>该注解可以用在 public 方法上面，也可以用在类的上面（表示该类所有public方法均加入事务）</p>
<h4 id="可选属性"><a href="#可选属性" class="headerlink" title="可选属性"></a>可选属性</h4><ul>
<li>propagation：事务的传播行为，使用的 Propagation类的枚举值。例如 <code>Propagation.REQUIRED</code></li>
<li>isolation：表示隔离级别， 使用 Isolation 类的枚举值，表示隔离级别。 默认 <code>Isolation.DEFAULT</code></li>
<li>readOnly：boolean 类型的值，表示数据库操作是不是只读的。默认是false</li>
<li>timeout：事务超时时限，默认是-1， 整数值，单位是秒</li>
<li>rollbackFor：表示回滚的异常类列表，为一个数组，每个值是异常类型的class</li>
<li>rollbackForClassName：表示回滚的异常类列表，他的值是异常类名称，是String类型的值</li>
<li>noRollbackFor：不需要回滚的异常类列表，是class类型的。</li>
<li>noRollbackForClassName：不需要回滚的异常类列表，是String类型的值</li>
</ul>
<h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><p>1、在 Spring 配置文件中，声明事务管理器，并且说明事务管理器对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transactionManager"</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--指定数据源DataSource--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"myDataSource"</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>2、声明使用注解管理事务，开启注解驱动</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- transaction-manager: 指定事务管理器的id --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<p>3、在相应方法上面添加 <code>@Transactional</code> 注解，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span>(<br>    propagation = Propagation.REQUIRED,<br>    isolation = Isolation.DEFAULT,<br>    readOnly = <span class="hljs-keyword">false</span>, timeout = <span class="hljs-number">20</span>,<br>    rollbackFor = &#123;NullPointerException<span class="hljs-class">.<span class="hljs-keyword">class</span>,<span class="hljs-title">NotEnougthException</span>.<span class="hljs-title">class</span>&#125;)</span><br></code></pre></td></tr></table></figure>

<h3 id="使用-Aspectj-框架使用配置文件管理事务"><a href="#使用-Aspectj-框架使用配置文件管理事务" class="headerlink" title="使用 Aspectj 框架使用配置文件管理事务"></a>使用 Aspectj 框架使用配置文件管理事务</h3><p>1、在 Spring 配置文件中声明事务管理器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"transactionManager"</span>  <span class="hljs-attr">class</span>=<span class="hljs-string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--指定数据源DataSource--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"dataSource"</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">"myDataSource"</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>2、声明业务方法需要的事务属性（如隔离级别、传播行为、超时时间等）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"serviceAdvice"</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">"transactionManager"</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--给具体的业务方法增加事务的说明--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--<br>            name: 业务方法名称：可直接指定名称，也可以使用通配符<br>            propagation:指定传播行为的值<br>            isolation：隔离级别<br>            read-only：是否只读，默认是false<br>            timeout：超时时间<br>            rollback-for：指定回滚的异常类列表，使用的异常全限定名称<br>        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"buy"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> <span class="hljs-attr">isolation</span>=<span class="hljs-string">"DEFAULT"</span><br>                   <span class="hljs-attr">read-only</span>=<span class="hljs-string">"false"</span> <span class="hljs-attr">timeout</span>=<span class="hljs-string">"20"</span><br>                   <span class="hljs-attr">rollback-for</span>=<span class="hljs-string">"java.lang.NullPointerException"</span>/&gt;</span><br><br><br>        <span class="hljs-comment">&lt;!-- 在业务方法有命名规则后， 可以对一类命名规则的方法使用事务 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"add*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRES_NEW"</span> <span class="hljs-attr">rollback-for</span>=<span class="hljs-string">"java.lang.Exception"</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"remove*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"REQUIRED"</span> <span class="hljs-attr">rollback-for</span>=<span class="hljs-string">"java.lang.Exception"</span> /&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- 对以上定义了的方法以外的全部方法使用相关事务管理方法 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"*"</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">"SUPPORTS"</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">"true"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>3、声明切入点表达式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--声明切入点表达式： 表示那些包中的类，类中的方法参与事务--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--声明切入点表达式<br>        expression：切入点表达式，表示需要参与事务的方法与类<br>        id：切入点表达式的名称，唯一值<br>    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"servicePointcut"</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">"execution(* *..service..*.*(..))"</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 关联切入点表达式和事务通知 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">"serviceAdvice"</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">"servicePointcut"</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>post</title>
    <url>/page/null.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Java多线程常用Demo</title>
    <url>/page/Java-multithread-demo.html</url>
    <content><![CDATA[<h2 id="两个线程交替打印奇偶数"><a href="#两个线程交替打印奇偶数" class="headerlink" title="两个线程交替打印奇偶数"></a>两个线程交替打印奇偶数</h2><h3 id="使用synchronized、wait、notify"><a href="#使用synchronized、wait、notify" class="headerlink" title="使用synchronized、wait、notify"></a>使用synchronized、wait、notify</h3><h2 id="三个线程交替打印ABC"><a href="#三个线程交替打印ABC" class="headerlink" title="三个线程交替打印ABC"></a>三个线程交替打印ABC</h2><h3 id="使用volatile实现状态变化"><a href="#使用volatile实现状态变化" class="headerlink" title="使用volatile实现状态变化"></a>使用<code>volatile</code>实现状态变化</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadABC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> state = <span class="hljs-number">0</span>;	<span class="hljs-comment">// 利用state判断当前哪个线程应该打印</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">char</span>[] list = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[]&#123;<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> type;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadABC</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.type = type;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; ) &#123;<br>            <span class="hljs-keyword">if</span> (state % <span class="hljs-number">3</span> == type) &#123;<br>                System.out.println(list[type]);<br>                state++;<br>                i++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> ThreadABC(<span class="hljs-number">0</span>).start();<br>        <span class="hljs-keyword">new</span> ThreadABC(<span class="hljs-number">1</span>).start();<br>        <span class="hljs-keyword">new</span> ThreadABC(<span class="hljs-number">2</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="使用Lock与state状态"><a href="#使用Lock与state状态" class="headerlink" title="使用Lock与state状态"></a>使用Lock与state状态</h3>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java12-5：控制并发流程</title>
    <url>/page/Java12-concurrent-process.html</url>
    <content><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>传入一个数值，倒数该数直到为0之前，线程一直处于等待状态，直到倒计时结束了，此线程才继续工作</p>
<h3 id="主要函数"><a href="#主要函数" class="headerlink" title="主要函数"></a>主要函数</h3><ul>
<li><code>CountDownLatch(int count)</code>，构造函数，参数 <code>count</code> 为需要倒数的值</li>
<li><code>await()</code>，调用该方法的线程会被挂起，直到count值为0时才继续执行</li>
<li><code>countDown()</code>，将<code>count</code> 的值减1，直到0为止，等待的线程会被唤醒</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>使用 <code>CountDownLatch</code> 实现控制线程的开始与结束。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        CountDownLatch begin = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);   <span class="hljs-comment">// 用于控制所有线程同时开始</span><br>        CountDownLatch end = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">5</span>);     <span class="hljs-comment">// 用于确保所有线程都运行完成了</span><br><br>        ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">5</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-keyword">int</span> finalI = i;<br>            Runnable runnable = <span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        begin.await();	<span class="hljs-comment">// 使用begin保证所有线程同时开始</span><br>                        System.out.println(finalI + <span class="hljs-string">"-开始工作"</span>);<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        end.countDown();	<br>                    &#125;<br>                &#125;<br>            &#125;;<br>            service.submit(runnable);<br>        &#125;<br>        Thread.sleep(<span class="hljs-number">5000</span>);<br>        System.out.println(<span class="hljs-string">"全部开始工作"</span>);<br>        begin.countDown();<br>        end.await();	<span class="hljs-comment">// 使用end保证所有线程都结束才继续</span><br>        System.out.println(<span class="hljs-string">"全部完成工作"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="Semaphore信号量"><a href="#Semaphore信号量" class="headerlink" title="Semaphore信号量"></a>Semaphore信号量</h2><p>与操作系统中利用信号量控制并发流程的思路一致，信号量可用来限制或管理数量有限的资源的使用情况</p>
<h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><ol>
<li>初始化 <code>Semaphore</code> 并指定“许可证”的数量。<code>new Semaphore(int permits, boolean fair)</code>，可以设置公平策略，为true时为先来先服务的模式</li>
<li>执行任务前，调用 <code>acquire()</code> 方法进行获取（获取不到则响应中断），也可以不响应中断。可以使用 <code>tryAcquire()</code> 进行判断</li>
<li>任务结束后，调用 <code>release()</code> 方法进行释放</li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>如下示例的运行结果即为 3行 一打印，表示一次只能获取 3 个许可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><span class="hljs-keyword">import</span> java.util.concurrent.Semaphore;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">3</span>, <span class="hljs-keyword">true</span>);	<span class="hljs-comment">// 只有3个许可</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ExecutorService service = Executors.newFixedThreadPool(<span class="hljs-number">30</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">60</span>; i++) &#123;<br>            service.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        semaphore.acquire();    <span class="hljs-comment">// 获取许可</span><br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">"拿到许可"</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Thread.sleep(<span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    semaphore.release();    <span class="hljs-comment">// 释放许可</span><br>                &#125;<br>            &#125;);<br>        &#125;<br>        service.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL索引相关问题</title>
    <url>/page/mysql-index.html</url>
    <content><![CDATA[<p>#</p>
<ol>
<li>主键与<code>unique</code>关键字约束的字段会自动添加索引</li>
</ol>
<p>索引失效：</p>
<p>1、模糊匹配当中以“%”开头了</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> ename <span class="hljs-keyword">like</span> <span class="hljs-string">'%T'</span>;<br></code></pre></td></tr></table></figure>

<p>2、如果使用or那么要求or两边的条件字段都要有索引，才会走索引</p>
<p>3、使用复合索引的时候，没有使用左侧的列查找（）</p>
<p>4、在where当中索引列参加了运算（或使用了函数），索引失效</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> emp <span class="hljs-keyword">where</span> sal+<span class="hljs-number">1</span> = <span class="hljs-number">800</span>;<br></code></pre></td></tr></table></figure>





<p>数据库设计三大范式</p>
<p>1、任何一张表必须有主键，每一个字段原子性不可再分</p>
<p>2、所有非主键字段完全依赖主键，不要产生部分依赖。</p>
<p>3、所有非主键字段直接依赖主键，不要产生传递依赖</p>
]]></content>
      <categories>
        <category>数据库 - MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP协议常见问题</title>
    <url>/page/HTTP.html</url>
    <content><![CDATA[<h2 id="问题汇总"><a href="#问题汇总" class="headerlink" title="问题汇总"></a>问题汇总</h2><h3 id="1-TCP三次握手和四次挥手"><a href="#1-TCP三次握手和四次挥手" class="headerlink" title="1. TCP三次握手和四次挥手"></a>1. TCP三次握手和四次挥手</h3><p>1.1 TCP三次握手和四次挥手的过程<br>1.2 为什么TCP建立连接需要三次握手,断开连接需要四次挥手<br>1.3 TCP四次挥手为什么有Time-Wait过程<br>1.4 TCP如果没有完成第四次挥手会发生什么<br>1.5 TCP第三次握手可以传输数据吗</p>
<h3 id="2-TCP和UDP的区别"><a href="#2-TCP和UDP的区别" class="headerlink" title="2. TCP和UDP的区别"></a>2. TCP和UDP的区别</h3><h3 id="3-TCP的可靠传输"><a href="#3-TCP的可靠传输" class="headerlink" title="3. TCP的可靠传输"></a>3. TCP的可靠传输</h3><p>3.1 TCP如何确保可靠性传输<br>3.2 TCP的拥塞控制<br>3.3 TCP传输通信时,<a href="https://www.nowcoder.com/jump/super-jump/word?word=客户端" target="_blank" rel="noopener">客户端</a>突然断开连接,服务端如何判断<br>3.4 TCP的端口时为了区分什么</p>
<h3 id="4-常见的HTTP状态码"><a href="#4-常见的HTTP状态码" class="headerlink" title="4. 常见的HTTP状态码"></a>4. 常见的HTTP状态码</h3><h3 id="5-HTTP报文"><a href="#5-HTTP报文" class="headerlink" title="5. HTTP报文"></a>5. HTTP报文</h3><p>5.1 HTTP请求报文和响应报文的组成<br>5.2 HTTP请求报文包含哪些方法, GET和POST的区别</p>
<h3 id="6-HTTP和HTTPS的区别"><a href="#6-HTTP和HTTPS的区别" class="headerlink" title="6. HTTP和HTTPS的区别"></a>6. HTTP和HTTPS的区别</h3><h3 id="7-HTTP1-0和1-1和2-0的区别"><a href="#7-HTTP1-0和1-1和2-0的区别" class="headerlink" title="7. HTTP1.0和1.1和2.0的区别"></a>7. HTTP1.0和1.1和2.0的区别</h3><h3 id="HTTP-1-0和HTTP-1-1的主要区别是什么"><a href="#HTTP-1-0和HTTP-1-1的主要区别是什么" class="headerlink" title="HTTP 1.0和HTTP 1.1的主要区别是什么"></a>HTTP 1.0和HTTP 1.1的主要区别是什么</h3><ol>
<li>连接：<strong>HTTP/1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接；<strong>HTTP 1.1起，默认使用长连接</strong>,默认开启<code>Connection： keep-alive</code></li>
<li>错误状态响应码：<strong>HTTP1.1中新增了24个错误状态响应码</strong></li>
<li>缓存处理：在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例</li>
<li>带宽优化及网络连接的使用：HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接</li>
</ol>
<p>HTTP/2.0：</p>
<p>1、采用二进制格式而非文本格式，将所有传输的信息分割为更小的消息和帧</p>
<p>2、首部压缩</p>
<h3 id="8-HTTPS密钥交换过程"><a href="#8-HTTPS密钥交换过程" class="headerlink" title="8. HTTPS密钥交换过程"></a>8. HTTPS密钥交换过程</h3><h3 id="9-HTTP的缓存机制"><a href="#9-HTTP的缓存机制" class="headerlink" title="9. HTTP的缓存机制"></a>9. HTTP的缓存机制</h3><h3 id="10-输入URL跳转网页的过程"><a href="#10-输入URL跳转网页的过程" class="headerlink" title="10. 输入URL跳转网页的过程"></a>10. 输入URL跳转网页的过程</h3><h2 id="cookie与session"><a href="#cookie与session" class="headerlink" title="cookie与session"></a>cookie与session</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h3 id="禁用cookie"><a href="#禁用cookie" class="headerlink" title="禁用cookie"></a>禁用cookie</h3><h3 id="cookie的跨域共享"><a href="#cookie的跨域共享" class="headerlink" title="cookie的跨域共享"></a>cookie的跨域共享</h3><p>正常的Cookie只能在一个应用中访问，使用<code>setDomain()</code> 等方法能够使得cookie实现跨域共享</p>
<p>即 a. jd.com 和 b.jd.com 都能够共享 jd.com 的 Cookie</p>
<h3 id="13-页面加载不出来的原因"><a href="#13-页面加载不出来的原因" class="headerlink" title="13. 页面加载不出来的原因"></a>13. 页面加载不出来的原因</h3><p>a.jd.com能否共享的Cookie？呢？</p>
<p>跨域共享</p>
<p><a href="https://blog.csdn.net/weixin_42053164/article/details/102921758" target="_blank" rel="noopener">cookie的跨域共享和setDomain()方法_weixin_42053164的博客-CSDN博客</a></p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>推送功能：</p>
<p>服务器可直接发送数据，而不必等待客户端的请求</p>
<p>减少通信量：</p>
<p>首部信息小，减少开销</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>网络协议</tag>
      </tags>
  </entry>
  <entry>
    <title>常用设计模式</title>
    <url>/page/design-pattern.html</url>
    <content><![CDATA[<h1 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h1><h2 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h2><blockquote>
<p>核心思想：在抽象类中定义抽象方法的执行顺序，并将抽象方法设定为只有子类实现</p>
</blockquote>
<p>模版模式定义了统⼀的执行结构（或者说特定方法的执行顺序与逻辑），使得后续实现者不需要关心调用逻辑，只需要关注具体的业务逻辑实现即可。这样有利于开发的拓展与迭代</p>
<h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3><p>Java中大名鼎鼎的 <code>AQS</code> （<code>AbstractQueueSynchronizer</code>）就使用了模板模式的思想进行实现</p>
<h3 id="思路实现"><a href="#思路实现" class="headerlink" title="思路实现"></a>思路实现</h3><p>1、定义了抽象方法执行顺序逻辑的核心抽象类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Template</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">mainMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 定义抽象方法执行逻辑</span><br>        method1();<br>        method2();<br>        method3();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、定义抽象方法的具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Template</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"demo1 method1"</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"demo1 method2"</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"demo1 method3"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、可以使用<code>Demo1</code>类中的实现完成逻辑</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Template template = <span class="hljs-keyword">new</span> Demo1();<br>    template.mainMethod();<br>&#125;<br><br><span class="hljs-comment">// demo1 method1</span><br><span class="hljs-comment">// demo1 method2</span><br><span class="hljs-comment">// demo1 method3</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java08-1：List相关实现类源码解析</title>
    <url>/page/Java08-List-source-code.html</url>
    <content><![CDATA[<h1 id="ArrayList-源码解析"><a href="#ArrayList-源码解析" class="headerlink" title="ArrayList 源码解析"></a>ArrayList 源码解析</h1><h2 id="底层容器"><a href="#底层容器" class="headerlink" title="底层容器"></a>底层容器</h2><p><code>ArrayList</code>底层就是一个长度可以动态增长的Object数组，如下<code>elementData</code>。</p>
<p>其中实现的接口中<code>RandomAccess</code>、<code>Cloneable</code>中都没有实现方法，更多的作为一种标识进行判断</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span><br></span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">8683452581122892189L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_CAPACITY = <span class="hljs-number">10</span>;	<span class="hljs-comment">// 默认初始容量</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;	<span class="hljs-comment">// 空数组（用于空实例）</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;	<span class="hljs-comment">// 默认空数组</span><br><br>    <span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// 保存ArrayList数据的数组</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;	<span class="hljs-comment">// ArrayList 所包含的元素个数</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>JDK1.7前，使用无参数构造方法创建<code>ArrayList</code>对象时，默认底层数组长度是10。类似于单例的饿汉式</p>
<p>JDK1.8后，使用无参数构造方法创建<code>ArrayList</code>对象时，默认底层数组长度是0，如下即指向了<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>。而当对数组进行添加元素操作后，才将数组扩容（第一次添加扩容为10），类似于单例的懒汉式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化时没有传入数据，默认将elementData构造为一个空数组</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ArrayList中提供了一个内部类Itr，实现了<code>Iterator</code>接口，实现对集合元素的遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Itr();<br>&#125;<br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123; &#125;<br></code></pre></td></tr></table></figure>



<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>主要有三种初始化办法：无参初始化、指定初始化数组大小初始化、指定初始数据初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;<br><br><span class="hljs-comment">// 无参数初始化，数组大小为空</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;<br>&#125;<br><br><span class="hljs-comment">// 指定初始数据初始化</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayList</span><span class="hljs-params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;<br>    <span class="hljs-comment">// elementData 是保存数组的容器，默认为 null</span><br>    elementData = c.toArray();<br>    <span class="hljs-comment">// 如果给定的集合（c）数据有值</span><br>    <span class="hljs-keyword">if</span> ((size = elementData.length) != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 如果集合元素类型不是 Object 类型，我们会转成 Object</span><br>        <span class="hljs-keyword">if</span> (elementData.getClass() != Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;<br>            elementData = Arrays.copyOf(elementData, size, Object[]<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 给定集合（c）无值，则默认空数组</span><br>        <span class="hljs-keyword">this</span>.elementData = EMPTY_ELEMENTDATA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>需要注意，JDK 1.8之后：<em>ArrayList 无参构造器初始化时，默认大小是空数组，当第一次add后才扩容为10</em></p>
<h2 id="新增与扩容"><a href="#新增与扩容" class="headerlink" title="新增与扩容"></a>新增与扩容</h2><h3 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>      <span class="hljs-comment">// 确保数组大小足够，不够执行扩容，size 为当前数组的大小</span><br>      ensureCapacityInternal(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>      <span class="hljs-comment">// 直接赋值(线程不安全)</span><br>      elementData[size++] = e;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureCapacityInternal</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>  	<span class="hljs-comment">//如果初始化数组大小时，有给定初始值，以给定的大小为准，不走 if 逻辑</span><br>	<span class="hljs-keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;<br>		minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);<br>    &#125;<br>    <span class="hljs-comment">// 确保容积足够</span><br>    ensureExplicitCapacity(minCapacity);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">ensureExplicitCapacity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-comment">// 修改记录数组</span><br>    modCount++;<br>    <span class="hljs-comment">// 如果我们期望的最小容量大于目前数组的长度，那么就扩容</span><br>    <span class="hljs-keyword">if</span> (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)<br>        grow(minCapacity);<br>&#125;<br><br><span class="hljs-comment">// 扩容(把现有数据拷贝到新的数组)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> oldCapacity = elementData.length;<br>    <span class="hljs-comment">// oldCapacity &gt;&gt; 1 是把 oldCapacity 除以 2 的意思</span><br>    <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 如果扩容后的值 &lt; 我们的期望值，扩容后的值就等于我们的期望值</span><br>    <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>        newCapacity = minCapacity;<br><br>    <span class="hljs-comment">// 如果扩容后的值 &gt; jvm 所能分配的数组的最大值，那么就用 Integer 的最大值</span><br>    <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>        newCapacity = hugeCapacity(minCapacity);<br><br>    <span class="hljs-comment">// 通过复制进行扩容</span><br>    elementData = Arrays.copyOf(elementData, newCapacity);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>扩容的规则并不是翻倍，而是扩为之前容量的1.5倍</li>
<li>ArrayList 中的数组的最大值是 <code>Integer.MAX_VALUE</code>，超过这个值，JVM 就不会给数组分配内存空间了</li>
<li>新增时，并没有对值进行严格的校验，所以 ArrayList 是允许 null 值的</li>
<li>扩容的底层是通过 <code>Arrays.copyOf(elementData, newCapacity);</code> 实现的</li>
</ul>
<h1 id="LinkedList-源码解析"><a href="#LinkedList-源码解析" class="headerlink" title="LinkedList 源码解析"></a>LinkedList 源码解析</h1><p><code>LinkedList</code>实现了<code>Deque</code>接口，所以除了可以作为线性表来使用外，还可以当做队列和栈来使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt;<br>    <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSequentialList</span>&lt;<span class="hljs-title">E</span>&gt;<br>    <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Deque</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span><br></span>&#123;<br>    <span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; first;<br><br>    <span class="hljs-keyword">transient</span> Node&lt;E&gt; last;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>利用静态内部类<code>Node</code>，表示双向链表的节点，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    E item;<br>    Node&lt;E&gt; next;<br>    Node&lt;E&gt; prev;<br><br>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;<br>        <span class="hljs-keyword">this</span>.item = element;<br>        <span class="hljs-keyword">this</span>.next = next;<br>        <span class="hljs-keyword">this</span>.prev = prev;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>Java12-3：线程隔离ThreadLocal</title>
    <url>/page/java12-ThreadLocal.html</url>
    <content><![CDATA[<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>利用<strong>线程隔离</strong>的思路解决线程安全问题，<code>ThreadLocal</code>变量的作用域是为线程，同一线程内共享，因此也就保证了线程安全</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul>
<li><p>每个线程需要一个独享的对象（比如说工具类或工具方法，该类方法通常不是线程安全的，所以需要将其在<strong>线程间隔离</strong>）</p>
<p>如使用线程池时，每个任务都需要创建一个对象完成工作，这种情况就可以使用 <code>ThreadLocal</code> 为每个线程创建一个目标对象，避免反复创建的同时也避免了“单例”情况下的线程不安全</p>
</li>
<li><p>每个线程内需要保存的全局变量，使得相应方法可以直接使用，避免参数的反复传递</p>
</li>
</ul>
<p>经典的使用场景是为每个线程分配一个 JDBC 连接 Connection。这样就可以保证每个线程的都在各自的 Connection 上进行数据库的操作，不会出现 A 线程将 B线程正在使用的 Connection 关闭</p>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>线程安全</li>
<li>不需要加锁，提高效率</li>
<li>更高效的利用内存、节省开销（不用每次新建对象）</li>
<li>避免参数反复传递，使代码耦合度更低</li>
</ul>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>基本使用就是声明<code>ThreadLocal</code>对象，然后使用<code>set</code>、<code>get</code>方法设置与得到相应的值（与线程绑定）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-comment">// 通常将 ThreadLocal 对象声明为 static final</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;&gt;();<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subthread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>                <span class="hljs-comment">// set 设置线程相关值</span><br>                threadLocal.set(Thread.currentThread().getName() + <span class="hljs-string">'-'</span> + i);<br>                <span class="hljs-comment">// get 取出相关值</span><br>                String val = threadLocal.get();<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">": "</span> + val);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Subthread t1 = <span class="hljs-keyword">new</span> Subthread();<br>        Subthread t2 = <span class="hljs-keyword">new</span> Subthread();<br>        t1.start();<br>        t2.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="http://cdn.ziyedy.top/Java12-3%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BBThreadLocal/ThreadLocal%E4%BD%BF%E7%94%A8%E7%BB%93%E6%9E%9C.png" alt=""></p>
<h2 id="ThreadLocal-源码解析"><a href="#ThreadLocal-源码解析" class="headerlink" title="ThreadLocal 源码解析"></a>ThreadLocal 源码解析</h2><h3 id="set-方法"><a href="#set-方法" class="headerlink" title="set 方法"></a>set 方法</h3><p>多个线程对同一个对象set操作，但只会get出自己set进去的值，原理如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// set时，把当前threadLocal对象作为key，想要保存的对象作为value，存入map</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(T value)</span> </span>&#123;<br>    Thread t = Thread.currentThread();<br>    ThreadLocalMap map = getMap(t);		<span class="hljs-comment">// 获取的 map 与当前线程绑定的</span><br>    <span class="hljs-keyword">if</span> (map != <span class="hljs-keyword">null</span>)<br>        map.set(<span class="hljs-keyword">this</span>, value);	<span class="hljs-comment">// 把当前threadLocal对象作为key，将value存入map</span><br>    <span class="hljs-keyword">else</span><br>        createMap(t, value);<br>&#125;<br><br><span class="hljs-function">ThreadLocalMap <span class="hljs-title">getMap</span><span class="hljs-params">(Thread t)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> t.threadLocals;	<span class="hljs-comment">// ThreadLocalMap 就存在 Thread 对象中</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>总结：<code>ThreadLocal</code> 看似自己保存了每个线程的变量副本，其实每个线程的变量副本是保存在线程对象中，因此自然就线程隔离了</em></p>
<p><img src="http://cdn.ziyedy.top/Java12-3%EF%BC%9A%E7%BA%BF%E7%A8%8B%E9%9A%94%E7%A6%BBThreadLocal/ThreadLocal%E5%8E%9F%E7%90%86.jpg" alt=""></p>
<h3 id="ThreadLocalMap-分析"><a href="#ThreadLocalMap-分析" class="headerlink" title="ThreadLocalMap 分析"></a>ThreadLocalMap 分析</h3><p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的静态内部类，其虽然作为属性存储在Thread类中，但由于<strong>访问权限问题</strong>只能由<code>ThreadLocal</code>进行维护</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 存在于 Thread 类中</span><br><span class="hljs-comment">// 即ThreadLocal其实是作为 “属性” 保存在Thread对象中的</span><br>ThreadLocal.ThreadLocalMap threadLocals = <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure>

<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><blockquote>
<p> 内存泄漏：为程序在申请内存后，无法释放已申请的内存空间（不会再被使用的对象或者变量占用的内存不能被回收）</p>
</blockquote>
<p><code>ThreadLocalMap</code>功能与其他Map类容器作用类似，但其中作为 key 存储的<code>ThreadLocal</code>对象为<strong>弱引用</strong>（如下），因此很容易被垃圾回收，但value对象并不会与之一起被回收，这样就会造成<strong>“内存泄漏”</strong>问题</p>
<p>通常线程运行完自动终止不会出现内存泄漏问题，但如果线程不终止（比如线程池中的线程），那么 Key 对应的 value 就不会被回收，因为存在调用链 <code>Thread -&gt; ThreadLocalMap -&gt; Entry(key == null) -&gt; Value</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 存在于 ThreadLocalMap 中，用于作为 key</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WeakReference</span>&lt;<span class="hljs-title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;<br>    <span class="hljs-comment">/** The value associated with this ThreadLocal. */</span><br>    Object value;<br><br>    Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;<br>        <span class="hljs-keyword">super</span>(k);<br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="如何避免内存泄漏"><a href="#如何避免内存泄漏" class="headerlink" title="如何避免内存泄漏"></a>如何避免内存泄漏</h3><p>JDK已经考虑了该问题，因此在 <code>set</code>、 <code>remove</code>等方法中会扫描key为 null 的Entry并把对应的value置为null，这样就能够对value进行回收</p>
<ul>
<li>每次使用完 <code>ThreadLocal</code> 都调用其 <code>remove()</code>方法清除数据（阿里规约）</li>
<li>将 <code>ThreadLocal</code> 变量定义为static，这样就保证了一直存在其强引用</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java12-4：线程池</title>
    <url>/page/Java12-thread-pool.html</url>
    <content><![CDATA[<h2 id="线程池简介"><a href="#线程池简介" class="headerlink" title="线程池简介"></a>线程池简介</h2><p>并发的本质其实就是任务的并行处理，所以绝大部分并发程序都是围绕离散任务进行的</p>
<ol>
<li>线程的创建与启动需要消耗资源，需要 JVM 和操作系统提供支持。如果线程运行的任务十分轻量级，那么反复创建线程开销巨大，会造成巨大的性能浪费</li>
<li>CPU 性能有限。当活跃的线程超过了 CPU 的承载限度，那么会有大量线程参与竞争 CPU，造成系统额外的开销，但是永远都会有很多线程无法竞争到 CPU，造成了资源的浪费；</li>
<li>系统能够支持的线程存在上限，过多的线程会占用过大的内存，造成OOM</li>
</ol>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><p>线程池的作用是维护一定数量的线程，接收任意数量的任务，这些任务被线程池中的线程并发执行</p>
<h2 id="线程池设计与实现"><a href="#线程池设计与实现" class="headerlink" title="线程池设计与实现"></a>线程池设计与实现</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p>维护一个任务队列 <code>RunnableTaskQueue</code> 用以接收 <code>Runnable</code>任务，其中任务一旦被线程池取完，则调用 <code>wait</code> 方法进入阻塞状态，而一旦有新的任务被添加进来，则</p>
<p>创建固定数量的线程作为线程池，不断的从 <code>RunnableTaskQueue</code> 中取得 <code>Runnable</code> 并调用其 <code>run</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunnableTaskQueue</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> LinkedList&lt;Runnable&gt; tasks = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Runnable <span class="hljs-title">getTask</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (tasks) &#123;<br>            <span class="hljs-keyword">while</span> (tasks.isEmpty()) &#123;<br>                System.out.println(<span class="hljs-string">"TaskQueue is empty"</span>);<br>                tasks.wait();<br>            &#125;<br>            <span class="hljs-keyword">return</span> tasks.removeFirst();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addTask</span><span class="hljs-params">(Runnable runnable)</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (tasks) &#123;<br>            tasks.add(runnable);<br>            tasks.notifyAll();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyExecutor</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> poolSize;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RunnableTaskQueue runnableTaskQueue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Thread&gt; threads = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> poolSize)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.poolSize = poolSize;<br>        <span class="hljs-keyword">this</span>.runnableTaskQueue = <span class="hljs-keyword">new</span> RunnableTaskQueue();<br>        Stream.iterate(<span class="hljs-number">1</span>, item -&gt; item + <span class="hljs-number">1</span>).limit(poolSize).forEach(item -&gt; &#123;<br>            initThread();<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initThread</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(threads.size() &lt;= poolSize) &#123;<br>            Thread thread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        Runnable task = runnableTaskQueue.getTask();<br>                        task.run();<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;);<br>            threads.add(thread);<br>            thread.start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable runnable)</span> </span>&#123;<br>        runnableTaskQueue.addTask(runnable);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p>阻塞队列是基于普通队列实现的，与多线程联系到一起。主要是对wait（）与notify（）操作的应用</p>
<p><a href="https://blog.csdn.net/weixin_45755718/article/details/106835215" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45755718/article/details/106835215</a></p>
<h2 id="Executor-线程池框架"><a href="#Executor-线程池框架" class="headerlink" title="Executor 线程池框架"></a>Executor 线程池框架</h2><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><table>
<thead>
<tr>
<th>参数名</th>
<th>类型</th>
<th>意义</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><code>coreSize</code> ：线程池在完成初始化</p>
<p>1：coreSize（核心线程数）：当新任务提交时，发现运行的线程数小于 coreSize，一个新的线程将被创建，即使这时候其它工作线程是空闲的，可以通过 getCorePoolSize 方法获得 coreSize；</p>
<p>2：maxSize（最大线程数）: 当任务提交时，coreSize &lt; 运行线程数 &lt;= maxSize，但队列没有满时，任务提交到队列中，如果队列满了，在 maxSize 允许的范围内新建线程；</p>
<p>corePoolSize == maxSize：创建固定大小的线程池，想让线程一下子增加到 maxSize，并且不要回收线程，防止线程回收，避免不断增加回收的损耗</p>
<p>线程池<strong>希望保持较少的线程数量</strong>，只有在负载变得很大时才增加它</p>
<p>使用无界</p>
<h3 id="向线程池提交任务的过程"><a href="#向线程池提交任务的过程" class="headerlink" title="向线程池提交任务的过程"></a>向线程池提交任务的过程</h3><h3 id="种类（5）"><a href="#种类（5）" class="headerlink" title="种类（5）"></a>种类（5）</h3><p>Executors#newCachedThreadPool 无界的线程池，并且可以自动回收</p>
<p>Executors#newFixedThreadPool 固定大小线程池；队列没有上限，有可能会导致OOM</p>
<p>Executors#newSingleThreadExecutor 单个线程的线程池；</p>
<p>ScheduledThreadPool    支持定时周期性任务执行的线程池</p>
<p>workStealingPool JDK 1.8 加入的</p>
<h3 id="拒绝策略（4）"><a href="#拒绝策略（4）" class="headerlink" title="拒绝策略（4）"></a>拒绝策略（4）</h3><h3 id="为什么建议手动创建线程池"><a href="#为什么建议手动创建线程池" class="headerlink" title="为什么建议手动创建线程池"></a>为什么建议手动创建线程池</h3><p>可以让我们更加明确线程池的运行规则，避免资源耗尽的风险</p>
<p>正确创建方法：根据不同业务场景，自己设置线程池参数（如内存有多大，想给线程取什么名字）</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/7ab4ae9443b9" target="_blank" rel="noopener">https://www.jianshu.com/p/7ab4ae9443b9</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM垃圾回收</title>
    <url>/page/jvm-garbage-collection.html</url>
    <content><![CDATA[<h1 id="对象死亡"><a href="#对象死亡" class="headerlink" title="对象死亡"></a>对象死亡</h1><h2 id="判断对象是否存活"><a href="#判断对象是否存活" class="headerlink" title="判断对象是否存活"></a>判断对象是否存活</h2><p>垃圾：内存中已经不再被使用到的内存空间就是垃圾</p>
<h3 id="引用计数器"><a href="#引用计数器" class="headerlink" title="引用计数器"></a>引用计数器</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的</p>
<ul>
<li><p>优点：实现简单、效率高</p>
</li>
<li><p>缺点：不能解决对象之间循环引用的问题（因此该方法不可行）</p>
</li>
</ul>
<p>循环引用就是：A引用B，B也引用A，但没别的对象引用这两个对象，这时其引用计数器不为0，所以引用计数器无法通知GC回收它们</p>
<h3 id="可达性分析法"><a href="#可达性分析法" class="headerlink" title="可达性分析法"></a>可达性分析法</h3><p>通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的</p>
<p><img src="http://cdn.ziyedy.top/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png" alt=""></p>
<h4 id="固定可作为-GC-Root-的对象"><a href="#固定可作为-GC-Root-的对象" class="headerlink" title="固定可作为 GC Root 的对象"></a>固定可作为 GC Root 的对象</h4><ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>在方法区中常量引用的对象，如字符串常量池中的引用</li>
<li>本地方法栈中JNI（即一般说的native方法）引用的对象</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻异常对象，以及系统类加载器</li>
<li>所有被同步锁（synchronized 关键字）修饰的对象</li>
</ul>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>如果一个对象具有强引用，Java 虚拟机宁愿抛出 <code>OutOfMemoryError</code> 错误，使程序异常终止，也<strong>不会靠随意回收具有强引用的对象来解决内存不足问题</strong>。</p>
<h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>如果内存空间足够，垃圾回收器就不会回收它，<strong>如果内存空间不足了，就会回收这些对象的内存</strong></p>
<h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，<strong>不管当前内存空间足够与否，都会回收它的内存</strong>。</p>
<h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在<strong>任何时候都可能被垃圾回收</strong>。</p>
<h1 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h1><h2 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h2><p>首先<strong>标记出</strong>所有不需要回收的对象</p>
<p>在标记完成后<strong>统一回收</strong>掉所有没有被标记的对象</p>
<img src="http://cdn.ziyedy.top/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpeg" style="zoom:50%;" />

<h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p>将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象<strong>复制</strong>到另一块去，然后再把使用的空间一次清理掉</p>
<p>JVM实际实现中，是将内存分为一块较大的Eden区和两块较小的Survivor空间，每次使用Eden和一块Survivor，<strong>回收时，把存活的对象复制到另一块Survivor</strong>。HotSpot默认的Eden和Survivor比是8:1，每次能够使用90%新生代空间</p>
<img src="http://cdn.ziyedy.top/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" style="zoom:50%;" />

<ul>
<li>优点：实现简单，运行高效，不用考虑碎片</li>
<li>缺点：内存有些浪费</li>
</ul>
<h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象<strong>向一端移动</strong>，然后直接<strong>清理掉端边界以外的内存</strong></p>
<img src="http://cdn.ziyedy.top/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" style="zoom: 80%;" />

<h2 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h2><p>核心思想：根据对象存活周期的不同将内存分为几块，从而可以根据各个年代的特点选择合适的垃圾收集算法</p>
<p><strong>如新生代通常采用复制算法，而老年代则采用标记-整理算法</strong></p>
<h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>垃圾收集器具体实现垃圾收集算法。HotSpot常见的收集算法及其作用邻域如下：</p>
<p>两个收集器之间存在连线，表示其可以搭配使用</p>
<img src="http://cdn.ziyedy.top/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/HotSpot%E6%94%B6%E9%9B%86%E5%99%A8.png" style="zoom:67%;" />

<h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>是一个单线程收集器，在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束</p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法</strong></p>
<p><img src="http://cdn.ziyedy.top/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png" alt=""></p>
<h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p> Serial 收集器的多线程并行版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）<strong>和 Serial 收集器完全一样</strong></p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p>除了 Serial 收集器外，只有它能与 CMS 收集器配合工作</p>
<p><img src="http://cdn.ziyedy.top/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png" alt=""></p>
<h2 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h2><blockquote>
<p>CMS（Concurrent Mark Sweep）收集器是一种以<strong>获取最短回收停顿时间</strong>为目标的收集器。它非常符合在注重用户体验的应用上使用。</p>
<p>收集器是 HotSpot 虚拟机第一款真正意义上的<strong>并发收集器</strong>，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作</p>
</blockquote>
<p><img src="http://cdn.ziyedy.top/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/CMS.png" alt=""></p>
<h3 id="运行过程"><a href="#运行过程" class="headerlink" title="运行过程"></a>运行过程</h3><p>使用的是<strong>标记-清除算法</strong>，其运行分为四个步骤：</p>
<ul>
<li><strong>初始标记</strong>阶段：暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快</li>
<li><strong>并发标记</strong>阶段：同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。跟踪记录<strong>发生引用更新的地方</strong></li>
<li><strong>重新标记</strong>阶段：修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录</li>
<li><strong>并发清除</strong>阶段：开启用户线程，同时 GC 线程开始对未标记的区域做清扫</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul>
<li>优点：并发收集、低停顿</li>
<li>缺点：对CPU资源敏感；无法处理浮动垃圾；由于使用标记-清除算法导致收集结束后会有大量空间碎片产生</li>
</ul>
<h2 id="G1"><a href="#G1" class="headerlink" title="G1"></a>G1</h2><p>G1是一个分代的，增量的，并行与并发的标记-复制垃圾回收器。设计目标是为了适应现在不断扩大的内存和不断增加的处理器数量，进一步降低暂停时间（pause time），同时兼顾良好的吞吐量</p>
<p><em>被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征</em></p>
<p><img src="http://cdn.ziyedy.top/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/G1.png" alt=""></p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li><p>可以面向堆内存任何部分来组成回收集（衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多）</p>
</li>
<li><p>开创<strong>基于 Region 的堆内存布局</strong>，即将连续的Java堆划分为多个大小相等的独立区域（Region），每一个 Region 都能根据需要扮演新生代或老年代空间，从而采用不同的策略进行处理（还有一类特殊的 Region，Humongous，即一个对象的大小超过了某一个阈值——HotSpot中是Region的1/2，即标记为 Humongous）</p>
</li>
<li><p>G1 仍然保留新生代和老年代的概念，但新生代与老年代不再是固定的，都是一系列的动态集合（物理上不需要连续，逻辑上连续）</p>
</li>
</ul>
<p>从年轻代空间（包括 Eden 和 Survivor 区域）回收内存被称为 Minor GC，对老年代GC称为Major GC，而Full GC是对整个堆来说的</p>
<p><strong>Minor GC：</strong>发生在Young space中的gc</p>
<p><strong>Major GC：</strong>发生在老年代Tenured space中的gc</p>
<p>STW(stop the world)：指的是用户线程在运行至安全点（safe point）或安全区域（safe region）之后，就自行挂起，进入暂停状态，对外的表现就是卡顿，而不论何种gc算法，不论是minor gc还是major gc都会STW，区别只在于STW的时间长短。<br><strong>Full GC：</strong>无官方定义，通常意义上而言指的是一次特殊GC的行为描述，这次GC会回收整个堆的内存，包含老年代，新生代，metaspace等。</p>
<p>但是实际情况中，我们主要看的是gc.log日志，其中也会发现在部分gc日志头中也有Full GC字眼，此处表示含义是在这次GC的全过程中，都是STW的状态，也就是说在这次GC的全过程中所有用户线程都是处于暂停的状态</p>
<p>参考：</p>
<blockquote>
<p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6</a></p>
<p><a href="https://blog.csdn.net/weixin_39309402/article/details/104756815" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39309402/article/details/104756815</a></p>
<p><a href="https://blog.csdn.net/qq_38384440/article/details/81710887" target="_blank" rel="noopener">https://blog.csdn.net/qq_38384440/article/details/81710887</a> （什么时候会发生FullGC）</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java内存模型</title>
    <url>/page/jvm-memory-model.html</url>
    <content><![CDATA[<blockquote>
<p>针对的是HotSpot虚拟机 </p>
</blockquote>
<h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="http://cdn.ziyedy.top/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F.png" alt=""></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><blockquote>
<p>程序计数器（Program Counter Register）是一块较小的内存空间，存储指向下一条指令的地址，可以看作是当前线程所执行字节码的<em>行号指示器</em></p>
</blockquote>
<ul>
<li><p><strong>线程私有</strong>，创建线程时创建相应的程序计数器</p>
</li>
<li><p>执行Java方法，记录的是正在执行的VM字节码指令的地址</p>
</li>
<li><p>执行本地（Native）方法，程序计数器为空（Undefined）</p>
</li>
<li><p>是<strong>唯一一个</strong>在JVM规范中不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡</p>
</li>
</ul>
<h3 id="Java虚拟机栈（Java栈）"><a href="#Java虚拟机栈（Java栈）" class="headerlink" title="Java虚拟机栈（Java栈）"></a>Java虚拟机栈（Java栈）</h3><blockquote>
<p>Java栈由一系列栈帧（Stack Frame）组成，因此Java栈也叫做<strong>帧栈</strong></p>
</blockquote>
<ul>
<li><p>线程私有，描述的是Java方法执行的线程内存模型</p>
</li>
<li><p>每个方法被执行时，JVM都会同步创建一个栈帧（Stack Frame）用于存储<strong>局部变量表、操作数栈、常量池指针、动态链接、方法返回值</strong>等等</p>
</li>
<li><p>每一个方法被调用直到执行结束，就对应一个栈帧在虚拟机栈中从入栈到出栈的过程（因此在栈中通常不存在垃圾回收问题）</p>
</li>
<li><p>会抛出<code>StackOverFlowError</code>与<code>OutOfMemoryError</code>两个异常</p>
</li>
</ul>
<img src="http://cdn.ziyedy.top/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/jvm-stack.jpg" style="zoom:67%;" />

<h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表存放了<strong>编译期可知</strong>的各种<strong>基本数据类型</strong>和<strong>引用类型</strong>，这些数据类型在局部变量表中以局部变量槽（Slot）来表示</p>
<p>每个slot存放32位的数据，因此long、double占两个槽位</p>
<p>局部变量表所需的<strong>内存空间在编译期间完成分配</strong>，进入一个方法时，该方法在栈帧中分配多大的局部变量空间是完全确定的</p>
<h3 id="本地方法栈（C栈）"><a href="#本地方法栈（C栈）" class="headerlink" title="本地方法栈（C栈）"></a>本地方法栈（C栈）</h3><p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用非常相似，区别在于：</p>
<ul>
<li><p>虚拟机栈为虚拟机执行Java方法（字节码）服务；</p>
</li>
<li><p>本地方法栈，用来支持<strong>Native方法</strong>执行</p>
</li>
</ul>
<h3 id="Java堆（Heap）"><a href="#Java堆（Heap）" class="headerlink" title="Java堆（Heap）"></a>Java堆（Heap）</h3><blockquote>
<p>一个JVM只有一个堆内存（<strong>线程共享</strong>），在虚拟机启动时创建</p>
<p><strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存</strong></p>
</blockquote>
<p>Java堆是<strong>垃圾收集器管理</strong>的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong></p>
<p>从垃圾回收的角度（更好回收与分配内存），由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：<strong>新生代和老年代</strong>：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等</p>
<p>如下分别为JDK 7与JDK 8的区域。</p>
<img src="http://cdn.ziyedy.top/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-JDK7.png" style="zoom:80%;" />

<img src="http://cdn.ziyedy.top/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/JVM%E5%A0%86%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84-jdk8.png" style="zoom:80%;" />



<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><blockquote>
<p>方法区（Method Area）用于存储已被虚拟机加载的类信息（类的结构信息）、常量（运行时常量池）、静态变量、即时编译器编译后的代码等数据</p>
</blockquote>
<ul>
<li>线程共享</li>
<li>Java虚拟机规范将方法区描述为<strong>堆的一个逻辑部分</strong>，但为了区分方法区又被称为<strong>非堆（Non-heap）</strong></li>
<li>通常和元空间（JDK 8之前“永久代”）关联在一起，但具体的跟JVM的实现和版本有关。<strong>元空间并不在虚拟机里面</strong>，而是直接使用本地内存</li>
</ul>
<h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>运行时常量池（Runtime Constant Pool）是方法区的一部分</p>
<p>在class文件中就存在<em>常量池表</em>，用于存放<strong>编译期间生成</strong>的各种字面量与符号引用，这部分内容将在<strong>类加载后</strong>存放到方法区的运行时常量池中</p>
<h2 id="对象创建全过程"><a href="#对象创建全过程" class="headerlink" title="对象创建全过程"></a>对象创建全过程</h2><h3 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h3><h4 id="step1：类加载检查"><a href="#step1：类加载检查" class="headerlink" title="step1：类加载检查"></a>step1：类加载检查</h4><p>虚拟机遇到一条 <code>new</code> 指令时，首先将去检查这个指令的参数是否能在<strong>常量池</strong>中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须<strong>先执行相应的类加载过程</strong>。</p>
<h4 id="step2：分配内存"><a href="#step2：分配内存" class="headerlink" title="step2：分配内存"></a>step2：分配内存</h4><p>类加载检查通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。</p>
<p>对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来</p>
<h4 id="step3：初始化零值"><a href="#step3：初始化零值" class="headerlink" title="step3：初始化零值"></a>step3：初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）</p>
<p>这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用</p>
<h4 id="step4：设置对象头"><a href="#step4：设置对象头" class="headerlink" title="step4：设置对象头"></a>step4：设置对象头</h4><p>初始化零值后，JVM对对象进行必要的设置（设置对象头相关信息）</p>
<h4 id="step5：执行init方法"><a href="#step5：执行init方法" class="headerlink" title="step5：执行init方法"></a>step5：执行init方法</h4><p>执行完以上步骤：从虚拟机角度而言，一个新对象已经产生了，但从Java程序角度而言，对象还没有进行初始化</p>
<p>因此需要执行init方法对对象进行初始化</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象在内存中存储的布局分为三部分∶对象头、实例数据和对齐填充</p>
<ul>
<li><p><strong>对象头</strong>，包含两个部分︰<br>（1）MarkWord：存储对象自身的运行数据，如∶HashCode、GC分代年龄、锁状态标志（<em>synchronized对象锁机制中的Monitor等信息就存储在这儿</em>）等<br>（2）类型指针：对象指向它的类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例</p>
</li>
<li><p><strong>实例数据</strong><br>真正存放对象实例数据的地方，即程序所定义的各个类型的字段内容</p>
</li>
<li><p><strong>对齐填充</strong><br>这部分不一定存在，也没有什么特别含义，仅仅是占位符。HotSpot要求对象起始地址都是8字节的整数倍，如果不是，就对齐填充</p>
</li>
</ul>
<p><img src="http://cdn.ziyedy.top/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80.png" alt=""></p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>在JVM规范中只规定了栈中的reference类型是一个指向对象的引用，但没有规定这个引用具体如何去定位、访问堆中对象的具体位置因此对象的访问方式<em>取决于JVM的实现</em>，目前主流的有：使用句柄、使用指针两种方式</p>
<ul>
<li><strong>使用句柄</strong>：Java堆中会划分出一块内存来做为句柄池，reference中存储句柄的地址，句柄中存储对象的实例数据和类元数据的地址</li>
</ul>
<img src="http://cdn.ziyedy.top/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E4%BD%BF%E7%94%A8%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" style="zoom:67%;" />

<ul>
<li><strong>使用指针</strong>（Hotpot使用）：Java堆中会存放访问类元数据的地址，reference存储的就直接是对象的地址</li>
</ul>
<img src="http://cdn.ziyedy.top/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/%E4%BD%BF%E7%94%A8%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png" style="zoom:67%;" />





<p>参考：</p>
<blockquote>
<p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F</a></p>
<p>《深入理解Java虚拟机》</p>
<p><a href="https://github.com/doocs/jvm/blob/main/docs/01-jvm-memory-structure.md" target="_blank" rel="noopener">https://github.com/doocs/jvm/blob/main/docs/01-jvm-memory-structure.md</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java12-1：线程安全问题与解决方案</title>
    <url>/page/Java12-thread-safe.html</url>
    <content><![CDATA[<h1 id="线程安全问题"><a href="#线程安全问题" class="headerlink" title="线程安全问题"></a>线程安全问题</h1><p>线程安全问题主要来源于并发时对共享资源的操作（如出现值更改与值不同步等问题）</p>
<p>线程安全主要表现在：<strong>原子性、可见性、有序性</strong>  三个方面</p>
<h2 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h2><blockquote>
<p>所有操作要么全部成功，要么全部失败</p>
</blockquote>
<p>即不可分割性，做为一个整体的N次操作，要么已经执行完毕，要么尚未发生。</p>
<h3 id="竞态条件"><a href="#竞态条件" class="headerlink" title="竞态条件"></a>竞态条件</h3><blockquote>
<p>在多线程的情况下，由于多个线程执行的时序不同，而出现不正确的结果</p>
</blockquote>
<p>即所做的“观察”得出的结论在进行执行时已经失效</p>
<p>例如：有一个a变量，查看时a==5，而在查看与执行中间的时间里a被修改使得a==10，因此使用 a==5 作为计算就会出现错误</p>
<h2 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h2><blockquote>
<p>一个线程对变量进行了修改，另外一个线程能够立刻读取到此变量的最新值</p>
</blockquote>
<h3 id="缓存一致性（可见性失败案例）"><a href="#缓存一致性（可见性失败案例）" class="headerlink" title="缓存一致性（可见性失败案例）"></a>缓存一致性（可见性失败案例）</h3><p>失败案例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">volatile1</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object o = <span class="hljs-keyword">new</span> Object();<br>        <span class="hljs-keyword">private</span> Boolean flag = <span class="hljs-keyword">false</span>;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">if</span> (flag) &#123;<br>                    <span class="hljs-comment">// 该行未打印</span><br>                    System.out.println(Thread.currentThread().getName() + <span class="hljs-string">":"</span> + flag);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Test test = <span class="hljs-keyword">new</span> Test();<br>        Thread thread = <span class="hljs-keyword">new</span> Thread(test);<br>        thread.start();<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        test.flag = <span class="hljs-keyword">true</span>;	<span class="hljs-comment">// 主函数中对flag进行修改并未被thread线程发现</span><br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        System.out.println(<span class="hljs-string">"Main thread is over"</span>);	<span class="hljs-comment">// 直接运行完该行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>出错原因：</p>
<p>为了提高计算效率，CPU 会从缓存中取得 flag 值。但是主存中 flag 值的变化，thread线程并不知道，导致其缓存和主存不一致，获取到的是失效的 flag 值（多个线程缓存不一致）</p>
<h2 id="解决方案——使用volatile关键字"><a href="#解决方案——使用volatile关键字" class="headerlink" title="解决方案——使用volatile关键字"></a>解决方案——使用volatile关键字</h2><p>上述代码中<strong>使用 volatile 修饰 flag 变量</strong>，会发现运行得到了想要的结果。<code>volatile</code> 关键字确保在多个线程并发时，任何一个线程改变了 flag 的值都会立即被其它线程所看到</p>
<h3 id="volatile的用处"><a href="#volatile的用处" class="headerlink" title="volatile的用处"></a>volatile的用处</h3><p>如之前在可见性中“缓存失败案例”中所述，使用<code>volatile</code>关键字可以解决可见性的问题</p>
<p>volatile 关键字可以用来修饰实例变量和类变量，被 volatile 修饰后，该变量可以获得可见性与有序性</p>
<ul>
<li><p><strong>可见性</strong>：任何线程对其修改，其它线程马上就能读到最新值；</p>
<p>volatile  编译为指令后有lock关键字，会锁住相关区域，即独占变量缓存而使其他缓存全部失效（缓存一致性协议）</p>
<p>1、执行写操作后，JMM会把工作内存中的最新变量值强制刷新到主内存</p>
<p>2、写操作会导致其他线程中的缓存无效</p>
</li>
<li><p><strong>有序性</strong>：禁止指令重排序。</p>
<p>通过<strong>内存屏障</strong>：即在屏障前所有指令可以重排序，在屏障后也可以重排序，但重排序不能够越过内存屏障</p>
</li>
</ul>
<p><strong>注：volatile 无法保证原子性</strong></p>
<p>参考：<a href="https://zhuanlan.zhihu.com/p/133851347" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/133851347</a></p>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><ol>
<li>volatile 的可见性和有序性只能作用于单一变量，且无法修饰方法</li>
<li>volatile 不能确保原子性</li>
</ol>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>volatile 最常用的用法，是<strong>使用 volatile 修饰作为标识判断的变量</strong>，如之前示例中用于进行判断的flag变量</p>
<h2 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h2><blockquote>
<p>代码在运行期间保证按照编写的顺序</p>
</blockquote>
<h3 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h3><p>代码在执行阶段，CPU会根据指令间的依赖关系进行优化以提高运行效率</p>
<h1 id="Atomic与CAS——原子性实现"><a href="#Atomic与CAS——原子性实现" class="headerlink" title="Atomic与CAS——原子性实现"></a>Atomic与CAS——原子性实现</h1><p>Atomic 相关类在 <code>java.util.concurrent.atomic</code> 包中，针对不同类型提供了很多类，<strong>它们都是使用  CAS 来保证原子性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">AtomicInteger count = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);		<span class="hljs-comment">// 利用Atomic声明当前变量</span><br>count.incrementAndGet();	<span class="hljs-comment">// 获取“最新”变量然后+1</span><br></code></pre></td></tr></table></figure>

<h2 id="CAS-算法"><a href="#CAS-算法" class="headerlink" title="CAS 算法"></a>CAS 算法</h2><p>CAS 即比较替换（Compare and swap） ，是一种乐观锁</p>
<p>它通过 CPU 指令实现，把无谓的同步消耗降到最低</p>
<h3 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h3><ul>
<li><p><strong>悲观锁</strong>：认为每一次自己的操作大概率会有其它线程在并发，所以自己在操作前都要对资源进行锁定，这种锁定是排他的。</p>
<p>悲观锁的缺点是不但把多线程并行转化为了串行，而且加锁和释放锁都会有额外的开支。</p>
</li>
<li><p><strong>乐观锁</strong>：认为每一次操作时大概率不会有其它线程并发，所以操作时并不加锁，而是在对数据操作时比较数据的版本，和自己更新前取得的版本一致才进行更新。</p>
<p>乐观锁省掉了加锁、释放锁的资源消耗，而且在并发量并不是很大的时候，很少会发生版本不一致的情况，此时乐观锁效率会更高。</p>
</li>
</ul>
<h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><p>首先从内存中取得要被更新的变量值，并且与期望的值进行比较（即需要更新操作的值）</p>
<ul>
<li><p>如果两个值<strong>相等</strong>，那么说明没有其它线程对其更新，本线程可以继续执行。</p>
</li>
<li><p>如果<strong>不等</strong>，说明有线程已经先于此线程进行了更新操作。那么则继续取得该变量的最新值，<strong>重复之前的逻辑</strong>，直至操作成功。</p>
</li>
</ul>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>其实Git的pull与push等操作就采用了CAS的思想，只是项目版本是否改变是由Git帮助我们进行判断</p>
<h2 id="Atomic源码分析"><a href="#Atomic源码分析" class="headerlink" title="Atomic源码分析"></a>Atomic源码分析</h2><h3 id="三个重要成员变量"><a href="#三个重要成员变量" class="headerlink" title="三个重要成员变量"></a>三个重要成员变量</h3><p><code>AtomicInteger</code> 中有 3 个重要的成员变量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Atomic 中的原子操作都是借助 unsafe 对象所实现的</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();<br><br><span class="hljs-comment">// AtomicInteger 包装的变量在内存中的地址，即 value 的地址</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> valueOffset;<br><br><span class="hljs-comment">// AtomicInteger 包装的变量值，并且用 volatile 修饰，以确保变量的变化能被其它线程看到</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> value;<br></code></pre></td></tr></table></figure>

<h3 id="incrementAndGet方法"><a href="#incrementAndGet方法" class="headerlink" title="incrementAndGet方法"></a>incrementAndGet方法</h3><p>首先调用<code>getAndAddInt</code>方法得到最新值，然后+1返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">incrementAndGet</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> unsafe.getAndAddInt(<span class="hljs-keyword">this</span>, valueOffset, <span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>getAndAddInt</code>基本就是CAS的实现，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAndAddInt</span><span class="hljs-params">(Object obj, <span class="hljs-keyword">long</span> valueOffset, <span class="hljs-keyword">int</span> <span class="hljs-keyword">var</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> expect;<br>    <span class="hljs-comment">// 利用循环</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// 获取value的最新值</span><br>        expect = <span class="hljs-keyword">this</span>.getIntVolatile(obj, valueOffset);<br>        <br>    &#125; <span class="hljs-keyword">while</span>(!<span class="hljs-keyword">this</span>.compareAndSwapInt(obj, valueOffset, expect, expect + <span class="hljs-keyword">var</span>));<br><br>    <span class="hljs-comment">// 返回value的原先值</span><br>    <span class="hljs-keyword">return</span> expect;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="CAS-的缺点"><a href="#CAS-的缺点" class="headerlink" title="CAS 的缺点"></a>CAS 的缺点</h2><ol>
<li>比较替换如果失败，则会一直循环，直至成功。这在并发量很大的情况下对 CPU 的消耗将会非常大</li>
<li>只能保证一个变量自身操作的原子性，但多个变量操作要实现原子性，是无法实现的</li>
<li>会导致 ABA 问题</li>
</ol>
<h3 id="ABA-问题"><a href="#ABA-问题" class="headerlink" title="ABA 问题"></a>ABA 问题</h3><p>问题描述：</p>
<p>假如本线程更新前取得期望值为 A，在更新操作发生前的这段时间内，其它线程可能把 value 改为了 B 又改回了 A。 而本线程更新时发现 value 和期望值一样还是 A，认为其没有变化，但其实此时的 A 已经不是彼时的 A 了。</p>
<p>解决方案：可以为使用<code>Atomic</code>包装的变量<strong>增加版本号</strong>，通过同时比较版本号来确定变脸是否发生变化</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java08-2：HashMap源码分析</title>
    <url>/page/Java08-hashmap-source-code.html</url>
    <content><![CDATA[<h2 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h2><p>JDK1.7及其之前，HashMap底层是一个<strong>table数组 + 链表</strong>实现的哈希表存储结构</p>
<p>JDK1.8以后，HashMap 底层的数据结构主要是：数组 + 链表 + 红黑树。其中当链表的长度大于等于 8 时，链表会转化成红黑树（能够降低查询的时间复杂度），当红黑树的大小小于等于 6 时，红黑树会转化成链表</p>
<h3 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始容量为 16</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br><br><span class="hljs-comment">// 最大容量</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-comment">// 负载因子默认值</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br><br><span class="hljs-comment">// 桶上的链表长度大于等于8时，链表转化成红黑树</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br><br><span class="hljs-comment">// 桶上的红黑树大小小于等于6时，红黑树转化成链表</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br><br><span class="hljs-comment">// 当数组容量大于 64 时，链表才会转化成红黑树</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br><br><span class="hljs-comment">// 记录迭代过程中 HashMap 结构是否发生变化，如果有变化，迭代时会 fail-fast</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> modCount;<br><br><span class="hljs-comment">// HashMap 的实际大小</span><br><span class="hljs-keyword">transient</span> <span class="hljs-keyword">int</span> size;<br><br><span class="hljs-comment">// 存放数据的数组</span><br><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-comment">// 触发扩容的阈值，有两种情况：</span><br><span class="hljs-comment">// 1、初始化时，给定数组大小，通过 tableSizeFor 方法计算</span><br><span class="hljs-comment">//	  数组大小为比给定数值大的2的整数次幂，如给定初始化大小19，实际上初始化大小即为为32</span><br><span class="hljs-comment">// 2、通过 resize 方法进行扩容，大小 = 数组容量 * 0.75</span><br><span class="hljs-keyword">int</span> threshold;<br><br><span class="hljs-comment">//链表的节点</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br><br><span class="hljs-comment">//红黑树的节点</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="为什么是-gt-8-时扩容"><a href="#为什么是-gt-8-时扩容" class="headerlink" title="为什么是 &gt;= 8 时扩容"></a>为什么是 &gt;= 8 时扩容</h3><p>红黑树需要占用的空间为链表的2倍，而链表数据不多时两者的查询速度差距没有那么明显，因此考虑到转化时间和空间损耗，必须定义出转化的边界值</p>
<p>因此使用<strong>泊松分布</strong>计算链表长度为8的概率，几乎接近于0，而一旦到8，说明哈希算法出现了问题，为提高性能则让链表转化为红黑树。</p>
<h3 id="HashMap-中数组大小为何一定为2的n次方"><a href="#HashMap-中数组大小为何一定为2的n次方" class="headerlink" title="HashMap 中数组大小为何一定为2的n次方"></a>HashMap 中数组大小为何一定为2的n次方</h3><p>HashMap在取模和扩容时进行了优化（加入了高位参与运算的过程），主要有如下三个步骤：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> h;<br>    <span class="hljs-comment">// 1、取hashCode值</span><br>    <span class="hljs-comment">// 2、高位参与运算</span><br>    <span class="hljs-keyword">return</span> (key == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br><br><span class="hljs-comment">//jdk1.7的源码，jdk1.8与之实现原理理一样</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>&#123; <br>	<span class="hljs-keyword">return</span> h &amp; (length-<span class="hljs-number">1</span>); <span class="hljs-comment">// 3、取模运算</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>该方法非常巧妙，通过 <code>h &amp; (length-1)</code> 来获取目标对象的位置（等价于h % length），而length保持了2的n次方能够大大加快运算效率，避免直接取模的效率损失。</p>
<h2 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h2><p>put方法的基本过程：</p>
<ol>
<li>空数组有无初始化，没有的话初始化；</li>
<li>如果通过 key 的 hash 能够直接找到值，跳转到 6，否则到 3；</li>
<li>如果 hash 冲突，两种解决方案：链表 or 红黑树；</li>
<li>如果是链表，递归循环，把新元素追加到队尾；</li>
<li>如果是红黑树，调用红黑树新增的方法；</li>
<li>通过 2、4、5 将新元素追加成功，再根据 onlyIfAbsent 判断是否需要覆盖；</li>
<li>判断是否需要扩容，需要扩容进行扩容，结束。</li>
</ol>
<h2 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h2><ul>
<li>JDK 1.7链表采用头插法</li>
<li>JDK 1.8链表采用尾插法</li>
</ul>
<p>由JDK1.7源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newCapacity)</span> </span>&#123; 	<span class="hljs-comment">// 传入新的容量</span><br>	Entry[] oldTable = table; 	<span class="hljs-comment">// 引⽤扩容前的Entry数组</span><br>	<span class="hljs-keyword">int</span> oldCapacity = oldTable.length;<br>	<span class="hljs-keyword">if</span> (oldCapacity == MAXIMUM_CAPACITY) &#123; 	<span class="hljs-comment">// 扩容前的数组大⼩如果已经达到最⼤(2^30)了</span><br>		threshold = Integer.MAX_VALUE; 		<span class="hljs-comment">// 修改阈值为int的最⼤大值(2^31-1)</span><br>		<span class="hljs-keyword">return</span>;<br>	&#125;<br>    <br>	Entry[] newTable = <span class="hljs-keyword">new</span> Entry[newCapacity]; <span class="hljs-comment">// 初始化一个新的Entry数组</span><br>	transfer(newTable); 	<span class="hljs-comment">// 将数据转移到新的Entry数组里</span><br>	table = newTable; 		<span class="hljs-comment">// HashMap的table属性引⽤新的Entry数组</span><br>	threshold = (<span class="hljs-keyword">int</span>)(newCapacity * loadFactor);	<span class="hljs-comment">// 修改阈值</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中 <code>transfer()</code> 方法将原有的数组中的元素拷贝到新的数组中去，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">transfer</span><span class="hljs-params">(Entry[] newTable)</span> </span>&#123;<br>	Entry[] src = table; 	<span class="hljs-comment">// src引⽤了旧的Entry数组</span><br>	<span class="hljs-keyword">int</span> newCapacity = newTable.length;<br>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; src.length; j++) &#123; 	<span class="hljs-comment">// 遍历旧的Entry数组</span><br>		Entry&lt;K,V&gt; e = src[j]; 		<span class="hljs-comment">// 取得旧Entry数组的每个元素</span><br>		<span class="hljs-keyword">if</span> (e != <span class="hljs-keyword">null</span>) &#123;<br>			src[j] = <span class="hljs-keyword">null</span>;	<span class="hljs-comment">// 释放旧Entry数组的对象引⽤用（for循环后，旧的Entry数组不再引⽤用任何对象）</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                Entry&lt;K,V&gt; next = e.next;<br>                <span class="hljs-keyword">int</span> i = indexFor(e.hash, newCapacity); <span class="hljs-comment">// 重新计算每个元素在数组中的位置</span><br>                e.next = newTable[i]; <span class="hljs-comment">//标记[1]</span><br>                newTable[i] = e; 	<span class="hljs-comment">//将元素放在数组上</span><br>                e = next;	 <span class="hljs-comment">// 访问下⼀个Entry链上的元素</span><br>            &#125; <span class="hljs-keyword">while</span> (e != <span class="hljs-keyword">null</span>);<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="HashMap-并发安全问题"><a href="#HashMap-并发安全问题" class="headerlink" title="HashMap 并发安全问题"></a>HashMap 并发安全问题</h3><p><strong>并发的多线程环境使用HashMap可能会造成死循环</strong></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>源码</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/page/memory-management.html</url>
    <content><![CDATA[<h1 id="内存概述"><a href="#内存概述" class="headerlink" title="内存概述"></a>内存概述</h1><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><blockquote>
<p>内存是用于存放数据的硬件，程序执行前需要先放到内存中才能被CPU处理</p>
</blockquote>
<ul>
<li><p>存储单元：按字节编址（一个存储单元1个字节，8个二进制位）；按字长编址（一个存储单元1个字长，按计算机的字长决定存储单元大小）</p>
</li>
<li><p>内存地址：从0开始，每一个地址对应一个存储单元</p>
</li>
</ul>
<h2 id="逻辑地址与物理地址"><a href="#逻辑地址与物理地址" class="headerlink" title="逻辑地址与物理地址"></a>逻辑地址与物理地址</h2><p>代码翻译成CPU可识别的指令，这些指令会告诉CPU该去内存中的哪个地址存/取数据，这时表示的是实际存放的地址，即<strong>物理地址</strong></p>
<p>生成机器指令的时候并不知道该进程的数据会放到什么位置，编译生成的指令中使用的是相对地址，即<strong>逻辑地址</strong></p>
<h2 id="程序运行基本原理"><a href="#程序运行基本原理" class="headerlink" title="程序运行基本原理"></a>程序运行基本原理</h2><p><img src="http://cdn.ziyedy.top/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E5%9F%BA%E6%9C%AC%E8%BF%87%E7%A8%8B.jpg" alt=""></p>
<h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>源代码文件(.c)生成目标模块(.o)，将高级语言翻译为机器语言。每一个目标模块都具有独立的逻辑地址</p>
<h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>目标模块生成装入模块(可执行文件，如.exe)，链接完成使得各模块形成整体的链接地址</p>
<ul>
<li><p>静态链接：装入前链接成一个完整模块</p>
</li>
<li><p>装入时动态链接：运行前边装入边链接</p>
</li>
<li><p>运行时动态链接：运行时需要什么模块才装入并链接</p>
</li>
</ul>
<h3 id="装载"><a href="#装载" class="headerlink" title="装载"></a>装载</h3><p>将装入模块装入内存运行，装入后形成物理地址</p>
<ul>
<li><p>绝对装入：编译时产生绝对地址，只适用于单道程序环境(那时候还没有操作系统，编译器负责实现)</p>
</li>
<li><p>静态重定位：编译链接后的装入模块地址是逻辑地址，装入时进行重定位，将指令中逻辑地址+装入的起始物理地址得到真实的物理地址（地址写死，早期系统使用）</p>
</li>
<li><p>动态重定位：运行时才将逻辑地址转换为物理地址。</p>
</li>
</ul>
<h1 id="内存空间的分配与回收"><a href="#内存空间的分配与回收" class="headerlink" title="内存空间的分配与回收"></a>内存空间的分配与回收</h1><h2 id="连续分配管理方式"><a href="#连续分配管理方式" class="headerlink" title="连续分配管理方式"></a>连续分配管理方式</h2><h3 id="单一连续分配"><a href="#单一连续分配" class="headerlink" title="单一连续分配"></a>单一连续分配</h3><p>内存被分为系统区和用户区，系统区通常位于内存的低地址部分，用于存放操作系统相关数据；而用户区用于存放用户进程相关数据</p>
<p>内存中只能有一道用户程序，用户程序独占用户区</p>
<h3 id="固定分区分配"><a href="#固定分区分配" class="headerlink" title="固定分区分配"></a>固定分区分配</h3><p>将用户空间划分为若干个固定大小（可以一样大也可以不一样大）的分区，在每个分区中只装入一个作业。操作系统需要建立并管理一个“分区说明表“，用来实现每个分区的分配与回收</p>
<p><img src="http://cdn.ziyedy.top/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%9B%BA%E5%AE%9A%E5%88%86%E5%8C%BA%E5%AD%98%E5%82%A8.png" alt=""></p>
<ul>
<li>优点：实现简单，无外部碎片</li>
<li>缺点：进程太多必须使用覆盖技术，使得性能降低；同时会采用内部碎片，导致内存利用率低</li>
</ul>
<h3 id="动态分区分配"><a href="#动态分区分配" class="headerlink" title="动态分区分配"></a>动态分区分配</h3><p>不事先划定分区，而是在进程装入内存时，根据进程的大小动态的建立分区（系统分区的大小和数目是可变的）</p>
<p>要实现动态分区分配，操作系统需要维护并管理存储<strong>空闲分区</strong>信息的数据结构，常用的有空闲分区表和空闲分区链</p>
<p>可以使用”紧凑“方法来解决外部随便，所谓紧凑就是移动进程所分配的内存块从而将空闲内存连续起来</p>
<p>实现动态分区分配的主要方法：</p>
<p><img src="http://cdn.ziyedy.top/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%8A%A8%E6%80%81%E5%88%86%E5%8C%BA%E5%88%86%E9%85%8D%E7%AE%97%E6%B3%95.jpg" alt=""></p>
<h2 id="！非连续分配管理方式"><a href="#！非连续分配管理方式" class="headerlink" title="！非连续分配管理方式"></a>！非连续分配管理方式</h2><blockquote>
<p>为用户进程分配的内存可以是一个<strong>离散</strong>的内存空间</p>
</blockquote>
<p>主要包括：分页管理、分段管理、段页式存储管理</p>
<h2 id="分页管理"><a href="#分页管理" class="headerlink" title="分页管理"></a>分页管理</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><ul>
<li><p>内存空间：分成一个个<strong>相等的小分区</strong>，每个分区就是一个<em>页框<em>，并从0开始依次分配</em>页框号</em></p>
</li>
<li><p>用户进程地址空间：拆分成一个个<strong>与页框大小相等</strong>的小部分，称为<em>页</em>，每个页也有一个从0开始分配的<em>页号</em></p>
</li>
</ul>
<p>之后<strong>操作系统以页框为单位为各个进程分配内存空间</strong>，进程的页与内存的页框一一对应，各个页不必连续存放，也不必按照一定顺序，实现了离散的存储</p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>为了能知道进程的每个页面在内存中存放的位置，操作系统要<strong>为每一个进程建立一张页表</strong>，页表具有如下特点：</p>
<p>1、一个进程对应一张页表</p>
<p>2、进程的每一页对应一块页表项</p>
<p>3、每个页表项由”页号“和”块号“组成</p>
<p>4、页表记录进程页面和实际存放的内存块之间的对应关系</p>
<p>5、每个页表项长度是相同的，所以页号是”隐含“的</p>
<h3 id="基本地址转换"><a href="#基本地址转换" class="headerlink" title="基本地址转换"></a>基本地址转换</h3><p>页表寄存器：保存页表在内存中的起始地址F和页表长度M。进程未执行的时候，F和M放在PCB中，进程被调度时，操作系统内核将其放到页表寄存器中</p>
<p><img src="http://cdn.ziyedy.top/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%88%86%E9%A1%B5%E5%9F%BA%E6%9C%AC%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2.png" alt=""></p>
<h3 id="利用快表的地址转换"><a href="#利用快表的地址转换" class="headerlink" title="利用快表的地址转换"></a>利用快表的地址转换</h3><p>根据<strong>局部性原理</strong>（见下文），可以使用快表（TLB，是一种告诉存储单元）来存放当前访问的若干页表项，以加速地址转化的过程</p>
<p><img src="http://cdn.ziyedy.top/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%88%86%E9%A1%B5%E5%BF%AB%E8%A1%A8%E5%9C%B0%E5%9D%80%E8%BD%AC%E5%8C%96.png" alt=""></p>
<h3 id="多级页表"><a href="#多级页表" class="headerlink" title="多级页表"></a>多级页表</h3><p>单级页表存在几个问题：</p>
<ul>
<li>所有页表项都要连续存放，页表很大时占用页框很多</li>
<li>进程一段时间可能只访问某几个特定的页面，因此没有必要让页表常驻</li>
</ul>
<p>为解决这些问题可以采用多级页表</p>
<h2 id="分段管理"><a href="#分段管理" class="headerlink" title="分段管理"></a>分段管理</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><ul>
<li><p>进程的地址空间：按照程序自身的逻辑关系划分为若干个段，每个段有一个段名，每个段从0开始编址</p>
</li>
<li><p>内存分配规则：以段为单位进行分配，每个段在内存中占据连续空间，但各段之间可以不相邻</p>
</li>
</ul>
<h3 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h3><p>程序分为多个段，离散的放入内存，必须能够从物理内存中找到各个逻辑段的存放位置（<strong>段表</strong>）</p>
<p>记录该段在内存中的起始位置（基址）、段的长度。各个段表项的长度一致，因此段号是隐含的可以不进行记录</p>
<p><img src="http://cdn.ziyedy.top/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%88%86%E6%AE%B5%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.jpg" alt=""></p>
<h2 id="段页式管理"><a href="#段页式管理" class="headerlink" title="段页式管理"></a>段页式管理</h2><h3 id="分段与分页的优缺点"><a href="#分段与分页的优缺点" class="headerlink" title="分段与分页的优缺点"></a>分段与分页的优缺点</h3><p><img src="http://cdn.ziyedy.top/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%88%86%E6%AE%B5%E4%B8%8E%E5%88%86%E9%A1%B5%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9.jpg" alt=""></p>
<h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><blockquote>
<p>将进程按逻辑模块分段，再进行分页</p>
</blockquote>
<p><img src="http://cdn.ziyedy.top/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%AE%B5%E9%A1%B5%E5%BC%8F.png" alt=""></p>
<h3 id="地址转换-1"><a href="#地址转换-1" class="headerlink" title="地址转换"></a>地址转换</h3><p>逻辑：段号、页号、页内地址（业内偏移量）</p>
<p>段号决定了每个进程最多可以分几个段</p>
<p>页号决定了每个段最大有多少页</p>
<p><img src="http://cdn.ziyedy.top/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E6%AE%B5%E9%A1%B5%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2.jpg" alt=""></p>
<h1 id="内存空间的扩充"><a href="#内存空间的扩充" class="headerlink" title="内存空间的扩充"></a>内存空间的扩充</h1><h2 id="覆盖技术"><a href="#覆盖技术" class="headerlink" title="覆盖技术"></a>覆盖技术</h2><p>按自身逻辑结构，让一些不可能被同时访问的程序段共享同一覆盖区（只存在于早期操作系统）</p>
<h2 id="交换技术"><a href="#交换技术" class="headerlink" title="交换技术"></a>交换技术</h2><p>将磁盘分为对换区（swap）和文件区，前者连续分配追求I/O速度，后者离散分配追求存储空间利用率</p>
<p><strong>内存紧张时，把进程暂时换出到外存相应区域</strong>。优先换出阻塞进程、低优先级进程（可能导致饥饿）、还要考虑进程在内存的驻留时间，PCB不会换出</p>
<h2 id="！虚拟存储技术"><a href="#！虚拟存储技术" class="headerlink" title="！虚拟存储技术"></a>！虚拟存储技术</h2><h3 id="传统内存分配方法缺陷"><a href="#传统内存分配方法缺陷" class="headerlink" title="传统内存分配方法缺陷"></a>传统内存分配方法缺陷</h3><ul>
<li>一次性：作业必须一次性全部装入内存后才能开始运行。大作业无法运行，多道程序并发度下降（比如一些几十个G的游戏显然无法在有限的内存中运行）。</li>
<li>驻留性：作业在运行期间一直驻留在内存，内存中驻留大量的暂时用不到的数据，浪费了宝贵的内存资源。</li>
</ul>
<h3 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h3><ul>
<li>时间局部性：现在访问的指令、数据在不久后很可能再次访问</li>
<li>空间局部性：现在访问的内存单元周围的内存空间很可能在不久之后访问</li>
<li>高速缓存：频繁访问的数据放到更高速的储存器中</li>
</ul>
<h3 id="虚拟内存概述"><a href="#虚拟内存概述" class="headerlink" title="虚拟内存概述"></a>虚拟内存概述</h3><p>根据传统内存分配方法的缺陷以及局部性原理的特点，使用虚拟内存方法进行改进：</p>
<blockquote>
<p>程序不需要全部装入内存即可运行，运行时根据需要动态调入数据，内存不够时，换出一些数据到外存</p>
</blockquote>
<ul>
<li>多次性：作业无需在运行时一次装入内存，而是允许分多次调用</li>
<li>对换性：作业无需在运行时常驻内存，允许作业换入、换出</li>
<li><strong>虚拟性：从逻辑上扩充了内存容量，用户看到的容量，远大于实际容量</strong></li>
</ul>
<h1 id="虚拟内存的实现"><a href="#虚拟内存的实现" class="headerlink" title="虚拟内存的实现"></a>虚拟内存的实现</h1><h2 id="请求换页"><a href="#请求换页" class="headerlink" title="请求换页"></a>请求换页</h2><blockquote>
<p>访问的信息不存在时，操作系统负责将需要的信息从外存调入内存</p>
</blockquote>
<h3 id="新增页表项"><a href="#新增页表项" class="headerlink" title="新增页表项"></a>新增页表项</h3><ul>
<li>状态位：表示页面是否已在内存中</li>
<li>访问字段：记录最近的被访问情况，供页面置换算法参考</li>
<li>修改位：表示页面调入内存中是否修改过，只有修改过的页面才需要在置换时写回外存</li>
<li>外存地址：页面在外存中存放的位置</li>
</ul>
<h3 id="缺页中断机制"><a href="#缺页中断机制" class="headerlink" title="缺页中断机制"></a>缺页中断机制</h3><p>每当访问的页面不存在时，便产生一个<strong>缺页中断</strong>，然后由操作系统的缺页中断处理程序处理中断。此时缺页的进程<strong>阻塞</strong>，放入阻塞队列，掉页完成后再将其放入就绪队列</p>
<h2 id="页面置换"><a href="#页面置换" class="headerlink" title="页面置换"></a>页面置换</h2><p>内存空间不足时，将内存中暂时不用的信息换到外存</p>
<p>页面的换入换出需要磁盘I/O，时间开销是很大的，缺页率越小越好</p>
<h3 id="最佳置换算法-OPT"><a href="#最佳置换算法-OPT" class="headerlink" title="最佳置换算法(OPT)"></a>最佳置换算法(OPT)</h3><blockquote>
<p>每次选择淘汰的页面将是<strong>以后再不使用的，或是在最长时间内不再被访问的页面</strong>，以保证最低的缺页率</p>
</blockquote>
<p>该算法实现的前提是知道页面的访问序列，这是无法预知的，因此该方法<strong>无法实现</strong></p>
<h3 id="先进先出置换算法-FIFO"><a href="#先进先出置换算法-FIFO" class="headerlink" title="先进先出置换算法(FIFO)"></a>先进先出置换算法(FIFO)</h3><blockquote>
<p>每次选择淘汰的页面是<strong>最早进入内存的页面</strong>，可以使用队列进行实现</p>
</blockquote>
<blockquote>
<p>Belady异常：当为进程分配的物理块增大时，缺页次数不增反降</p>
</blockquote>
<p>FIFO算法会产生Belady异常，其实现简单，但性能差（最早进入与最近是否访问没有明显关联）</p>
<h3 id="最近最久未使用算法-LRU"><a href="#最近最久未使用算法-LRU" class="headerlink" title="最近最久未使用算法(LRU)"></a>最近最久未使用算法(LRU)</h3><blockquote>
<p>LRU（least recently used）：每次选择淘汰的页面是<strong>最近最久未使用的页面</strong></p>
</blockquote>
<p>实现方式：给每个页面对应的页表项中，用访问字段记录该页面自上次被访问以来所经历的时间t，当需要淘汰一个页面时，选择所有页面中t最大的，即最近最久未使用的页面</p>
<h3 id="时钟置换算法-CLOCK"><a href="#时钟置换算法-CLOCK" class="headerlink" title="时钟置换算法(CLOCK)"></a>时钟置换算法(CLOCK)</h3><p>实现方法：</p>
<p>为每个页面设置一个访问位（如1表示最近访问过，0表示最近没访问过），再将内存中的页面链接为一个循环队列</p>
<p>若某页被访问，则将访问位置为1。当需要淘汰一个页面时，则<strong>淘汰第一个访问位为0的页面</strong>，若遇到访问位为1的页面，则将其访问位置为0</p>
<p>因此，使用该方法选择一个淘汰页面最多会进行<strong>两轮扫描</strong></p>
<h3 id="改进型时钟置换算法"><a href="#改进型时钟置换算法" class="headerlink" title="改进型时钟置换算法"></a>改进型时钟置换算法</h3><blockquote>
<p>相对于普通时钟置换算法，最大的改变就是使用<strong>（访问位，修改位）</strong>的形式表示各页面的状态</p>
<p>以优先找到最近<strong>既没被访问过，又没被修改过</strong>的页面</p>
</blockquote>
<h3 id="页面置换算法总结与比较"><a href="#页面置换算法总结与比较" class="headerlink" title="页面置换算法总结与比较"></a>页面置换算法总结与比较</h3><p><img src="http://cdn.ziyedy.top/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E9%A1%B5%E9%9D%A2%E7%BD%AE%E6%8D%A2%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83.jpg" alt=""></p>
<h1 id="页面分配策略"><a href="#页面分配策略" class="headerlink" title="页面分配策略"></a>页面分配策略</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><blockquote>
<p>驻留集：请求分页存储管理中给进程分配的物理块的集合。在采用了虚拟存储技术的系统中，驻留集大小一般小于进程大小</p>
</blockquote>
<ul>
<li><p>固定分配：操作系统为进程分配一组固定数目的物理块，在运行期间不变（驻留集不变）</p>
</li>
<li><p>可变分配：在运行期间驻留集大小可变</p>
</li>
<li><p>局部置换：发生缺页时只能进程自己的物理块进行置换</p>
</li>
<li><p>全局置换：可以使用其他空间进行置换</p>
</li>
<li><p>抖动现象：给进程分配的物理块太少，刚刚换出的页面马上又要换入内存,刚刚换入的页面马上又要换出外存，这种<strong>频繁的页面调度行为</strong>称为抖动或颠簸。</p>
</li>
</ul>
<h2 id="从何处调页"><a href="#从何处调页" class="headerlink" title="从何处调页"></a>从何处调页</h2><h3 id="对换区空间足够"><a href="#对换区空间足够" class="headerlink" title="对换区空间足够"></a>对换区空间足够</h3><p><img src="http://cdn.ziyedy.top/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%AF%B9%E6%8D%A2%E5%8C%BA%E7%A9%BA%E9%97%B4%E8%B6%B3%E5%A4%9F.png" alt=""></p>
<h3 id="对换区空间不够"><a href="#对换区空间不够" class="headerlink" title="对换区空间不够"></a>对换区空间不够</h3><p><img src="http://cdn.ziyedy.top/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E5%AF%B9%E6%8D%A2%E5%8C%BA%E7%A9%BA%E9%97%B4%E4%B8%8D%E5%A4%9F.png" alt=""></p>
<h3 id="Unix-方式"><a href="#Unix-方式" class="headerlink" title="Unix 方式"></a>Unix 方式</h3><p><img src="http://cdn.ziyedy.top/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/unix%E6%96%B9%E5%BC%8F.png" alt=""></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>进程管理</title>
    <url>/page/process-management.html</url>
    <content><![CDATA[<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><blockquote>
<p>进程是程序的一次执行过程，是一个程序及其数据在处理机上顺序执行时所发生的活动</p>
</blockquote>
<h2 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h2><h3 id="进程组成"><a href="#进程组成" class="headerlink" title="进程组成"></a>进程组成</h3><p>进程由以下三个部分组成</p>
<ul>
<li>程序段：存放程序代码本身</li>
<li>数据段：存放程序运行过程中处理的各种数据</li>
<li>PCB：进程管理所需的数据都放在这里，PCB是进程存在的标志</li>
</ul>
<p>其中操作系统管理进程，主要是管理进程所对应的PCB</p>
<p><strong>PCB中包括了进程的描述信息</strong>（进程标识符 PID、用户标识符 UID、父进程、子进程等）；进程控制和管理信息（进程优先级、进程当前状态、进程同步和通信机制等）；资源分配清单（程序段指针、数据段指针、外设资源等）；处理器信息（如各类寄存器的值，程序计数器等等）</p>
<h3 id="进程的组织"><a href="#进程的组织" class="headerlink" title="进程的组织"></a>进程的组织</h3><blockquote>
<p>进程的组织其实就是组织进程所对应的PCB</p>
</blockquote>
<p>主要可以用两种数据结构实现：</p>
<ul>
<li>链接方式：即按照进程状态将PCB分为多个队列，同时操作系统对各队列的指针进行管理（比如进程的就绪队列等等）</li>
<li>索引方式：根据进程状态建立索引表，操作系统持有各表的指针</li>
</ul>
<h3 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h3><blockquote>
<p>进程控制就是对系统中的所有进程实施有效的管理，如创建新进程、撤销已有进程、实现进程状态转换等功能</p>
<p><strong>进程控制使用原语实现</strong></p>
</blockquote>
<p>进程控制会导致进程状态的转换，主要需要实现如下控制：</p>
<ul>
<li>更新PCB中的信息</li>
<li>将PCB插入合适的队列</li>
<li>分配/回收资源</li>
</ul>
<h3 id="进程的特性"><a href="#进程的特性" class="headerlink" title="进程的特性"></a>进程的特性</h3><ul>
<li>动态性：最基本特征。进程是程序的一次执行过程，是动态地产生、变化和消亡的</li>
<li>并发性：内存中有多个进程实体，各进程可以并行执行</li>
<li>独立性：进程是能独立运行、获得资源、接受调度的基本单位</li>
<li><strong>异步性</strong>：各进程按各自独立的、不可预测的速度向前推进，异步性会导致并发程序执行结果的不确定性，操作系统要提供<strong>“进程同步机制”</strong>来解决异步问题</li>
<li>结构性：每一个进程都会配置PCB</li>
</ul>
<h2 id="进程的状态与转换"><a href="#进程的状态与转换" class="headerlink" title="进程的状态与转换"></a>进程的状态与转换</h2><h3 id="进程的状态"><a href="#进程的状态" class="headerlink" title="进程的状态"></a>进程的状态</h3><blockquote>
<p>进程有三个基本状态：运行、就绪、阻塞/等待，此外还有创建状态和终止状态</p>
</blockquote>
<ul>
<li>运行状态(Running)：占有CPU，并在CPU上运行</li>
<li>就绪状态(Ready)：进程已经具备一切运行条件，除了没有空闲CPU，导致暂时不能运行</li>
<li>阻塞状态(Waiting/Blocked)：等待某一事件或资源而暂时不能运行，比如等待操作系统分配打印机、等待磁盘读写</li>
<li>创建状态(New)：操作系统为该进程分配所需内存等系统资源，为其创建、初始化PCB(分配PID等等)</li>
<li>终止状态(Terminated)：进程运行结束，或者出现Bug导致无法继续执行，操作系统需要撤销进程 完成资源回收，撤销PCB</li>
</ul>
<h3 id="进程状态转换"><a href="#进程状态转换" class="headerlink" title="进程状态转换"></a>进程状态转换</h3><p><img src="http://cdn.ziyedy.top/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%BF%9B%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.jpg" alt=""></p>
<h1 id="进程间通信（IPC）"><a href="#进程间通信（IPC）" class="headerlink" title="进程间通信（IPC）"></a>进程间通信（IPC）</h1><h2 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h2><blockquote>
<p>进程通信就是进程之间的信息交换。</p>
<p>由于各进程的内存地址空间相互独立，一个进程不能直接访问另一个进程的地址空间，所以就产生了进程间通信（IPC）问题</p>
</blockquote>
<h3 id="1、共享存储"><a href="#1、共享存储" class="headerlink" title="1、共享存储"></a>1、共享存储</h3><blockquote>
<p>使得多个进程可以访问同一块内存空间，不同进程可以看到对方进程对共享内存中数据的更新。</p>
</blockquote>
<p>两个进程对共享空间的访问必须是<strong>互斥</strong>的，所以该方法需要依靠某种同步操作，如互斥锁和信号量等</p>
<p><img src="http://cdn.ziyedy.top/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8.png" alt=""></p>
<h3 id="2、管道通信"><a href="#2、管道通信" class="headerlink" title="2、管道通信"></a>2、管道通信</h3><blockquote>
<p>管道是指用于连接读写进程的一个共享文件</p>
</blockquote>
<p>管道只能采用半双工通信，某一时间段只能实现单向传输，同时各进程也必须<strong>互斥</strong>的访问管道</p>
<p><img src="http://cdn.ziyedy.top/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.png" alt=""></p>
<h3 id="3、消息传递"><a href="#3、消息传递" class="headerlink" title="3、消息传递"></a>3、消息传递</h3><blockquote>
<p>进程间的数据交换以格式化的消息（Message）为单位，进程通过操作系统提供的“发送消息/接收消息”原语进行数据交换，如<strong>消息队列</strong>等等</p>
</blockquote>
<h2 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h2><blockquote>
<p>进程同步又叫进程的“直接制约关系”，为了完成某种任务而建立两个或多个进程，这些进程因为需要在某些位置上<strong>协调工作次序</strong>而产生制约关系。</p>
</blockquote>
<p>进程具有异步性，各并发执行的进程以各自独立、不可预测的速度向前推进。</p>
<p>但有时需要保证不同的进程按照特地的次序推进，比如管道读、写数据两个操作必需按照“写数据-&gt;读数据”的顺序执行，因此就产生了进程同步的需求</p>
<h2 id="进程互斥"><a href="#进程互斥" class="headerlink" title="进程互斥"></a>进程互斥</h2><blockquote>
<p>进程互斥指一个进程访问某些临界资源时，另一个想要访问该临界资源的进程必需等待，直到资源被释放。又叫“间接制约关系”</p>
</blockquote>
<blockquote>
<p><strong>临界资源</strong>：一个时间段内只允许一个进程使用的资源（比如一些物理设备，变量数据，内存缓冲区）</p>
</blockquote>
<p>进程互斥主要包括三个部分</p>
<ol>
<li>进入区：负责检查是否可以进入临界区，若可以进入则设置“正在访问临界资源的标志”（<strong>上锁</strong>），阻止其它进程同时进入临界区</li>
<li>临界区：负责访问临界资源</li>
<li>负责解除“正在访问临界资源的标志”（<strong>解锁</strong>）</li>
</ol>
<h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul>
<li>空闲让进：临界区空闲，应允许一个进程访问</li>
<li>忙则等待：临界区正在被访问时，其它试图访问的进程需要等待</li>
<li>有限等待：在有限的时间内进入临界区，保证不会饥饿</li>
<li>让权等待：进不了临界区的进程，释放处理机，防止忙等</li>
</ul>
<h2 id="进程互斥软件实现方法"><a href="#进程互斥软件实现方法" class="headerlink" title="进程互斥软件实现方法"></a>进程互斥软件实现方法</h2><h3 id="1、单标志法"><a href="#1、单标志法" class="headerlink" title="1、单标志法"></a>1、单标志法</h3><p>两个进程在访问完临界区后会把临界区的权限转交给下一个进程（<strong>每个进程进入临界区的权限只能被另一个进程赋予</strong>）</p>
<p>因此如果一个进程一直不使用临界区资源，会导致即使临界区空闲，仍然无法访问，<strong>违背”空闲让进“原则</strong></p>
<p><img src="http://cdn.ziyedy.top/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%8D%95%E6%A0%87%E5%BF%97%E6%B3%95.png" alt=""></p>
<h3 id="2、双标志先检查"><a href="#2、双标志先检查" class="headerlink" title="2、双标志先检查"></a>2、双标志先检查</h3><p>使用一个数组来标记各进程是否想进入临界区，每个进程在进入临界区前查看是否有其他进程想访问临界区，若没有，则设置自身标记再访问临界区。</p>
<p>如下，若按照①-&gt;⑤-&gt;…进行执行的话，会使得P0和P1同时进入临界区，<strong>违背忙则等待</strong></p>
<p>原因：进入临界区的“检查”与“上锁”两个处理不是一气呵成的，两者之间可能会发生进程切换</p>
<p><img src="http://cdn.ziyedy.top/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%8F%8C%E6%A0%87%E5%BF%97%E6%B3%95.png" alt=""></p>
<h3 id="3、双标志后检查"><a href="#3、双标志后检查" class="headerlink" title="3、双标志后检查"></a>3、双标志后检查</h3><p>即改为先上锁、再检查</p>
<p>当按照①-&gt;⑤-&gt;…进行执行的话，会使得P0和P1都无法进入临界区，<strong>违背空闲让进和有限等待</strong></p>
<p><img src="http://cdn.ziyedy.top/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%8F%8C%E6%A0%87%E5%BF%97%E5%90%8E%E6%A3%80%E6%9F%A5%E6%B3%95.png" alt=""></p>
<h3 id="4、Peterson算法"><a href="#4、Peterson算法" class="headerlink" title="4、Peterson算法"></a>4、Peterson算法</h3><p>若几个进程都想进入临界区，则主动让对方先进入临界区</p>
<p>是几个方法中最好的，但违背让权等待，可能造成CPU资源的浪费</p>
<p><img src="http://cdn.ziyedy.top/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/Peterson%E7%AE%97%E6%B3%95.png" alt=""></p>
<h2 id="信号量机制"><a href="#信号量机制" class="headerlink" title="信号量机制"></a>信号量机制</h2><p>软件解决方案的主要问题是由<strong>“进入区的各种操作无法一次性完成”</strong> ，因此如果能把进入区、退出区的操作都用<strong>“原语”</strong>实现就能避免问题。</p>
<blockquote>
<p><strong>信号量</strong>：一个标识系统中某种资源数量等标志的变量</p>
</blockquote>
<p>用户进程可以通过使用操作系统提供的一对原语来对信号量进行操作，从而实现进程的互斥与同步</p>
<p>即wait(S)原语和signal(S)原语，也即PV操作，可以简写为P(S)、V(S)</p>
<p>因此利用信号量机制实现进程的互斥与同步只需要将PV操作置于合适的位置并且在PV操作内对信号量进行合理的操作即可</p>
<h1 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h1><blockquote>
<p>任务很多资源有限，就需要确定某种规则来决定任务的处理顺序</p>
<p>进程的调度就是从就绪队列中按照一定算法选择一个进程并将处理机分配给他运行，以实现进程的并发执行</p>
</blockquote>
<h2 id="调度概述"><a href="#调度概述" class="headerlink" title="调度概述"></a>调度概述</h2><h3 id="进程调度的时机"><a href="#进程调度的时机" class="headerlink" title="进程调度的时机"></a>进程调度的时机</h3><ul>
<li>进程自动放弃处理机：正常终止、异常终止、主动请求阻塞</li>
<li>进程被动放弃处理机：时间片用完、更高优先级进程进入就绪队列（被抢夺）</li>
</ul>
<h3 id="调度算法的评价指标"><a href="#调度算法的评价指标" class="headerlink" title="调度算法的评价指标"></a>调度算法的评价指标</h3><ul>
<li>CPU利用率：CPU忙碌时间(+IO时间)/总时间</li>
<li>系统吞吐量：总共完成的作业数/总时间</li>
<li>周转时间</li>
<li>等待时间</li>
<li>响应时间</li>
</ul>
<h2 id="批处理系统中的调度算法"><a href="#批处理系统中的调度算法" class="headerlink" title="批处理系统中的调度算法"></a>批处理系统中的调度算法</h2><h3 id="1、先来先服务（FCFS）"><a href="#1、先来先服务（FCFS）" class="headerlink" title="1、先来先服务（FCFS）"></a>1、先来先服务（FCFS）</h3><p>作业/进程谁先到后备队列的谁先得到服务，是非抢占式算法</p>
<p>优点：公平，算法简单</p>
<p>缺点：对长作业（进程）有利，对短作业不利（带权周转时间很大） ，不会导致饥饿</p>
<h3 id="2、最短作业优先（SJF）"><a href="#2、最短作业优先（SJF）" class="headerlink" title="2、最短作业优先（SJF）"></a>2、最短作业优先（SJF）</h3><p>算法思想：追求最少的平均等待时间，最少平均周转时间，最少平均带权周转时间</p>
<p>算法规则：需要服务时间最短的作业、进程先得到服务，可以实现为非抢占式也可以实现为抢占式</p>
<p>优点：“最短的”平均等待时间、平均周转时间</p>
<p>缺点：不公平，短作业有利，长作业不利。 可能导致饥饿，如果有源源不断的短作业到来，长作业可能一直得不到服务（饿死）</p>
<h3 id="3、高响应比优先"><a href="#3、高响应比优先" class="headerlink" title="3、高响应比优先"></a>3、高响应比优先</h3><p>算法思想：综合考虑作业/进程的等待时间和服务时间</p>
<p>算法规则：每次调度时选择响应比最高的作业/进程。响应比=(等待时间+要求服务时间)/要求服务时间</p>
<p>非抢占式，除非当前作业/进程主动放弃处理机，才需要调度</p>
<p>优点：综合考虑了等待时间和运行时间</p>
<h2 id="交互式系统中的调度算法"><a href="#交互式系统中的调度算法" class="headerlink" title="交互式系统中的调度算法"></a>交互式系统中的调度算法</h2><h3 id="1、时间片轮转（round-robin）"><a href="#1、时间片轮转（round-robin）" class="headerlink" title="1、时间片轮转（round robin）"></a>1、时间片轮转（round robin）</h3><p>常用于分时操作系统，注重响应时间，而非周转时间</p>
<p>算法思想：公平、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</p>
<p>算法规则：按照各进程到达就绪队列的顺序,轮流让各个进程执行一个时间片(如100ms) 。若进程未在一个时间片内执行完,则剥夺处理机,将进程重新放到就绪队列队尾重新排队。</p>
<p>抢占式算法，由时钟中断通知CPU时间片已到，不会饥饿</p>
<p>缺点：高频率进程切换，有一定的开销，不区分任务的紧急程度</p>
<h3 id="2、优先级调度"><a href="#2、优先级调度" class="headerlink" title="2、优先级调度"></a>2、优先级调度</h3><p>调度时选择优先级高的进程，适用于实时操作系统，可能发生饥饿</p>
<p>根据优先级是否可以动态改变分为静态优先级和动态优先级两种</p>
<p>通常系统进程优先级高于用户进程，前台进程优先级高于后台进程</p>
<h3 id="3、多级反馈队列"><a href="#3、多级反馈队列" class="headerlink" title="3、多级反馈队列"></a>3、多级反馈队列</h3><p>对之前所述算法的综合，抢占式，可能导致饥饿，<em>Unix即使用该算法</em></p>
<p><img src="http://cdn.ziyedy.top/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97.png" alt=""></p>
<h4 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h4><p>如上图所示：</p>
<p>1、设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</p>
<p>2、新进程到达时进入第1级队列，按FCFS原则等待分配时间片，若时间片用完还未运行结束，则进入下一级队列队尾，若已经在最后一级队列，则重新放回该队列队尾</p>
<p>3、只有第k级队列为空，才会为k+1级队列分配时间片用于进程调度</p>
<p>4、该算法是抢占式的，在第k级队列的进程运行时，若上层队列进入了一个新进程，则该新进程会抢占处理机</p>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><h2 id="死锁的概念"><a href="#死锁的概念" class="headerlink" title="死锁的概念"></a>死锁的概念</h2><blockquote>
<p>并发环境下，各进程因为竞争资源造成的：互相等待对方手里的资源，导致各进程都阻塞，无法向前推进的现象</p>
</blockquote>
<p>其中资源泛指一类需要排他性使用的对象，对不可剥夺资源<em>分配不合理</em>可能导致死锁</p>
<p>死锁是“循环等待对方手中的资源”导致的，因此若有死锁现象，则至少有两个或两个以上的进程同时发生死锁</p>
<h2 id="死锁产生的条件"><a href="#死锁产生的条件" class="headerlink" title="死锁产生的条件"></a>死锁产生的条件</h2><ul>
<li>互斥条件：争抢互斥资源</li>
<li>不可剥夺条件：进程获得的资源未使用完成，其它进程不能强行夺走，只能等待主动释放</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但是又提出新的资源请求，同时该资源被其它进程占有，此时请求进程被阻塞，但是对自己拥有资源又保持不放</li>
<li>循环等待条件：死锁时存在循环等待链（比如哲学家吃饭问题每个哲学家拿出一个筷子）</li>
</ul>
<h2 id="死锁的处理策略"><a href="#死锁的处理策略" class="headerlink" title="死锁的处理策略"></a>死锁的处理策略</h2><h3 id="预防死锁"><a href="#预防死锁" class="headerlink" title="预防死锁"></a>预防死锁</h3><p>即破坏上述死锁产生的四个条件</p>
<h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><blockquote>
<p>安全序列：系统按照这种序列分配资源，能让每个进程都顺利完成</p>
</blockquote>
<blockquote>
<p>不安全状态：只要存在一个安全序列，系统就是安全状态。找不到安全序列，即为不安全状态</p>
</blockquote>
<p><em>不安全状态可能发生死锁（不一定发生），安全状态一定不会死锁</em></p>
<p>避免死锁即避免系统进入不安全状态（银行家算法），即构建最大需求、已分配资源、最多还需要资源的表格并进行比较，从而找到一条安全序列</p>
<h3 id="检测和解除死锁"><a href="#检测和解除死锁" class="headerlink" title="检测和解除死锁"></a>检测和解除死锁</h3><p>死锁发生后，操作系统负责检查死锁并解除死锁</p>
<p><img src="http://cdn.ziyedy.top/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BE.png" alt="资源分配图"></p>
<h4 id="检测死锁"><a href="#检测死锁" class="headerlink" title="检测死锁"></a>检测死锁</h4><blockquote>
<p>死锁定理：如果某时刻资源分配图是不可完全简化的，那么此时进程死锁</p>
</blockquote>
<p>因此检测死锁就是在资源分配图中，不断找出能够变为“孤点”的进程，在一系列操作中若能消去图中的所有变，则称该图是可完全简化的</p>
<p>同时，用死锁检测算法化简资源分配图后，<strong>还连着边的就是死锁进程</strong></p>
<h4 id="死锁解除"><a href="#死锁解除" class="headerlink" title="死锁解除"></a>死锁解除</h4><ul>
<li>资源剥夺法：挂起死锁进程并剥夺其所有资源（必须防止饥饿）</li>
<li>终止进程法：直接终止，可能造成系统资源的浪费</li>
<li>进程回退法：让死锁进程回退到足以避免死锁的地步</li>
</ul>
<p>参考：</p>
<blockquote>
<p>《现代操作系统》</p>
<p><a href="https://mubu.com/doc/Cd-Y4YOfkh" target="_blank" rel="noopener">https://mubu.com/doc/Cd-Y4YOfkh</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/page/singleton-pattern.html</url>
    <content><![CDATA[<h2 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h2><blockquote>
<p>保证一个类仅有一个实例，并提供一个全局访问点，属于创建者模式</p>
</blockquote>
<h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><p>数据库连接池等等</p>
<h2 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h2><h3 id="懒汉模式（线程不安全）"><a href="#懒汉模式（线程不安全）" class="headerlink" title="懒汉模式（线程不安全）"></a>懒汉模式（线程不安全）</h3><ul>
<li>默认的构造函数中添加了私有属性<code>private</code></li>
<li>多个访问者同时获取对象实例会造成多个同样的实例并存</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton_01</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != instance) <span class="hljs-keyword">return</span> instance;<br>        instance = <span class="hljs-keyword">new</span> Singleton();<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="懒汉模式（线程安全）"><a href="#懒汉模式（线程安全）" class="headerlink" title="懒汉模式（线程安全）"></a>懒汉模式（线程安全）</h3><p>相对上一种实现方法在获取实例方法前使用了<code>synchronized</code>关键字，但这种模式由于上锁会导致资源浪费，不建议使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != instance) <span class="hljs-keyword">return</span> instance;<br>        instance = <span class="hljs-keyword">new</span> Singleton();<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="饿汉模式（线程安全）"><a href="#饿汉模式（线程安全）" class="headerlink" title="饿汉模式（线程安全）"></a>饿汉模式（线程安全）</h3><p>在程序启动的时候直接运⾏行行加载，后续有外部需要使⽤用的时候获取即可，但不是懒加载，会造成性能上的损失</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    	<span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="使用类的内部类（线程安全）"><a href="#使用类的内部类（线程安全）" class="headerlink" title="使用类的内部类（线程安全）"></a>使用类的内部类（线程安全）</h3><p>是一种比较好的方式</p>
<p>既保证了线程安全又保证了懒加载，同时不会因为加锁的方式耗费性能（因为JVM保证了一个类的构造方法在多线程环境下能够被正确的加载）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>    	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>    	<span class="hljs-keyword">return</span> SingletonHolder.instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="双重锁校验（线程安全）"><a href="#双重锁校验（线程安全）" class="headerlink" title="双重锁校验（线程安全）"></a>双重锁校验（线程安全）</h3><p>是<strong>懒汉模式（线程安全）</strong>方法级锁的优化，减少了部分获取实例的耗时，同时也满足了懒加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getSingleton</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> instance;<br>        <span class="hljs-keyword">synchronized</span> (Singleton<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;<br>            <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>                instance = <span class="hljs-keyword">new</span> Singleton();<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/page/factory-pattern.html</url>
    <content><![CDATA[<h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><blockquote>
<p>简单工厂模式不属于23种设计模式，指的是<em>由一个工厂对象决定创建出哪一种产品类的实例</em></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">NBAPlayer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">// 实现类1</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KobeBryant</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">NBAPlayer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"Kobe"</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 工厂类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NBAFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> NBAPlayer <span class="hljs-title">getNBAPlayer</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">"Kobe"</span>.equals(name)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> KobeBryant();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">"LeBron"</span>.equals(name)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LeBronJames();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 主方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NBAFactory factory = <span class="hljs-keyword">new</span> NBAFactory();	<span class="hljs-comment">// 创建工厂类</span><br>        NBAPlayer player = factory.getNBAPlayer(<span class="hljs-string">"Kobe"</span>);	<span class="hljs-comment">// 通过工厂类创建主方法 </span><br>        player.getName();	<span class="hljs-comment">// 调用对应成员方法 Kobe</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<p>工厂类职责过重，创建新的类时需要修改工厂类的判断逻辑，违背开闭原则</p>
<h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>类的个数容易过多，增加复杂度，增加了系统的抽象性和理解难度</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL常用命令</title>
    <url>/page/mysql-command.html</url>
    <content><![CDATA[<h3 id="查看数据库版本信息"><a href="#查看数据库版本信息" class="headerlink" title="查看数据库版本信息"></a>查看数据库版本信息</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># 查看数据库版本</span><br>mysql <span class="hljs-comment">--version</span><br>mysql -V<br></code></pre></td></tr></table></figure>

<h3 id="登录数据库"><a href="#登录数据库" class="headerlink" title="登录数据库"></a>登录数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># 登录数据库</span><br>mysql -u 用户名 -p 密码<br></code></pre></td></tr></table></figure>

<h3 id="查看、操作数据库"><a href="#查看、操作数据库" class="headerlink" title="查看、操作数据库"></a>查看、操作数据库</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># 查看现有的数据库</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">databases</span>; <br><br><span class="hljs-comment"># 创建叫 ziye 的数据库</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">database</span> ziye;<br><br><span class="hljs-comment"># 使用 ziye 数据库</span><br><span class="hljs-keyword">use</span> ziye;<br><br><span class="hljs-comment"># 删除 ziye 数据库</span><br><span class="hljs-keyword">drop</span> <span class="hljs-keyword">database</span> ziye;<br><br><span class="hljs-comment"># 运行对应sql语句</span><br>source D:\ziye.sql<br></code></pre></td></tr></table></figure>

<h3 id="使用-select-获取相关信息"><a href="#使用-select-获取相关信息" class="headerlink" title="使用 select 获取相关信息"></a>使用 select 获取相关信息</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># 查看当前使用的数据库</span><br><span class="hljs-keyword">select</span> <span class="hljs-keyword">database</span>();<br><br><span class="hljs-comment"># 常看数据库版本</span><br><span class="hljs-keyword">select</span> <span class="hljs-keyword">version</span>();<br></code></pre></td></tr></table></figure>

<h3 id="查看表"><a href="#查看表" class="headerlink" title="查看表"></a>查看表</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># 查看当前库中的表</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span>;<br><br><span class="hljs-comment"># 查看名为 ziye 的数据库中的表</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">tables</span> <span class="hljs-keyword">from</span> ziye;<br></code></pre></td></tr></table></figure>

<h3 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># 查看 dept 表的表结构</span><br>desc dept;<br><br><span class="hljs-comment"># 查看 dept 表的创建语句</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> dept;<br></code></pre></td></tr></table></figure>

<h3 id="退出-mysql"><a href="#退出-mysql" class="headerlink" title="退出 mysql"></a>退出 mysql</h3><p>键入以下命令可退出数据库：<code>\q</code>、<code>quit</code> 、<code>exit</code></p>
]]></content>
      <categories>
        <category>数据库</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven基础使用</title>
    <url>/page/maven.html</url>
    <content><![CDATA[<h2 id="maven基础"><a href="#maven基础" class="headerlink" title="maven基础"></a>maven基础</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>Maven是Java项目的构建工具，支持从远程库中下载相关jar包等文件，进行依赖管理，并使用xml作为配置文件格式</p>
<p>类似于Python中的pip等工具</p>
</blockquote>
<h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><ul>
<li><strong>依赖管理</strong>：支持使用<code>groupId、artifactId、version</code>组成的<code>Coordination</code>（坐标）唯一标识一个依赖，而任何基于 Maven 构建的项目自身也必须定义这三项属性，生成的包可以是 Jar 包，也可以是 war 包或者 jar 包</li>
<li><strong>多模块构建</strong>：可以定义父模块与子模块，完成软件架构的分离（如 dao service controller 三层架构）</li>
<li><strong>一致的目录结构</strong>：只要是使用Maven构建的项目，在不同的IDE中项目结构是一致的</li>
<li><strong>一致的构建模型与插件的机制</strong>：如配置tomcat、jetty等插件在不同环境下是一样的</li>
</ul>
<h3 id="maven项目目录结构"><a href="#maven项目目录结构" class="headerlink" title="maven项目目录结构"></a>maven项目目录结构</h3><figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">|<span class="hljs-string">——src/main/	<br></span>|<span class="hljs-string">	   </span>|<span class="hljs-string">——java		项目Java源代码<br></span>|<span class="hljs-string">	   </span>|<span class="hljs-string">——resources	项目资源<br></span>|<br>|<span class="hljs-string">——src/test/<br></span>|<span class="hljs-string">	   </span>|<span class="hljs-string">——java		项目测试类（JUnit）<br></span>|<span class="hljs-string">	   </span>|<span class="hljs-string">——resources	测试资源<br></span>|<br>|<span class="hljs-string">——pom.xml	配置文件</span><br></code></pre></td></tr></table></figure>

<h3 id="maven设置"><a href="#maven设置" class="headerlink" title="maven设置"></a>maven设置</h3><blockquote>
<p>maven的配置文件为<code>path/to/maven/conf/settings.xml</code>，大部分配置都在该文件中修改</p>
</blockquote>
<h4 id="修改默认仓库的位置"><a href="#修改默认仓库的位置" class="headerlink" title="修改默认仓库的位置"></a>修改默认仓库的位置</h4><p>修改<code>&lt;localRepository&gt;</code>标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 本地仓库地址，存放jar包的位置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>/path/to/local/repo<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="修改国内镜像"><a href="#修改国内镜像" class="headerlink" title="修改国内镜像"></a>修改国内镜像</h4><p>在相同的配置文件中更改<code>&lt;mirrors&gt;</code>中加载国内镜像</p>
<h3 id="maven仓库"><a href="#maven仓库" class="headerlink" title="maven仓库"></a>maven仓库</h3><blockquote>
<p>对于 Maven 来说， 仓库只分为两类： 本地仓库和远程仓库</p>
<p>当 Maven 根据坐标寻找构件时，首先会查看本地仓库，如果本地仓库存在，则直接使用； 如果本地没有，Maven 就会去远程仓库查找；如果都没有则报错</p>
</blockquote>
<h3 id="maven命令格式"><a href="#maven命令格式" class="headerlink" title="maven命令格式"></a>maven命令格式</h3><p>执行<code>plugin-name</code>插件的<code>goal-name</code>目标</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">mvn [plugin-<span class="hljs-built_in">name</span>]:[goal-<span class="hljs-built_in">name</span>]<br></code></pre></td></tr></table></figure>

<p>命令参数：以<code>-D</code>开头传入属性参数，以<code>-P</code>开头使用指定的Profile配置</p>
<h4 id="使用-D"><a href="#使用-D" class="headerlink" title="使用-D"></a>使用-D</h4><figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">mvn exec:<span class="hljs-keyword">java </span>-Dexec.mainClass=<span class="hljs-string">"类A"</span>		<span class="hljs-comment"># 执行类A</span><br></code></pre></td></tr></table></figure>

<h4 id="使用-P"><a href="#使用-P" class="headerlink" title="使用-P"></a>使用-P</h4><p>使用-P选择打包的对应环境，以下选择了test环境</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake">mvn package t -Ptest -Dmaven.<span class="hljs-keyword">test</span>.skip=<span class="hljs-keyword">true</span>		<span class="hljs-comment"># 打包测试环境并跳过maven测试</span><br></code></pre></td></tr></table></figure>

<h3 id="maven常用命令"><a href="#maven常用命令" class="headerlink" title="maven常用命令"></a>maven常用命令</h3><table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>mvn -version</td>
<td>显示版本信息</td>
</tr>
<tr>
<td>mvn clean</td>
<td>清理项目生产的临时文件，—般是模块下的target目录</td>
</tr>
<tr>
<td>mvn compile</td>
<td>编译源代码，一般编译模块下的src/main/java目录</td>
</tr>
<tr>
<td>mvn package</td>
<td>项目打包工具，会在模块下的target目录生成jar或war等文件</td>
</tr>
<tr>
<td>mvn test</td>
<td>测试命令，或执行src/test/javal下junit的测试用例</td>
</tr>
<tr>
<td>mvn install</td>
<td>将打包的jar/war文件复制到你的本地仓库中，供其他模块使用</td>
</tr>
<tr>
<td>mvn deploy</td>
<td>将打包的文件发布到远程参考,提供其他人员进行下载依赖</td>
</tr>
<tr>
<td>mvn dependency:tree</td>
<td>打印出项目的整个依赖树</td>
</tr>
<tr>
<td>mvn tomcat7:run</td>
<td>在tomcat容器中运行web应用</td>
</tr>
<tr>
<td>mvn jetty:run</td>
<td>调用Jetty插件的 Run目标在Jetty Servlet容器中启动web应用</td>
</tr>
</tbody></table>
<h3 id="pom文件常用标签"><a href="#pom文件常用标签" class="headerlink" title="pom文件常用标签"></a>pom文件常用标签</h3><h2 id="IDEA中使用maven"><a href="#IDEA中使用maven" class="headerlink" title="IDEA中使用maven"></a>IDEA中使用maven</h2><h3 id="配置maven"><a href="#配置maven" class="headerlink" title="配置maven"></a>配置maven</h3><p>在<code>Setting for New Project</code>中选择下载的maven目录以及对应的<code>settings.xml</code>配置文件，使得每次使用IDEA创建maven项目使用我们下载的而不是IDEA系统自带的。</p>
<h3 id="创建maven项目"><a href="#创建maven项目" class="headerlink" title="创建maven项目"></a>创建maven项目</h3><p>新建项目选择Maven，如果是创建普通项目，选择<code>quickstart</code>，创建Web项目选择<code>webapp</code>。</p>
<p><img src="http://cdn.ziyedy.top/Maven/maven%E9%A1%B9%E7%9B%AE%E5%90%AF%E5%8A%A8.png" alt=""></p>
<h3 id="设置运行方式"><a href="#设置运行方式" class="headerlink" title="设置运行方式"></a>设置运行方式</h3><p>在IDEA右上角选择运行Maven项目的命令，如下即构建了Maven 的编译命令，如果是使用Maven构建的Web项目的话也可以使用Maven中相应的使用服务器运行的方法。</p>
<p><img src="http://cdn.ziyedy.top/Maven/%E8%AE%BE%E7%BD%AEmaven%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4.png" alt=""></p>
<h2 id="maven常见bug"><a href="#maven常见bug" class="headerlink" title="maven常见bug"></a>maven常见bug</h2><h3 id="bug1：IDEA构建项目失败"><a href="#bug1：IDEA构建项目失败" class="headerlink" title="bug1：IDEA构建项目失败"></a>bug1：IDEA构建项目失败</h3><h4 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h4><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">Could not transfer metadata org.apache.maven.plugins:maven-archetype-plugin<span class="hljs-regexp">/maven-metadata.xml from/</span>to alimaven (http:<span class="hljs-regexp">//m</span>aven.aliyun.com<span class="hljs-regexp">/nexus/</span>content<span class="hljs-regexp">/repositories/</span>central<span class="hljs-regexp">/): Transfer failed for http:/</span><span class="hljs-regexp">/maven.aliyun.com/</span>nexus<span class="hljs-regexp">/content/</span>repositories<span class="hljs-regexp">/central/</span>o<br></code></pre></td></tr></table></figure>

<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>在设置中为Maven启动加入如下命令</p>
<p><img src="http://cdn.ziyedy.top/Maven/bug1.png" alt=""></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">-Dmaven<span class="hljs-selector-class">.wagon</span><span class="hljs-selector-class">.http</span><span class="hljs-selector-class">.ssl</span>.insecure=true -Dmaven<span class="hljs-selector-class">.wagon</span><span class="hljs-selector-class">.http</span><span class="hljs-selector-class">.ssl</span>.allowall=true -Dmaven<span class="hljs-selector-class">.wagon</span><span class="hljs-selector-class">.http</span><span class="hljs-selector-class">.ssl</span><span class="hljs-selector-class">.ignore</span><span class="hljs-selector-class">.validity</span>.dates=true<br></code></pre></td></tr></table></figure>

<h3 id="bug2：插件出错"><a href="#bug2：插件出错" class="headerlink" title="bug2：插件出错"></a>bug2：插件出错</h3><h4 id="报错-1"><a href="#报错-1" class="headerlink" title="报错"></a>报错</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">Cannot</span> <span class="hljs-selector-tag">resolve</span> <span class="hljs-selector-tag">plugin</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.apache</span><span class="hljs-selector-class">.maven</span><span class="hljs-selector-class">.plugins</span><span class="hljs-selector-pseudo">:maven-clean-plugin</span><span class="hljs-selector-pseudo">:2.5</span> <span class="hljs-selector-tag">Maven</span><br></code></pre></td></tr></table></figure>

<h4 id="解决-1"><a href="#解决-1" class="headerlink" title="解决"></a>解决</h4><p>如图所示，删除对应出错的插件，然后点击左上角重新构建即可</p>
<img src="http://cdn.ziyedy.top/Maven/bug2.png" style="zoom:67%;" />

<h3 id="bug3：Could-not-transfer-artifact-…"><a href="#bug3：Could-not-transfer-artifact-…" class="headerlink" title="bug3：Could not transfer artifact …"></a>bug3：Could not transfer artifact …</h3><p>在导入的虚拟机选项中插入如下代码，忽略SSL证书的验证</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">-<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dmaven</span>.</span></span>wagon.http.ssl.insecure=<span class="hljs-literal">true</span> -<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dmaven</span>.</span></span>wagon.http.ssl.allowall=<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<img src="http://cdn.ziyedy.top/Maven/bug3.png" style="zoom: 50%;" />

<p>如果还报错的话，则将maven本地包中结尾为<code>.lastUpdate</code>的文件删除，输出该类文件需要使用相关命令或脚本，如下为Windows下删除方法。</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">cd maven仓库<br><span class="hljs-keyword">for</span> /r <span class="hljs-literal">%i</span> <span class="hljs-keyword">in</span> (*.lastUpdated) <span class="hljs-keyword">do</span> <span class="hljs-built_in">del</span> <span class="hljs-literal">%i</span><br></code></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Java类加载机制</title>
    <url>/page/jvm-classloader.html</url>
    <content><![CDATA[<h1 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h1><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><blockquote>
<p>类从被加载到虚拟机内存开始，到卸载出内存为止，它的整个生命周期包括以下 7 个阶段</p>
</blockquote>
<img src="http://cdn.ziyedy.top/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" style="zoom:67%;" />

<h2 id="类加载中初始化的时机"><a href="#类加载中初始化的时机" class="headerlink" title="类加载中初始化的时机"></a>类加载中初始化的时机</h2><p>Java 虚拟机规范没有强制约束类加载过程的第一阶段（即：加载）什么时候开始，但<strong>对于“初始化”阶段，有着严格的规定</strong>。有且仅有 5 种情况必须立即对类进行“初始化”（即<strong>主动引用</strong>）</p>
<ul>
<li><p>在遇到 new、putstatic、getstatic、invokestatic <strong>特定字节码指令</strong>时，如果类尚未初始化，则需要先触发其初始化</p>
</li>
<li><p>对类进行<strong>反射调用</strong>时，如果类还没有初始化，则需要先触发其初始化</p>
</li>
<li><p>初始化一个类时，如果其父类还没有初始化，则需要先初始化父类（<em>与接口的区别</em>）</p>
</li>
<li><p>虚拟机启动时，用于需要指定一个<strong>包含 <code>main()</code> 方法的主类</strong>，虚拟机会先初始化这个主类</p>
</li>
<li><p>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化</p>
</li>
</ul>
<h2 id="接口的加载"><a href="#接口的加载" class="headerlink" title="接口的加载"></a>接口的加载</h2><ul>
<li><p>当一个类在初始化时，要求其父类全部都已经初始化过了</p>
</li>
<li><p>一个接口在初始化时，并不要求其父接口全部都完成了初始化，当<strong>真正用到父接口的时候才会初始化</strong>。</p>
</li>
</ul>
<h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><h2 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h2><h3 id="加载的过程"><a href="#加载的过程" class="headerlink" title="加载的过程"></a>加载的过程</h3><ol>
<li>通过类的全限定名获取该类的二进制字节流</li>
<li>将二进制字节流所代表的静态结构转化为方法区的运行时数据结构</li>
<li>在内存中创建一个代表该类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p><em>注：对于 HotSpot 虚拟机而言，Class 对象比较特殊，它虽然是对象，但存放在方法区中</em></p>
<h3 id="“非数组类”与“数组类”加载比较"><a href="#“非数组类”与“数组类”加载比较" class="headerlink" title="“非数组类”与“数组类”加载比较"></a>“非数组类”与“数组类”加载比较</h3><ul>
<li>非数组类加载阶段可以使用系统提供的引导类加载器，也可以由用户自定义的类加载器完成（如重写一个类加载器的 <code>loadClass()</code> 方法）</li>
<li><strong>数组类本身不通过类加载器创建</strong>，它是由 Java 虚拟机直接创建的，再由类加载器创建数组中的元素类</li>
</ul>
<h2 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h2><blockquote>
<p>就是将已经读入内存的类的二进制数据合并到JVM运行时环境中</p>
</blockquote>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><blockquote>
<p>确保被加载类的正确性（即class文件的字节流符合一般文件格式及当前虚拟机的要求）</p>
</blockquote>
<ul>
<li><p><strong>类文件结构检查</strong>∶按照JVM规范规定的类文件结构进行</p>
</li>
<li><p><strong>元数据验证</strong>：对字节码描述的信息进行语义分析，保证其符合Java语言规范要求</p>
</li>
<li><p><strong>字节码验证</strong>∶通过对数据流和控制流进行分析，确保程序语义是合法和符合逻辑的。这里主要对<strong>方法体</strong>进行校验</p>
</li>
<li><p><strong>符号引用验证</strong>：对类自身以外的信息，也就是常量池中的各种符号引用，进行匹配校验，<strong>确保解析正常执行</strong></p>
</li>
</ul>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><blockquote>
<p>为类的静态成员变量（static修饰）分配内存，并设置初始值</p>
</blockquote>
<p><strong>这些变量（不包括实例变量）所使用的内存都在方法区中进行分配</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">123</span>;			<span class="hljs-comment">// 准备阶段后初始值为 0</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> value = <span class="hljs-number">123</span>;	<span class="hljs-comment">// 准备阶段后初始值为 123</span><br></code></pre></td></tr></table></figure>

<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><blockquote>
<p>将常量池中的符号引用替换为直接引用</p>
</blockquote>
<ul>
<li><p>符号引用：以一组无歧义的符号来描述所引用的目标，与虚拟机无关</p>
</li>
<li><p>直接引用：直接指向目标的指针、相对偏移量、或是能间接定位到目标的句柄，是和虚拟机实现相关的</p>
</li>
</ul>
<p>主要针对：类、接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><blockquote>
<p>为类的静态变量赋初始值，或者说是执行类构造器<code>&lt;clinit&gt;</code>方法的过程</p>
</blockquote>
<blockquote>
<p><code>&lt;clinit&gt;</code>方法是由<strong>编译器自动收集</strong>类中的所有类变量的赋值动作和静态语句块（static {} 块）中的语句<strong>合并</strong>产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的</p>
</blockquote>
<h1 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h1><h2 id="类加载器种类"><a href="#类加载器种类" class="headerlink" title="类加载器种类"></a>类加载器种类</h2><p>Java虚拟机自带的加载器包括如下3种∶</p>
<ul>
<li><p>启动类加载器（BootstrapClassLoader）：由C++语言实现，是虚拟机的一部分</p>
<p> 负责将存放在 <code>&lt;JAVA_HOME&gt;\lib</code> 目录中的，并且能被虚拟机识别的（仅<strong>按照文件名</strong>识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中</p>
</li>
<li><p>拓展类加载器（Extension ClassLoader，JDK8）  </p>
<p> JDK9之后为平台类加载器（PlatformClassLoader）。负责加载 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录中的所有类库，开发者可以直接使用扩展类加载器</p>
</li>
<li><p>应用程序类加载器（AppClassLoader）</p>
<p>它负责加载用户类路径（classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中<strong>默认的类加载器</strong>。</p>
</li>
<li><p>用户自定义的加载器</p>
<p>是<code>java.lang.ClassLoader</code>的子类，用户可以定制类的加载方式;只不过自定义类加载器其加载的顺序是在所有系统类加载器的最后</p>
</li>
</ul>
<img src="http://cdn.ziyedy.top/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.png" style="zoom:67%;" />



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test t = <span class="hljs-keyword">new</span> Test();<br><br>        Class&lt;? extends Test&gt; tClass = t.getClass();<br><br>        ClassLoader classLoader = tClass.getClassLoader();<br>        System.out.println(classLoader);<br>        System.out.println(classLoader.getParent());<br>        System.out.println(classLoader.getParent().getParent());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**<br> * jdk.internal.loader.ClassLoaders$AppClassLoader@3fee733d<br> * jdk.internal.loader.ClassLoaders$PlatformClassLoader@6acbcfc0<br> * null	表示启动类加载器<br>*/</span><br></code></pre></td></tr></table></figure>

<h2 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h2><p>JVM中的ClassLoader通常采用双亲委派模型，要求除了启动类加载器外，其余的类加载器都应该有自己的父级加载器（这里的父子关系一般不会以继承的关系实现，而是<strong>以组合关系来复用父加载器的代码</strong>）</p>
<img src="http://cdn.ziyedy.top/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6.png" style="zoom: 80%;" />

<h3 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h3><p>1、首先判断当前类是否被加载过，已经被加载的类会直接返回，否则才会尝试加载；</p>
<p>2、加载的时候，首先会把该请求委派该父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中；</p>
<p>3、当父类加载器无法完成这个加载请求（找不到所需的类）时，子加载器才会尝试自己去加载。</p>
<h3 id="为何使用双亲委派模型"><a href="#为何使用双亲委派模型" class="headerlink" title="为何使用双亲委派模型"></a>为何使用双亲委派模型</h3><p>1、双亲委派模型保证了Java程序的稳定运作，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），<em>保证没有同包同名的类</em></p>
<p>2、保证了Java的核心API不被篡改，<em>保证系统类不会被覆盖</em></p>
<p>比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类，而双亲委派机制很好的避免了这个问题。</p>
<h2 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h2><blockquote>
<p>由于实现双亲委派的代码在<code>java.lang.ClassLoader</code>的<code>loadClass()</code>方法中，如果自定义类加载器的话，推荐覆盖实现<code>findClass()</code>方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span></span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClassLoader</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-keyword">byte</span>[] data = loadClassData(name);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defineClass(name, data, <span class="hljs-number">0</span>, data.length);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] loadClassData(String clsName) &#123;<br>        <span class="hljs-keyword">byte</span>[] data = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-comment">// 进行输入输出流的编写</span><br>        <span class="hljs-comment">// 可以自行定义一些规则，比如加载某些或不加载某些</span><br>        <span class="hljs-keyword">return</span> data;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<p>参考：</p>
<blockquote>
<p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B</a></p>
<p>《深入理解Java虚拟机》</p>
<p><a href="https://github.com/doocs/jvm" target="_blank" rel="noopener">https://github.com/doocs/jvm</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Java字节码</title>
    <url>/page/jvm-classbytecode.html</url>
    <content><![CDATA[<h2 id="Class文件"><a href="#Class文件" class="headerlink" title="Class文件"></a>Class文件</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>.class文件即字节码（bytecode）文件，是一个二进制文件</p>
<p>具有平台无关性，可以由其他语言编译生成，由JVM执行</p>
</blockquote>
<h3 id="文件构成"><a href="#文件构成" class="headerlink" title="文件构成"></a>文件构成</h3><p>主要包括两种数据类型：</p>
<ol>
<li>定长数据：无符号数，u1, u2, u4（分别代表1个字节、2个字节、4个字节的无符号数），所以u1相当于就是使用两个16进制位表示</li>
<li>不定长数据：由多个无符号数组成，通常在数据前面给出其长度</li>
</ol>
<h3 id="文件内容"><a href="#文件内容" class="headerlink" title="文件内容"></a>文件内容</h3><p>每个<code>.class</code>文件对应一个<code>ClassFile</code>结构（摘自Java虚拟机规范）</p>
<img src="http://cdn.ziyedy.top/1%E3%80%81Java%E5%AD%97%E8%8A%82%E7%A0%81/classfile.png" style="zoom:80%;" />

<p>对应到中文按照顺序分别为</p>
<ul>
<li>Magic（魔数）：唯一作用是确定该文件是否为一个能被JVM接受的class文件，其固定值为0xCAFEBABE</li>
<li>minor_version（副版本号）、major_version（主版本号）：可以理解为标识JDK的版本</li>
<li>constant_pool_count（常量池计数器）：其值等于常量池中成员+1</li>
<li>constant_pool[]（常量池）：一种表结构，按顺序存储相关结构，具体结构可进行查找</li>
</ul>
<blockquote>
<p>常量池主要存放两类常量：</p>
<p>字面量（如文本字符串、 final 的常量值等）</p>
<p>符号引用（类和接口的全限定名、字段的名称和描述符、方法的名称和描述符）</p>
</blockquote>
<ul>
<li>access_flag（访问标志）：用于表示某个类或接口的访问权限及属性（是类还是接口，是否被public等修饰）</li>
</ul>
<p><img src="http://cdn.ziyedy.top/1%E3%80%81Java%E5%AD%97%E8%8A%82%E7%A0%81/%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97%E8%A1%A8.png" alt="访问标志表"></p>
<ul>
<li>this_class（类索引）：表示这个class文件所定义的类或接口，由常量池中某项表示</li>
<li>super_class（父类索引）：为0表示没有父类（即Object类），否则与类索引相同，只是表示其父类</li>
<li>interfaces_count（接口计数器）：表示当前接口或类实现接口的数量</li>
<li>interfaces[]（接口表）：存储接口</li>
<li>fields_count（字段计数器）、fields[]（字段表）</li>
<li>methods_count（方法计数器）、methods[]（方法表）</li>
<li>attributes_count（属性计数器）、attributes[]（属性表）：字节码最后一部分，存放了基本信息，由编译器写入，JVM会忽略不认识的属性信息。</li>
</ul>
<h1 id="Class文件、反编译文件、源码的对照阅读"><a href="#Class文件、反编译文件、源码的对照阅读" class="headerlink" title="Class文件、反编译文件、源码的对照阅读"></a>Class文件、反编译文件、源码的对照阅读</h1><h2 id="Java源代码"><a href="#Java源代码" class="headerlink" title="Java源代码"></a>Java源代码</h2><p>定义在<code>HelloWorld.java</code>中的一个简单代码</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">package com.jvm.classfile;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWorld</span> &#123;</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">String</span> msg = <span class="hljs-string">"Hello World"</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">"msg = "</span> + msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Class字节码文件"><a href="#Class字节码文件" class="headerlink" title="Class字节码文件"></a>Class字节码文件</h2><h3 id="魔数、版本号"><a href="#魔数、版本号" class="headerlink" title="魔数、版本号"></a>魔数、版本号</h3><p>如下所示，魔数固定为CAFEBABE，而主版本号16进制39转化为10进制就是57，代表Java13（版本对应可查看《Java虚拟机规范》）</p>
<img src="http://cdn.ziyedy.top/1%E3%80%81Java%E5%AD%97%E8%8A%82%E7%A0%81%E9%AD%94%E6%95%B0%E3%80%81%E4%B8%BB%E7%89%88%E6%9C%AC%E5%8F%B7.png" style="zoom:80%;" />

<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>常量池记录中具有以下通用格式：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-class">cp_info </span>&#123;<br>	u1 tag;		<span class="hljs-comment">// 用于表示常量类型</span><br>	u1 info[];	<span class="hljs-comment">// 后续的内容由tag确定的类型确定</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>如下，常量个数3A即为58，而根据下面反编译文件，符合57+1</p>
<img src="http://cdn.ziyedy.top/1%E3%80%81Java%E5%AD%97%E8%8A%82%E7%A0%81/%E5%B8%B8%E9%87%8F.png" style="zoom:80%;" />

<p>而后第一个常量tag为0A（即10），根据对应表可见为如下常量类型，而后两个参数分别为2和3，与反编译文件中常量池第一个常量一致。</p>
<p><img src="http://cdn.ziyedy.top/1%E3%80%81Java%E5%AD%97%E8%8A%82%E7%A0%81/methodref.png" alt=""></p>
<h3 id="访问标志及各类索引"><a href="#访问标志及各类索引" class="headerlink" title="访问标志及各类索引"></a>访问标志及各类索引</h3><p>如下，首先根据最后一个常量为Lookup找到常量池结束的位置，类标识为0021（即0x0001和0x0020），对照反编译文件符合。</p>
<p>而类索引与父类索引对应反编译文件第9、10行也一致</p>
<p><img src="http://cdn.ziyedy.top/1%E3%80%81Java%E5%AD%97%E8%8A%82%E7%A0%81/%E7%B1%BB%E6%A0%87%E8%AF%86.png" alt=""></p>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>由于源码中未实现接口，因此如上节中父类标识后为0000，表示不存在接口</p>
<h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>字段的通用表示格式：</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-class">field_info </span>&#123;<br>	u2 access_flags;		<span class="hljs-comment">// 字段访问权限标识符</span><br>	u2 name_index;			<span class="hljs-comment">// 对常量池的索引，即字段名</span><br>	u2 descriptor_index;	<span class="hljs-comment">// 对常量池的索引，字段类型</span><br>	u2 attributes_count;	<span class="hljs-comment">// 附加属性数量</span><br>	attribute_info[]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如下，0001表示只有一个字段，000A表示源码中的<code>private static</code>，对应关系可查对应表</p>
<p>0011表示字段名索引为17，由反编译文件第29行可知，对应的为<code>msg</code>，与源码定义一致</p>
<p>0012表示字段类型索引为18，对应反编译文件第30行，为<code>String</code>类型</p>
<p>0000表示无附加属性</p>
<p><img src="http://cdn.ziyedy.top/1%E3%80%81Java%E5%AD%97%E8%8A%82%E7%A0%81/%E5%AD%97%E6%AE%B5.png" alt=""></p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>方法的通用表示格式：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">method_info &#123;<br>	u2 access_flags<span class="hljs-comment">;		// 访问权限</span><br>	u2 name_index<span class="hljs-comment">;			// 名称索引</span><br>	u2 descriptor_index<span class="hljs-comment">;	// 方法描述符</span><br>	u2 attribute_count<span class="hljs-comment">;</span><br>	attribute_info[]<span class="hljs-comment">;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>由上一节向后看：</p>
<p>0003表示该类有三个方法，类初始化方法、实例初始化方法、源码中我们自己定义的方法</p>
<p>其余的查看方法与字段相同，可以看到分别对应相关的方法，以及其参数与返回值。</p>
<h2 id="反编译文件"><a href="#反编译文件" class="headerlink" title="反编译文件"></a>反编译文件</h2><h3 id="反编译结果"><a href="#反编译结果" class="headerlink" title="反编译结果"></a>反编译结果</h3><p>使用<code>javap -verbose</code>反编译后的文件，如下。</p>
<p>可以看到其中内容与之间说明的文件内容是<strong>一一对应</strong>的，如<code>Constant pool</code>中就包括常量池的内容</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><code class="hljs lasso">Classfile /D:/java<span class="hljs-params">-demo</span>/jvm/out/production/jvm/com/jvm/classfile/HelloWorld.class<br>  Last modified <span class="hljs-number">2021</span>年<span class="hljs-number">2</span>月<span class="hljs-number">3</span>日; size <span class="hljs-number">1128</span> <span class="hljs-built_in">bytes</span><br>  SHA<span class="hljs-number">-256</span> checksum ce04ce48aa10126385c2a8b9bd8399ebf073b33cd6c7cb17f4b3ec73903aef7a<br>  Compiled from <span class="hljs-string">"HelloWorld.java"</span><br><span class="hljs-keyword">public</span> class com.jvm.classfile.HelloWorld<br>  minor version: <span class="hljs-number">0</span><br>  major version: <span class="hljs-number">57</span><br>  flags: (<span class="hljs-number">0x0021</span>) ACC_PUBLIC, ACC_SUPER<br>  this_class: #14                         <span class="hljs-comment">// com/jvm/classfile/HelloWorld</span><br>  super_class: #2                         <span class="hljs-comment">// java/lang/Object</span><br>  interfaces: <span class="hljs-number">0</span>, fields: <span class="hljs-number">1</span>, methods: <span class="hljs-number">3</span>, attributes: <span class="hljs-number">3</span><br>Constant pool:<br>   #1 = Methodref          #2.#3          <span class="hljs-comment">// java/lang/Object."&lt;init&gt;":()V</span><br>   #2 = Class              #4             <span class="hljs-comment">// java/lang/Object</span><br>   #3 = NameAndType        #5:#6          <span class="hljs-comment">// "&lt;init&gt;":()V</span><br>   #4 = Utf8               java/lang/Object<br>   #5 = Utf8               &lt;init&gt;<br>   #6 = Utf8               ()V<br>   #7 = Fieldref           #8.#9          <span class="hljs-comment">// java/lang/System.out:Ljava/io/PrintStream;</span><br>   #8 = Class              #10            <span class="hljs-comment">// java/lang/System</span><br>   #9 = NameAndType        #11:#12        <span class="hljs-comment">// out:Ljava/io/PrintStream;</span><br>  #10 = Utf8               java/lang/System<br>  #11 = Utf8               out<br>  #12 = Utf8               Ljava/io/PrintStream;<br>  #13 = Fieldref           #14.#15        <span class="hljs-comment">// com/jvm/classfile/HelloWorld.msg:Ljava/lang/String;</span><br>  #14 = Class              #16            <span class="hljs-comment">// com/jvm/classfile/HelloWorld</span><br>  #15 = NameAndType        #17:#18        <span class="hljs-comment">// msg:Ljava/lang/String;</span><br>  #16 = Utf8               com/jvm/classfile/HelloWorld<br>  #17 = Utf8               msg<br>  #18 = Utf8               Ljava/lang/<span class="hljs-built_in">String</span>;<br>  #19 = InvokeDynamic      #0:#20         <span class="hljs-comment">// #0:makeConcatWithConstants:(Ljava/lang/String;)Ljava/lang/String;</span><br>  #20 = NameAndType        #21:#22        <span class="hljs-comment">// makeConcatWithConstants:(Ljava/lang/String;)Ljava/lang/String;</span><br>  #21 = Utf8               makeConcatWithConstants<br>  #22 = Utf8               (Ljava/lang/<span class="hljs-built_in">String</span>;)Ljava/lang/<span class="hljs-built_in">String</span>;<br>  #23 = Methodref          #24.#25        <span class="hljs-comment">// java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>  #24 = Class              #26            <span class="hljs-comment">// java/io/PrintStream</span><br>  #25 = NameAndType        #27:#28        <span class="hljs-comment">// println:(Ljava/lang/String;)V</span><br>  #26 = Utf8               java/io/PrintStream<br>  #27 = Utf8               println<br>  #28 = Utf8               (Ljava/lang/<span class="hljs-built_in">String</span>;)V<br>  #29 = <span class="hljs-built_in">String</span>             #30            <span class="hljs-comment">// Hello World</span><br>  #30 = Utf8               Hello World<br>  #31 = Utf8               Code<br>  #32 = Utf8               LineNumberTable<br>  #33 = Utf8               LocalVariableTable<br>  #34 = Utf8               this<br>  #35 = Utf8               Lcom/jvm/classfile/HelloWorld;<br>  #36 = Utf8               main<br>  #37 = Utf8               (<span class="hljs-meta">[</span>Ljava/lang/<span class="hljs-built_in">String</span>;)V<br>  #38 = Utf8               args<br>  #39 = Utf8               <span class="hljs-meta">[</span>Ljava/lang/<span class="hljs-built_in">String</span>;<br>  #40 = Utf8               &lt;clinit&gt;<br>  #41 = Utf8               SourceFile<br>  #42 = Utf8               HelloWorld.java<br>  #43 = Utf8               BootstrapMethods<br>  #44 = MethodHandle       <span class="hljs-number">6</span>:#45          <span class="hljs-comment">// REF_invokeStatic java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Lja</span><br>va/lang/invoke/MethodType;Ljava/lang/<span class="hljs-built_in">String</span>;<span class="hljs-meta">[</span>Ljava/lang/Object;)Ljava/lang/invoke/CallSite;<br>  #45 = Methodref          #46.#47        <span class="hljs-comment">// java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/Me</span><br>thodType;Ljava/lang/<span class="hljs-built_in">String</span>;<span class="hljs-meta">[</span>Ljava/lang/Object;)Ljava/lang/invoke/CallSite;<br>  #46 = Class              #48            <span class="hljs-comment">// java/lang/invoke/StringConcatFactory</span><br>  #47 = NameAndType        #21:#49        <span class="hljs-comment">// makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/String;Ljava/lang/invoke/MethodType;Ljava/lang/String;[Ljava/lan</span><br>g/Object;)Ljava/lang/invoke/CallSite;<br>  #48 = Utf8               java/lang/invoke/StringConcatFactory<br>  #49 = Utf8               (Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/<span class="hljs-built_in">String</span>;Ljava/lang/invoke/MethodType;Ljava/lang/<span class="hljs-built_in">String</span>;<span class="hljs-meta">[</span>Ljava/lang/Object;)Ljava/lang/invoke/CallSite;<br>  #50 = <span class="hljs-built_in">String</span>             #51            <span class="hljs-comment">// msg = \u0001</span><br>  #51 = Utf8               msg = \u0001<br>  #52 = Utf8               InnerClasses<br>  #53 = Class              #54            <span class="hljs-comment">// java/lang/invoke/MethodHandles$Lookup</span><br>  #54 = Utf8               java/lang/invoke/MethodHandles$Lookup<br>  #55 = Class              #56            <span class="hljs-comment">// java/lang/invoke/MethodHandles</span><br>  #56 = Utf8               java/lang/invoke/MethodHandles<br>  #57 = Utf8               Lookup<br>&#123;<br>  <span class="hljs-keyword">public</span> com.jvm.classfile.HelloWorld();<br>    descriptor: ()V<br>    flags: (<span class="hljs-number">0x0001</span>) ACC_PUBLIC<br>    Code:<br>      <span class="hljs-built_in">stack</span>=<span class="hljs-number">1</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: aload_0<br>         <span class="hljs-number">1</span>: invokespecial #1                  <span class="hljs-comment">// Method java/lang/Object."&lt;init&gt;":()V</span><br>         <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">3</span>: <span class="hljs-number">0</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>       <span class="hljs-number">5</span>     <span class="hljs-number">0</span>  this   Lcom/jvm/classfile/HelloWorld;<br><br>  <span class="hljs-keyword">public</span> static <span class="hljs-literal">void</span> main(java.lang.<span class="hljs-built_in">String</span><span class="hljs-meta">[</span><span class="hljs-meta">]</span>);<br>    descriptor: (<span class="hljs-meta">[</span>Ljava/lang/<span class="hljs-built_in">String</span>;)V<br>    flags: (<span class="hljs-number">0x0009</span>) ACC_PUBLIC, ACC_STATIC<br>    Code:<br>      <span class="hljs-built_in">stack</span>=<span class="hljs-number">2</span>, locals=<span class="hljs-number">1</span>, args_size=<span class="hljs-number">1</span><br>         <span class="hljs-number">0</span>: getstatic     #7                  <span class="hljs-comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span><br>         <span class="hljs-number">3</span>: getstatic     #13                 <span class="hljs-comment">// Field msg:Ljava/lang/String;</span><br>         <span class="hljs-number">6</span>: invokedynamic #19,  <span class="hljs-number">0</span>             <span class="hljs-comment">// InvokeDynamic #0:makeConcatWithConstants:(Ljava/lang/String;)Ljava/lang/String;</span><br>        <span class="hljs-number">11</span>: invokevirtual #23                 <span class="hljs-comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br>        <span class="hljs-number">14</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">7</span>: <span class="hljs-number">0</span><br>        line <span class="hljs-number">8</span>: <span class="hljs-number">14</span><br>      LocalVariableTable:<br>        Start  Length  Slot  Name   Signature<br>            <span class="hljs-number">0</span>      <span class="hljs-number">15</span>     <span class="hljs-number">0</span>  args   <span class="hljs-meta">[</span>Ljava/lang/<span class="hljs-built_in">String</span>;<br><br>  static &#123;&#125;;<br>    descriptor: ()V<br>    flags: (<span class="hljs-number">0x0008</span>) ACC_STATIC<br>    Code:<br>      <span class="hljs-built_in">stack</span>=<span class="hljs-number">1</span>, locals=<span class="hljs-number">0</span>, args_size=<span class="hljs-number">0</span><br>         <span class="hljs-number">0</span>: ldc           #29                 <span class="hljs-comment">// String Hello World</span><br>         <span class="hljs-number">2</span>: putstatic     #13                 <span class="hljs-comment">// Field msg:Ljava/lang/String;</span><br>         <span class="hljs-number">5</span>: <span class="hljs-keyword">return</span><br>      LineNumberTable:<br>        line <span class="hljs-number">4</span>: <span class="hljs-number">0</span><br>&#125;<br>SourceFile: <span class="hljs-string">"HelloWorld.java"</span><br>BootstrapMethods:<br>  <span class="hljs-number">0</span>: #44 REF_invokeStatic java/lang/invoke/StringConcatFactory.makeConcatWithConstants:(Ljava/lang/invoke/MethodHandles$Lookup;Ljava/lang/<span class="hljs-built_in">String</span>;Ljava/lang/invoke/MethodType;Ljava/lang<br>/<span class="hljs-built_in">String</span>;<span class="hljs-meta">[</span>Ljava/lang/Object;)Ljava/lang/invoke/CallSite;<br>    Method arguments:<br>      #50 msg = \u0001<br>InnerClasses:<br>  <span class="hljs-keyword">public</span> static final #57= #53 of #55;    <span class="hljs-comment">// Lookup=class java/lang/invoke/MethodHandles$Lookup of class java/lang/invoke/MethodHandles</span><br></code></pre></td></tr></table></figure>

<h3 id="反编译方法阅读"><a href="#反编译方法阅读" class="headerlink" title="反编译方法阅读"></a>反编译方法阅读</h3><p>stack：方法执行时操作栈深度</p>
<p>locals：局部变量所需的存储空间，单位是slot（虚拟机为局部变量分配内存的最小单位）</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式六大原则</title>
    <url>/page/design-pattern-6-principle.html</url>
    <content><![CDATA[<h2 id="开闭原则"><a href="#开闭原则" class="headerlink" title="开闭原则"></a>开闭原则</h2><blockquote>
<p>一个软件实体如类、模块和函数应该<strong>对拓展开放，对修改关闭</strong></p>
</blockquote>
<p>越基层的模块影响越大，越高层的影响越小</p>
<p>应用层改变</p>
<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>高层模块不应该依赖低层模块，二者都应该依赖其<strong>抽象</strong></p>
<p>依赖倒置原则可以减少类间的耦合性、提高系统稳定性，提高代码可读性和可维护性，降低修改程序所造成的风险</p>
</blockquote>
<p>在Java中集中表现在<strong>面向接口编程</strong>的思想</p>
<ol>
<li>模块间的依赖通过抽象发生，<em>实现类之间不直接发生依赖关系</em>（依赖通过相同的接口产生）</li>
<li>接口与抽象类不依赖于实现类，而实现类依赖于接口与抽象类</li>
</ol>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><h2 id="单一职责原则"><a href="#单一职责原则" class="headerlink" title="单一职责原则"></a>单一职责原则</h2><blockquote>
<p>不要存在多于一个导致类变更的原因，一个类/接口/方法只负责一项职责</p>
<p>优点：可以降低类的复杂度，提高类的可读性，提高系统的可维护性</p>
</blockquote>
<p>单一职责原则很好理解，在面向接口编程中即表现为<em>一个类实现多个接口</em>，将多个接口的职责融合在一起，从而将接口解耦合</p>
<h2 id="接口隔离原则"><a href="#接口隔离原则" class="headerlink" title="接口隔离原则"></a>接口隔离原则</h2><blockquote>
<p>用多个专门的接口，而不使用单一的总接口（尽量细化接口，接口中的方法尽量少）</p>
<p>符合高内聚低耦合的设计思想，从而使类具有很好的可读性、可拓展性和可维护性</p>
</blockquote>
<h2 id="迪米特法则"><a href="#迪米特法则" class="headerlink" title="迪米特法则"></a>迪米特法则</h2><blockquote>
<p>一个对象应该对其他对象保持最少的了解，即“最少知道原则”，尽量降低类之间的耦合</p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java11：注解</title>
    <url>/page/Java-annotation.html</url>
    <content><![CDATA[<h2 id="注解基础"><a href="#注解基础" class="headerlink" title="注解基础"></a>注解基础</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><blockquote>
<p>注解（Annotation），JDK1.5引入</p>
<p>位于源码中（可以理解Java源码由<em>代码/注释/注解</em> 构成）</p>
<p>注解用于修饰程序的元素，而不会对被修饰的对象有直接影响，只有通过<strong>某种配套的工具</strong>才会对注解信息进行访问和处理（比如一些框架中就利用反射技术对注解中内容进行处理）</p>
</blockquote>
<h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul>
<li><p>提供信息给编译器/IDE（如<code>@SuppressWarnings</code>即让IDE压制相应警告信息）</p>
</li>
<li><p>可用于其他工具来产生额外的代码/配置文件（比如Java web中即可使用注解生成配置文件）</p>
</li>
<li><p>有一些注解可在程序运行时访问，增加程序的动态性</p>
</li>
</ul>
<h3 id="普通注解"><a href="#普通注解" class="headerlink" title="普通注解"></a>普通注解</h3><p>即Java预定义的普通注解，主要有以下一些</p>
<ul>
<li><code>@Override</code>：修饰方法，强制该方法代码必须符合父类中该方法的定义，避免代码错误</li>
<li><code>@Deprecated</code>：修饰类/类元素/包，表明该部分废除，建议不再使用（IDE会显示为被横线划掉）</li>
<li><code>@SuppressWarnings</code>：压制不同类型的警告信息，使得编译器不再显示警告（警告类型由IDE自定）。同时该方法可以传入参数，用于标识忽略哪些信息，示例如下</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@SuppressWarnings(<span class="hljs-meta-string">"all"</span>)</span>	<span class="hljs-comment">// 忽略所有警告</span><br></code></pre></td></tr></table></figure>

<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><blockquote>
<p>元注解即修饰注解的注解，在自定义注解时比较常用</p>
</blockquote>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><blockquote>
<p>该注解用于修饰其他注解的存在范围</p>
<p><code>RetentionPolicy.SOURCE</code>：注解仅存在于源码，不在class文件</p>
<p><code>RetentionPolicy.CLASS</code>：<em>默认参数</em>，注解存在于.class文件，但不能被JVM加载</p>
<p><code>RetentionPolicy.RUNTIME</code>：表示注解可以被JVM运行时访问到，通常情况下可以结合反射进行一些工作</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span>	<span class="hljs-comment">// 修饰的注解存在于JVM中</span><br></code></pre></td></tr></table></figure>

<h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><blockquote>
<p>用于限定目标注解能够作用在什么地方</p>
<p>比如有些注解只能修饰方法，就是使用这个实现的</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.FIELD&#125;)</span>	<span class="hljs-comment">// 限定修饰方法与成员变量</span><br></code></pre></td></tr></table></figure>

<h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><blockquote>
<p>使得修饰的注解修饰的类与它的子类都能够包含某个注解</p>
<p>普通的注解没有继承功能</p>
</blockquote>
<h4 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h4><blockquote>
<p>修饰的注解可以重复应用标注，常用于测试</p>
<p>需要定义注解和注解容器（即原注解的数组）</p>
</blockquote>
<h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><blockquote>
<p>指明该注解可以被Javadoc工具解析，形成帮助文档</p>
</blockquote>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><blockquote>
<p>注解的定义即拓展<code>java.lang.annotation.Annotation</code>注解接口</p>
<p>其中绝大部分类型都可以作为其参数，但属性定义成方法 的样子</p>
</blockquote>
<p>定义形式如下</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">public @interface MyAnnotation &#123;<br>    int a()<span class="hljs-built_in"> default </span>0;<br>    int b()<span class="hljs-built_in"> default </span>0;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="注解的解析"><a href="#注解的解析" class="headerlink" title="注解的解析"></a>注解的解析</h2><p>暂略</p>
<h2 id="注解的应用"><a href="#注解的应用" class="headerlink" title="注解的应用"></a>注解的应用</h2><p>暂略</p>
<blockquote>
<p>参考：</p>
<p>mooc华东师范大学Java核心技术</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JDBC使用步骤</title>
    <url>/page/JDBC-summary.html</url>
    <content><![CDATA[<h2 id="0、数据库连接配置"><a href="#0、数据库连接配置" class="headerlink" title="0、数据库连接配置"></a>0、数据库连接配置</h2><p>新建一个 <code>jdbc.properties</code> 文件进行配置，主要信息有数据库的驱动，以及连接数据库的必要的信息。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">driver</span> = com.mysql.jdbc.Driver<br><span class="hljs-attr">url</span> = jdbc:mysql://localhost:<span class="hljs-number">3306</span>/mybatis?characterEncoding=utf8<br><span class="hljs-attr">username</span> = root<br><span class="hljs-attr">password</span> = shagds139<br></code></pre></td></tr></table></figure>

<p>进行驱动的加载</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ResourceBundle bundle = ResourceBundle.getBundle(<span class="hljs-string">"jdbc"</span>);<br>String driver = bundle.getString(<span class="hljs-string">"driver"</span>);<br>String url = bundle.getString(<span class="hljs-string">"url"</span>);<br>String username = bundle.getString(<span class="hljs-string">"username"</span>);<br>String password = bundle.getString(<span class="hljs-string">"password"</span>);<br></code></pre></td></tr></table></figure>

<h2 id="1、注册驱动"><a href="#1、注册驱动" class="headerlink" title="1、注册驱动"></a>1、注册驱动</h2><p>说明要连接什么数据库，即使用各个数据库厂商实现的 Java 定义的用于连接数据库的接口。主要有两种实现方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">DriverManager.registerDriver(<span class="hljs-keyword">new</span> com.mysql.jdbc.Driver());<br></code></pre></td></tr></table></figure>

<p>通常使用以下方法进行驱动的加载。主要好处有通过反射可以使用配置文件的方式传入数据库驱动，同时<code>Class.forName()</code>的执行会导致类的加载，因此可以利用类加载的动作实现其静态代码块的执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Class.forName(driver);<br></code></pre></td></tr></table></figure>

<h2 id="2、获取连接"><a href="#2、获取连接" class="headerlink" title="2、获取连接"></a>2、获取连接</h2><p>表示 JVM 的进程和数据库进程之间的通道打开了，这属于进程之间的重量级通信，因此不能频繁创建。<code>Connection</code> 在JDBC中用于表示数据库的连接</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Connection connection = <span class="hljs-keyword">null</span>;<br>connection = DriverManager.getConnection(url, username, password);<br></code></pre></td></tr></table></figure>

<p><code>Connection</code> 有如下一些常用方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>createStatement()</td>
<td>创建向数据库发送sql的statement对象</td>
</tr>
<tr>
<td>prepareStatement(sql)</td>
<td>创建向数据库发送预编译sql的PrepareSatement对象</td>
</tr>
<tr>
<td>prepareCall(sql)</td>
<td>创建执行存储过程的callableStatement对象</td>
</tr>
<tr>
<td>setAutoCommit(boolean autoCommit)</td>
<td>设置事务是否自动提交</td>
</tr>
<tr>
<td>commit()</td>
<td>提交事务</td>
</tr>
<tr>
<td>rollback()</td>
<td>回滚事务</td>
</tr>
</tbody></table>
<p>其中 <strong>JDBC 事务默认是自动提交</strong>的，即执行任意一条DML语句，就自动提交一次，要实现手动提交事务通常使用如下步骤实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    connection.setAutoCommit(<span class="hljs-keyword">false</span>);	<span class="hljs-comment">// 关闭自动提交</span><br>    <br>    <span class="hljs-comment">// 执行 sql 语句</span><br>    <br>    connection.commit();	<span class="hljs-comment">// 手动提交</span><br>    <br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        connection.rollback();	<span class="hljs-comment">// 出现异常则进行回滚</span><br>    &#125; <span class="hljs-keyword">catch</span> (SQLException throwables) &#123;<br>        throwables.printStackTrace();<br>    &#125;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="3、获取数据库操作对象"><a href="#3、获取数据库操作对象" class="headerlink" title="3、获取数据库操作对象"></a>3、获取数据库操作对象</h2><p>获取数据库操作对象，即用于执行 sql 语句的对象</p>
<h3 id="sql-语句拼接问题（注入攻击）"><a href="#sql-语句拼接问题（注入攻击）" class="headerlink" title="sql 语句拼接问题（注入攻击）"></a>sql 语句拼接问题（注入攻击）</h3><p>如使用如下语句进行用户名与密码的验证，<strong>输入包含恒为真的条件</strong>可能造成注入攻击，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String sql = <span class="hljs-string">"select * from user where username = '"</span> + name + <span class="hljs-string">"' and password = '"</span> + pwd + <span class="hljs-string">"'"</span>;<br></code></pre></td></tr></table></figure>

<p>输入 <code>ziye&#39; or &#39;1&#39;=&#39;1</code> 即可以将 sql 语句拼接为如下语句，恒为真</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> * <span class="hljs-keyword">from</span> <span class="hljs-keyword">user</span> <span class="hljs-keyword">where</span> username = <span class="hljs-string">'ziye'</span> <span class="hljs-keyword">and</span> <span class="hljs-keyword">password</span> = <span class="hljs-string">'ziye'</span> <span class="hljs-keyword">or</span> <span class="hljs-string">'1'</span>=<span class="hljs-string">'1'</span><br></code></pre></td></tr></table></figure>

<h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Statement statement = <span class="hljs-keyword">null</span>;<br>statement = connection.createStatement();<br></code></pre></td></tr></table></figure>

<p><code>Statement</code> 有如下常用方法：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>executeQuery(String sql)</td>
<td>用于向数据发送查询语句，返回 <code>ResultSet</code></td>
</tr>
<tr>
<td>executeUpdate(String sql)</td>
<td>用于向数据库发送insert、update、delete等DML语句，返回记录条数</td>
</tr>
<tr>
<td>execute(String sql)</td>
<td>用于向数据库发送任意sql语句</td>
</tr>
<tr>
<td>addBatch(String sql)</td>
<td>把多条sql语句放到一个批处理中</td>
</tr>
<tr>
<td>executeBatch()</td>
<td>向数据库发送一批sql语句执行</td>
</tr>
</tbody></table>
<h3 id="PreperedStatement"><a href="#PreperedStatement" class="headerlink" title="PreperedStatement"></a>PreperedStatement</h3><p>是 <code>Statement</code> 的子类，相对于 <code>Statement</code> ，其可通过占位符等操作避免 sql注入攻击等问题。同时 <code>statement</code> 编译一次执行一次，而 <code>PreparedStatement</code> 可进行预编译，编译一次执行n次，效率较高。同时由于需要向占位符传入数据，<code>PreparedStatement</code>在Java程序的编译阶段会进行检查</p>
<h2 id="4、执行-sql-语句"><a href="#4、执行-sql-语句" class="headerlink" title="4、执行 sql 语句"></a>4、执行 sql 语句</h2><h3 id="Statement-常规执行"><a href="#Statement-常规执行" class="headerlink" title="Statement 常规执行"></a>Statement 常规执行</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行查询语句</span><br>String sql = <span class="hljs-string">"select * from student"</span>;<br>resultSet = statement.executeQuery(sql);<br><br><span class="hljs-comment">// 执行 DML 语句</span><br>String sql1 = <span class="hljs-string">"insert into student(id, name, age, email) value(111, 'test', 10, 'zzz@qq.com')"</span>;<br>String sql2 = <span class="hljs-string">"delete from student where id=111"</span>;<br>String sql3 = <span class="hljs-string">"update student set name = 'modify', email = 'null' where id = 4"</span>;<br><span class="hljs-keyword">int</span> count = statement.executeUpdate(sql1);<br></code></pre></td></tr></table></figure>

<h3 id="PreperedStatement-使用占位符"><a href="#PreperedStatement-使用占位符" class="headerlink" title="PreperedStatement 使用占位符 ?"></a>PreperedStatement 使用占位符 ?</h3><p>传入的信息只作为数值传入，而不参与 sql 编译即可避免注入攻击，可以使用 <code>prepareStatement</code> 完成</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 ? 作为占位符</span><br>String sql = <span class="hljs-string">"select * from user where username = ? and password = ?"</span>;<br>ps = connection.prepareStatement(sql);<br><br>ps.setString(<span class="hljs-number">1</span>, name);	<span class="hljs-comment">// 给占位符传值，第一个问号的下标为 1</span><br>ps.setString(<span class="hljs-number">2</span>, pwd);	<span class="hljs-comment">// 第二个问号的下标为 2</span><br><br>resultSet = ps.executeQuery();	<span class="hljs-comment">// 获取结果</span><br></code></pre></td></tr></table></figure>

<h2 id="5、处理查询结果集"><a href="#5、处理查询结果集" class="headerlink" title="5、处理查询结果集"></a>5、处理查询结果集</h2><p>使用 <code>select</code> 查询语句后会得到结果集，需要对其进行处理</p>
<p><code>ResultSet</code> 封装了执行结果，只需要迭代的将结果取出即可，示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>    <span class="hljs-comment">// 对查询结果进行相应的处理</span><br>    Student stu = <span class="hljs-keyword">new</span> Student(resultSet.getInt(<span class="hljs-string">"id"</span>),<br>                              resultSet.getString(<span class="hljs-string">"name"</span>),<br>                              resultSet.getInt(<span class="hljs-string">"age"</span>),<br>                              resultSet.getString(<span class="hljs-string">"email"</span>));<br>    studentList.add(stu);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="6、释放资源"><a href="#6、释放资源" class="headerlink" title="6、释放资源"></a>6、释放资源</h2><p>Jdbc程序运行完后，要释放程序在运行过程中创建的那些与数据库进行交互的对象，这些对象通常是<code>ResultSet</code>、<code>Statement</code>和 <code>Connection</code> 对象，要<strong>按照创建的顺序</strong>依次进行 关闭</p>
<p><em>为确保资源释放代码能运行，资源释放代码也一定要放在finally语句</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 必须要依次关闭</span><br>    <span class="hljs-keyword">if</span> (resultSet != <span class="hljs-keyword">null</span>) &#123;<br>        resultSet.close();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (statement != <span class="hljs-keyword">null</span>) &#123;<br>        statement.close();<br>    &#125;<br>    <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;<br>        connection.close();<br>    &#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Connection connection = <span class="hljs-keyword">null</span>;<br>    Statement statement = <span class="hljs-keyword">null</span>;<br>    ResultSet resultSet = <span class="hljs-keyword">null</span>;<br><br><br>    ResourceBundle bundle = ResourceBundle.getBundle(<span class="hljs-string">"jdbc"</span>);<br>    String driver = bundle.getString(<span class="hljs-string">"driver"</span>);<br>    String url = bundle.getString(<span class="hljs-string">"url"</span>);<br>    String username = bundle.getString(<span class="hljs-string">"username"</span>);<br>    String password = bundle.getString(<span class="hljs-string">"password"</span>);<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 1、注册驱动</span><br>        Class.forName(driver);<br>        <span class="hljs-comment">// DriverManager.registerDriver(new com.mysql.jdbc.Driver());</span><br><br>        <span class="hljs-comment">// 2、获取数据库连接对象</span><br>        connection = DriverManager.getConnection(url, username, password);<br><br>        <span class="hljs-comment">// 3、数据库操作对象</span><br>        statement = connection.createStatement();<br><br>        <span class="hljs-comment">// 4、执行 sql 语句 （以执行DQL语句为例）</span><br>        String sql = <span class="hljs-string">"select * from student"</span>;<br>        resultSet = statement.executeQuery(sql);<br>        <br>        <span class="hljs-comment">// 5、处理查询结果集</span><br>        List&lt;Student&gt; studentList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">while</span> (resultSet.next()) &#123;<br>            Student stu = <span class="hljs-keyword">new</span> Student(resultSet.getInt(<span class="hljs-string">"id"</span>),<br>                                      resultSet.getString(<span class="hljs-string">"name"</span>),<br>                                      resultSet.getInt(<span class="hljs-string">"age"</span>),<br>                                      resultSet.getString(<span class="hljs-string">"email"</span>));<br>            studentList.add(stu);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (Student stu : studentList) &#123;<br>            System.out.println(stu);<br>        &#125;<br>        <br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>        <br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 6、释放资源</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (resultSet != <span class="hljs-keyword">null</span>) &#123;<br>                resultSet.close();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (statement != <span class="hljs-keyword">null</span>) &#123;<br>                statement.close();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (connection != <span class="hljs-keyword">null</span>) &#123;<br>                connection.close();<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Servlet基础总结</title>
    <url>/page/servlet-basic-summary.html</url>
    <content><![CDATA[<h1 id="Servlet基础"><a href="#Servlet基础" class="headerlink" title="Servlet基础"></a>Servlet基础</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote>
<p>Servlet是 Server 与 Applet 的缩写，是用Java语言编写的<em>运行在服务器端</em>，由服务器调用执行，按照 Servlet 标准来开发的类，用来完成B/S架构下，客户端请求的响应处理。</p>
<p>Servlet 本质上也是 Java 类，但要遵循 Servlet 规范进行编写，它的创建、使用、销毁都由 Servlet 容器进行管理，所谓 Servlet 容器即为提供了 Servlet 功能的服务器，常见的有Tomcat、Jetty、JBoss等等（即服务器会自动调用Servlet程序）</p>
<p>同时Servlet与HTTP紧密相连，可以处理HTTP协议相关的所有内容，因此在Java Web开发中应用广泛</p>
</blockquote>
<h2 id="Servlet实现"><a href="#Servlet实现" class="headerlink" title="Servlet实现"></a>Servlet实现</h2><h3 id="继承-HttpServlet-类"><a href="#继承-HttpServlet-类" class="headerlink" title="继承 HttpServlet 类"></a>继承 <code>HttpServlet</code> 类</h3><blockquote>
<p>该类中已经完成了通信的规则，我们只需要进行业务的实现即可</p>
</blockquote>
<p>在整个Servlet程序之中最重要的就是Servlet接口，在此接口下定义了一个GenericServlet的子类，但是一般不会直接继承此类，而是根据所使用的协议选择GenericServlet的子类继承，例如：现在是采用HTTP协议处理的，所以一般而言当需要使用HTTP协议操作时用户自定义的Servlet类都要继承HttpServlet类。</p>
<h3 id="重写service方法"><a href="#重写service方法" class="headerlink" title="重写service方法"></a>重写<code>service</code>方法</h3><p>该方法用来处理请求的操作，也可以重写<code>doGet</code>、<code>doPost</code>等方法，<code>service</code>方法的本质其实是调用了这两个方法。</p>
<h3 id="设置注解"><a href="#设置注解" class="headerlink" title="设置注解"></a>设置注解</h3><blockquote>
<p>可以通过注解指定访问路径（在Servlet 3.0之后版本支持，否则得配置<code>web.xml</code>文件）</p>
</blockquote>
<p>示例如下，表示该网页位于<code>root/gg/ss</code>下，（name只是作为一个标识，没有太大实际作用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">"/gg/ss"</span>)<br><span class="hljs-meta">@WebServlet</span>(value=<span class="hljs-string">"/gg/ss"</span>)<br><span class="hljs-meta">@WebServlet</span>(urlPatterns=<span class="hljs-string">"/gg/ss"</span>)<br><span class="hljs-meta">@WebServlet</span>(name=<span class="hljs-string">"Servlet01"</span>,value=<span class="hljs-string">"/gg/ss"</span>)<br></code></pre></td></tr></table></figure>

<p>也可以配置多路径访问，如下表示两个路径都能够进行访问。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">@<span class="hljs-constructor">WebServlet(<span class="hljs-params">name</span>=<span class="hljs-string">"Servlet01"</span>,<span class="hljs-params">value</span>=&#123;<span class="hljs-string">"/ss"</span>,'<span class="hljs-operator">/</span><span class="hljs-params">gg</span>'&#125;)</span><br></code></pre></td></tr></table></figure>

<h3 id="IDEA中更改Web项目根目录"><a href="#IDEA中更改Web项目根目录" class="headerlink" title="IDEA中更改Web项目根目录"></a>IDEA中更改Web项目根目录</h3><img src="http://cdn.ziyedy.top/Servlet%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/IDEA%E8%AE%BE%E7%BD%AEURL%E5%9C%B0%E5%9D%80.png" style="zoom: 50%;" />

<h2 id="Servlet生命周期"><a href="#Servlet生命周期" class="headerlink" title="Servlet生命周期"></a>Servlet生命周期</h2><p>Servlet没有main()方法，不能独立运行，<strong>其运行完全由Servlet容器（即tomcat等服务器）来控制和调度</strong>。</p>
<p>其生命周期则是指Servlet容器何时创建servlet实例、何时调用其方法进行请求的处理、何时销毁其实例的整个过程。</p>
<blockquote>
<p>Servlet类加载——&gt;实例化——&gt;服务——&gt; 销毁</p>
</blockquote>
<ul>
<li><p>实例化与初始化（创建是否存在 servlet 对象）</p>
<p>请求到达容器时，容器查找该 <em>servlet对象</em> 是否存在，若不存在，则创建实例并初始化。默认方法 <code>init()</code></p>
</li>
<li><p>就绪/调用/服务阶段</p>
<p>调用 <code>service()</code> 方法处理请求，在生命周期中可以被多次调用，<code>HttpServlet</code> 中的该方法根据请求方式调用 <code>doGet</code> 和 <code>doPost</code> 方法</p>
</li>
<li><p>销毁时机</p>
<p>当容器关闭时，将Servlet实例进行销毁，<code>destroy()</code> 方法。</p>
</li>
</ul>
<h1 id="请求与响应"><a href="#请求与响应" class="headerlink" title="请求与响应"></a>请求与响应</h1><h2 id="HttpServletRequest对象"><a href="#HttpServletRequest对象" class="headerlink" title="HttpServletRequest对象"></a>HttpServletRequest对象</h2><p><code>HttpServletRequest</code> 是 <code>ServletRequest</code> 唯一的子接口，主要作用是用来<strong>接收客户端发送过来的请求信息</strong>（如请求参数、表单等信息）</p>
<p><code>service()</code>方法中形参接收的是 <code>HttpServletRequest</code> 接口的实例化对象，表示该对象主要应用在 HTTP 协议上，该对象是<strong>由 Tomcat 等 servlet 容器封装好传递过来</strong>，我们只需要调用相应方法取出信息进行处理即可</p>
<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><p>获取基本信息的方法。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>getRequestURL()</td>
<td>获取客户端请求的完整URL（从http开始，到?前面结束）</td>
</tr>
<tr>
<td>getRequestURI()</td>
<td>获取客户端请求的部分URL（从站点名开始，到?前面结束）</td>
</tr>
<tr>
<td>getQueryString()</td>
<td>获取请求行中的参数部分（?后面的部分，没有返回null）</td>
</tr>
<tr>
<td>getMethod()</td>
<td>获取客户端请求方法（GET、POST）</td>
</tr>
<tr>
<td>getProtocol()</td>
<td>获取HTTP版本号</td>
</tr>
<tr>
<td>getContextPath()</td>
<td>获取webapp名字</td>
</tr>
</tbody></table>
<h3 id="处理表单输入（getParameter-方法）"><a href="#处理表单输入（getParameter-方法）" class="headerlink" title="处理表单输入（getParameter() 方法）"></a>处理表单输入（getParameter() 方法）</h3><p>使用 <code>getParameter()</code> 方法获取指定名称的对应值</p>
<p>使用 <code>getParameterValues()</code> 方法获取指定名称所有对应值，返回数组</p>
<p>HTML表单如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"test"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"get"</span>&gt;</span><br>    请输入：<br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"info"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"提交"</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>

<img src="http://cdn.ziyedy.top/Servlet%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/%E5%A4%84%E7%90%86%E8%A1%A8%E5%8D%95%E8%BE%93%E5%85%A5.png" style="zoom:80%;" />

<p>Servlet处理逻辑：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">"/test"</span>)    <span class="hljs-comment">// 子目录</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        resp.setContentType(<span class="hljs-string">"text/html;charset=UTF-8"</span>); <span class="hljs-comment">// 解决中文乱码</span><br>        String info = req.getParameter(<span class="hljs-string">"info"</span>);	<span class="hljs-comment">// 获取名为info的值</span><br>        PrintWriter out=resp.getWriter();<br>        out.println(<span class="hljs-string">"&lt;html&gt;&lt;head&gt;&lt;title&gt;test&lt;/title&gt;&lt;/head&gt;"</span>);<br>        out.println(<span class="hljs-string">"&lt;body&gt;&lt;h1&gt;"</span>+info+<span class="hljs-string">"&lt;/h1&gt;"</span>);<br>        out.println(<span class="hljs-string">"&lt;/body&gt;&lt;/html"</span>);<br>        out.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="http://cdn.ziyedy.top/Servlet%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/%E5%A4%84%E7%90%86%E8%A1%A8%E5%8D%95%E7%BB%93%E6%9E%9C.png" style="zoom:67%;" />

<h2 id="HttpServletResponse对象"><a href="#HttpServletResponse对象" class="headerlink" title="HttpServletResponse对象"></a>HttpServletResponse对象</h2><p>主要用于向客户端输出数据</p>
<p><code>service()</code> 方法中形参接收的是 <code>HttpServletResponse</code> 接口的实例化对象，这个对象中封装了向客户端发送数据、发送响应头、发送响应状态码的方法</p>
<h3 id="响应数据"><a href="#响应数据" class="headerlink" title="响应数据"></a>响应数据</h3><p>通过<code>HttpServletResponse</code>对象直接使用<em>输出流</em>进行响应，响应的数据回到客户端被浏览器解析</p>
<p><code>getWriter()</code> 获取字符流</p>
<p><code>getOutputStream()</code> 获取字节流，可以响应一切数据</p>
<p>示例如下：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">// 字符输出流<br>PrintWriter writer = response.getWriter()<span class="hljs-comment">;</span><br>writer.write(<span class="hljs-string">"&lt;h2&gt;Hello&lt;/h2&gt;"</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字节输出流</span><br>ServletOutputStream out = response.getOutputStream();<br>out.write(<span class="hljs-string">"&lt;h2&gt;Hello&lt;/h2&gt;"</span>.getBytes());<br></code></pre></td></tr></table></figure>

<p>设置响应类型，默认是字符串：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置响应MIME类型</span><br>response.setHeader(<span class="hljs-string">"content-type"</span>,<span class="hljs-string">"text/html"</span>); <span class="hljs-comment">// html</span><br></code></pre></td></tr></table></figure>

<h2 id="处理中文乱码"><a href="#处理中文乱码" class="headerlink" title="处理中文乱码"></a>处理中文乱码</h2><p>解决服务器返回页面中文乱码问题</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">response.setContentType(<span class="hljs-string">"text/html;charset=UTF-8"</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>解决post方式请求表单参数中文乱码问题，在接收所有数据前设定</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">request.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>Tomcat9.0已经解决了get方式请求中文乱码问题，可以不需要做此配置。</p>
<h2 id="Servlet跳转"><a href="#Servlet跳转" class="headerlink" title="Servlet跳转"></a>Servlet跳转</h2><h3 id="请求转发"><a href="#请求转发" class="headerlink" title="请求转发"></a>请求转发</h3><blockquote>
<p>一种服务器行为，只能跳转到该站点下的目录</p>
</blockquote>
<p>只存在一次请求（因此request数据共享），地址栏不会发生改变</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">request.getRequestDispatcher(url).forward(request, response);<br></code></pre></td></tr></table></figure>

<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p>服务端指导，客户端行为，存在<strong>两次请求</strong>，且地址栏会发生改变。可以跳转到任意目录，比如<a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></p>
<p>第一次请求会获得3开头的响应码，并且含有一个 location 头信息（代表重定向的地址）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重定向跳转到index.jsp</span><br>response.sendRedirect(<span class="hljs-string">"index.jsp"</span>);<br></code></pre></td></tr></table></figure>

<h2 id="ServletContext对象"><a href="#ServletContext对象" class="headerlink" title="ServletContext对象"></a>ServletContext对象</h2><p>在Web容器启动的时候，会为每一个 Web 应用程序创建一个对应的 <code>ServletContext</code> 对象，每个Web应用都有且只有一个<code>ServletContext</code>对象</p>
<p>主要作用：1、作为域对象在整个Web应用共享数据；2、保存了当前应用程序的相关信息</p>
<h3 id="获取与常用方法"><a href="#获取与常用方法" class="headerlink" title="获取与常用方法"></a>获取与常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过 request 对象获取</span><br>ServletContext servletContext = request.getServletContext();<br><br><span class="hljs-comment">// 通过 session 对象获取</span><br>ServletContext servletContext = request.getSession().getServletContext();<br><br><span class="hljs-comment">// 通过 servletConfig 对象获取</span><br>ServletConfig servletConfig = getServletConfig();<br>ServletContext servletContext = servletConfig.getServletContext();<br><br><span class="hljs-comment">// 直接通过Servlet类获取</span><br>ServletContext servletContext = getServletContext();<br><br><span class="hljs-comment">// 获取项目存放的真实路径</span><br>String realPath = request.getServletContext().getRealPath(<span class="hljs-string">"/"</span>);<br><span class="hljs-comment">// 获取当前服务器的版本信息</span><br>String serverInfo = request.getServletContext().getServerInfo();<br></code></pre></td></tr></table></figure>

<h3 id="ServletContext域对象使用"><a href="#ServletContext域对象使用" class="headerlink" title="ServletContext域对象使用"></a>ServletContext域对象使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取ServletContext对象</span><br>ServletContext servletContext = request.getServletContext();<br><span class="hljs-comment">// 设置域对象</span><br>servletContext.setAttribute(<span class="hljs-string">"name"</span>,<span class="hljs-string">"zhangsan"</span>);<br><span class="hljs-comment">// 获取域对象</span><br>String name = (String) servletContext.getAttribute(<span class="hljs-string">"name"</span>);<br><span class="hljs-comment">// 移除域对象</span><br>servletContext.removeAttribute(<span class="hljs-string">"name"</span>);<br></code></pre></td></tr></table></figure>



<h1 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h1><h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><p>在 <code>javax.servlet.http.Cookie</code> 包下</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>Cookie只保存在当前浏览器中</li>
<li>Cookie中不能出现中文，需要进行编解码操作</li>
<li>如果服务器端发送重复的Cookie那么会覆盖原有的Cookie</li>
<li>浏览器存放Cookie的数量是有上限的</li>
</ul>
<h3 id="Cookie的创建与发送"><a href="#Cookie的创建与发送" class="headerlink" title="Cookie的创建与发送"></a>Cookie的创建与发送</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建Cookie对象</span><br>Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">"id"</span>, <span class="hljs-number">0</span>);<br><span class="hljs-comment">// 发送Cookie对象</span><br>response.addCookie(cookie);<br></code></pre></td></tr></table></figure>

<img src="http://cdn.ziyedy.top/Servlet%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/%E5%88%9B%E5%BB%BAcookie.png" style="zoom:67%;" />

<p>如上，即创建了我们自己的cookie</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">"/cookie1"</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cookie1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-comment">// 创建Cookie对象</span><br>        Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">"id"</span>, <span class="hljs-string">"id"</span>);<br>        <span class="hljs-comment">// 发送Cookie对象</span><br>        response.addCookie(cookie);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Cookie的获取"><a href="#Cookie的获取" class="headerlink" title="Cookie的获取"></a>Cookie的获取</h3><p>Servlet提供了一个 <code>getCookies()</code>的方法用来获取客户端回传的所有 cookie 组成的一个<em>数组</em>，如果需要获取单个 cookie 则需要通过遍历，<code>getName()</code>获取 Cookie 的名称，<code>getValue()</code>获取 Cookie 的值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取Cookie数组</span><br>Cookie[] cookies = request.getCookies();<br><span class="hljs-comment">// 判断数组是否为空</span><br><span class="hljs-keyword">if</span> (cookies != <span class="hljs-keyword">null</span> &amp;&amp; cookies.length &gt; <span class="hljs-number">0</span>) &#123;<br>  	<span class="hljs-comment">// 遍历Cookie数组</span><br>  	<span class="hljs-keyword">for</span> (Cookie cookie : cookies)&#123;<br>  		<span class="hljs-comment">// 判断并获取</span><br>    	System.out.println(cookie.getName());<br>    	System.out.println(cookie.getValue());<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Cookie的路径"><a href="#Cookie的路径" class="headerlink" title="Cookie的路径"></a>Cookie的路径</h3><p>Cookie的<code>setPath()</code>方法设置cookie的路径，这个路径直接决定服务器的请求是否会从浏览器中加载某些cookie</p>
<p>默认情况下只有当前项目能获取当前项目产生的cookie</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 设置路径为"/"，表示在当前服务器下任何项目都可访问到该Cookie对象</span><br><span class="hljs-selector-tag">cookie</span><span class="hljs-selector-class">.setPath</span>(<span class="hljs-string">"/"</span>);<br><br><span class="hljs-comment">// 只有gg项目能访问该cookie</span><br><span class="hljs-selector-tag">cookie</span><span class="hljs-selector-class">.setPath</span>(<span class="hljs-string">"/gg"</span>);<br><br><span class="hljs-comment">// 只有/gg/ss目录下的文件才能访问到cookie</span><br><span class="hljs-selector-tag">cookie</span><span class="hljs-selector-class">.setPath</span>(<span class="hljs-string">"/gg/ss"</span>);<br></code></pre></td></tr></table></figure>

<h3 id="Cookie的到期时间"><a href="#Cookie的到期时间" class="headerlink" title="Cookie的到期时间"></a>Cookie的到期时间</h3><p>Cookie默认当前浏览器关闭即失效，也可以通过 <code>setMaxAge(int time)</code>方法设定 cookie 的最大有效时间，以秒为单位</p>
<p>time为负数，表示不存储该Cookie，浏览器关闭即失效</p>
<p>time为0，表示删除该cookie</p>
<p>time为正数则为存储的秒数</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><blockquote>
<p>session 本身就属于 HTTP 协议，用于保留某个用户访问的信息，只保存在当前浏览器当中。</p>
</blockquote>
<p>对于服务器而言，每一个连接到它的客户端都是一个 session，servlet 容器使用<code>javax.servlet.http.HttpSession</code>创建 HTTP 客户端和 HTTP 服务器之间的会话</p>
<p>简而言之，Session 的作用就是为了标识一次会话，或者说确认一个用户，并且在一次会话（一个用户的多次请求）期间共享数据</p>
<h3 id="Session的获取与基本使用"><a href="#Session的获取与基本使用" class="headerlink" title="Session的获取与基本使用"></a>Session的获取与基本使用</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">"/session1"</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Session1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>    	<span class="hljs-comment">// 获取Session对象</span><br>        HttpSession session = request.getSession();<br><br>		<span class="hljs-comment">// 获取Session会话标识符</span><br>		<span class="hljs-comment">// D111F6C6F0A65C44184672B9BF04D728</span><br>        System.out.println(session.getId());<br><br>		<span class="hljs-comment">// 获取Session创建时间</span><br>		<span class="hljs-comment">// 1612756089930</span><br>        System.out.println(session.getCreationTime());<br><br>		<span class="hljs-comment">// 获取最后一次访问时间</span><br>		<span class="hljs-comment">// 1612756089935</span><br>        System.out.println(session.getLastAccessedTime());<br>		<br>		<span class="hljs-comment">// 判断是否是新的Session对象</span><br>		<span class="hljs-comment">// false</span><br>        System.out.println(session.isNew());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="JSESSIONID标识符"><a href="#JSESSIONID标识符" class="headerlink" title="JSESSIONID标识符"></a>JSESSIONID标识符</h3><blockquote>
<p>使用一个叫JSESSIONID的特殊cookie来标识一次会话，<strong>Session 的底层依赖 Cookie 来实现</strong></p>
</blockquote>
<img src="http://cdn.ziyedy.top/Servlet%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/session.png" style="zoom: 67%;" />

<h3 id="Session域对象"><a href="#Session域对象" class="headerlink" title="Session域对象"></a>Session域对象</h3><blockquote>
<p>Session 用来表示一次会话，在一次会话中数据是可以共享的，这时 session 作为域对象存在</p>
</blockquote>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 向域对象中添加数据</span><br><span class="hljs-function"><span class="hljs-title">setAttribute</span><span class="hljs-params">(name, value)</span></span><br><br><span class="hljs-comment">// 从域对象中获取数据</span><br><span class="hljs-function"><span class="hljs-title">getAttribute</span><span class="hljs-params">(name)</span></span><br><br><span class="hljs-comment">// 从域对象中移除数据</span><br><span class="hljs-function"><span class="hljs-title">removeAttribute</span><span class="hljs-params">(name)</span></span><br></code></pre></td></tr></table></figure>

<h3 id="Session对象的销毁"><a href="#Session对象的销毁" class="headerlink" title="Session对象的销毁"></a>Session对象的销毁</h3><h4 id="默认到期时间"><a href="#默认到期时间" class="headerlink" title="默认到期时间"></a>默认到期时间</h4><blockquote>
<p>由服务器设置产生，如Tomcat 中 session 默认的存活时间为30min，一旦客户端有操作，session 会重新计时</p>
</blockquote>
<p>可以在 Tomcat 中的 conf 目录下的 web.xml 文件中进行修改</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">session-config</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">session-timeout</span>&gt;</span>30<span class="hljs-tag">&lt;/<span class="hljs-name">session-timeout</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">session-config</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="设置到期时间"><a href="#设置到期时间" class="headerlink" title="设置到期时间"></a>设置到期时间</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置session的最大不活动时间(单位为秒)</span><br>session.setMaxInactiveInterval(<span class="hljs-number">30</span>); <span class="hljs-comment">// 30秒</span><br><br><span class="hljs-comment">// 获取session的最大不活动时间</span><br><span class="hljs-keyword">int</span> time = session.getMaxInactiveInterval();<br></code></pre></td></tr></table></figure>

<h4 id="立即失效"><a href="#立即失效" class="headerlink" title="立即失效"></a>立即失效</h4><figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 销毁session对象</span><br><span class="hljs-selector-tag">session</span><span class="hljs-selector-class">.invalidate</span>();<br></code></pre></td></tr></table></figure>

<h3 id="Servlet三大域对象"><a href="#Servlet三大域对象" class="headerlink" title="Servlet三大域对象"></a>Servlet三大域对象</h3><p>Servlet的三大域对象：</p>
<p>1、request域对象；在一次请求中有效</p>
<p>2、session域对象；在一次会话中有效</p>
<p>3、servletContext域对象；在整个应用程序中有效，服务器关闭后失效</p>
<h1 id="文件的上传与下载"><a href="#文件的上传与下载" class="headerlink" title="文件的上传与下载"></a>文件的上传与下载</h1><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="前台实现"><a href="#前台实现" class="headerlink" title="前台实现"></a>前台实现</h3><blockquote>
<p>表单提交类型选择post；表单类型选择<code>enctype=&quot;multipart/form-data&quot;</code></p>
</blockquote>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"uploadServlet"</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">"multipart/form-data"</span>&gt;</span><br>    文件：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"myfile"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span>&gt;</span>提交<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="后台实现"><a href="#后台实现" class="headerlink" title="后台实现"></a>后台实现</h3><p>1、使用注解<code>@MultipartConfig()</code>标识文件上传</p>
<p>2、 Servlet 将 <code>multipart/form-data</code> 的 POST 请求封装成 Part，通过 Part 对上传的文件进行操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span>(<span class="hljs-string">"/uploadServlet"</span>)<br><span class="hljs-meta">@MultipartConfig</span>()<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UploadServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">service</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        request.setCharacterEncoding(<span class="hljs-string">"UTF-8"</span>);<br>        Part part = request.getPart(<span class="hljs-string">"myfile"</span>);<br><br>        String cd = part.getHeader(<span class="hljs-string">"Content-Disposition"</span>);<br>        String fileName = cd.substring(cd.lastIndexOf(<span class="hljs-string">"="</span>)+<span class="hljs-number">2</span>, cd.length()-<span class="hljs-number">1</span>);<br><br>        String realPath = request.getServletContext().getRealPath(<span class="hljs-string">"/"</span>);<br>        part.write(realPath + fileName);	<span class="hljs-comment">// 写入文件</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h2><h3 id="超链接下载"><a href="#超链接下载" class="headerlink" title="超链接下载"></a>超链接下载</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 当超链接遇到浏览器不识别的资源时，会自动下载 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"test.zip"</span>&gt;</span>超链接下载<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 通过download属性可进行下载 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"test.zip"</span> <span class="hljs-attr">download</span>&gt;</span>超链接下载<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Java10：反射</title>
    <url>/page/Java-reflection.html</url>
    <content><![CDATA[<h1 id="反射的基本概念"><a href="#反射的基本概念" class="headerlink" title="反射的基本概念"></a>反射的基本概念</h1><h2 id="反射（reflective）"><a href="#反射（reflective）" class="headerlink" title="反射（reflective）"></a>反射（reflective）</h2><p>程序可以访问、检测和修改它本身状态和行为的能力（自描述和自控制），称为反射，在<code>java.lang.reflect</code>包中。</p>
<p>即在运行时加载、探知和使用编译期间完全未知的类，能够<strong>增加动态语言特性，弥补强动态语言的不足</strong></p>
<p>注：直观来说就是可以将类名以字符串形式传入，从而达到动态修改程序的目的</p>
<h2 id="反射机制的作用"><a href="#反射机制的作用" class="headerlink" title="反射机制的作用"></a>反射机制的作用</h2><ul>
<li>在运行时分析类的能力</li>
<li>在运行时查看和操作对象（比如编写一个适用于所有类的toString方法）</li>
<li>实现泛型数组操作代码</li>
<li>利用Method对象（类似于C++中的函数指针）</li>
</ul>
<h2 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h2><h3 id="方法1：静态编译"><a href="#方法1：静态编译" class="headerlink" title="方法1：静态编译"></a>方法1：静态编译</h3><p>即传统的使用<code>new</code>关键字创建对象</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns"><span class="hljs-keyword">A</span> a = new <span class="hljs-keyword">A</span>()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>



<h3 id="方法2：克隆"><a href="#方法2：克隆" class="headerlink" title="方法2：克隆"></a>方法2：克隆</h3><p>即实现<code>Cloneable</code>接口，直接拷贝内存中的相关信息，不再调用构造函数</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Cloneable</span></span> </span>&#123;<br><br>&#125;<br><br>A a1 = <span class="hljs-keyword">new</span> <span class="hljs-type">A</span>();<br>A a2 = (A) a1.clone();<br></code></pre></td></tr></table></figure>



<h3 id="方法3：反射"><a href="#方法3：反射" class="headerlink" title="方法3：反射"></a>方法3：反射</h3><p>使用反射直接构建类对象</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">A a = (A) <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span>for<span class="hljs-constructor">Name(<span class="hljs-string">"A"</span>)</span>.<span class="hljs-keyword">new</span><span class="hljs-constructor">Instance()</span>;<br></code></pre></td></tr></table></figure>

<p>使用构造器构造类对象</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">Constructor</span>&lt;<span class="hljs-title">A</span>&gt; <span class="hljs-title">constructor</span> = <span class="hljs-title">A</span>.<span class="hljs-title">class</span>.<span class="hljs-title">getConstructor</span><span class="hljs-params">()</span>;</span><br>A a = <span class="hljs-function"><span class="hljs-keyword">constructor</span>.<span class="hljs-title">newInstance</span><span class="hljs-params">()</span>;</span><br></code></pre></td></tr></table></figure>





<h1 id="反射的关键类与方法"><a href="#反射的关键类与方法" class="headerlink" title="反射的关键类与方法"></a>反射的关键类与方法</h1><h2 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h2><p>在Java程序运行时，JVM为每个对象维护一个<em>运行时类型标识</em>，该信息追踪每个对象所属的类，而JVM则利用该信息选择要执行的正确的方法。</p>
<blockquote>
<p>可以使用<code>Class</code>类访问这些信息，而Object类中的<code>getClass()</code>方法则会返回一个Class类型的实例</p>
</blockquote>
<h2 id="Class类的获取"><a href="#Class类的获取" class="headerlink" title="Class类的获取"></a>Class类的获取</h2><p><em>Class类实际上是一个泛型类，<code>A.class</code>的类型是<code>Class&lt;A&gt;</code></em>，主要有以下三种获取Class类对象的方法</p>
<h3 id="使用getClass-方法"><a href="#使用getClass-方法" class="headerlink" title="使用getClass()方法"></a>使用<code>getClass()</code>方法</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">String s = <span class="hljs-string">"123"</span>;<br>Class c = s.get<span class="hljs-constructor">Class()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(c.get<span class="hljs-constructor">Name()</span>); # java.lang.String<br></code></pre></td></tr></table></figure>

<h3 id="使用forName-方法"><a href="#使用forName-方法" class="headerlink" title="使用forName()方法"></a>使用<code>forName()</code>方法</h3><p>若类名保存在一个字符串中，即可以使用该方法。使用该方法时必须提供一个异常处理器（用于应对输入字符串不是一个类的情况）</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">Class c = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span>for<span class="hljs-constructor">Name(<span class="hljs-string">"java.lang.String"</span>)</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(c.get<span class="hljs-constructor">Name()</span>); # java.lang.String<br></code></pre></td></tr></table></figure>

<h3 id="使用-class"><a href="#使用-class" class="headerlink" title="使用.class"></a>使用<code>.class</code></h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">Class c = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">String</span>.</span></span><span class="hljs-keyword">class</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(c.get<span class="hljs-constructor">Name()</span>); # java.lang.String<br></code></pre></td></tr></table></figure>



<h2 id="Class类中常用方法"><a href="#Class类中常用方法" class="headerlink" title="Class类中常用方法"></a>Class类中常用方法</h2><figure class="highlight fortran"><table><tr><td class="code"><pre><code class="hljs fortran">// 获取<span class="hljs-keyword">Target</span>类的<span class="hljs-keyword">class</span>对象<br><span class="hljs-keyword">Class</span> c = <span class="hljs-keyword">Target</span>.<span class="hljs-keyword">class</span>;<br></code></pre></td></tr></table></figure>

<h3 id="成员变量（Field）"><a href="#成员变量（Field）" class="headerlink" title="成员变量（Field）"></a>成员变量（Field）</h3><blockquote>
<p>在运行时获取到类的所有成员变量，还可以给成员变量赋值和获取成员变量的值。</p>
</blockquote>
<h4 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h4><figure class="highlight protobuf"><table><tr><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// 获取所有public修饰的成员变量</span><br>Field[] fields1 = c.getFields();<br><br><span class="hljs-comment">// 获取所有声明的成员变量</span><br>Field[] fields2 = c.getDeclaredFields();	<br><br><span class="hljs-comment">// 获取变量名为value1的变量</span><br>Field field3 = c.getField(<span class="hljs-string">"value1"</span>);<br>Field field4 = c.getDeclaredField(<span class="hljs-string">"value1"</span>);<br></code></pre></td></tr></table></figure>

<h4 id="获取变量类型"><a href="#获取变量类型" class="headerlink" title="获取变量类型"></a>获取变量类型</h4><figure class="highlight vbnet"><table><tr><td class="code"><pre><code class="hljs vbnet"><span class="hljs-built_in">Object</span> fieldType = field3.<span class="hljs-built_in">getType</span>();<br></code></pre></td></tr></table></figure>

<h4 id="成员变量赋值与取值"><a href="#成员变量赋值与取值" class="headerlink" title="成员变量赋值与取值"></a>成员变量赋值与取值</h4><blockquote>
<p>使用<code>Field</code>中的<code>set</code>与<code>get</code>方法</p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="code"><pre><code class="hljs cs">Target t = <span class="hljs-keyword">new</span> Target();	<span class="hljs-comment">// 获取target对象</span><br>Object <span class="hljs-keyword">value</span> = filed3.<span class="hljs-keyword">get</span>(t);	<span class="hljs-comment">// 传入对象，获取成员变量值</span><br>field3.setAccessible(<span class="hljs-literal">true</span>);	<span class="hljs-comment">// 为了对类中的参数进行修改取消安全检查（针对私有变量）</span><br>field3.<span class="hljs-keyword">set</span>(t, <span class="hljs-number">1</span>)	<span class="hljs-comment">// 将该值设置成1</span><br></code></pre></td></tr></table></figure>

<h3 id="成员方法（Method）"><a href="#成员方法（Method）" class="headerlink" title="成员方法（Method）"></a>成员方法（Method）</h3><h4 id="获取成员方法"><a href="#获取成员方法" class="headerlink" title="获取成员方法"></a>获取成员方法</h4><blockquote>
<p>获取方法数组无法获取到继承父类的方法</p>
</blockquote>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene"><span class="hljs-comment">// 获取所有public修饰的方法</span><br><span class="hljs-function"><span class="hljs-keyword">Method</span>[] <span class="hljs-title">methods</span> = <span class="hljs-title">c</span>.<span class="hljs-title">getMethods</span><span class="hljs-params">()</span>;</span>	<br><br><span class="hljs-comment">// 获取所有声明的成员方法</span><br><span class="hljs-function"><span class="hljs-keyword">Method</span>[] <span class="hljs-title">methods1</span> = <span class="hljs-title">c</span>.<span class="hljs-title">getDeclaredMethods</span><span class="hljs-params">()</span>;</span><br><br><span class="hljs-comment">// 获取无参的method方法</span><br><span class="hljs-function"><span class="hljs-keyword">Method</span> <span class="hljs-title">method</span> = <span class="hljs-title">birdClass</span>.<span class="hljs-title">getMethod</span><span class="hljs-params">("<span class="hljs-keyword">method</span>", null)</span>;</span><br><br><span class="hljs-comment">// 获取参数为指定类型的method方法</span><br><span class="hljs-function"><span class="hljs-keyword">Method</span> <span class="hljs-title">method1</span> = <span class="hljs-title">birdClass</span>.<span class="hljs-title">getDeclaredMethod</span><span class="hljs-params">("<span class="hljs-keyword">method</span>", <span class="hljs-keyword">new</span> <span class="hljs-keyword">Class</span>[]&#123;int.<span class="hljs-keyword">class</span>&#125;)</span>;</span><br></code></pre></td></tr></table></figure>

<h4 id="获取方法参数与与返回类型"><a href="#获取方法参数与与返回类型" class="headerlink" title="获取方法参数与与返回类型"></a>获取方法参数与与返回类型</h4><figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene"><span class="hljs-comment">// 获取参数列表</span><br><span class="hljs-keyword">Class</span>[] parameterTypes = <span class="hljs-function"><span class="hljs-keyword">method</span>.<span class="hljs-title">getParameterTypes</span><span class="hljs-params">()</span>;</span><br><br><span class="hljs-comment">// 获取返回类型</span><br><span class="hljs-keyword">Class</span> returnType = <span class="hljs-function"><span class="hljs-keyword">method</span>.<span class="hljs-title">getReturnType</span><span class="hljs-params">()</span>;</span><br></code></pre></td></tr></table></figure>

<h4 id="invoke-方法"><a href="#invoke-方法" class="headerlink" title="invoke()方法"></a>invoke()方法</h4><blockquote>
<p>只要通过反射获取到方法名之后，就可以使用<code>invoke()</code>调用对应的方法</p>
<p>参数1为调用方法的对象，参数2而调用方法的参数</p>
<p>当调用static方法时，参数1为null</p>
</blockquote>
<figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene">Target t = <span class="hljs-keyword">new</span> Target();	<span class="hljs-comment">// 获取target对象</span><br><span class="hljs-function"><span class="hljs-keyword">method</span>.<span class="hljs-title">invoke</span><span class="hljs-params">(t, “123”)</span>;</span>	<span class="hljs-comment">// 调用method方法，传入参数“123”</span><br></code></pre></td></tr></table></figure>



<h3 id="构造方法（Constructor）"><a href="#构造方法（Constructor）" class="headerlink" title="构造方法（Constructor）"></a>构造方法（Constructor）</h3><figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">Constructor</span>[] <span class="hljs-title">constructors</span> = <span class="hljs-title">c</span>.<span class="hljs-title">getConstructors</span><span class="hljs-params">()</span>;</span><br></code></pre></td></tr></table></figure>



<p>其他获取父接口等等暂略</p>
<h2 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h2><h1 id="反射的应用举例"><a href="#反射的应用举例" class="headerlink" title="反射的应用举例"></a>反射的应用举例</h1><p>暂略</p>
<blockquote>
<p>参考：</p>
<p>《Java核心技术卷1》</p>
<p>MOOC华东师范大学Java核心技术课程</p>
<p><a href="https://zhuanlan.zhihu.com/p/80519709" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/80519709</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java02：数据类型与运算符</title>
    <url>/page/java-datatype-operator.html</url>
    <content><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="8种基本数据类型"><a href="#8种基本数据类型" class="headerlink" title="8种基本数据类型"></a>8种基本数据类型</h3><blockquote>
<p>Java有8中基本数据类型</p>
</blockquote>
<ul>
<li><p>数字类型（byte&lt;1&gt;、short&lt;2&gt;、int&lt;4&gt;、long&lt;8&gt;、float&lt;4&gt;、double&lt;8&gt;）；</p>
</li>
<li><p>字符类型（char&lt;2&gt;）；</p>
</li>
<li><p>布尔型（boolean&lt;依赖于JVM的具体实现&gt;）</p>
</li>
</ul>
<p>（其中&lt;&gt;内为其所对应的字节数，每个基本数据类型又有对应的默认值，其中<strong>数据类型的基本都是0</strong>）</p>
<blockquote>
<p>数字类型中前四种使用了<em>常量池</em>技术，而后两种没实现，具体的影响见下一节中的案例部分</p>
</blockquote>
<h3 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h3><h4 id="转换规律"><a href="#转换规律" class="headerlink" title="转换规律"></a>转换规律</h4><blockquote>
<p>基本按照常识即可判断无精度损失</p>
<p>需要注意的是int转float、long转float、long转double是有可能出现精度损失的</p>
<p>当使用<em>二元运算符</em>连接两个操作数时，先判断有没有<code>double</code>，再判断有没有<code>float</code>，再判断有没有<code>long</code>，判断有则结果就为对应类型，否则为<code>int</code>。</p>
</blockquote>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><blockquote>
<p>有信息损失的通常需要进行强制转换</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">double</span> x = <span class="hljs-number">3.14</span>;<br><span class="hljs-built_in">int</span> x = (<span class="hljs-built_in">int</span>) x;	<span class="hljs-comment">// double强制转换为int</span><br></code></pre></td></tr></table></figure>

<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><blockquote>
<p>使用<code>final</code>修饰的为常量，使用<code>static final</code>修饰的为类常量</p>
<p>常量名通常全大写</p>
</blockquote>
<h2 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h2><p>参考：<a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3780005.html</a></p>
<blockquote>
<p>Java为每种基本数据类型都提供了对应的<strong>包装器类型</strong>，将基本数据类型转换成包装类称为<strong>装箱</strong>，反之则称为<strong>拆箱</strong>。</p>
</blockquote>
<h3 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h3><blockquote>
<p>装箱：基本数据类型——&gt;包装类</p>
<p>其中第一种方法不会触发自动装箱的机制，在执行效率和资源占用上，第二种方法通常要优于第一种情况。</p>
</blockquote>
<figure class="highlight lasso"><table><tr><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Integer</span> i = <span class="hljs-literal">new</span> <span class="hljs-built_in">Integer</span>(<span class="hljs-number">10</span>);	<span class="hljs-comment">// 手动装箱</span><br><span class="hljs-built_in">Integer</span> i = <span class="hljs-number">10</span>;	<span class="hljs-comment">// 自动装箱</span><br></code></pre></td></tr></table></figure>

<h3 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h3><blockquote>
<p>拆箱：包装类——&gt;基本数据类型</p>
<p>直接进行赋值语句即可，同时如“+”、“-”等常规数值运算符会触发自动拆箱</p>
</blockquote>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">int i2 = i<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="装箱与拆箱的实现"><a href="#装箱与拆箱的实现" class="headerlink" title="装箱与拆箱的实现"></a>装箱与拆箱的实现</h3><p><strong>装箱过程是通过调用包装器的<code>valueOf()</code>方法实现的</strong></p>
<p><strong>拆箱过程是通过调用包装器的 xxxValue方法实现的（xxx代表对应的基本数据类型）</strong></p>
<p>Java源码：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>	Integer a = <span class="hljs-number">1</span>;<br>	<span class="hljs-keyword">int</span> b = a + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>反编译后结果：</p>
<p><img src="http://cdn.ziyedy.top/2%E3%80%81Java%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E8%BF%90%E7%AE%97%E7%AC%A6/%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E5%8F%8D%E7%BC%96%E8%AF%91.png" alt=""></p>
<h3 id="valueOf方法"><a href="#valueOf方法" class="headerlink" title="valueOf方法"></a>valueOf方法</h3><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><blockquote>
<p>以<code>Integer</code>为例，源码如下，可见</p>
<p>若数值在<strong>[-128,127]</strong>之间，便返回<code>IntegerCache.cache</code>中已存在的对象的引用，否则创建一个新的<code>Integer</code>对象</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public static Integer value<span class="hljs-constructor">Of(<span class="hljs-params">int</span> <span class="hljs-params">i</span>)</span> &#123;<br>	<span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">IntegerCache</span>.</span></span>low<span class="hljs-operator"> &amp;&amp; </span>i &lt;= <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">IntegerCache</span>.</span></span>high)<br>		return <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">IntegerCache</span>.</span></span>cache<span class="hljs-literal">[<span class="hljs-identifier">i</span> + (-I<span class="hljs-identifier">ntegerCache</span>.<span class="hljs-identifier">low</span>)]</span>;<br>	return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Integer(<span class="hljs-params">i</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>因此：</p>
<ul>
<li><code>Integer a = 0;</code>会直接使用常量池中的对象</li>
<li><code>Integer b = new Integer(0);</code>会创建新的对象</li>
</ul>
<p>所以若输出<code>a == b</code>，会输出false</p>
</blockquote>
<h4 id="问题案例"><a href="#问题案例" class="headerlink" title="问题案例"></a>问题案例</h4><p>1、常量池相关问题</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">Integer i1 = <span class="hljs-number">100</span>;<br>Integer i2 = <span class="hljs-number">100</span>;<br><br>Integer i3 = <span class="hljs-number">200</span>;<br>Integer i4 = <span class="hljs-number">200</span>;<br><br>System.out.println(i1==i2);<br>System.out.println(i3==i4);<br><br>####################################<br>true<br>false<br></code></pre></td></tr></table></figure>

<blockquote>
<p>Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的（<strong>这些方法实现了常量池技术</strong>），而Double、Float的valueOf方法的实现是类似的（<strong>这些方法没有使用常量池技术</strong>）。因此，上述代码若换成Double，会输出“false false”，换成Boolean会输出“true true”。</p>
</blockquote>
<p>2、算数运算符相关问题</p>
<blockquote>
<p>如果这些包装类使用了算数运算符，那么“==”比较的将会是数值（即触发了自动拆箱），如下：</p>
</blockquote>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">Integer a = <span class="hljs-number">1</span>;<br>Integer b = <span class="hljs-number">2</span>;<br>Integer c = <span class="hljs-number">3</span>;<br>System.out.println(c==(a+b));	<span class="hljs-comment">// 实际比较的是数值 3 == 3 为true</span><br><br>#########################################<br>true<br></code></pre></td></tr></table></figure>

<hr>
<blockquote>
<p>对于包装器类型，equals方法并不会进行类型转换，如下：</p>
</blockquote>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">Integer a = <span class="hljs-number">1</span>;<br>Integer b = <span class="hljs-number">2</span>;<br><br>Long c = <span class="hljs-number">3</span>L;<br>Long d = <span class="hljs-number">2</span>L;<br><br>System.out.println(c==a+b);<br>System.out.println(c.equals(a+b));<br>System.out.println(c.equals(a+d));<br><br>###########################################<br>true<br>false<br>true<br></code></pre></td></tr></table></figure>





<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h2 id="相关常见问题"><a href="#相关常见问题" class="headerlink" title="相关常见问题"></a>相关常见问题</h2><blockquote>
<p>参考：</p>
<p><a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3780005.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu下bug解决</title>
    <url>/page/ubuntu-debug.html</url>
    <content><![CDATA[<h2 id="系统频繁卡死"><a href="#系统频繁卡死" class="headerlink" title="系统频繁卡死"></a>系统频繁卡死</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">EXT4-fs <span class="hljs-keyword">error</span><br></code></pre></td></tr></table></figure>



<h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><p>编辑配置文件为GRUB添加内核启动参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">sudo nano /etc/default/grub<br></code></pre></td></tr></table></figure>

<p>添加参数</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">GRUB_CMDLINE_LINUX_DEFAULT</span>=<span class="hljs-string">"quiet splash nvme_core.default_ps_max_latency_us=5500"</span><br></code></pre></td></tr></table></figure>

<p>保存并更新</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo update-grub</span><br></code></pre></td></tr></table></figure>

<h3 id="详见"><a href="#详见" class="headerlink" title="详见"></a>详见</h3><p><a href="https://askubuntu.com/questions/905710/ext4-fs-error-after-ubuntu-17-04-upgrade/906105#906105" target="_blank" rel="noopener">https://askubuntu.com/questions/905710/ext4-fs-error-after-ubuntu-17-04-upgrade/906105#906105</a></p>
<h2 id="无法打开终端"><a href="#无法打开终端" class="headerlink" title="无法打开终端"></a>无法打开终端</h2><h3 id="问题解决-1"><a href="#问题解决-1" class="headerlink" title="问题解决"></a>问题解决</h3><p>在设置中更改时间格式即可（莫名其妙的一个bug）</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://askubuntu.com/questions/1040566/cant-open-terminal-in-ubuntu-18-04-after-upgrade-from-17-10" target="_blank" rel="noopener">https://askubuntu.com/questions/1040566/cant-open-terminal-in-ubuntu-18-04-after-upgrade-from-17-10</a></p>
<h2 id="dpkg安装报错"><a href="#dpkg安装报错" class="headerlink" title="dpkg安装报错"></a>dpkg安装报错</h2><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm">E: <span class="hljs-keyword">Sub-process </span>/usr/<span class="hljs-keyword">bin/dpkg </span>returned an error <span class="hljs-meta">code</span> (<span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<p>该问题产生的原因通常是由于有dpkg安装包安装时中断等引起</p>
<p>该问题产生的通常解决方法可见：<a href="https://www.tecmint.com/sub-process-usr-bin-dpkg-returned-an-error-in-ubuntu/" target="_blank" rel="noopener">https://www.tecmint.com/sub-process-usr-bin-dpkg-returned-an-error-in-ubuntu/</a></p>
<p>比如安装向日葵时就会产生这种中断从而导致该问题，解决方法：</p>
<p>即为在<code>/etc/apt/source.list</code>中加入<code>deb http://cz.archive.ubuntu.com/ubuntu bionic main universe</code></p>
]]></content>
      <categories>
        <category>问题解决</category>
        <category>Ubuntu</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>Java12-2：锁机制</title>
    <url>/page/Java12-lock.html</url>
    <content><![CDATA[<h1 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h1><p>使用 <code>synchronized</code> 修饰的作用域中的代码为同步执行的，也就是并发的情况下，执行到对<strong>同一个对象加锁</strong>的 synchronized 代码块时，为串行执行的</p>
<h2 id="synchronized-使用"><a href="#synchronized-使用" class="headerlink" title="synchronized 使用"></a>synchronized 使用</h2><h3 id="1、同步代码块"><a href="#1、同步代码块" class="headerlink" title="1、同步代码块"></a>1、同步代码块</h3><p>小括号里的对象是可以是任意的对象，这个对象负责对想要执行同步代码块的线程进行“调度”，起到对象锁的作用</p>
<p>每个对其 synchronized 的线程，它都会记录下来，然后等到同步代码块没有线程执行的时候，它就会通知其它线程来执行同步代码块</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Lock lock = <span class="hljs-keyword">new</span> Lock();	<span class="hljs-comment">// 此处可以是任意对象</span><br><br><span class="hljs-comment">// 对象锁</span><br><span class="hljs-keyword">synchronized</span> (lock) &#123;<br>&#125;<br><br><span class="hljs-comment">// 类锁</span><br><span class="hljs-keyword">synchronized</span> (Lock<span class="hljs-class">.<span class="hljs-keyword">class</span>) </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>不同类型的多个 Thread 如果有代码要同步执行，锁对象要使用所有线程共同持有的同一个对象</em></p>
<h3 id="2、修饰方法"><a href="#2、修饰方法" class="headerlink" title="2、修饰方法"></a>2、修饰方法</h3><h4 id="2-1-修饰普通成员方法"><a href="#2-1-修饰普通成员方法" class="headerlink" title="2.1 修饰普通成员方法"></a>2.1 修饰普通成员方法</h4><p>此时锁对象就是<code>this</code>，所以以下两种写法等价</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>&#123;<br>	.......<br>  .......<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>	<span class="hljs-keyword">synchronized</span>(<span class="hljs-keyword">this</span>)&#123;<br>		.......<br>  	.......<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2-2-修饰静态方法"><a href="#2-2-修饰静态方法" class="headerlink" title="2.2 修饰静态方法"></a>2.2 修饰静态方法</h4><p>此时锁对象为类的 Class 对象。如果静态方法所在的类为 Test。那么锁对象就是 Test.class</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 锁对象为 Test.class</span><br>        <span class="hljs-comment">// 同步方法体</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><em>注意：构造方法是不能使用 synchronized 关键字修饰的</em></p>
<h2 id="synchronized-原理"><a href="#synchronized-原理" class="headerlink" title="synchronized 原理"></a>synchronized 原理</h2><h3 id="1、synchronized-同步语句块原理"><a href="#1、synchronized-同步语句块原理" class="headerlink" title="1、synchronized 同步语句块原理"></a>1、synchronized 同步语句块原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>) &#123;<br>            System.out.println(<span class="hljs-string">"synchronized 代码块"</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用<code>javap</code>命令进行反编译后可以得到：</p>
<img src="http://cdn.ziyedy.top/Java12-2%EF%BC%9A%E9%94%81%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%90%8C%E6%AD%A5%E8%AF%AD%E5%8F%A5%E5%9D%97%E5%8E%9F%E7%90%86.png" style="zoom:80%;" />

<p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p>
<p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置， <code>monitorexit</code> 指令则指明同步代码块的结束位置</p>
<p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p>
<p>在执行 <code>monitorexit</code> 指令后，将锁计数器设为 0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<p>在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由ObjectMonitor实现的。每个对象中都内置了一个 <code>ObjectMonitor</code>对象（在Java对象头中，维护了所需要的各类信息，如当前持有锁的对象，以及其他等待队列等）。</p>
<p>另外，<code>wait/notify</code>等方法也依赖于<code>monitor</code>对象，这就是为什么只有在同步的块或者方法中才能调用<code>wait/notify</code>等方法，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常的原因。</p>
<h3 id="2、synchronized-修饰方法原理"><a href="#2、synchronized-修饰方法原理" class="headerlink" title="2、synchronized 修饰方法原理"></a>2、synchronized 修饰方法原理</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"synchronized 方法"</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用<code>javap</code>命令进行反编译后可以得到：</p>
<img src="http://cdn.ziyedy.top/Java12-2%EF%BC%9A%E9%94%81%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E5%8E%9F%E7%90%86.png" style="zoom:80%;" />

<p><code>synchronized</code> 修饰的方法并没有 <code>monitorenter</code> 指令和 <code>monitorexit</code> 指令，取而代之的是 <code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。JVM 通过该 <code>ACC_SYNCHRONIZED</code> 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<p><strong>总结：两者的本质都是对对象监视器 monitor 的获取。同时 monitor 锁是非公平锁</strong></p>
<h2 id="synchronized-注意事项"><a href="#synchronized-注意事项" class="headerlink" title="synchronized 注意事项"></a>synchronized 注意事项</h2><p>1、synchronized 使用的为非公平锁，如果需要公平锁，可以使用 ReentrantLock，设置为公平锁</p>
<p>2、锁对象不能为 null。因为锁对象为 null，就不存在对象头，以及与其关联的 monitor 锁</p>
<p>3、由于加锁的开销很大，所以应该把共享资源的操作放在 synchronized 代码块中，而尽量把不需要同步的代码移出 synchronized 代码块</p>
<h1 id="Lock显式锁"><a href="#Lock显式锁" class="headerlink" title="Lock显式锁"></a>Lock显式锁</h1><p><code>java.util.concurrent.locks</code> 包下的 <code>Lock</code> 接口和它的一些实现类如 <code>ReentrantLock</code></p>
<p>显式锁：在代码中需要主动的去进行 lock 操作</p>
<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p>ReentrantLock 也是互斥锁，有如下三种互斥情况：读/写、写/写、读/读。</p>
<p>相对于<code>synchronized</code>，<code>ReentrantLock</code> 更为灵活，它能够支持公平和非公平锁两种形式</p>
<p>默认的无参构造方法则会创建非公平锁，要创建公平锁需要在声明的时候传入 true</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Lock lock = <span class="hljs-keyword">new</span> ReentrantLock(<span class="hljs-keyword">true</span>);	<span class="hljs-comment">// 创建公平锁</span><br></code></pre></td></tr></table></figure>

<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>基本使用就是使用<code>lock</code>加锁，然后使用<code>unlock</code>解锁（建议使用<code>finally</code>避免出现异常锁没有释放掉）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Lock lock = <span class="hljs-keyword">new</span> ReentrantLock();<br>lock.lock();	<span class="hljs-comment">// 加锁</span><br><span class="hljs-keyword">try</span> &#123;<br>	<span class="hljs-comment">// 操作代码</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>	lock.unlock();	<span class="hljs-comment">// 解锁</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="使用tryLock完成加锁操作"><a href="#使用tryLock完成加锁操作" class="headerlink" title="使用tryLock完成加锁操作"></a>使用<code>tryLock</code>完成加锁操作</h3><p>使用<code>lock.lock()</code>进行加锁操作是阻塞的，直到获取锁才会继续向下进行</p>
<p>而使用<code>tryLock</code>，调用后会立即（也可以通过传入时间和单位，来控制等待获取锁的时长）返回获取锁的情况，获取为 true，未能获取为 false，因此能够<em>根据结果进行进一步的处理</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(lock.tryLock(<span class="hljs-number">1</span>, TimeUnit.SECONDS))&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        doSomething();<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    doSomethingElse();<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="lock-方法源码解析"><a href="#lock-方法源码解析" class="headerlink" title="lock 方法源码解析"></a><code>lock</code> 方法源码解析</h2><p>如下可见，<code>lock</code> 方法通过 <code>ReentrantLock</code> 内置的 <code>syn</code> 对象上锁，而 <code>syn</code>对象则是在 <code>ReentrantLock</code> 的构造方法中创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>    sync.lock();<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="ReentrantLock-的构造方法"><a href="#ReentrantLock-的构造方法" class="headerlink" title="ReentrantLock 的构造方法"></a>ReentrantLock 的构造方法</h3><p>如下可见 <code>ReentrantLock</code> 的构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无参构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">()</span> </span>&#123;<br>    sync = <span class="hljs-keyword">new</span> NonfairSync();<br>&#125;<br><br><span class="hljs-comment">// 有参构造函数</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ReentrantLock</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> fair)</span> </span>&#123;<br>    sync = fair ? <span class="hljs-keyword">new</span> FairSync() : <span class="hljs-keyword">new</span> NonfairSync();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如下：<code>FairSync</code> 和 <code>NonFairSync</code> 都继承自 <code>Sync</code>，而<code>Sync</code>继承自<code>AbstractQueuedSynchronizer</code>，即所谓的<strong>AQS</strong></p>
<p><img src="http://cdn.ziyedy.top/Java12-2%EF%BC%9A%E9%94%81%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/Syn%E7%9A%84%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB.jpg" alt=""></p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS 的实现思想就是：</p>
<ul>
<li>若资源空闲，则将当前请求的线程设置为有效工作线程，并将共享资源设置为锁定状态</li>
<li>若资源被占用，则使用一套线程等待阻塞等待以及锁分配机制，该机制AQS使用一个<strong>虚拟双向队列</strong>实现</li>
</ul>
<p>通俗而言，就是AQS使用 <code>volatile</code> 去修饰共享变量 state，线程通过CAS去改变状态符，成功则获取共享内容，失败则进入等待队列，等待被唤醒，如下图所示：</p>
<img src="http://cdn.ziyedy.top/Java12-2%EF%BC%9A%E9%94%81%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/AQS.jpg" style="zoom:80%;" />

<p>AQS 底层使用<strong>模板方法模式</strong>，定义了两种资源共享方式：</p>
<ul>
<li><strong>Exclusive</strong>：独占资源，如ReentrantLock</li>
<li><strong>Share</strong>：共享，多个线程可以同时执行，如ReadWriteLock</li>
</ul>
<h3 id="获取锁的流程"><a href="#获取锁的流程" class="headerlink" title="获取锁的流程"></a>获取锁的流程</h3><p>获取锁的流程大致如下，公平锁与不公平锁的实现主要体现在``tryAcquire<code></code>中逻辑的差异</p>
<ol>
<li>直接通过 <code>tryAcquire</code> 尝试获取锁，成功直接返回；</li>
<li>如果没能获取成功，那么把自己加入等待队列；</li>
<li><strong>自旋</strong>查看自己的排队情况；</li>
<li>如果排队轮到自己，那么尝试通过 <code>tryAcquire</code> 获取锁；</li>
<li>如果没轮到自己，那么回到第三步查看自己的排队情况。</li>
</ol>
<h2 id="ReadWriteLock"><a href="#ReadWriteLock" class="headerlink" title="ReadWriteLock"></a>ReadWriteLock</h2><p>ReadWriteLock 顾名思义读写锁，也就是说同一个锁对读和写的上锁方式是不一样的，写锁的互斥性更高。</p>
<p>ReadWriteLock 提供了<em>读写之间不同互斥策略</em>的锁。因此，当程序有频繁的读操作时，他能够带来更好的性能</p>
<p>由于读写控制的策略不一样，带来了锁内部的复杂度。所以如果程序的读操作并没有达到一定数量，使用读写锁会比互斥锁性能更差</p>
<p>如下为读写锁的继承关系：</p>
<p><img src="http://cdn.ziyedy.top/Java12-2%EF%BC%9A%E9%94%81%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E4%B8%8E%E5%AE%9E%E7%8E%B0/ReadWriteLock%E5%AE%9E%E7%8E%B0.jpg" alt=""></p>
<h3 id="锁降级与锁升级"><a href="#锁降级与锁升级" class="headerlink" title="锁降级与锁升级"></a>锁降级与锁升级</h3><ul>
<li><p>锁降级：如果线程持有写锁，如果可以在不释放写锁的情况下，获取读锁，这就是锁降级。</p>
<p><strong>ReadWriteLock 支持锁降级</strong>，如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ReadWriteLock lock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>Lock readLock = lock.readLock();<br>Lock writeLock = lock.writeLock();<br><br>writeLock.lock();<br>System.out.println(<span class="hljs-string">"got the write lock"</span>);	<span class="hljs-comment">// 成功输出</span><br>readLock.lock();<br>System.out.println(<span class="hljs-string">"got the read lock"</span>);	<span class="hljs-comment">// 成功输出</span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>锁升级：如果线程持有读锁，能够直接获取写锁。这意味着从一个低级别的锁升级到高级别的锁，其实就是变相的插队，无视其它在排队等待写锁的线程。</p>
<p><strong>ReadWriteLock 并不支持锁升级</strong>，如下：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ReadWriteLock lock = <span class="hljs-keyword">new</span> ReentrantReadWriteLock();<br>Lock readLock = lock.readLock();<br>Lock writeLock = lock.writeLock();<br><br>readLock.lock();<br>System.out.println(<span class="hljs-string">"got the read lock"</span>);	<span class="hljs-comment">// 成功输出</span><br>writeLock.lock();<br>System.out.println(<span class="hljs-string">"got the write lock"</span>);	<span class="hljs-comment">// 未输出</span><br></code></pre></td></tr></table></figure>



<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p><a href="https://www.cnblogs.com/three-fighter/p/14396208.html" target="_blank" rel="noopener">https://www.cnblogs.com/three-fighter/p/14396208.html</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>Java12：多线程与并发编程</title>
    <url>/page/Java12-multithread-concurrency.html</url>
    <content><![CDATA[<h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>Thread类是Java提供的线程顶级类，继承Thread类可快速定义线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 线程体，线程要完成的任务，要执行的代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><p>实现Runnable接口，作为参数传递给Thread构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 线程体，线程要执行的任务</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h3><p>使用Runnable接口更好</p>
<ul>
<li>Java不支持双继承，如果继承Thread会降低其拓展性</li>
<li>从代码架构来说：使用Runnable能够解耦合（线程控制逻辑在Thread类中，业务运行逻辑在Runnable实现类中），并且实现Runnable的实例，可以被多个线程共享并执行</li>
<li>新建线程的损耗：使用Runnable只需要传入target，不需要反复创建与销毁线程</li>
</ul>
<h2 id="线程启动"><a href="#线程启动" class="headerlink" title="线程启动"></a>线程启动</h2><blockquote>
<p>调用start方法才是真正开始了一个线程的周期，而调用run方法则只是调用一个普通的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">MyThread myThread = <span class="hljs-keyword">new</span> MyThread();<br>myThread.run();		<span class="hljs-comment">// 未启动线程，只是调用了myThread实例的run方法</span><br>myThread.start();	<span class="hljs-comment">// 启动线程</span><br></code></pre></td></tr></table></figure>

<h3 id="Thread中start方法源码分析"><a href="#Thread中start方法源码分析" class="headerlink" title="Thread中start方法源码分析"></a>Thread中start方法源码分析</h3><p>start方法调用start0（start0是一个native方法，也称为JNI（Java Native Interface）方法），而start0方法在JVM中会调用run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 检查线程的状态，判断是否可以启动</span><br>    <span class="hljs-keyword">if</span> (threadStatus != <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>    <br>    <span class="hljs-comment">// 把线程加入到线程group中</span><br>    group.add(<span class="hljs-keyword">this</span>);<br><br>    <span class="hljs-comment">// 调用了start0()方法</span><br>    <span class="hljs-keyword">boolean</span> started = <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        start0();<br>        started = <span class="hljs-keyword">true</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (!started) &#123;<br>                group.threadStartFailed(<span class="hljs-keyword">this</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start0</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>

<p>而run方法则会先判断target是否为空（target即为传入的Runnable对象），因此当传入Runnable对象后，该Thread类所执行的代码是传入的Runnable对象的run方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Runnable target;	<span class="hljs-comment">// 传入的 Runnable</span><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 判断如果target不为空，则执行传入的target中的逻辑</span><br>    <span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span>) &#123;<br>        target.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如下，<code>start</code>方法执行总结如下：</p>
<p><img src="http://cdn.ziyedy.top/Java12%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/start%E6%96%B9%E6%B3%95.jpg" alt=""></p>
<h2 id="线程生命周期"><a href="#线程生命周期" class="headerlink" title="线程生命周期"></a>线程生命周期</h2><ul>
<li><strong>New状态</strong>：当一个 Thread 对象刚刚被创建时，状态为 NEW，此时与其他 Java 对象没有什么不同</li>
<li><strong>RUNNABLE状态</strong>：调用 <code>start</code> 方法后即进入 RUNNABLE 状态</li>
<li><strong>RUNNING状态</strong>：该状态得到CPU分配时即进入RUNNING状态</li>
<li><strong>BLOCKED状态</strong>：包括Blocked（被阻塞）、Waiting（等待）、Time_waiting（计时等待）等等</li>
<li><strong>TERMINATED状态</strong>：线程的终止状态，意味着线程的生命周期已经走完</li>
</ul>
<h3 id="线程状态的转换"><a href="#线程状态的转换" class="headerlink" title="线程状态的转换"></a>线程状态的转换</h3><p><img src="http://cdn.ziyedy.top/Java12%EF%BC%9A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt=""></p>
<h2 id="Thread类常用方法"><a href="#Thread类常用方法" class="headerlink" title="Thread类常用方法"></a>Thread类常用方法</h2><h3 id="currentThread-及线程对象常用方法"><a href="#currentThread-及线程对象常用方法" class="headerlink" title="currentThread()及线程对象常用方法"></a>currentThread()及线程对象常用方法</h3><p>该方法返回的是代码实际运行时候的<strong>线程对象实例</strong></p>
<p><em>注：由于同一段代码可能被不同线程执行，因此当前线程是相对的</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Thread.currentThread();					    <span class="hljs-comment">// 获取当前线程</span><br>Thread.currentThread().getName();		    <span class="hljs-comment">// 获取当前线程名称</span><br>Thread.currentThread().setName(线程名称);	 <span class="hljs-comment">// 设置线程名称</span><br>Thread.currentThread().isAlive();			<span class="hljs-comment">// 判断当前线程是否处于活动状态</span><br>Thread.currentThread().getId();				<span class="hljs-comment">// 获得线程的唯一标识</span><br></code></pre></td></tr></table></figure>

<h3 id="join-——阻塞线程（插队）"><a href="#join-——阻塞线程（插队）" class="headerlink" title="join()——阻塞线程（插队）"></a>join()——阻塞线程（插队）</h3><p><code>t.join()</code>方法是阻塞调用此方法的线程进入<code>Timed_Waited</code>状态，直到线程t完成，此线程再继续。因此，<strong>join()方法是阻塞别的线程，让自己先运行</strong>，也就是插队</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">MyThread myThread = <span class="hljs-keyword">new</span> MyThread();<br><span class="hljs-comment">/**		启动线程	**/</span><br>myThread.join();	<span class="hljs-comment">// 先执行完myThread再执行其他</span><br></code></pre></td></tr></table></figure>

<h3 id="sleep-——让线程休眠"><a href="#sleep-——让线程休眠" class="headerlink" title="sleep()——让线程休眠"></a>sleep()——让线程休眠</h3><p>使当前线程（即调用<code>Thread.currentThread()</code>返回的线程）休眠指定的毫秒数</p>
<p>但在这段时间内，该线程持有的 monitor 锁并不会被放弃（所占有的资源并不会交还）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Thread.sleep(<span class="hljs-number">10</span>);	<span class="hljs-comment">// 休眠10毫秒</span><br></code></pre></td></tr></table></figure>

<h3 id="yield-——礼让线程"><a href="#yield-——礼让线程" class="headerlink" title="yield()——礼让线程"></a>yield()——礼让线程</h3><p>让当前正在执行线程暂停（即让出CPU资源），不是阻塞线程，而是将线程转入就绪（RUNNABLE）状态。</p>
<p>如果调用了yield方法之后，没有其他等待执行的线程，这个时候当前线程就会马上恢复执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Thread.yield();<br></code></pre></td></tr></table></figure>

<h3 id="设置线程优先级"><a href="#设置线程优先级" class="headerlink" title="设置线程优先级"></a>设置线程优先级</h3><p>用于设置/获得线程的优先级（所谓优先级只是获得CPU资源的<em>概率</em>），默认为5，最高为10，最低为1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPriority</span><span class="hljs-params">()</span></span>;	<span class="hljs-comment">// 获取线程优先级</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPriority</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newPriority)</span></span>;	<span class="hljs-comment">// 设置线程优先级</span><br></code></pre></td></tr></table></figure>

<h3 id="setDaemon-——设置守护线程"><a href="#setDaemon-——设置守护线程" class="headerlink" title="setDaemon()——设置守护线程"></a>setDaemon()——设置守护线程</h3><p>守护线程即在后台运行的线程，比如JVM中的垃圾清理就是守护线程执行</p>
<p>当 JVM 中没有任何一个非守护线程时，所有的守护线程都会进入到 TERMINATED 状态，此时JVM 退出</p>
<p>可以将指定的线程设置成后台线程，创建后台线程的线程结束时，后台线程也随之消亡。</p>
<p><em>只能在线程启动（即 start 方法调用前）之前把它设为后台线程</em></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Thread t = <span class="hljs-keyword">new</span> Thread();<br>t.setDaemon(<span class="hljs-keyword">true</span>);<br>t.start();<br></code></pre></td></tr></table></figure>

<h3 id="interrupt-——中断"><a href="#interrupt-——中断" class="headerlink" title="interrupt()——中断"></a>interrupt()——中断</h3><p>并不是中断线程，而是让可中断方法（如sleep）中断</p>
<p>一旦调用了 interrupt 方法，那么在不进行处理的情况下，线程的 interrupted 状态会一直为 ture</p>
<h2 id="其他线程控制方法"><a href="#其他线程控制方法" class="headerlink" title="其他线程控制方法"></a>其他线程控制方法</h2><h3 id="wait-notify"><a href="#wait-notify" class="headerlink" title="wait/notify"></a>wait/notify</h3><p>这两类方法不在Thread上，而是在Object类中，所有Java类都会继承这两类方法</p>
<ul>
<li>调用 <code>wait</code>方法：原本 RUNNING 的线程，进入 BLOCKING 状态，此线程会放弃原来持有的锁</li>
<li>调用 <code>notify</code> 方法：唤醒 wait 的线程，让其继续往下执行</li>
</ul>
<p>方法 <code>wait()</code> 的作用是使当前执行代码的线程进行等待， <strong><code>wait()</code> 方法只能在同步方法中或同步块中调用</strong>， <code>wait()</code> 方法执行后，当前线程释放锁，线程与其他线程竞争重新获取锁</p>
<p>方法 <code>notify()</code> 也要在同步方法或同步块中调用，该方法是用来通知那些可能等待该对象的对象锁的其他线程，对其发出通知notify，并使进入就绪态，等待获取锁。如果有多个线程等待，则有线程规划器随机挑选出一个呈wait状态的线程。在notify()方法后，当前线程不会马上释放该对象锁，要等到执行notify()方法的线程将程序执行完，也就是退出同步代码块中</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>利用独立级联模型求解影响力最大的点</title>
    <url>/page/ic.html</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定750个点以及点与点之间的感染概率，并且感染过程符合独立级联（IC）模型以及一次感染的要求，求解在该点集中影响力最大的top5个点与top10个点</p>
<h2 id="原理介绍"><a href="#原理介绍" class="headerlink" title="原理介绍"></a>原理介绍</h2><p>给定的数据其实可以归纳为一个有向有权图结构，而整个问题也就可以抽象为一个有向有权图中求影响力最大的问题，也就是“影响力最大化”问题，该问题在本题中可以归纳为给定节点个数k，选择出k个节点作为种子集使得种子集能影响的节点数最多。</p>
<p>而解决这类问题最主要的就是确定传播模型，传播模型中比较经典的有独立级联（IC）模型与线性阈值（LT）模型，由于本题直接指定了传播模型，因此解决问题的关键原理其实也就集中到了独立级联（IC）模型的介绍上。</p>
<p>独立级联模型是一种概率型的传播模型，英文全称为Independent Cascade Model，其基本原理的描述如下：</p>
<p>在有向有权图G（V，E）中，点集V中的节点具有两种状态，即激活状态与待激活状态。初始状态下，处于激活状态的节点会以一定概率（这种概率就是其边集E所带的权值决定）将与其相连的处于待激活状态状态下的节点激活。</p>
<p>整个过程可以归纳如下：</p>
<p>1、首先，在初始状态下，即t=0时，有且仅有种子集合S（也可以按照顺序将各个点作为种子集合）中的节点全部被设置为激活状态。</p>
<p>2、之后，当t=k时，所有在t=k-1时由待激活状态转变为激活状态态的全部节点，以一定的概率去尝试影响它们所有处于待激活态的邻节点。</p>
<p>3、不断重复过程2，直到整个网络中所剩余的具备激活其他节点能力的节点数为0（即待激活节点为0），传播过程结束。</p>
<h2 id="实验思路与过程"><a href="#实验思路与过程" class="headerlink" title="实验思路与过程"></a>实验思路与过程</h2><h3 id="1、读入数据，得到图的邻接矩阵"><a href="#1、读入数据，得到图的邻接矩阵" class="headerlink" title="1、读入数据，得到图的邻接矩阵"></a>1、读入数据，得到图的邻接矩阵</h3><p>该步骤主要完成数据的加载以及图的邻接矩阵的初始化，使用numpy中的相应函数完成即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_graph</span><span class="hljs-params">(data)</span>:</span><br>    <span class="hljs-string">"""<br>    通过输入数据生成图的邻接矩阵（感染概率矩阵）<br>    :param data: 输入数据(父节点, 子节点, 感染概率)<br>    :return: 图的邻接矩阵<br>    """</span><br>    num_node = int(data.max())   <span class="hljs-comment"># 节点个数</span><br>    num_line = data.shape[<span class="hljs-number">0</span>]    <span class="hljs-comment"># 数据条数</span><br>    graph = np.zeros((num_node, num_node))<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(num_line):<br>        x, y = int(data[i, <span class="hljs-number">0</span>] - <span class="hljs-number">1</span>), int(data[i, <span class="hljs-number">1</span>] - <span class="hljs-number">1</span>)<br>        graph[x, y] = data[i, <span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">return</span> graph<br><br>data = np.loadtxt(<span class="hljs-string">"DUNF with Weights.txt"</span>)<br>graph = generate_graph(data)<br>print(graph)<br></code></pre></td></tr></table></figure>

<h3 id="2、构建独立级联模型（主要逻辑）"><a href="#2、构建独立级联模型（主要逻辑）" class="headerlink" title="2、构建独立级联模型（主要逻辑）"></a>2、构建独立级联模型（主要逻辑）</h3><p>该步骤主要完成整个模型的逻辑编写。在实现中，我将整个过程封装成立一个类，而独立级联模型等等要用到的逻辑代码则作为类中的私有函数，其中逻辑上主要可以分为模拟爆发与增量计算两个过程。</p>
<p>模拟爆发则是在实现单个点的独立级联传播函数的基础上对所有点进行多次模拟，采用了一定蒙特卡洛算法的思想，假设感染概率为0.3，则生成一个0到1的随机数，若该随机数大于0.3则未能通过传播，若该随机数小于0.3，则通过了传播，以此进行多次模拟（本题我分别使用100000次实验了三次，使用500000次实验了一次），得到了一个到达概率矩阵（以矩阵坐标举例，即横坐标的点传播到纵坐标的点的概率）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ICModel</span>:</span><br>    <span class="hljs-string">"""<br>    独立级联模型类<br>    """</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, graph)</span>:</span><br>        <span class="hljs-string">"""<br>        :param graph: 感染概率矩阵<br>        """</span><br>        <span class="hljs-comment"># 邻接矩阵（感染概率矩阵）</span><br>        self.graph = graph<br>        <span class="hljs-comment"># 节点的个数</span><br>        self.num_node = graph.shape[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment"># 到达概率矩阵</span><br>        self.influence_matrix = np.zeros_like(graph)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_ic_process</span><span class="hljs-params">(self, actived_node)</span>:</span><br>        <span class="hljs-string">"""<br>        实现独立级联过程<br>        :param actived_node: 初始激活点<br>        """</span><br>        self.influence_matrix[actived_node, actived_node] += <span class="hljs-number">1</span><br>        actived_new = [actived_node]<br>        actived_set = [actived_node]<br>        <span class="hljs-comment"># 进行类似于广度优先搜索的过程</span><br>        <span class="hljs-keyword">while</span> actived_new:<br>            <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> actived_new:<br>                actived_new.remove(node)<br>                p = np.random.uniform(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)     <span class="hljs-comment"># 生成[0, 1)的随机数</span><br>                news = np.where(self.graph[node] &gt; p)[<span class="hljs-number">0</span>].tolist()   <span class="hljs-comment"># 找到通过的节点</span><br>                <span class="hljs-keyword">for</span> new <span class="hljs-keyword">in</span> news:<br>                    <span class="hljs-comment"># 防止多次感染</span><br>                    <span class="hljs-keyword">if</span> new <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> actived_set:<br>                        actived_new.append(new)<br>                        actived_set.append(new)<br>                        self.influence_matrix[actived_node, new] += <span class="hljs-number">1</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_caculate_increase_matrix</span><span class="hljs-params">(self, m1, m2)</span>:</span><br>        <span class="hljs-string">"""<br>        计算增量矩阵<br>        :return: 增量矩阵<br>        """</span><br>        res = m1 - m2<br>        res[res &lt; <span class="hljs-number">0</span>] = <span class="hljs-number">0</span><br>        <span class="hljs-keyword">return</span> res<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_increase</span><span class="hljs-params">(self)</span>:</span><br>        <span class="hljs-string">"""<br>        计算增量过程<br>        :return: 影响力最大的10个点<br>        """</span><br>        result = []<br>        <span class="hljs-comment"># 按行求和找到影响力最大的点，并作为搜索起始点</span><br>        best_node = np.argmax(self.influence_matrix.sum(axis=<span class="hljs-number">1</span>))<br>        best_row = self.influence_matrix[best_node]<br>        <span class="hljs-comment"># 将影响力最大的点加入（不要忘了加1）</span><br>        result.append(best_node + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">9</span>):<br>            increase_matrix = self._caculate_increase_matrix(self.influence_matrix, best_row)<br>            best_node = np.argmax(increase_matrix.sum(axis=<span class="hljs-number">1</span>))<br>            best_row = np.maximum(self.influence_matrix[best_node], best_row)<br>            result.append(best_node + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> result<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(self, times)</span>:</span><br>        <span class="hljs-string">"""<br>        向外的接口，用于运行整个搜索最大影响力点的过程<br>        :param times: 模拟爆发的次数<br>        :return: 到达概率矩阵, 影响力最大的十个点<br>        """</span><br>        <span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> range(self.num_node):<br>            <span class="hljs-comment"># 显示运行进度</span><br>            <span class="hljs-keyword">if</span> node % <span class="hljs-number">50</span> == <span class="hljs-number">0</span>:<br>                print(<span class="hljs-string">'The node\'s number: &#123;&#125;'</span>.format(node))    <br>            <span class="hljs-keyword">for</span> time <span class="hljs-keyword">in</span> range(times):<br>                self._ic_process(node)<br>        self.influence_matrix /= times<br>        result = self._increase()<br>        <span class="hljs-keyword">return</span> self.influence_matrix, result<br></code></pre></td></tr></table></figure>

<h3 id="3、开始搜索"><a href="#3、开始搜索" class="headerlink" title="3、开始搜索"></a>3、开始搜索</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">ic = ICModel(graph)<br>influence_matrix, result = ic.run(<span class="hljs-number">100000</span>)<br></code></pre></td></tr></table></figure>

<h2 id="实验结果与分析"><a href="#实验结果与分析" class="headerlink" title="实验结果与分析"></a>实验结果与分析</h2><h3 id="可视化分析"><a href="#可视化分析" class="headerlink" title="可视化分析"></a>可视化分析</h3><p>使用Python中的networkx包进行可视化分析，networkx包是一种专门用来处理图结构数据的包，因此能够很轻松的实现可视化等操作，相关代码及结果如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> networkx <span class="hljs-keyword">as</span> nx<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>G = nx.DiGraph()<br>G.add_weighted_edges_from(data)<br>node_color_map = []<br>node_size_map = []<br><span class="hljs-comment"># 给节点赋颜色与大小</span><br><span class="hljs-keyword">for</span> node <span class="hljs-keyword">in</span> G:<br>    <span class="hljs-keyword">if</span> node <span class="hljs-keyword">in</span> result:<br>        node_color_map.append(<span class="hljs-string">'red'</span>)<br>        node_size_map.append(<span class="hljs-number">50</span>)<br>    <span class="hljs-keyword">else</span>:<br>        node_color_map.append(<span class="hljs-string">'green'</span>)<br>        node_size_map.append(<span class="hljs-number">5</span>)<br>nx.draw(G, node_size=node_size_map, node_color=node_color_map, width=<span class="hljs-number">0.5</span>)<br>plt.show()<br></code></pre></td></tr></table></figure>

<p><img src="http://cdn.ziyedy.top/%E5%BD%B1%E5%93%8D%E5%8A%9B%E5%8F%AF%E8%A7%86%E5%8C%96.png" alt=""></p>
<p>由上图可视化结果，其中绿色的点为普通的节点，而红色的节点为求出的影响力最大的十个点，从图中可以很明显的看出红色的节点基本处于整个网络中比较密集的区域（也就是其出度通常都较大），与“影响力”这个要求还是比较吻合的</p>
]]></content>
      <categories>
        <category>AI相关</category>
      </categories>
      <tags>
        <tag>智能算法</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis使用方法总结</title>
    <url>/page/mybatis-basic-summary.html</url>
    <content><![CDATA[<h2 id="mybatis框架概述"><a href="#mybatis框架概述" class="headerlink" title="mybatis框架概述"></a>mybatis框架概述</h2><p>MyBatis 本是 apache 的一个开源项目，主要用于减轻使用 JDBC 的复杂性（如JDBC中每次使用都需要重复创建一些对象，同时需要手动关闭连接以及手动实现ORM），同时可以将Java代码与sql语句分离，减小代码的耦合度。</p>
<p>MyBatis的使用可以参考其官方文档： <a href="https://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">https://mybatis.org/mybatis-3/zh/index.html</a></p>
<h3 id="mybatis完成的主要工作"><a href="#mybatis完成的主要工作" class="headerlink" title="mybatis完成的主要工作"></a>mybatis完成的主要工作</h3><ul>
<li>注册数据库的驱动，即<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></li>
<li>创建 JDBC 中必须的 <code>Connection</code> 、<code>Statement</code>、 <code>ResultSet</code> 等对象</li>
<li>从xml文件中获取相应sql，并执行sql语句，将 ResultSet 结果转化为 Java 对象</li>
<li>关闭资源</li>
</ul>
<h2 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a>基本使用步骤</h2><h3 id="0、实验数据库"><a href="#0、实验数据库" class="headerlink" title="0、实验数据库"></a>0、实验数据库</h3><p>实验数据表 student 的基本字段如下：</p>
<p><img src="http://cdn.ziyedy.top/MyBatis%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/%E5%BB%BA%E6%B5%8B%E8%AF%95%E8%A1%A8.png" alt=""></p>
<h3 id="1、创建实体类"><a href="#1、创建实体类" class="headerlink" title="1、创建实体类"></a>1、创建实体类</h3><p>类中属性名与列名需要保持一致</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2、创建dao接口"><a href="#2、创建dao接口" class="headerlink" title="2、创建dao接口"></a>2、创建dao接口</h3><p>定义操作数据库的方法，用于对应mapper映射文件中的sql语句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentDao</span> </span>&#123;<br>    <span class="hljs-function">Student <span class="hljs-title">selectStudentById</span><span class="hljs-params">(Integer id)</span></span>;	<span class="hljs-comment">// 定义需要处理数据库的方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">insertStudent</span><span class="hljs-params">(Student student)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3、创建mapper映射文件"><a href="#3、创建mapper映射文件" class="headerlink" title="3、创建mapper映射文件"></a>3、创建mapper映射文件</h3><p>在dao接口的同目录下创建xml文件（mapper映射文件），名称与对应dao接口一致，<strong>用于编写对应dao接口中方法的sql语句</strong></p>
<ul>
<li><p>其中根目录 <code>&lt;mapper&gt;</code> 中的属性 <code>namespace</code> 通常设置为对应 dao 接口的全限定名称</p>
</li>
<li><p><code>&lt;mapper&gt;</code> 下可以使用 <code>&lt;insert&gt;</code> <code>&lt;update&gt;</code> <code>&lt;delete&gt;</code> <code>&lt;select&gt;</code>等标签，分别对应于sql语句中的相应子句，其中以 select 为例，其 id 属性用于唯一标识该标签内容，resultType 属性用于标识返回值类型，通常是实体类的全限定名</p>
</li>
<li><p>传入的参数可使用 <code>#{}</code> 占位符的方式用在标签内的 sql 语句中</p>
</li>
</ul>
<p><em>注意：<code>&lt;select&gt;</code> 等标签中的 <code>id</code> 值需要与 dao 接口中定义的方法名一致，这样mybatis就可以使用反射等机制自动创建 dao 接口的相应实现类。</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span><br>        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span><br>        <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"org.example.dao.StudentDao"</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 编写 sql 语句 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectStudentById"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.Student"</span>&gt;</span><br>        select id, name, age, email from student where id=#&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"insertStudent"</span>&gt;</span><br>        insert into student value(#&#123;id&#125;, #&#123;name&#125;, #&#123;age&#125;, #&#123;email&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="4、创建mybatis主配置文件"><a href="#4、创建mybatis主配置文件" class="headerlink" title="4、创建mybatis主配置文件"></a>4、创建mybatis主配置文件</h3><p>创建mybatis的主配置文件，放置在resources目录下。</p>
<p>主要用于配置mybatis相关的内容，比如日志、连接数据库所必要的一些信息</p>
<p><em>此处配置了 logImpl 日志用于实验结果的展示</em></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span><br>        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span><br>        <span class="hljs-meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 使用日志，方便掌握运行结果 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"logImpl"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"STDOUT_LOGGING"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">"development"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"development"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"JDBC"</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!-- 创建Connection对象，用于连接数据库 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"POOLED"</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"driver"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"com.mysql.jdbc.Driver"</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"url"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"jdbc:mysql://localhost:3306/mybatis?useUnicode=true<span class="hljs-symbol">&amp;amp;</span>characterEncoding=utf-8"</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"username"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"root"</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"shagds139"</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">"org/example/dao/StudentDao.xml"</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="5、基本使用"><a href="#5、基本使用" class="headerlink" title="5、基本使用"></a>5、基本使用</h3><ul>
<li><code>Resources</code> 类：用于读取资源文件（加载解析mybatis主配置文件），返回的是IO流</li>
<li><code>SqlSessionFactoryBuilder</code>类：调用其 <code>build()</code> 方法可完成 <code>SqlSessionFactory</code> 的创建</li>
<li><code>SqlSessionFactory</code>接口：是一个重量级对象，且为线程安全的，因此一个应用只需要一个该对象，可使用<code>openSession()</code>方法创建 <code>SqlSession</code> 对象，默认该方法传入的参数为 false（手动提交），传入参数为 true 时，即<code>openSession(true)</code>，为自动提交事务</li>
<li><code>SqlSession</code> 接口：用于执行持久化操作，一个 <code>SqlSession</code> 对应一次数据库会话，其提供了大量的执行 sql 语句的方法<ul>
<li>selectOne：执行select语句，最多得到一行记录</li>
<li>selectList：执行select语句，返回多行数据</li>
<li>insert：执行insert语句</li>
<li>update：执行update语句</li>
<li>delete：执行delete语句</li>
<li>commit：提交事务</li>
<li>rollback：回滚事务</li>
</ul>
</li>
</ul>
<p>基本使用流程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsert</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    String config = <span class="hljs-string">"mybatis.xml"</span>;<br>    InputStream inputStream = Resources.getResourceAsStream(config);	<span class="hljs-comment">// 读取配置文件</span><br>    SqlSessionFactory factory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<br>    SqlSession session = factory.openSession();<br>    String sqlId = <span class="hljs-string">"org.example.dao.StudentDao.insertStudent"</span>;	<span class="hljs-comment">// mapper文件中对应的sql语句</span><br><br>    Student newStudent = <span class="hljs-keyword">new</span> Student(<span class="hljs-number">1002</span>, <span class="hljs-string">"wuli"</span>, <span class="hljs-number">10</span>, <span class="hljs-string">"wuli@qq.com"</span>);<br>    <span class="hljs-keyword">int</span> row = session.insert(sqlId, newStudent);	<span class="hljs-comment">// 执行对应sql语句</span><br><br>    <span class="hljs-comment">// mybatis默认执行sql语句是手动提交事务模式</span><br>    <span class="hljs-comment">// insert后需要手动提交事务</span><br>    session.commit();<br><br>    session.close();<br>&#125;<br></code></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="http://cdn.ziyedy.top/MyBatis%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/update%E6%89%A7%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt=""></p>
<h3 id="6、使用Dao代理"><a href="#6、使用Dao代理" class="headerlink" title="6、使用Dao代理"></a>6、使用Dao代理</h3><p>根据上述步骤，由于 dao 接口中的方法名与 mapper映射文件中的 对应的 id 是一致的，因此mybatis可以通过相关的信息自动帮助生成dao接口的实现类，获取该实现类的方法为 <code>session.getMapper(StudentDao.class);</code>，之后只需要执行对应的方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testProxy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    String config = <span class="hljs-string">"mybatis.xml"</span>;<br>    InputStream inputStream = Resources.getResourceAsStream(config);<br>    SqlSessionFactory factory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<br>    SqlSession session = factory.openSession();<br><br>    StudentDao dao = session.getMapper(StudentDao<span class="hljs-class">.<span class="hljs-keyword">class</span>)</span>;	<span class="hljs-comment">// 获取实现类</span><br>    dao.selectByIdOrName(<span class="hljs-number">1</span>, <span class="hljs-string">"dddy"</span>);	<span class="hljs-comment">// 执行 dao 接口中对应的方法</span><br>    <br>    session.close();<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="传入参数使用"><a href="#传入参数使用" class="headerlink" title="传入参数使用"></a>传入参数使用</h2><p>参数主要是指dao接口方法的形参，用于<strong>通过Java程序将数据传入到mapper文件中的sql语句</strong>中</p>
<h3 id="传入单个简单类型参数"><a href="#传入单个简单类型参数" class="headerlink" title="传入单个简单类型参数"></a>传入单个简单类型参数</h3><p>简单类型指：Java基本类型与String对象</p>
<p>此时使用占位符 <code>#{任意字符}</code> 即可使用，与<strong>对应方法形参名无关</strong>。如上一节中相关的示例</p>
<h3 id="传入多个简单类型参数"><a href="#传入多个简单类型参数" class="headerlink" title="传入多个简单类型参数"></a>传入多个简单类型参数</h3><h4 id="1、使用-Param注解"><a href="#1、使用-Param注解" class="headerlink" title="1、使用@Param注解"></a>1、使用@Param注解</h4><p>@Param：该注解为mybatis提供，放置在形参的前面，其value为自定义参数的名称，该名称在mapper文件中可作为该形参的对应标识。如下中<code>#{id}</code>即代表形参<code>Integer id</code>。</p>
<p>dao接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">selectByIdOrName</span><span class="hljs-params">(@Param(<span class="hljs-string">"id"</span>)</span> Integer id,<br>                               @<span class="hljs-title">Param</span><span class="hljs-params">(<span class="hljs-string">"name"</span>)</span> String name)</span>;<br></code></pre></td></tr></table></figure>

<p>mapper文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectByIdOrName"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.Student"</span>&gt;</span><br>    select id, name, age, email from student where id=#&#123;id&#125; or name =#&#123;name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="2、根据形参位置"><a href="#2、根据形参位置" class="headerlink" title="2、根据形参位置"></a>2、根据形参位置</h4><p>参数位置： dao接口中方法的形参列表，从左往右，参数位置是 0，1，2 依此类推</p>
<p>语法格式：<code>#{arg0}</code>表示位置0的参数，<code>#{arg1}</code>表示位置1的参数</p>
<p>dao接口的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">selectByIdOrName</span><span class="hljs-params">(Integer id, String name)</span></span>;<br></code></pre></td></tr></table></figure>

<p>mapper文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectByIdOrName"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.Student"</span>&gt;</span><br>    select id, name, age, email from student where id=#&#123;arg0&#125; or name =#&#123;arg1&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="传入对象"><a href="#传入对象" class="headerlink" title="传入对象"></a>传入对象</h3><p>即dao方法形参为一个Java对象，该Java对象可以表示多个参数，通过<code>#{对象成员变量名}</code>可以直接使用</p>
<p>定义用于传参的Java对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueryParam</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Object p1;<br>    <span class="hljs-keyword">private</span> Object p2;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>dao接口的方法定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">selectByQueryParam</span><span class="hljs-params">(QueryParam param)</span></span>;<br></code></pre></td></tr></table></figure>

<p>mapper文件（通过直接使用 <code>#{p1}</code> 来获取 <code>QueryParam</code>对象中的 p1 属性）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 简写版，mybatis 自动进行 ORM --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectByQueryParam"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.Student"</span>&gt;</span><br>     select * from student where name=#&#123;p1&#125; or age=#&#123;p2&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 完整版，指定类型映射 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectByQueryParam"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.Student"</span>&gt;</span><br>    select * from student where<br>    name=#&#123;name, javaType=java.lang.String, jdbcType=VARCHAR&#125;<br>    or<br>    age=#&#123;age, javaType=java.lang.Integer, jdbcType=INTEGER&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="传入Map"><a href="#传入Map" class="headerlink" title="传入Map"></a>传入Map</h3><p>使用Map作为 dao 接口对应方法的参数，并且在 mapper 文件中使用 <code>#{key}</code>，通过 key 获取对应的 value 值。</p>
<p>dao接口方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">selectStudentByMap</span><span class="hljs-params">(Map&lt;String, Object&gt; map)</span></span>;<br></code></pre></td></tr></table></figure>

<p>mapper文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectStudentByMap"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.Student"</span>&gt;</span><br>     select * from student where name=#&#123;name&#125; or age=#&#123;age&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>核心方法调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;String,Object&gt; data = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>data.put(<span class="hljs-string">"name"</span>, <span class="hljs-string">"李思思"</span>);<br>data.put(<span class="hljs-string">"age"</span>, <span class="hljs-number">20</span>);<br><br>List&lt;Student&gt; students = dao.selectStudentByMap(data);	<span class="hljs-comment">// 传入map调用相应方法</span><br></code></pre></td></tr></table></figure>

<h3 id="与-占位符的区别"><a href="#与-占位符的区别" class="headerlink" title="# 与 $ 占位符的区别"></a># 与 $ 占位符的区别</h3><ul>
<li>#为占位符，表示该处用实际的参数值替代。即使用 <code>PrepareStatement</code> 对象执行 sql 语句，使用 <code>#{}</code> 代替 sql 语句中的 ?</li>
<li>$为字符串替换，即表示该处使用${}中包含的“字符串”替换其所在位置，即使用 <code>Statement</code> 将sql语句和<code>${}</code>中的字符串连接**起来</li>
</ul>
<h2 id="mapper文件常用标签"><a href="#mapper文件常用标签" class="headerlink" title="mapper文件常用标签"></a>mapper文件常用标签</h2><blockquote>
<p>mybatis框架提供的标签，可以实现<strong>同一个dao的方法， 根据不同的条件可以表示不同的sql语句</strong></p>
</blockquote>
<h3 id="if-标签"><a href="#if-标签" class="headerlink" title="if 标签"></a>if 标签</h3><p>当<code>&lt;if&gt;</code>标签中的值为true时，会将其包含的sql语句<strong>拼接</strong>到其所在的sql语句中。因此需要进行一些特殊处理避免拼接导致的sql语句出错（比如where后无条件或者多了or或and等关键字等情况）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 语法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"boolean判断结果"</span>&gt;</span><br>    sql语句<br><span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 示例 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectIf"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.Student"</span>&gt;</span><br>    select * from student<br>    where 1=1<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"name!=null and name!=''"</span>&gt;</span><br>       and name=#&#123;name&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="where-标签"><a href="#where-标签" class="headerlink" title="where 标签"></a>where 标签</h3><p><code>if</code>标签需要在 where 子句后手动添加一个 <code>1==1</code> 的永为真的子句（否则若 if 条件全为 false 等情况会出现sql语句中多出where或or等字段的情况造成sql语句执行出错）。因此可以使用 <code>&lt;where&gt;</code> 标签，<strong>当满足查询条件时会自动添加上 where 子句</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 语法 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"条件1"</span>&gt;</span>sql语句1<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    其他动态sql语句<br><span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 示例 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectWhere"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.Student"</span>&gt;</span><br>    select * from student<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"name!=null and name!=''"</span>&gt;</span><br>            or name = #&#123;name&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"age &gt;0"</span>&gt;</span><br>            or age <span class="hljs-symbol">&amp;lt;</span> #&#123;age&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="foreach-标签"><a href="#foreach-标签" class="headerlink" title="foreach 标签"></a>foreach 标签</h3><p>该标签主要用于实现对集合或数组之间的遍历，通常用在sql的 <code>in</code> 子句处，用于实现相应的sql字符串的拼接</p>
<p>如下为手动实现 sql 语句的拼接：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; idList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>idList.add(<span class="hljs-number">1001</span>);<br>idList.add(<span class="hljs-number">1002</span>);<br>idList.add(<span class="hljs-number">1003</span>);<br><br>StringBuffer sql= <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">""</span>);<br>sql.append(<span class="hljs-string">"select * from student where id in "</span>);<br><br>sql.append(<span class="hljs-string">"("</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;idList.size(); i++)&#123;<br>    Integer item  = idList.get(i);	<span class="hljs-comment">// item是集合成员</span><br>    sql.append(item);	<span class="hljs-comment">//添加成员到 sql字符串</span><br>    sql.append(<span class="hljs-string">","</span>); 	<span class="hljs-comment">//集合成员之间的分隔符</span><br>&#125;<br>sql.deleteCharAt( sql.length()-<span class="hljs-number">1</span>) ;<br><br><span class="hljs-comment">//循环之后，加入 )</span><br>sql.append(<span class="hljs-string">")"</span>);<br></code></pre></td></tr></table></figure>

<p>使用 <code>&lt;foreach&gt;</code> 标签的基本语法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 语法 --&gt;</span><br><span class="hljs-tag">&lt; <span class="hljs-attr">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">"集合类型，list表示集合，array表示数组"</span> <br>         <span class="hljs-attr">open</span>=<span class="hljs-string">"循环开始时的字符"</span> <span class="hljs-attr">close</span>=<span class="hljs-string">"循环结束时字符"</span> <br>         <span class="hljs-attr">item</span>=<span class="hljs-string">"用于标识集合中的成员"</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">"集合成员之间的分隔符"</span>&gt;</span><br>    #&#123;item属性定义的值&#125;<br><span class="hljs-tag">&lt;/ <span class="hljs-attr">foreach</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="输入参数为普通类型"><a href="#输入参数为普通类型" class="headerlink" title="输入参数为普通类型"></a>输入参数为普通类型</h4><p>dao 方法定义，输入的参数 为 <code>Integer</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">selectForeach1</span><span class="hljs-params">(List&lt;Integer&gt; idList)</span></span>;<br></code></pre></td></tr></table></figure>

<p>mapper文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectForeach1"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.Student"</span>&gt;</span><br>    select * from student where id in<br>    <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">"list"</span> <span class="hljs-attr">open</span>=<span class="hljs-string">"("</span> <span class="hljs-attr">close</span>=<span class="hljs-string">")"</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">","</span> <span class="hljs-attr">item</span>=<span class="hljs-string">"id"</span> &gt;</span><br>        #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>执行方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; idList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>idList.add(<span class="hljs-number">2</span>);<br>idList.add(<span class="hljs-number">3</span>);<br>idList.add(<span class="hljs-number">4</span>);<br>dao.selectForeach1(idList);<br></code></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="http://cdn.ziyedy.top/MyBatis%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/foreach1.png" alt=""></p>
<h4 id="输入参数为引用类型"><a href="#输入参数为引用类型" class="headerlink" title="输入参数为引用类型"></a>输入参数为引用类型</h4><p>dao方法定义，输入的基本参数为 <code>Student</code>  类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">List&lt;Student&gt; <span class="hljs-title">selectForeach2</span><span class="hljs-params">(List&lt;Student&gt; studentList)</span></span>;<br></code></pre></td></tr></table></figure>

<p>mapper文件：采用了 <code>#{item.id}</code>的写法，表示 <code>Student</code>  中的 <code>id</code> 属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectForeach2"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.Student"</span>&gt;</span><br>    select * from student<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"list != null and list.size &gt; 0"</span>&gt;</span><br>        where id in <br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">"list"</span> <span class="hljs-attr">open</span>=<span class="hljs-string">"("</span> <span class="hljs-attr">close</span>=<span class="hljs-string">")"</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">","</span> <span class="hljs-attr">item</span>=<span class="hljs-string">"item"</span>&gt;</span><br>            #&#123;item.id&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>执行方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Student&gt; stuList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>stuList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-number">1</span>, <span class="hljs-string">"ziye"</span>, <span class="hljs-number">10</span>, <span class="hljs-string">"123"</span>));<br>stuList.add(<span class="hljs-keyword">new</span> Student(<span class="hljs-number">2</span>, <span class="hljs-string">"123"</span>, <span class="hljs-number">11</span>, <span class="hljs-string">"123"</span>));<br>dao.selectForeach2(stuList);<br></code></pre></td></tr></table></figure>

<p>执行结果：</p>
<p><img src="http://cdn.ziyedy.top/MyBatis%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/foreach2.png" alt=""></p>
<h3 id="sql标签"><a href="#sql标签" class="headerlink" title="sql标签"></a>sql标签</h3><p><code>&lt;sql&gt;</code> 标签<strong>标识一段sql语句</strong>，可以在其他位置通过该标签的 <code>id</code> 属性值结合 <code>include</code> 标签实现对其标识的sql语句的复用</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 定义代码片段 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectStudent"</span>&gt;</span><br>    select * from student<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 使用代码片段 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"selectIf"</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">"org.example.Student"</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- select * from student --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">"selectStudent"</span> /&gt;</span><br>    <br>    where 1=1<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">"name!=null and name!=''"</span>&gt;</span><br>       and name=#&#123;name&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
        <category>框架</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础方法与应用</title>
    <url>/page/sklearn-ml.html</url>
    <content><![CDATA[<h2 id="分类：K近邻算法（KNN）"><a href="#分类：K近邻算法（KNN）" class="headerlink" title="分类：K近邻算法（KNN）"></a>分类：K近邻算法（KNN）</h2><h3 id="sklearn使用"><a href="#sklearn使用" class="headerlink" title="sklearn使用"></a>sklearn使用</h3><figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">from sklearn.neighbors <span class="hljs-built_in">import</span> KNeighborsClassifier<br><br><span class="hljs-attr">knn</span> = KNeighborsClassifier(<span class="hljs-attr">n_neighbors=6)</span><br>knn.fit(x_train, y_train)	<span class="hljs-comment"># 进行训练</span><br>knn.score(x_test, y_test)	<span class="hljs-comment"># 获取训练得分</span><br><span class="hljs-attr">y_predict</span> = knn.predict(x_predict)<br></code></pre></td></tr></table></figure>



<h3 id="决策边界"><a href="#决策边界" class="headerlink" title="决策边界"></a>决策边界</h3><h2 id="回归：线性回归"><a href="#回归：线性回归" class="headerlink" title="回归：线性回归"></a>回归：线性回归</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><h3 id="sklearn实现"><a href="#sklearn实现" class="headerlink" title="sklearn实现"></a>sklearn实现</h3><figure class="highlight capnproto"><table><tr><td class="code"><pre><code class="hljs capnproto"><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LinearRegression<br><br>lin_reg = LinearRegression()<br>lin_reg.fit(X_train, Y_train)<br>lin_reg.coef_   <span class="hljs-comment"># 系数矩阵</span><br>lin_reg.intercept_  <span class="hljs-comment"># 截距</span><br></code></pre></td></tr></table></figure>



<p>多项式回归使用线性回归的思路，为原来的样本添加新的特征，原有的特征的多项式组合</p>
<h2 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><h3 id="sklearn使用多项式回归"><a href="#sklearn使用多项式回归" class="headerlink" title="sklearn使用多项式回归"></a>sklearn使用多项式回归</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> PolynomialFeatures<br><br>poly = PolynomialFeatures(degree=<span class="hljs-number">2</span>)  # 指定x的最高维度为<span class="hljs-number">2</span><br>poly.fit(x)<br>x2 = poly.transform(x)  # 输出x^<span class="hljs-number">0</span> x^<span class="hljs-number">1</span> x^<span class="hljs-number">2</span>作为输入线性回归的参数<br></code></pre></td></tr></table></figure>



<h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><figure class="highlight sas"><table><tr><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">from</span> sklearn.pipeline import Pipeline<br><br>poly_reg = Pipeline([<br>    (<span class="hljs-string">"Poly"</span>, PolynomialFeatures(degree=3)),<br>    (<span class="hljs-string">"std_scaler"</span>, StandardScaler()),<br>    (<span class="hljs-string">"lin_reg"</span>, LinearRegressi<span class="hljs-meta">on(</span>))<br>])<br>poly_reg.fit(<span class="hljs-meta">x</span>, y)<br>poly_reg.predict(<span class="hljs-meta">x</span>)<br></code></pre></td></tr></table></figure>







<h2 id="sklearn基本操作"><a href="#sklearn基本操作" class="headerlink" title="sklearn基本操作"></a>sklearn基本操作</h2><h3 id="数据集的获取与创建"><a href="#数据集的获取与创建" class="headerlink" title="数据集的获取与创建"></a>数据集的获取与创建</h3><figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">from sklearn <span class="hljs-built_in">import</span> datasets<br>from sklearn.model_selection <span class="hljs-built_in">import</span> train_test_split<br><br><span class="hljs-comment"># 获取包中自带的数据集，以鸢尾花数据集为例</span><br><span class="hljs-attr">iris</span> = datasets.load_iris()<br><span class="hljs-attr">x</span> = iris.data<br><span class="hljs-attr">y</span> = iris.target<br><br><span class="hljs-comment"># 将数据集分割为测试数据集和训练数据集</span><br><span class="hljs-comment"># 可以传入测试数据集的比例以及一个随机种子</span><br>x_train, x_test, y_train, <span class="hljs-attr">y_test</span> = train_test_split(x, y, <span class="hljs-attr">test_size=0.2,</span> <span class="hljs-attr">random_state=666)</span><br></code></pre></td></tr></table></figure>



<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">from sklearn<span class="hljs-selector-class">.metrics</span> import accuracy_score<br><br><span class="hljs-function"><span class="hljs-title">accuracy_score</span><span class="hljs-params">(y_test, y_predict)</span></span><br></code></pre></td></tr></table></figure>



<h3 id="超参数搜索"><a href="#超参数搜索" class="headerlink" title="超参数搜索"></a>超参数搜索</h3><blockquote>
<p>用于搜索确定获取最优解的超参数</p>
<p>GridSearchCV中的CV指的是交叉验证</p>
</blockquote>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> GridSearchCV<br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br><br># 定义参数的搜索范围<br>param_grid = [<br>    &#123;<br>        <span class="hljs-string">'weights'</span>: [<span class="hljs-string">'uniform'</span>],<br>        <span class="hljs-string">'n_neighbors'</span>: [i for i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)]<br>    &#125;,<br>    &#123;<br>        <span class="hljs-string">'weights'</span>: [<span class="hljs-string">'distance'</span>],<br>        <span class="hljs-string">'n_neighbors'</span>: [i for i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>)],<br>        <span class="hljs-string">'p'</span>: [i for i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>)]<br>    &#125;<br>]<br><br>knn_clf = KNeighborsClassifier()<br><br># 进行网格搜索，n_jobs代表使用核的个数<br>grid_search = GridSearchCV(knn_clf, param_grid, n_jobs=<span class="hljs-number">-1</span>)<br>grid_search.fit(x_train, y_train)<br><br>grid_search.best_estimator_ # 获取最佳分类器<br>grid_search.best_score_     # 获取最佳参数的准确度<br>grid_search.best_params_    # 获取最佳参数<br>knn_clf = grid_search.best_estimator_   # 将最佳分类器赋给原模型<br></code></pre></td></tr></table></figure>



<h3 id="归一化处理"><a href="#归一化处理" class="headerlink" title="归一化处理"></a>归一化处理</h3><blockquote>
<p>即将所有数据映射到同一尺度，包括最值归一化（映射到0-1之间）与均值方差归一化（将所有数据归一到均值为0方差为1的分布中）</p>
<p>对测试数据集进行归一化处理时，通常使用训练数据集的均值与方差等统计数据</p>
</blockquote>
<p>scikit-learn中使用Scaler，实现<em>均值方差归一化</em></p>
<figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">from sklearn.preprocessing <span class="hljs-built_in">import</span> StandardScaler<br><br><span class="hljs-attr">standardScaler</span> = StandardScaler()<br>standardScaler.fit(x_train)<br>standardScaler.mean_    <span class="hljs-comment"># 不是用户传来的变量，而是用户传进去的数据计算出来的变量</span><br>standardScaler.scale_   <span class="hljs-comment"># 得到标准差</span><br><span class="hljs-attr">x_train</span> = standardScaler.transform(x_train)<br><span class="hljs-attr">x_test</span> = standardScaler.transform(x_test)<br></code></pre></td></tr></table></figure>

<p>仿照<code>sklearn</code>中的对应类实现一个均值方差归一化的类。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardScaler</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self)</span>:</span><br>        self.mean_ = <span class="hljs-literal">None</span><br>        self.scale_ = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit</span><span class="hljs-params">(self, X)</span>:</span><br>        <span class="hljs-string">""" 计算X获得数据的均值与标准差 """</span><br>        self.mean_ = np.array([np.mean(X[:, i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(X.shape[<span class="hljs-number">1</span>])])<br>        self.scale_ = np.array([np.std(X[:, i]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(X.shape[<span class="hljs-number">1</span>])])<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transform</span><span class="hljs-params">(self, X)</span>:</span><br>        <span class="hljs-string">""" 将X进行均值方差归一化处理 """</span><br>        res = np.empty(shape=X.shape, dtype=float)<br>        <span class="hljs-keyword">for</span> col <span class="hljs-keyword">in</span> range(X.shape[<span class="hljs-number">1</span>]):<br>            res[:, col] = (X[:, col] - self.mean_[col]) / self.scale_[col]<br>        <span class="hljs-keyword">return</span> res<br></code></pre></td></tr></table></figure>



<h3 id="模型正则化"><a href="#模型正则化" class="headerlink" title="模型正则化"></a>模型正则化</h3><p>导致偏差：对问题本身的定义不正确（选取不相关的特征），欠拟合（线性回归天生高偏差，对数据有极强的假设）</p>
<p>导致方差：数据的扰动会影响，模型太复杂（KNN天生高方差，对数据依赖）</p>
<p>大多数算法具有相应的参数，可以调整偏差与方差</p>
<p>解决高方差：降低模型复杂度、减少数据噪声、增加样本数、实验验证集、模型正则化</p>
<p>模型正则化：限制参数的大小</p>
]]></content>
      <categories>
        <category>AI相关</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title>Normalized Object Coordinate Space for Category-Level 6D Object Pose and Size Estimation</title>
    <url>/page/nocs.html</url>
    <content><![CDATA[<blockquote>
<p>[CVPR 2019]Normalized Object Coordinate Space for Category-Level 6D Object Pose and Size Estimation</p>
<p>论文地址：<a href="https://arxiv.org/abs/1901.02970" target="_blank" rel="noopener">https://arxiv.org/abs/1901.02970</a></p>
<p>GitHub：<a href="https://github.com/hughw19/NOCS_CVPR2019" target="_blank" rel="noopener">https://github.com/hughw19/NOCS_CVPR2019</a></p>
</blockquote>
<h2 id="文章主要内容"><a href="#文章主要内容" class="headerlink" title="文章主要内容"></a>文章主要内容</h2><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>现有的相关6dof姿态估计方法都是instance-level的（即有目标物体的CAD模型作为先验知识）</p>
<p>相关的三维目标检测方法能够得到目标物体的3D边界框，但缺乏精确方向</p>
<h3 id="category-level的6dof姿态估计"><a href="#category-level的6dof姿态估计" class="headerlink" title="category-level的6dof姿态估计"></a>category-level的6dof姿态估计</h3><p>作为严格意义上6dof的类别估计下的<em>第一篇文章</em>，本文对category-level的叙述非常简单易懂，需要解决的核心问题即为<strong>如何对同属一类的不同实例进行统一规范的表示（a shared canonical representation）</strong></p>
<p>面临的主要挑战</p>
<ol>
<li>在特定类别中为不同实例寻找一种能够<strong>统一表示</strong>其<em>6D信息和尺寸信息</em>的表示方法</li>
<li>现有的<strong>数据集</strong>很难作为训练和测试的基准（相关数据集缺乏相关注释，且很多不包含桌面级物体类别）</li>
</ol>
<h3 id="本文的主要贡献"><a href="#本文的主要贡献" class="headerlink" title="本文的主要贡献"></a>本文的主要贡献</h3><p>针对上面两个问题，本文分别提出了相应的解决方案，相应的算法流程如下</p>
<p><img src="http://cdn.ziyedy.top/NOCS/%E6%B5%81%E7%A8%8B.png" alt=""></p>
<h4 id="1、针对对同类物体的统一表示"><a href="#1、针对对同类物体的统一表示" class="headerlink" title="1、针对对同类物体的统一表示"></a>1、针对对同类物体的统一表示</h4><blockquote>
<p>本文提出了一种NOCS的共享空间关系（Normalized Object Coordinate Spac），用于建立物体像素点与NOCS中物体的信息的对应关系</p>
</blockquote>
<p>NOCS是一个三维空间中的单位立方体，对给定的类别将其规范化并“放置”于该立方体当中。</p>
<p><img src="http://cdn.ziyedy.top/NOCS/NOCS.png" alt=""></p>
<p>立方体中每个点存储的是一个3维的RGB信息，我个人认为这种思路与instance-level中的热力图的方法思路很相近，利用一种可视化的思路表示物体的朝向进而表示物体位姿（比如在NOCS中红色表示模型正前方，那么经过网络前向传播输出的NOCS图中红色最”浓“的地方就表示物体的正前方）</p>
<h4 id="2、针对缺乏数据集的问题"><a href="#2、针对缺乏数据集的问题" class="headerlink" title="2、针对缺乏数据集的问题"></a>2、针对缺乏数据集的问题</h4><blockquote>
<p>本文提出了一种CAMERA（Context-Aware MixEd ReAlity）的数据生成方法用于生成数据</p>
<p>模型来源于ShapeNet，同时创建时考虑了图像上下文（即在将模型2D投影嵌入背景前在Unity中使用灯光对其进行了渲染），并且加入了一些错误的类用以增加训练的鲁棒性</p>
</blockquote>
<h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><blockquote>
<p>使用Mask R-CNN作为骨架网络，并且多了三条分支用于分别估计NOCS中的RGB</p>
</blockquote>
<p><img src="http://cdn.ziyedy.top/NOCS/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png" alt=""></p>
<h3 id="训练trick"><a href="#训练trick" class="headerlink" title="训练trick"></a>训练trick</h3><ol>
<li>将回归NOCS变为了一个分类问题（经过文章的实验验证得出改为B=32的分类问题具有最佳的性能）</li>
<li>在训练中没有使用深度图（作者使用COCO数据集来提高网络鲁棒性，而COCO不包含深度图）</li>
</ol>
<h3 id="后序6D位姿与尺寸估计"><a href="#后序6D位姿与尺寸估计" class="headerlink" title="后序6D位姿与尺寸估计"></a>后序6D位姿与尺寸估计</h3><p>利用输出的NOCS图和深度图来进行被检测物体的6D姿态估计与尺寸大小检查。</p>
<p>首先将深度图与RGB图对齐，之后利用输出的Mask来获得物体的3D点云Pm，同时使用NOCS图获得预测位姿Pn。之后，<strong>估计将Pn转换为Pm的比例、旋转和平移</strong>。对于这个7维刚性变换估计问题，作者使用Umeyama算法，而对于离群点去除，作者使用RANSAC。</p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="在合成数据上"><a href="#在合成数据上" class="headerlink" title="在合成数据上"></a>在合成数据上</h4><p>对于50%的3D IoU，mAP为83.9%，位姿使用(5cm，5°)度量，mAP为40.9%</p>
<h4 id="在真实数据集上"><a href="#在真实数据集上" class="headerlink" title="在真实数据集上"></a>在真实数据集上</h4><p>对于50%的3D IoU， mAP为76.4%，位姿使用(5cm，5°)，mAP为10.2%</p>
<h4 id="与PoseCNN进行比较"><a href="#与PoseCNN进行比较" class="headerlink" title="与PoseCNN进行比较"></a>与PoseCNN进行比较</h4><p>使用2D重投影误差，本文的方法误差的mAP为30.2%，PoseCNN为17.2%</p>
<h2 id="文章的不足与可改进之处"><a href="#文章的不足与可改进之处" class="headerlink" title="文章的不足与可改进之处"></a>文章的不足与可改进之处</h2><ol>
<li>显然，处理对称物体是6dof问题的一个难点，本文所提出的NOCS类别表示器并没有将<strong>物体的对称性</strong>考虑进去（只设计了处理对称物体的损失函数）</li>
<li>文章的输入数据是RGB-D数据，可以该进的地方在于仅使用较容易获取的RGB数据</li>
<li>文章中构建的NOCS表示方法仅仅利用了物体的朝向信息，而忽略了可能隐藏的刚体之间的几何等信息，处理类别个人认为应当使用网络对这些信息进行归纳与学习（新的问题）。</li>
</ol>
]]></content>
      <categories>
        <category>AI相关</category>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>6dof姿态估计</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归</title>
    <url>/page/logistic-regression.html</url>
    <content><![CDATA[<p>j</p>
<p>将样本的特征与样本发生的概率联系起来，概率是一个数</p>
<p>逻辑回归既可以看作回归算法也可以看作分类算法。通常作为分类算法使用，只解决二分类问题</p>
<p>决策边界</p>
]]></content>
      <categories>
        <category>AI相关</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title>PCA算法</title>
    <url>/page/pca-basic-use.html</url>
    <content><![CDATA[<h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><blockquote>
<p>PCA算法是一种使用广泛的数据降维算法，主要思想是将n维特征映射到k维上（k &lt; n）。降维的本质也就是<em>从原始坐标系映射到另一个维数更小的坐标系</em></p>
<p>PCA的工作就是从原始的空间中<em>顺序地</em>找一组<em>相互正交</em>的坐标轴（所以<strong>主成分也可以理解为降维后新坐标系的坐标轴</strong>，比如，第一主成分即为求出来的第一个坐标轴），新的坐标轴的选择与数据本身是密切相关的（原始数据中方差最大的方向）</p>
</blockquote>
<h2 id="二维数据可视化"><a href="#二维数据可视化" class="headerlink" title="二维数据可视化"></a>二维数据可视化</h2><h3 id="原始二维数据"><a href="#原始二维数据" class="headerlink" title="原始二维数据"></a>原始二维数据</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"># 构建原始二维数据<br>x = np.empty((<span class="hljs-number">50</span>, <span class="hljs-number">2</span>))<br>x[:, <span class="hljs-number">0</span>] = np.random.uniform(<span class="hljs-number">0</span>, <span class="hljs-number">50</span>, size=<span class="hljs-number">50</span>)<br>x[:, <span class="hljs-number">1</span>] = <span class="hljs-number">0.8</span> * x[:, <span class="hljs-number">0</span>] + <span class="hljs-number">2</span> + np.random.normal(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>, size=<span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure>

<img src="http://cdn.ziyedy.top/PCA%E7%AE%97%E6%B3%95/%E5%88%9D%E5%A7%8B%E6%95%B0%E6%8D%AE.png" style="zoom:67%;" />



<h3 id="对数据样本进行中心化"><a href="#对数据样本进行中心化" class="headerlink" title="对数据样本进行中心化"></a>对数据样本进行中心化</h3><p>进行中心化即<strong>将样本的均值归为0</strong>，在计算方差时可以将尾数约掉</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><code class="hljs sas">def d<span class="hljs-meta">emean(</span><span class="hljs-meta">x</span>):<br>    <span class="hljs-meta">return</span> <span class="hljs-meta">x</span> - np<span class="hljs-meta">.mean(</span><span class="hljs-meta">x</span>, axis=0)<br><br>x_demean = d<span class="hljs-meta">emean(</span><span class="hljs-meta">x</span>)<br></code></pre></td></tr></table></figure>

<img src="http://cdn.ziyedy.top/PCA%E7%AE%97%E6%B3%95/%E5%BD%920%E5%8C%96%E6%95%B0%E6%8D%AE.png" style="zoom:67%;" />



<h3 id="最大化方差"><a href="#最大化方差" class="headerlink" title="最大化方差"></a>最大化方差</h3><p>找到<strong>一组权重</strong>，使得样本空间中所有点映射到这个轴后方差最大（有点类似于“梯度上升”）</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(w, x)</span>:</span><br>    <span class="hljs-keyword">return</span> np.sum((x.dot(w)**<span class="hljs-number">2</span>)) / len(x)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">df</span><span class="hljs-params">(w, x)</span>:</span><br>    <span class="hljs-keyword">return</span> x.T.dot(x.dot(w)) * <span class="hljs-number">2.</span> / len(x)<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gradient_ascent</span><span class="hljs-params">(x, w)</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">direction</span><span class="hljs-params">(w)</span>:</span><br>        <span class="hljs-string">""" 将w转化为单位方向向量 """</span><br>        <span class="hljs-keyword">return</span> w / np.linalg.norm(w)<br>    cur_iter = <span class="hljs-number">0</span><br>    w = direction(w)<br>    <span class="hljs-keyword">while</span> cur_iter &lt; <span class="hljs-number">1e4</span>:<br>        gradient = df(w, x)<br>        last_w = w<br>        w = w + <span class="hljs-number">0.001</span> * gradient<br>        w = direction(w)<br>        <span class="hljs-keyword">if</span> abs(f(w, x) - f(last_w, x) &lt; <span class="hljs-number">1e-8</span>):<br>            <span class="hljs-keyword">break</span><br>        cur_iter += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> w<br><br><br>initial_w = np.random.random(x.shape[<span class="hljs-number">1</span>])<br>w = gradient_ascent(x_demean, initial_w)<br><br>plt.scatter(x_demean[:, <span class="hljs-number">0</span>], x_demean[:, <span class="hljs-number">1</span>])<br>plt.plot([-w[<span class="hljs-number">0</span>]*<span class="hljs-number">50</span>, w[<span class="hljs-number">0</span>]*<span class="hljs-number">50</span>], [-w[<span class="hljs-number">1</span>]*<span class="hljs-number">50</span>, w[<span class="hljs-number">1</span>]*<span class="hljs-number">50</span>], c=<span class="hljs-string">'r'</span>)<br>plt.show()<br></code></pre></td></tr></table></figure>

<p>如图所示，该红线即为方差最大时的权重（可以理解为将这些数据点投影上去能够保留最多信息）</p>
<img src="http://cdn.ziyedy.top/PCA%E7%AE%97%E6%B3%95/%E6%A0%87%E5%87%86%E6%AD%A3%E4%BA%A4%E5%9F%BA%E5%90%91%E9%87%8F.png" style="zoom:67%;" />



<h2 id="PCA的实现"><a href="#PCA的实现" class="headerlink" title="PCA的实现"></a>PCA的实现</h2><p>模仿<code>sklearn</code>机器学习库的API，实现PCA类</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PCA</span>:</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(self, n_components)</span>:</span><br>        <span class="hljs-string">""" 初始化PCA """</span><br>        self.n_components = n_components<br>        self.components_ = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">fit</span><span class="hljs-params">(self, x)</span>:</span><br>        <span class="hljs-string">""" 获取数据集的前n个主成分 """</span><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demean</span><span class="hljs-params">(x)</span>:</span><br>            <span class="hljs-keyword">return</span> x - np.mean(x, axis=<span class="hljs-number">0</span>)<br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f</span><span class="hljs-params">(w, x)</span>:</span><br>            <span class="hljs-keyword">return</span> np.sum((x.dot(w) ** <span class="hljs-number">2</span>)) / len(x)<br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">df</span><span class="hljs-params">(w, x)</span>:</span><br>            <span class="hljs-keyword">return</span> x.T.dot(x.dot(w)) * <span class="hljs-number">2.</span> / len(x)<br><br>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">gradient_ascent</span><span class="hljs-params">(x, w)</span>:</span><br>            <span class="hljs-string">""" 梯度上升法获取第1主成分 """</span><br>            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">direction</span><span class="hljs-params">(w)</span>:</span><br>                <span class="hljs-string">""" 将w转化为单位方向向量 """</span><br>                <span class="hljs-keyword">return</span> w / np.linalg.norm(w)<br>            cur_iter = <span class="hljs-number">0</span><br>            w = direction(w)<br>            <span class="hljs-keyword">while</span> cur_iter &lt; <span class="hljs-number">1e4</span>:<br>                gradient = df(w, x)<br>                last_w = w<br>                w = w + <span class="hljs-number">0.001</span> * gradient<br>                w = direction(w)<br>                <span class="hljs-keyword">if</span> abs(f(w, x) - f(last_w, x) &lt; <span class="hljs-number">1e-8</span>):<br>                    <span class="hljs-keyword">break</span><br>                cur_iter += <span class="hljs-number">1</span><br>            <span class="hljs-keyword">return</span> w<br><br>        x_pca = demean(x)<br>        self.components_ = np.empty(shape=(self.n_components, x.shape[<span class="hljs-number">1</span>]))<br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(self.n_components):<br>            initial_w = np.random.random(x_pca.shape[<span class="hljs-number">1</span>])<br>            <span class="hljs-comment"># 在x_pca上求得第一主成分</span><br>            w = gradient_ascent(x_pca, initial_w)<br>            self.components_[i, :] = w<br>            <span class="hljs-comment"># 将x_pca映射到求出来的主成分上，在此基础上再求第一主成分</span><br>            x_pca = x_pca - x_pca.dot(w).reshape(<span class="hljs-number">-1</span>, <span class="hljs-number">1</span>) * w<br>        <span class="hljs-keyword">return</span> self<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transform</span><span class="hljs-params">(self, X)</span>:</span><br>        <span class="hljs-string">""" 将给定的X，映射到各个主成分分量z中 """</span><br>        <span class="hljs-keyword">return</span> X.dot(self.components_.T)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">detransform</span><span class="hljs-params">(self, X)</span>:</span><br>        <span class="hljs-string">""" 将给定的X，反向映射回原来的特征空间 """</span><br>        <span class="hljs-keyword">return</span> X.dot(self.components_)<br></code></pre></td></tr></table></figure>



<h2 id="PCA的使用"><a href="#PCA的使用" class="headerlink" title="PCA的使用"></a>PCA的使用</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>sklearn</code>库中的PCA的用法与之前实现的基本一致。</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">from sklearn.decomposition import <span class="hljs-keyword">PCA</span><br><br><span class="hljs-keyword">pca</span> = <span class="hljs-keyword">PCA</span>(n_components=1)<br><span class="hljs-keyword">pca</span>.<span class="hljs-keyword">fit</span>(x_data)<br><span class="hljs-keyword">pca</span>.components_  # 得到的主成分<br>x_reduction = <span class="hljs-keyword">pca</span>.transform(x_data)<br>x_restore = <span class="hljs-keyword">pca</span>.inverse_transform(x_reduction)<br></code></pre></td></tr></table></figure>

<h3 id="PCA效果的查看"><a href="#PCA效果的查看" class="headerlink" title="PCA效果的查看"></a>PCA效果的查看</h3><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">pca</span><span class="hljs-selector-class">.explained_variance_ratio_</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>该方法返回一个表示降维后每个轴能够代表整个数据信息的比例，可以查看降维的效果以及数据损失的程度</p>
</blockquote>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata"># 获取<span class="hljs-keyword">PCA</span>所有轴数据损失的程度<br><span class="hljs-keyword">pca</span> = <span class="hljs-keyword">PCA</span>(n_components=x_train.shape[1])<br><span class="hljs-keyword">pca</span>.<span class="hljs-keyword">fit</span>(x_train)<br><span class="hljs-keyword">pca</span>.explained_variance_ratio_<br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>AI相关</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
        <tag>sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章：传输层</title>
    <url>/page/transport-layer.html</url>
    <content><![CDATA[<h1 id="传输层概述"><a href="#传输层概述" class="headerlink" title="传输层概述"></a>传输层概述</h1><h2 id="传输层概述-1"><a href="#传输层概述-1" class="headerlink" title="传输层概述"></a>传输层概述</h2><blockquote>
<p>传输层协议为运行在不同主机上的<strong>应用进程</strong>之间提供<strong>逻辑通信</strong>功能 </p>
<p>传输层协议是在<strong>端系统</strong>中而不是在网络路由器中实现的</p>
</blockquote>
<h2 id="传输层与网络层关系"><a href="#传输层与网络层关系" class="headerlink" title="传输层与网络层关系"></a>传输层与网络层关系</h2><blockquote>
<p>传输层为运行在不同主机上的<strong>进程间</strong>的逻辑通信，而网络层则提供了<strong>主机之间</strong>的逻辑通信</p>
<p>传输层协议所能提供的服务也受到了<em>底层网络层协议的服务模型的限制</em>，</p>
</blockquote>
<h2 id="因特网传输概述"><a href="#因特网传输概述" class="headerlink" title="因特网传输概述"></a>因特网传输概述</h2><p>传输层主要有TCP（传输控制协议）与UDP（用户数据报协议）两种协议，特点及区别如下：</p>
<p><img src="http://cdn.ziyedy.top/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%2CUDP.png" alt=""></p>
<h2 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h2><blockquote>
<p>多路复用与多路分解：本质上是将网络层所提供的<em>主机到主机</em>交付服务，<strong>扩展</strong>到为在主机上运行的应用程序所提供的<em>进程到进程</em>交付服务</p>
<p>即将从网络层接收的报文段，交付给合适的应用进程</p>
</blockquote>
<h3 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h3><blockquote>
<p>从源主机的不同套接字中收集数据块，井为每个数据块封装上首部信息( ( 在多路分解时使用) ) 从而生成报文段，然后将报文段传递到网络层的工作称为多路复用</p>
</blockquote>
<p>传输层要达到多路复用，必须保证</p>
<ul>
<li>套接字有唯一标识符</li>
<li>每个传输层报文段有特殊字段来指示该报文段所要交付的套接字（即源端口号字段与目的端口号字段）</li>
</ul>
<h3 id="多路分解"><a href="#多路分解" class="headerlink" title="多路分解"></a>多路分解</h3><blockquote>
<p>将传输层报文段中的数据放置到正确的套接字的工作称为多路分解，确切地说，多路分解其实是多路分发，或者说是数据流的分解。</p>
</blockquote>
<h1 id="无连接传输：UDP"><a href="#无连接传输：UDP" class="headerlink" title="无连接传输：UDP"></a>无连接传输：UDP</h1><p>UDP 只是做了传输层协议能够做的最少工作。除了多路复用/多路分解功能及少量的差错检测外，它几乎没有对 IP 增加别的东西</p>
<p>UDP发送报文前，发送方与接收方之间并未进行握手，因此UDP是<strong>无连接的</strong></p>
<p>DNS即是一个使用UDP的例子，此外音频、视频等通常也使用UDP</p>
<h2 id="UDP的优点"><a href="#UDP的优点" class="headerlink" title="UDP的优点"></a>UDP的优点</h2><ul>
<li>应用层能更好地设置要发送的数据和发送时间（有较快发送速率，且能容忍一些丢包）</li>
<li>无需建立连接（不会引入建立连接的时延）</li>
<li>无连接状态（UDP无连接状态，也无需追踪一些相关参数）</li>
<li>分组首部开销小（TCP有20字节的首部开销，而UDP仅有8个字节）</li>
</ul>
<h2 id="UDP报文结构"><a href="#UDP报文结构" class="headerlink" title="UDP报文结构"></a>UDP报文结构</h2><p><img src="http://cdn.ziyedy.top/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/UDP%E6%8A%A5%E6%96%87%E6%AE%B5.png" alt=""></p>
<p>由4个字段组成，每个字段包含2个字节</p>
<p>源端口号、目的端口号</p>
<p>长度：包含首部在内的UDP报文段长度，以字节为单位</p>
<p>校验和：计算报文段在传输的过程中是否出现了差错</p>
<h3 id="校验和"><a href="#校验和" class="headerlink" title="校验和"></a>校验和</h3><blockquote>
<p>校验和提供了差错检测功能，即当 UDP 报文段从源到达目的时，校验和用于确定其中的比特是否发生了改变</p>
</blockquote>
<h3 id="UDP如何实现可靠连接"><a href="#UDP如何实现可靠连接" class="headerlink" title="UDP如何实现可靠连接"></a>UDP如何实现可靠连接</h3><p>核心思路：传输层无法保证数据的可靠传输，就通过应用层来实现，实现的方法可以参考TCP以及可靠数据传输的原理</p>
<p>实现确认机制、重传机制、窗口确认机制</p>
<h1 id="可靠数据传输原理（建模）"><a href="#可靠数据传输原理（建模）" class="headerlink" title="可靠数据传输原理（建模）"></a>可靠数据传输原理（建模）</h1><blockquote>
<p>考虑单向实现可靠传输的建模，得到TCP实现的基本思路</p>
</blockquote>
<h2 id="完全可靠信道上"><a href="#完全可靠信道上" class="headerlink" title="完全可靠信道上"></a>完全可靠信道上</h2><blockquote>
<p>底层信道完全可靠</p>
<p>no bit errors;    no loss of packets</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 发送方</span><br>packet = make<span class="hljs-constructor">_pkt(<span class="hljs-params">data</span>)</span>	<span class="hljs-comment">// 生成数据分组</span><br>packet = make<span class="hljs-constructor">_pkt(<span class="hljs-params">data</span>)</span>	<span class="hljs-comment">// 发送分组</span><br><br><span class="hljs-comment">// 接收方</span><br>extract (packet,data)	<span class="hljs-comment">// 从分组中提取</span><br>deliver<span class="hljs-constructor">_data(<span class="hljs-params">data</span>)</span>		<span class="hljs-comment">// 交付数据给应用层</span><br></code></pre></td></tr></table></figure>

<h2 id="具有比特差错信道上"><a href="#具有比特差错信道上" class="headerlink" title="具有比特差错信道上"></a>具有比特差错信道上</h2><h3 id="ACK、NAK不受损"><a href="#ACK、NAK不受损" class="headerlink" title="ACK、NAK不受损"></a>ACK、NAK不受损</h3><blockquote>
<p>在传输过程中会产生比特差错</p>
<p>需要引入：<strong>自动重传请求协议</strong>（ARQ），即</p>
<ul>
<li>差错检测</li>
<li>接收方反馈（ACK：数据包OK；NAK：数据包存在错误）</li>
<li>重传：接收方收到有差错的分组时，发送方进行重传</li>
</ul>
</blockquote>
<h3 id="ACK、NAK受损"><a href="#ACK、NAK受损" class="headerlink" title="ACK、NAK受损"></a>ACK、NAK受损</h3><p>确认信息在传输中本身出现错误</p>
<p>解决方法：发送方为数据报添加<strong>序号字段</strong>，而接收方抛弃重复的数据报</p>
<h2 id="具有比特差错的丢包信道上"><a href="#具有比特差错的丢包信道上" class="headerlink" title="具有比特差错的丢包信道上"></a>具有比特差错的丢包信道上</h2><p>除去比特受损外，还有可能丢包</p>
<p>解决方法：发送方等待ACK到来足够的时间（采用<strong>定时器</strong>实现），然后进行<strong>重传</strong></p>
<h2 id="流水线可靠数据传输协议"><a href="#流水线可靠数据传输协议" class="headerlink" title="流水线可靠数据传输协议"></a>流水线可靠数据传输协议</h2><blockquote>
<p>为提高发送效率（解决上述“停等协议”的问题）：以“不停等”方式运行，<em>允许发送方发送多个分组而无需等待确认</em>，该技术称为流水线。流水线提出了新的需求：</p>
</blockquote>
<ul>
<li>必须增加序号范围。保证每个传输的分组有一个唯一的序号</li>
<li>协议的发送方和接收方必须缓存多个分组。</li>
<li>所需序号范围和对缓冲的要求取决于数据传输协议处理丢失、损坏及过度延时分组：<strong>回退N步与选择重传</strong></li>
</ul>
<h3 id="回退N步（GBN）"><a href="#回退N步（GBN）" class="headerlink" title="回退N步（GBN）"></a>回退N步（GBN）</h3><blockquote>
<p>在 GBN 协议中，允许发送方发送多个分组而不需等待确认，但<em>在流水线中未确认的分组数不能超过某个最大允许数N</em></p>
<p>已被发送但还未被确认的分组的许可序号范围可以被看成是一个<strong>在序号范围内长度为N的窗口</strong>，因此N常被称为窗口长度，GBN也被称为滑动窗口协议</p>
<p><em>当有超时事件发生，出现丢失和过度时延分组时，发送方将重传所有已发送但还未被确认的分组</em></p>
<p>GBN使用了<strong>累积确认</strong>技术，累积确认指接收一个未出错分组（可能失序）时总是返回一个最后接收的按顺序到达分组的确认。</p>
</blockquote>
<h3 id="选择重传"><a href="#选择重传" class="headerlink" title="选择重传"></a>选择重传</h3><blockquote>
<p>选择重传 (SR) 协议通过让发送方仅重传那些它怀疑在接收方出错的分组而避免了不必要的重传。</p>
</blockquote>
<p>这种个别的、按需的重传要求接收方逐个地确认正确接收的分组，也用窗口长度N来限制流水线中未完成、未被确认的分组数。</p>
<h1 id="面向连接的传输：TCP"><a href="#面向连接的传输：TCP" class="headerlink" title="面向连接的传输：TCP"></a>面向连接的传输：TCP</h1><blockquote>
<p>TCP是<strong>面向连接</strong>的传输层协议，<em>连接的实质是双方都初始化与连接相关的发送/接收缓冲区，以及许多 TCP 状态变量</em></p>
</blockquote>
<ul>
<li>TCP连接提供的是全双工服务</li>
<li>TCP连接是点对点的（TCP不可能多播）</li>
</ul>
<p>TCP连接每一端都有各自的发送缓冲和接收缓存，TCP 可从缓存中取出并放入报文段中发送的数据量受限于<strong>最大报文段长MSS（Maximum Segment Size）</strong>，通常由<strong>最大链路层帧长度（即最大传输单元MTU）</strong>来决定（也就是底层的通信链路决定）</p>
<p>除去进行通信的两台主机之中维护TCP连接所需的内容，这两台主机之间的路由器交换机并未为该连接分配任何缓存和控制变量</p>
<h2 id="TCP报文格式"><a href="#TCP报文格式" class="headerlink" title="TCP报文格式"></a>TCP报文格式</h2><p><img src="http://cdn.ziyedy.top/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E6%8A%A5%E6%96%87%E6%AE%B5.png" alt=""></p>
<ul>
<li>源端口号与目的端口号：用于多路复用/多路分解来自或送至上层应用的数据</li>
<li>32 比特的序号字段和 32 比特的确认号字段：用来实现可靠数据传输服务</li>
</ul>
<blockquote>
<p>序号字段：即该数据报在所需传送的字节流上的位置，用于实现TCP报文的有序性</p>
<p>确认号字段：用于标识接收方期待从发送方收到的下一报文段首字节的序号</p>
</blockquote>
<ul>
<li>16 比特的接收窗口字段：用于<em>流量控制</em>，用于指示接受方能够接收的字节数量</li>
<li>4 比特的首部长度字段：用于指示以 32 比特的字为单位的 TCP 首部长度，一般 TCP 首部的长度就是 20 字节</li>
<li>6比特标志字段：主要使用以下三个</li>
</ul>
<blockquote>
<p>ACK：用于指示确认字段中的值是有效的（对成功接收报文的确认），ACK=1时有效</p>
<p>SYN：表示建立一个连接</p>
<p>​    SYN=1，ACK=0时，表示这是一个<strong>连接请求报文段</strong></p>
<p>​    SYN=1，ACK=1时，表示对方同意建立连接</p>
<p>FIN：告知对方关闭连接</p>
</blockquote>
<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p><img src="http://cdn.ziyedy.top/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt=""></p>
<h3 id="第一次握手"><a href="#第一次握手" class="headerlink" title="第一次握手"></a>第一次握手</h3><p>发送方创建一个特殊的TCP报文段（<strong>SYN报文段</strong>）：</p>
<ol>
<li>不包含任何应用层数据；</li>
<li>将SYN标志位置为1；</li>
<li>随机生成一个初始序号（client_isn），并将该序号置于该报文的序号字段（seq）处</li>
</ol>
<h3 id="第二次握手"><a href="#第二次握手" class="headerlink" title="第二次握手"></a>第二次握手</h3><p>收到SYN报文段后，接收方会返回允许连接的报文段（SYNACK报文段）：</p>
<ol>
<li>SYN标志位置为1，ACK标志位置为1；</li>
<li>确认号字段（ack）置为client_isn+1；</li>
<li>接收端生成一个自己的初始序号（server_isn），并将该序号置于自己报文的序号字段（seq）处</li>
</ol>
<h3 id="第三次握手"><a href="#第三次握手" class="headerlink" title="第三次握手"></a>第三次握手</h3><blockquote>
<p>RFC793文档里说明带有SYN标志的过程包是不可以携带数据的，因此三次握手的前两次是不能携带数据的</p>
<p>而第三次握手运行携带数据</p>
</blockquote>
<ol>
<li>SYN被置为0，ACK置为1</li>
<li>确认号字段置为server_isn+1</li>
<li>seq字段设置为client_isn+1</li>
</ol>
<h3 id="异常情况"><a href="#异常情况" class="headerlink" title="异常情况"></a>异常情况</h3><ul>
<li>第一次握手丢失：会触发超时重传（重传3此syn包，每次间隔一定时间）</li>
<li>第二次握手丢失：会触发情况1，同时服务器也会进行超时重传（每次间隔一定时间），收到客户端的syn报文会立即回复</li>
<li>第三次握手丢失：此时客户端已经进入 ESTABLISHED  状态，而服务器仍然处于 SYN-RCVD 状态。此时服务器接收到客户端发送过来的数据会判断连接已经建立，并进入 ESTABLISHED 状态。</li>
</ul>
<p>参考：<a href="https://blog.csdn.net/plokmju88/article/details/103884145" target="_blank" rel="noopener">https://blog.csdn.net/plokmju88/article/details/103884145</a></p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><img src="http://cdn.ziyedy.top/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%A4%BA%E6%84%8F%E5%9B%BE.png" style="zoom:80%;" />

<ol>
<li>主机A发送一个用来释放连接的报文（标识了<strong>FIN=1</strong>，序列号<strong>seq=a</strong>，ack=z，），并处于<strong>FIN-WAIT-1状态</strong>，此处A不再有数据发送，但仍然可以接收数据</li>
<li>主机B回应一个标识了<strong>ACK=1</strong>的数据段，序列号<strong>seq=b</strong>，确认序号<strong>ack=a+1</strong>，作为对主机A的FIN报文的确认，并且进入<strong>CLOSE-WAIT状态</strong>。A收到确认后，进入<strong>FIN-WAIT-2**</strong>状态**，等待B的连接释放报文段</li>
<li>主机B向主机A发送一个标识了<strong>FIN=1，ACK=1</strong>的数据段，序列号为<strong>seq=b</strong>，确认序列号为<strong>ack=a+1</strong>，用以释放连接</li>
<li>主机A发送标识了<strong>ACK=1</strong>，序列号<strong>seq=a+1</strong>，确认序号<strong>ack=b+1</strong>，用以确认关闭</li>
</ol>
<p><strong>客户端或服务器均可主动发起挥手动作</strong></p>
<h3 id="为什么要进行四次挥手（CLOSE-WAIT状态的意义）"><a href="#为什么要进行四次挥手（CLOSE-WAIT状态的意义）" class="headerlink" title="为什么要进行四次挥手（CLOSE_WAIT状态的意义）"></a>为什么要进行四次挥手（CLOSE_WAIT状态的意义）</h3><p>因为TCP是全双工模式，一方发送FIN报文只是代表单方面没有信息需要发送了，但另一方可以继续发送报文，<strong>只有双方都发送了FIN报文整个通信过程才能结束</strong></p>
<h3 id="TCP释放连接为何发送方TIME-WAIT状态必须等待2MSL的时间"><a href="#TCP释放连接为何发送方TIME-WAIT状态必须等待2MSL的时间" class="headerlink" title="TCP释放连接为何发送方TIME_WAIT状态必须等待2MSL的时间"></a>TCP释放连接为何发送方<code>TIME_WAIT</code>状态必须等待2MSL的时间</h3><blockquote>
<p><strong>MSL（Maximum Segment Lifetime）</strong>：报文段最大生存时间，任何报文在网络上存在时间超过该时间就会被丢弃</p>
</blockquote>
<ul>
<li><p>为了保证A发送的最后一个ACK报文能够到达B，从而<strong>可靠地实现TCP全双工连接的终止</strong></p>
<p>由于该ACK报文段有可能丢失，因而使处在LAST-ACK状态的B收不到对已发送的FIN+ACK报文段的确认，因此会引起超时重传。而若A不等待而是直接释放连接，就无法收到B重传的FIN报文段，就不会再发送一次确认报文段，<strong>最终会导致B无法按照正常的步骤进入CLOSED状态</strong></p>
</li>
<li><p><strong>允许老的报文在网络中消逝</strong></p>
<p>经过2MSL时间，可以使本次连接所产生的所有报文段都从网络中消失。这样就可以使下一个新的连接中不会出现旧的连接请求的报文段（<strong>彻底完成这次报文的发送与接收</strong>）</p>
</li>
</ul>
<h3 id="大量TIME-WAIT造成的影响"><a href="#大量TIME-WAIT造成的影响" class="headerlink" title="大量TIME_WAIT造成的影响"></a>大量<code>TIME_WAIT</code>造成的影响</h3><p>tcp中TIME_WAIT状态的危害</p>
<h2 id="TCP可靠数据传输"><a href="#TCP可靠数据传输" class="headerlink" title="TCP可靠数据传输"></a>TCP可靠数据传输</h2><p>主要有超时重传和快速重传：</p>
<ul>
<li>超时重传：超时后进行重传，需要设置超时事件（通常4个往返时间RTT）</li>
<li>快速重传：如果发送者收到了重复的3个ACK报文段（接收方如果发现有丢失（即收到了间隔后的报文段）会重复发送ACK报文段，），说明该报文段所指下一个段丢失，会在超时触发前快速重传该报文段。可以避免超时引起的大时延</li>
</ul>
<h3 id="延迟确认机制"><a href="#延迟确认机制" class="headerlink" title="延迟确认机制"></a>延迟确认机制</h3><p>接收方在收到数据后，并不会立即回复ACK，而是延迟一定时间（通常每200ms检查一次）</p>
<p>目的：</p>
<ul>
<li>ACK是可以合并的，也就是指如果连续收到两个TCP包，并不一定需要ACK两次，只要回复最终的ACK就可以了，可以降低网络流量</li>
<li>如果接收方有数据要发送，那么就会在发送数据的TCP数据包里，带上ACK信息。这样做，可以避免大量的ACK以一个单独的TCP包发送，减少了网络流量</li>
</ul>
<h2 id="TCP流量控制——滑动窗口"><a href="#TCP流量控制——滑动窗口" class="headerlink" title="TCP流量控制——滑动窗口"></a>TCP流量控制——滑动窗口</h2><blockquote>
<p>流量控制只要在于消除发送方导致接收方<strong>缓存溢出</strong>的可能性（避免因为接收方缓存区满而造成的大量丢包的问题），流量控制是一个<strong>速度匹配</strong>服务，即发送方的发送速率与接收方应用程序的读速率相匹配</p>
</blockquote>
<p>TCP通过维护报文中<strong>接收窗口</strong>字段来提供流量控制，接收窗口用于告诉发送方，该接收方还有多少可用的缓存空间</p>
<p>发送方的发送窗口大小不能超过接收方给出窗口大小，当发送方收到接收窗口的大小为0时，发送方就会停止发送数据</p>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><p>报文中有的窗口字段表示窗口的大小，请求和响应窗口大小一增一减表示窗口的滑动<br>$$<br>发送窗口 = min(拥塞窗口, 接收窗口)<br>$$</p>
<h1 id="拥塞控制原理"><a href="#拥塞控制原理" class="headerlink" title="拥塞控制原理"></a>拥塞控制原理</h1><h2 id="产生拥塞的情况"><a href="#产生拥塞的情况" class="headerlink" title="产生拥塞的情况"></a>产生拥塞的情况</h2><h3 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h3><blockquote>
<p>两个发送方和一个具有无穷大缓存的路由器</p>
</blockquote>
<p>当分组到达速率接近<em>链路容量</em>时，分组将经历较长的排队时延</p>
<h3 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h3><blockquote>
<p>两个发送方和一个具有有限缓存的路由器</p>
</blockquote>
<p>发送方在遇到大时延时所进行的不必要重传，导致路由器需要利用其链路带宽来转发不必要的分组</p>
<h3 id="情况3"><a href="#情况3" class="headerlink" title="情况3"></a>情况3</h3><blockquote>
<p>四个发送方、具有有限缓存的多台路由器和多跳路径</p>
</blockquote>
<p>当一个分组沿一条路径被丢弃时每个上游路由器用于转发该分组而使用的传输容量最终被浪费掉了</p>
<h2 id="拥塞控制方法"><a href="#拥塞控制方法" class="headerlink" title="拥塞控制方法"></a>拥塞控制方法</h2><h3 id="端到端控制"><a href="#端到端控制" class="headerlink" title="端到端控制"></a>端到端控制</h3><blockquote>
<p>网络层没有为传输层拥塞控制提供显式支持，因此端系统必须对网络行为观察（分组丢失、时延等），来<strong>推断</strong>拥塞的发生</p>
</blockquote>
<p>TCP中将报文段的丢失（通过超时或3次冗余确认得知），认为是网络拥塞的一个迹象，之后TCP会相应减小其发送的窗口</p>
<h3 id="网络辅助的拥塞控制"><a href="#网络辅助的拥塞控制" class="headerlink" title="网络辅助的拥塞控制"></a>网络辅助的拥塞控制</h3><blockquote>
<p>网络层对是否产生拥塞显式反馈给端系统</p>
</blockquote>
<h2 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h2><blockquote>
<p>由于IP向端系统提供显式的网络拥塞反馈，因此TCP必须使用端到端的拥塞控制</p>
<p>拥塞控制的过程是源主机不断试探网络传输能力的过程，如果一个TCP发送方没有感知到拥塞，它就会增加其发送速率；如果感知到拥塞，则降低其发送速率</p>
</blockquote>
<p>TCP拥塞控制机制使用一个控制变量，即拥塞窗口（congestion window）来表征网络的拥塞情况</p>
<p>发送窗口 = min{CongWin, RcvWin}</p>
<h3 id="加性增，乘性减"><a href="#加性增，乘性减" class="headerlink" title="加性增，乘性减"></a>加性增，乘性减</h3><ul>
<li>加性增：每个RTT周期CongWin增加1个MSS单位，直到检测到丢包</li>
<li>乘性减：当检测到丢包时，CongWin减半</li>
</ul>
<p><img src="http://cdn.ziyedy.top/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/%E5%8A%A0%E6%80%A7%E5%A2%9E%E4%B9%98%E6%80%A7%E5%87%8F.png" alt=""></p>
<h3 id="慢启动"><a href="#慢启动" class="headerlink" title="慢启动"></a>慢启动</h3><p>在慢启动阶段，每当一个传输的报文段被确认后，CongWin 的值就增加1个 MSS ，由于TCP 一次发送多个报文段进入网络，从<br>而使发送方的发送速率在经过一个 RTT 时间后成倍增长</p>
<p>以指数级增长后，直到遇到一个丢包，CongWin减半后开始变为线性增长</p>
<h3 id="对超时事件的反应"><a href="#对超时事件的反应" class="headerlink" title="对超时事件的反应"></a>对超时事件的反应</h3><ol>
<li>收到3个冗余ACK后，TCP将拥塞窗口减小一半，然后线性增长</li>
<li>超时事件发生后，TCP则进入一个慢启动状态</li>
</ol>
<p>TCP通过维持一个称为阈值 (Threshold) 的变量来确定慢启动将结束并且拥塞避免将开始的窗口长度</p>
<p>变量Threshold初始化时被设置为一个很大的值，每当发生一个丢包事件时，Threshold值就会被设置为当前CongWin值的一半</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>慢启动：CongWin &lt; Threshold，CongWin指数增长</li>
<li>拥塞避免：CongWin &gt; Threshold，CongWin线性增长</li>
<li>快速恢复：3个冗余ACK，Threshold设置为Threshold/2，CongWin设置为Threshold</li>
<li>超时处理：timeout事件，Threshold设置为Threshold/2，CongWin设置为1MMS大小</li>
</ul>
<p><img src="http://cdn.ziyedy.top/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E4%BC%A0%E8%BE%93%E5%B1%82/TCP%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E8%BF%87%E7%A8%8B.png" alt=""></p>
<p>参考：</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/145260638" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/145260638</a></p>
</blockquote>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>使用plyfile库对.ply文件进行读写操作</title>
    <url>/page/plyfile.html</url>
    <content><![CDATA[<h3 id="安装plyfile库"><a href="#安装plyfile库" class="headerlink" title="安装plyfile库"></a>安装plyfile库</h3><p>直接使用pip命令即可</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> plyfile<br></code></pre></td></tr></table></figure>

<h3 id="进行-ply文件读取"><a href="#进行-ply文件读取" class="headerlink" title="进行*.ply文件读取"></a>进行*.ply文件读取</h3><p>读取ply文件返回的是numpy数组，读取的方法也比较简单</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># 读入ply文件</span><br>plydata = PlyData.read('tet.ply')<br><br><span class="hljs-section"># 读取所有x坐标</span><br>plydata.elements[0].data['x']<br>plydata['vertex'].data['x']<br>plydata[<span class="hljs-string">'vertex'</span>][<span class="hljs-symbol">'x'</span>]<br><br><span class="hljs-section"># 读取第一个点的3d坐标</span><br>plydata.elements[0].data[0]<br>plydata[<span class="hljs-string">'vertex'</span>][<span class="hljs-symbol">0</span>]<br></code></pre></td></tr></table></figure>

<h4 id="读取函数"><a href="#读取函数" class="headerlink" title="读取函数"></a>读取函数</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> plyfile <span class="hljs-keyword">import</span> PlyData, PlyElement<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_ply</span><span class="hljs-params">(filename)</span>:</span><br>    <span class="hljs-string">""" 读取坐标，返回值为 n * 3 """</span><br>    plydata = PlyData.read(filename)<br>    pc = plydata[<span class="hljs-string">'vertex'</span>].data<br>    pc_array = np.array([[x, y, z] <span class="hljs-keyword">for</span> x,y,z <span class="hljs-keyword">in</span> pc])<br>    <span class="hljs-keyword">return</span> pc_array<br></code></pre></td></tr></table></figure>

<h3 id="进行-ply文件写入"><a href="#进行-ply文件写入" class="headerlink" title="进行*.ply文件写入"></a>进行*.ply文件写入</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> plyfile <span class="hljs-keyword">import</span> PlyData, PlyElement<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">write_ply</span><span class="hljs-params">(save_path, points, text=True)</span>:</span><br>    <span class="hljs-string">"""<br>    输入点云数据，并写入一个*.ply文件<br>    :param save_path: 文件路径 + *.ply<br>    :param points:<br>    :param text:<br>    :return: <br>    """</span><br>    points = [(points[i, <span class="hljs-number">0</span>], points[i, <span class="hljs-number">1</span>], points[i, <span class="hljs-number">2</span>]) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(points.shape[<span class="hljs-number">0</span>])]<br>    vertex = np.array(points, dtype=[(<span class="hljs-string">'x'</span>, <span class="hljs-string">'f4'</span>), (<span class="hljs-string">'y'</span>, <span class="hljs-string">'f4'</span>), (<span class="hljs-string">'z'</span>, <span class="hljs-string">'f4'</span>)])<br>    el = PlyElement.describe(vertex, <span class="hljs-string">'vertex'</span>, comments=[<span class="hljs-string">'vertices'</span>])<br>    PlyData([el], text=text).write(save_path)<br></code></pre></td></tr></table></figure>



<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p>以上主要就是利用plyfile库进行点数据的读取，关于面数据之类的其实与点数据差别不大，重点在于对ply文件格式的认识</p>
</blockquote>
<p><a href="https://blog.csdn.net/phy12321/article/details/107373073" target="_blank" rel="noopener">https://blog.csdn.net/phy12321/article/details/107373073</a></p>
<p><a href="https://pypi.org/project/plyfile/" target="_blank" rel="noopener">https://pypi.org/project/plyfile/</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>3D视觉</tag>
        <tag>点云</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现深度图转点云</title>
    <url>/page/python-depth-points.html</url>
    <content><![CDATA[<h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>深度图转点云本质上我认为就算利用深度信息<strong>将图像从像素坐标系转化到相机坐标系的过程</strong>（很多资料说是转到世界坐标系，但我认为这是一个如何定义世界坐标系的问题）</p>
<p><img src="http://cdn.ziyedy.top/Python%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%BA%A6%E5%9B%BE%E8%BD%AC%E7%82%B9%E4%BA%91/%E5%9D%90%E6%A0%87%E7%B3%BB.jpg" alt=""></p>
<p>忽略推导过程，其实可以归纳为从图像点<code>[u, v]</code>到相机坐标点<code>[x_c, y_c, z_c]</code>的过程，具体公式如下（其中depth(u, v)表示深度图(u, v)位置的像素值）<br>$$<br>x_c = z_c (u - u_0) / f_x \<br>y_c = z_c (v - v_0) / f_y \<br>z_c = depth(u, v)<br>$$</p>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><h3 id="深度图"><a href="#深度图" class="headerlink" title="深度图"></a>深度图</h3><p><img src="http://cdn.ziyedy.top/Python%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%BA%A6%E5%9B%BE%E8%BD%AC%E7%82%B9%E4%BA%91/%E6%B7%B1%E5%BA%A6%E5%9B%BE.png" alt="深度图"></p>
<h3 id="转换代码"><a href="#转换代码" class="headerlink" title="转换代码"></a>转换代码</h3><figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">def depth2pc(depth_img):<br>    <span class="hljs-string">""</span><span class="hljs-string">"<br>    深度图转点云数据<br>    图像坐标系 -&gt; 世界坐标系 <br>    :param depth_img: 深度图<br>    :return: 点云数据 N*3<br>    "</span><span class="hljs-string">""</span><br>    <br>    <span class="hljs-comment"># 相机内参</span><br>    <span class="hljs-attr">cam_fx</span> = <span class="hljs-number">1120.12</span><br>    <span class="hljs-attr">cam_fy</span> = <span class="hljs-number">1120.12</span><br>    <span class="hljs-attr">cam_cx</span> = <span class="hljs-number">640.5</span><br>    <span class="hljs-attr">cam_cy</span> = <span class="hljs-number">360.5</span><br>    <span class="hljs-attr">factor</span> = <span class="hljs-number">1</span><br><br>	<span class="hljs-comment"># 逐点处理，此过程可以使用numpy优化</span><br>    m, <span class="hljs-attr">n</span> = depth_img.shape<br>    <span class="hljs-attr">point_cloud</span> = []<br>    for v <span class="hljs-keyword">in</span> range(m):<br>        for u <span class="hljs-keyword">in</span> range(n):<br>            <span class="hljs-keyword">if</span> depth_img[v, u] == <span class="hljs-number">0</span>:<br>                continue<br>            <span class="hljs-attr">depth</span> = depth_img[v, u]<br>            <span class="hljs-attr">p_z</span> = depth / factor<br>            <span class="hljs-attr">p_x</span> = (u - cam_cx) * p_z / cam_fx<br>            <span class="hljs-attr">p_y</span> = (v - cam_cy) * p_z / cam_fy<br>            point_cloud.append([p_x, p_y, p_z])<br><br>    <span class="hljs-attr">point_cloud</span> = np.array(point_cloud)<br><br>    return point_cloud<br></code></pre></td></tr></table></figure>

<h3 id="转换后的点云"><a href="#转换后的点云" class="headerlink" title="转换后的点云"></a>转换后的点云</h3><p><em>略去了将桌面等背景略去的相关代码</em>，转换后的点云数据如下</p>
<p><img src="http://cdn.ziyedy.top/Python%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%BA%A6%E5%9B%BE%E8%BD%AC%E7%82%B9%E4%BA%91/%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE.png" alt=""></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>由于本人是初次接触点云相关数据，而任务又有时间要求，所以没有使用较为主流的C++下的pcl库，未来两个月打算学习以下点云相关的操作与理论，届时再进行更新</p>
<p><a href="https://blog.csdn.net/weixin_30284355/article/details/98320637" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30284355/article/details/98320637</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>3D视觉</tag>
        <tag>点云</tag>
      </tags>
  </entry>
  <entry>
    <title>conda产生的bug处理</title>
    <url>/page/conda-debug.html</url>
    <content><![CDATA[<h2 id="没有写权限"><a href="#没有写权限" class="headerlink" title="没有写权限"></a>没有写权限</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">EnvironmentNotWritableError: The current<span class="hljs-built_in"> user </span>does <span class="hljs-keyword">not</span> have write permissions <span class="hljs-keyword">to</span> the target environment.<br>  environment location: /opt/anaconda3<br>  uid: 1000<br>  gid: 1000<br></code></pre></td></tr></table></figure>

<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>将anconda及其子文件赋予最高权限</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">sudo chmod <span class="hljs-number">777</span> -R /opt/anaconda3/<br></code></pre></td></tr></table></figure>



<h2 id="下载源问题"><a href="#下载源问题" class="headerlink" title="下载源问题"></a>下载源问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="http://cdn.ziyedy.top/conda%E4%BA%A7%E7%94%9F%E7%9A%84bug%E5%A4%84%E7%90%86/%E4%B8%8B%E8%BD%BD%E6%BA%90%E9%97%AE%E9%A2%98.png" alt=""></p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>换源或者直接采用conda默认的源（以下换回conda的默认源）</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">conda<span class="hljs-built_in"> config </span>--remove-key channels<br></code></pre></td></tr></table></figure>

<p>换成清华源或中科大源，将以下配置文件写入<code>~/.condarc</code>中</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><code class="hljs haml">channels:<br>  -<span class="ruby"> <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/mirrors.tuna.tsinghua.edu.cn/anaconda</span><span class="hljs-regexp">/pkgs/main</span><span class="hljs-regexp">/<br></span></span>  -<span class="ruby"><span class="hljs-regexp"> https:/</span><span class="hljs-regexp">/mirrors.tuna.tsinghua.edu.cn/anaconda</span><span class="hljs-regexp">/pkgs/free</span><span class="hljs-regexp">/<br></span></span>  -<span class="ruby"><span class="hljs-regexp"> https:/</span><span class="hljs-regexp">/mirrors.tuna.tsinghua.edu.cn/anaconda</span><span class="hljs-regexp">/cloud/conda</span>-forge/<br></span>  -<span class="ruby"> <span class="hljs-symbol">https:</span>/<span class="hljs-regexp">/mirrors.tuna.tsinghua.edu.cn/anaconda</span><span class="hljs-regexp">/cloud/pytorch</span><span class="hljs-regexp">/<br></span></span>ssl_verify: true<br></code></pre></td></tr></table></figure>





<h2 id="异常关机导致的conda异常中断"><a href="#异常关机导致的conda异常中断" class="headerlink" title="异常关机导致的conda异常中断"></a>异常关机导致的conda异常中断</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="http://cdn.ziyedy.top/conda%E4%BA%A7%E7%94%9F%E7%9A%84bug%E5%A4%84%E7%90%86/%E5%BC%82%E5%B8%B8%E5%85%B3%E6%9C%BA%E5%AF%BC%E8%87%B4%E7%9A%84conda%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD.png" alt=""></p>
<h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><p>将所有出问题的文件移除</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">rm</span> -rf <span class="hljs-string">"出错文件路径"</span><br></code></pre></td></tr></table></figure>



<h2 id="创建新环境报错"><a href="#创建新环境报错" class="headerlink" title="创建新环境报错"></a>创建新环境报错</h2><h3 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">Collecting package metadata (current_repodata.json): failed<br><br>NotWritableError: The current<span class="hljs-built_in"> user </span>does <span class="hljs-keyword">not</span> have write permissions <span class="hljs-keyword">to</span> a required path.<br>  path: /home/ziyedy/.conda/pkgs/urls.txt<br>  uid: 1000<br>  gid: 1000<br><br><span class="hljs-keyword">If</span> you feel that permissions on this path are <span class="hljs-builtin-name">set</span> incorrectly, you can manually<br>change them by executing<br><br>  $ sudo chown 1000:1000 /home/ziyedy/.conda/pkgs/urls.txt<br><br><span class="hljs-keyword">In</span> general, it<span class="hljs-string">'s not advisable to use '</span>sudo conda<span class="hljs-string">'.</span><br></code></pre></td></tr></table></figure>

<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>按照提示尝试操作没用，解决方法是命令行输入如下：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">sudo chown -R ziyedy anaconda3 # ziyedy is<span class="hljs-built_in"> user </span>name.<br></code></pre></td></tr></table></figure>

<p>参考：<a href="https://blog.csdn.net/PecoHe/article/details/104578700" target="_blank" rel="noopener">https://blog.csdn.net/PecoHe/article/details/104578700</a></p>
<h2 id="无法改变环境"><a href="#无法改变环境" class="headerlink" title="无法改变环境"></a>无法改变环境</h2><p>正常情况下输入<code>conda activate &lt;env_name&gt;</code>时，python应该改变为该环境下的python版本，可以使用<code>python -V</code>查看，但有时命令行显示上环境已经更改但实际上所使用的python解释器没有更换，解决方法如下：</p>
<ol>
<li>使用记事本打开编辑环境（该目录下的.bashrc存储的为个人的一些配置文件，如别名路径）</li>
</ol>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">sudo gedit ~<span class="hljs-string">/.bashrc</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>在末尾按照规律添加如下内容</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-string">"export PATH="</span>~/anaconda3/bin:$PATH"   #base环境下的python，已有的<br>alias <span class="hljs-attribute">python1</span>=<span class="hljs-string">"~/anaconda3/bin/python   # 你需要添加的</span><br></code></pre></td></tr></table></figure>

<p><code>alias</code>用于设置指令的别名，下面一条语句的意思就算你输入python1就会自动指向后面</p>
<ol start="3">
<li>使得修改生效</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> ~/.bashrc<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>conda</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章：应用层</title>
    <url>/page/no2-application-llayer.html</url>
    <content><![CDATA[<h2 id="应用层内容架构"><a href="#应用层内容架构" class="headerlink" title="应用层内容架构"></a>应用层内容架构</h2><p><img src="http://cdn.ziyedy.top/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/%E5%BA%94%E7%94%A8%E5%B1%82%E5%86%85%E5%AE%B9.png" alt=""></p>
<p>图源：<a href="https://blog.csdn.net/qq_39326472/article/details/88089747" target="_blank" rel="noopener">https://blog.csdn.net/qq_39326472/article/details/88089747</a></p>
<h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><blockquote>
<p>网络核心设备并不在应用层上起作用，而仅在较低层起作用</p>
<p>设计核心思想：<strong>将应用软件限制在端系统</strong></p>
</blockquote>
<h3 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h3><h4 id="客户-服务器体系结构"><a href="#客户-服务器体系结构" class="headerlink" title="客户-服务器体系结构"></a>客户-服务器体系结构</h4><p>在该体系结构中，有一个<strong>总是打开</strong>的主机，即服务器，它接收和服务来自其他许多被称为客户的主机请求；值得注意的是，在该体系结构中，<strong>客户之间是不直接通信</strong>的；该服务器具有固定的、周知的地址（IP地址）</p>
<h4 id="P2P体系结构"><a href="#P2P体系结构" class="headerlink" title="P2P体系结构"></a>P2P体系结构</h4><p>应用程序在间断连接的<strong>主机对之间使用直接通信</strong>，这些主机被称为<strong>对等方</strong></p>
<p>该体系结构下，对位于数据中心的专用服务器有着最小（或者没有）依赖。</p>
<p>P2P体系结构最引人入胜的特性之一就是它们的<strong>自扩展性（self-scalability）</strong>（即对等方通过为其他对等方传送文件而为原始拥有者分担压力）</p>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><blockquote>
<p>即<strong>运行在不同端系统上的进程</strong>之间的通信，运行在不同端系统上的进程对之间通过计算机网络来实现通信</p>
</blockquote>
<h4 id="客户与服务器进程"><a href="#客户与服务器进程" class="headerlink" title="客户与服务器进程"></a>客户与服务器进程</h4><p>首先发起通信的进程被标记为客户，在会话开始时等待联系的进程被称为服务器。</p>
<h4 id="进程与计算机网络之间的接口"><a href="#进程与计算机网络之间的接口" class="headerlink" title="进程与计算机网络之间的接口"></a>进程与计算机网络之间的接口</h4><blockquote>
<p>进程通过一个称为<strong>套接字（socket）</strong>的软件接口向网络发送和接收报文。（套接字是同一台主机内应用层与传输层之间的接口）</p>
</blockquote>
<p>应用程序开发者可以控制套接字在应用层的一切内容，但是对于运输层的相关部分，几乎没有控制权<em>（能控制传输层协议的选择，以及设定最大缓存和最大报文长度等几个传输层参数）</em></p>
<h4 id="进程寻址（标识接收方的地址）"><a href="#进程寻址（标识接收方的地址）" class="headerlink" title="进程寻址（标识接收方的地址）"></a>进程寻址（标识接收方的地址）</h4><blockquote>
<p>主机地址（<strong>IP地址</strong>） + 目的主机接收进程的标识符（<strong>端口号</strong>）</p>
</blockquote>
<h3 id="端口个数"><a href="#端口个数" class="headerlink" title="端口个数"></a>端口个数</h3><blockquote>
<p><strong>端口数由两个字节组成，一个字节8个比特位，因此有2的16次方（65536）个端口</strong></p>
</blockquote>
<h3 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h3><blockquote>
<p>传输层协议的特点大致可以从以下这四个方面考量：可靠数据传输、吞吐量、定时和安全性</p>
</blockquote>
<p>从可靠数据传输、吞吐量、定时、安全性等四个角度来看传输层提供的服务，传输层无法对吞吐量和定时做出保证。但是，今天的因特网能够为时间敏感的应用提供满意的服务，尽管它并不提供任何定时或者带宽保证</p>
<h3 id="因特网提供的传输层服务"><a href="#因特网提供的传输层服务" class="headerlink" title="因特网提供的传输层服务"></a>因特网提供的传输层服务</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul>
<li><strong>面向连接的服务</strong></li>
<li><strong>可靠的数据传输</strong></li>
<li>提供了<strong>拥塞控制</strong>机制（不一定会给通行双方带来好处，但是会给网络带来整体好处）</li>
</ul>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><blockquote>
<p>UDP是无连接的也就是说通信之前没有握手；UDP不提供数据的可靠传输；UDP也没有拥塞控制机制。有些应用场景下，UDP协议将带来更多的便利和效率</p>
</blockquote>
<h2 id="WEB和HTTP"><a href="#WEB和HTTP" class="headerlink" title="WEB和HTTP"></a>WEB和HTTP</h2><h3 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h3><blockquote>
<p>HTTP（HyperText Transfer Protocol）是WEB的应用层协议，它是Web的核心；HTTP有两部分实现，一个客户端程序一个服务器程序；HTTP定义了客户和服务器进行报文交换的方法；</p>
</blockquote>
<p>HTTP服务器不存储任何关于该客户的状态信息，因此HTTP被称为<strong>无状态协议</strong></p>
<h3 id="持续连接和非持续连接"><a href="#持续连接和非持续连接" class="headerlink" title="持续连接和非持续连接"></a>持续连接和非持续连接</h3><p>持续连接即<strong>多个对象，一次连接</strong>，HTTP既可使用持续连接也可以使用非持续连接。尽管<strong>HTTP在静默情况下使用持续连接</strong></p>
<p>非持续连接可以理解为<strong>多个对象，多个连接</strong>（比如一个HTML中有10个图片，即需对10个图片均进行一次TCP连接）</p>
<h3 id="HTTP报文格式：请求报文和响应报文"><a href="#HTTP报文格式：请求报文和响应报文" class="headerlink" title="HTTP报文格式：请求报文和响应报文"></a>HTTP报文格式：请求报文和响应报文</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p><img src="http://cdn.ziyedy.top/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt=""></p>
<blockquote>
<p>报文第一行：<strong>请求行</strong>（包括：方法字段、URL字段、HTTP版本），其中方法字段可为：GET、POST、PUT、DELETE、HEAD等</p>
<p>后继各行：<strong>首部行</strong>（包含是否在发送完响应报文后关闭TCP连接的Connection；请求的主机地址（该头部信息被Web高速缓存所要求）；浏览器版本；可接受的语言等头部信息；）</p>
<p>空行（用于分隔）</p>
<p><strong>实体行</strong>：该实体体可以在POST方法里传递Form表单内容或者传递其它一些二进制流数据等</p>
</blockquote>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p><img src="http://cdn.ziyedy.top/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png" alt=""></p>
<blockquote>
<p><strong>状态行</strong>：（HTTP版本、状态码、状态信息）</p>
<p><strong>首部行</strong>：（发送日期、服务器类型、上一次修改请求资源的时间、内容的类型）</p>
<p><strong>实体体</strong>：<strong>实体包含请求对象本身（HTML文件等）</strong>。</p>
</blockquote>
<h3 id="用户与服务器的交互：Cookie"><a href="#用户与服务器的交互：Cookie" class="headerlink" title="用户与服务器的交互：Cookie"></a>用户与服务器的交互：Cookie</h3><p>HTTP是无状态协议，但是Web站点可以使用Cookie技术对用户进行跟踪。Web站点生成一个<strong>唯一标识码</strong>，下次访问该站点时，浏览器就会查询cookie文件并抽取识别码</p>
<p>Cookie技术包含4个组件</p>
<ol>
<li>HTTP响应报文里增加一个关于Cookie的首部行；</li>
<li>HTTP请求报文里增加一个关于Cookie的首部行；</li>
<li>用户端系统保留一个Cookie文件，由浏览器保存维护；</li>
<li>Web站点建立Cookie和用户身份的关联；</li>
</ol>
<h3 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h3><p>Web缓存器（Web cache）也被称为<strong>代理服务器</strong>（proxy server），能够代表初始Web服务器来满足部分HTTP请求的网络实体</p>
<p>当代理服务器收到一个HTTP请求后，它将<em>检查本地是否缓存过该对象</em>，如果缓存过该对象，将<em>检查是否过期</em>（<strong>条件GET方法</strong>，使用GET方法的时候，增加一个<code>If-Modified-Since</code>首部行，其对应的内容是一个时间），如果没有过期，则直接将该对象返回给浏览器；如果本地不存在或者存在已过期，则代理服务器将根据请求报文里的Host首部行以及请求行里的URL字段向初始服务器发出请求，然后将响应对象返回给浏览器并缓存在本地。</p>
<p>因此，<strong>Web缓存器既是服务器又是客户</strong></p>
<h4 id="使用Web缓存器的原因"><a href="#使用Web缓存器的原因" class="headerlink" title="使用Web缓存器的原因"></a>使用Web缓存器的原因</h4><ol>
<li>大大减少对用户请求的响应时间（规避瓶颈带宽）</li>
<li>大大减少一个机构的接入链路到因特网的通行量（节省成本）</li>
</ol>
<h2 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h2><blockquote>
<p>因特网电子邮件系统有三个核心组件：<strong>用户代理</strong>、<strong>邮件服务器</strong>、<strong>SMTP</strong>（简单邮件传输协议，Simple Mail Transfer Protocol）</p>
</blockquote>
<h3 id="SMTP（25号端口）"><a href="#SMTP（25号端口）" class="headerlink" title="SMTP（25号端口）"></a>SMTP（25号端口）</h3><p><strong>传输的三个阶段</strong>：握手、传输、关闭连接</p>
<p>SMTP是<strong>持续连接</strong>的，同时由于继承的问题，它限制邮件报文的所有部分只能使用<strong>7比特的ASCII</strong>表示（导致一些多媒体文件在发送方需要编码，接收方则需要解码）</p>
<h4 id="与HTTP对比"><a href="#与HTTP对比" class="headerlink" title="与HTTP对比"></a>与HTTP对比</h4><p>HTTP和SMTP都是用TCP协议；持续的HTTP和SMTP都是用持续连接；但是两者也有区别：</p>
<ul>
<li>HTTP被设计为一个Pull协议而SMTP被设计为一个Push协议。即用户通过HTTP主动向服务器请求内容，而SMTP则是客户将内容推向服务器端；</li>
<li>HTTP传输的数据不一定是用ASCII字符，但是SMTP则只能使用ASCII字符；</li>
<li>HTTP将每个对象封装在自己的响应报文里，而SMTP则将所有的报文对象放到一个报文之中；</li>
</ul>
<h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><p>需要注意的是，<strong>SMTP是邮件服务器之间发送邮件报文</strong>的协议，并不是用户通过代理和邮件服务器之间通信的协议；用户代理使用邮件访问协议来从邮件服务器上获取邮件信息；目前常用的邮件访问协议有<strong>POP3</strong>（Post Office Protocol-Version 3）、<strong>因特网邮件访问协议</strong>（<strong>IMAP</strong>，Internet Mail Access protocol）和<strong>HTTP</strong></p>
<h2 id="DNS：因特网的目录服务"><a href="#DNS：因特网的目录服务" class="headerlink" title="DNS：因特网的目录服务"></a>DNS：因特网的目录服务</h2><p>DNS（Domain Name System）域名系统，用于处理<strong>主机名和IP地址的转换问题</strong>。</p>
<p>DNS是一个由分层的DNS服务器组成的分布式数据库和一个使得主机可以查询分布式数据库的应用层协议组成</p>
<p><strong>DNS运行在UDP之上</strong>，使用53号端口</p>
<h3 id="DNS工作机理概述"><a href="#DNS工作机理概述" class="headerlink" title="DNS工作机理概述"></a>DNS工作机理概述</h3><p><strong>DNS采用分布式的设计方案</strong></p>
<p>因为单一的DNS服务器无法解决<em>单点故障</em>、<em>保证通信容量</em>、<em>邻近所有的查询主机</em>和<em>维护困难</em>等问题</p>
<h4 id="分布式层次的数据库"><a href="#分布式层次的数据库" class="headerlink" title="分布式层次的数据库"></a>分布式层次的数据库</h4><p>为了处理扩展性问题，DNS服务器采用层次式组织，并且分布在全世界范围内；大致来说，存在三种DNS服务器：<strong>根DNS服务器</strong>、<strong>顶级域DNS服务器</strong>和<strong>权威DNS服务器</strong></p>
<table>
<thead>
<tr>
<th>分类</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>根DNS服务器</td>
<td>因特网上有13个根DNS服务器</td>
</tr>
<tr>
<td>顶级域DNS服务器</td>
<td>负责顶级域名，如com，org，net，edu，gov以及各个国家的顶级域名的转换</td>
</tr>
<tr>
<td>权威DNS服务器</td>
<td>如大学、公司等公共可访问的DNS记录</td>
</tr>
<tr>
<td><strong>本地DNS服务器</strong></td>
<td>最重要的DNS服务器，当主机发出DNS请求时，该请求被发往本地DNS服务器，它起着<strong>代理</strong>的作用，并将请求转发到DNS服务器层次结构中</td>
</tr>
</tbody></table>
<img src="http://cdn.ziyedy.top/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/DNS%E5%9F%9F%E5%90%8D%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.png" style="zoom:80%;" />

<h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><p>DNS查询有两种，一种是<strong>递归查询</strong>一种是<strong>迭代查询</strong></p>
<p>实践中，查询通常满足这样的模式：<strong>从请求主机到本地DNS服务器的查询是递归的，其余查询是迭代的</strong>。</p>
<p>因此，域名解析过程具体可以描述如下：</p>
<ol>
<li>主机先向本地域名服务器进行递归查询</li>
<li>本地域名服务器采用迭代查询，向一个根域名服务器进行查询</li>
<li>根域名服务器告诉本地域名服务器，下一次应该查询的顶级域名服务器的IP地址</li>
<li>本地域名服务器向顶级域名服务器进行查询</li>
<li>顶级域名服务器告诉本地域名服务器，下一步查询权限服务器的IP地址</li>
<li>本地域名服务器向权限服务器进行查询</li>
<li>权限服务器告诉本地域名服务器所查询的主机的IP地址</li>
<li>本地域名服务器最后把查询结果告诉主机</li>
</ol>
<h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><p>当某DNS服务器接收一个DNS回答时，其将映射缓存到本地存储器中</p>
<p><strong>由于缓存，除了少数DNS查询以外，根服务器被绕过了</strong></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>《计算机网络——自顶向下方法》</p>
<p><a href="https://blog.csdn.net/qq_39326472/article/details/88089747" target="_blank" rel="noopener">https://blog.csdn.net/qq_39326472/article/details/88089747</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发五：广播机制</title>
    <url>/page/Android5-broadcast.html</url>
    <content><![CDATA[<h2 id="接收系统广播"><a href="#接收系统广播" class="headerlink" title="接收系统广播"></a>接收系统广播</h2><h3 id="动态注册（app运行时能够进行接收）"><a href="#动态注册（app运行时能够进行接收）" class="headerlink" title="动态注册（app运行时能够进行接收）"></a>动态注册（app运行时能够进行接收）</h3><ol>
<li>创建一个广播接收器</li>
</ol>
<blockquote>
<p>新建一个继承自 <code>BroadcastReceiver</code>的类，并重写父类的 <code>onReceive()</code> 方法</p>
</blockquote>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NetworkChangeReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BroadcastReceiver</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    public void onReceive(<span class="hljs-type">Context</span> context, <span class="hljs-type">Intent</span> intent) &#123;<br>    	<span class="hljs-comment">// 若检测到变化，则弹出相关信息</span><br>        <span class="hljs-type">Toast</span>.makeText(context, <span class="hljs-string">"network changes"</span>, <span class="hljs-type">Toast</span>.<span class="hljs-type">LENGTH_SHORT</span>).show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>在<code>onCreate()</code>中创建一个<code>IntentFilter</code>实例，并使用<code>addAction()</code>添加系统发送的广播（<code>action1</code>）。之后创建一个步骤1类的实例。调用<code>registerReceiver()</code>方法将<code>NetworkChangeReceiver</code>的实例与<code>IntentFilter</code>的实例都传进去，即可<strong>使得<code>NetworkChangeReceiver</code>接收到对应的<code>action1</code></strong></li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> IntentFilter intentFilter;<br><span class="hljs-keyword">private</span> NetworkChangeReceive networkChangeReceive;<br><br>@Override<br>protected void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;<br>    super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span>;<br>    set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_main</span>)</span>;<br>    intentFilter = <span class="hljs-keyword">new</span> <span class="hljs-constructor">IntentFilter()</span>;<br>    intentFilter.add<span class="hljs-constructor">Action(<span class="hljs-string">"android.net.conn.CONNECTIVITY_CHANGE"</span>)</span>;	<span class="hljs-comment">// 添加需要监听的广播</span><br>    networkChangeReceive = <span class="hljs-keyword">new</span> <span class="hljs-constructor">NetworkChangeReceive()</span>;<br>    register<span class="hljs-constructor">Receiver(<span class="hljs-params">networkChangeReceive</span>, <span class="hljs-params">intentFilter</span>)</span>;	<span class="hljs-comment">// 绑定</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>动态注册的广播接收器一定都要取消注册才行，在<code>onDestroy()</code>方法中通过调用<code>unregisterReceiver()</code>方法来实现</li>
</ol>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">onDestroy</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onDestroy();<br>    unregisterReceiver(networkChangeReceive);<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>在<code>AndroidManifest.xml</code>中声明权限</li>
</ol>
<blockquote>
<p>注：如果程序需要进行一些对用户来说比较敏感的操作，就必须在配置文件中声明权限才可以，否则程序将会直接崩溃</p>
</blockquote>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">&lt;uses-permission android:<span class="hljs-built_in">name</span>=<span class="hljs-string">"填入相关权限"</span> /&gt;<br></code></pre></td></tr></table></figure>

<h3 id="静态注册（开机启动）"><a href="#静态注册（开机启动）" class="headerlink" title="静态注册（开机启动）"></a>静态注册（开机启动）</h3><ol>
<li><p>右击 com.example.broadcasttest 包 →New→Other→ Broadcast Receiver，创建一个广播接收器</p>
</li>
<li><p>重写<code>onReceive()</code>方法</p>
</li>
<li><p>在<code>AndroidManifest.xml</code>文件中注册（AS通常情况会自动注册）</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 声明权限 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">uses-permission</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.permission.RECEIVE_BOOT_COMPLETED"</span> /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span><br>    <span class="hljs-attr">android:name</span>=<span class="hljs-string">".BootCompleteReceiver"</span><br>    <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">"true"</span><br>    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">"true"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>    	<span class="hljs-comment">&lt;!-- 开机启动 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.action.BOOT_COMPLETED"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="自定义广播"><a href="#自定义广播" class="headerlink" title="自定义广播"></a>自定义广播</h2><h3 id="发送标准广播"><a href="#发送标准广播" class="headerlink" title="发送标准广播"></a>发送标准广播</h3><ol>
<li>定义接收器（与上一部分一样）</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BroadcastReceiver</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    public void onReceive(<span class="hljs-type">Context</span> context, <span class="hljs-type">Intent</span> intent) &#123;<br>        <span class="hljs-type">Toast</span>.makeText(context, <span class="hljs-string">"received in MyReceiver"</span>, <span class="hljs-type">Toast</span>.<span class="hljs-type">LENGTH_SHORT</span>).show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>在<code>AndroidManifest.xml</code>中对事件接收器进行注册（注册接收什么事件）</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span><br>    <span class="hljs-attr">android:name</span>=<span class="hljs-string">".MyReceiver"</span><br>    <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">"true"</span><br>    <span class="hljs-attr">android:exported</span>=<span class="hljs-string">"true"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>    	<span class="hljs-comment">&lt;!-- 接收名为MY_BROADCAST的广播 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.example.broadcasttest.MY_BROADCAST"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>定义发送广播（名称与接收处一致，此处以点击事件作为例子）。首先构建一个<code>Intent</code>对象，并传入广播值，之后调用<code>sendBroadcast()</code>方法将广播发送出去（此时所有监听该广播的广播接收器就会收到消息）</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">@Override<br>public void on<span class="hljs-constructor">Click(View <span class="hljs-params">view</span>)</span> &#123;<br>    Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent(<span class="hljs-string">"com.example.broadcasttest.MY_BROADCAST"</span>)</span>;<br>    send<span class="hljs-constructor">Broadcast(<span class="hljs-params">intent</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="发送有序广播"><a href="#发送有序广播" class="headerlink" title="发送有序广播"></a>发送有序广播</h3><blockquote>
<p>广播是一种可以跨进程的通信方式，即在我们应用程序内发出的广播，其他的应用程序应该也可以收到</p>
</blockquote>
<p>发送有序广播只需要改变广播发送的代码为<code>sendOrderedBroadcast()</code>，传入Intent和与权限相关的字符串。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">send<span class="hljs-constructor">OrderedBroadcast(<span class="hljs-params">intent</span>, <span class="hljs-params">null</span>)</span>;<br></code></pre></td></tr></table></figure>

<h4 id="设置广播接收器的先后顺序"><a href="#设置广播接收器的先后顺序" class="headerlink" title="设置广播接收器的先后顺序"></a>设置广播接收器的先后顺序</h4><p>如下，使用<code>android:priority</code>设置优先级为100</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span> <span class="hljs-attr">android:priority</span>=<span class="hljs-string">"100"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.example.broadcasttest.MY_BROADCAST"</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="中断广播"><a href="#中断广播" class="headerlink" title="中断广播"></a>中断广播</h4><p>在<code>onReceive()</code>方法中调用了<code>abortBroadcast()</code>方法，就表示将这条广播截断，后面的广播接收器将无法再接收到这条广播。</p>
<h2 id="本地广播"><a href="#本地广播" class="headerlink" title="本地广播"></a>本地广播</h2><blockquote>
<p><strong>本地广播机制</strong>：使用这个机制发出的广播只能够在应用程序的内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播</p>
</blockquote>
<blockquote>
<p><strong>本地广播使用</strong>：使用一个<code>LocalBroadcastManager</code>来对广播进行管理，并提供了发送广播和注册广播接收器的方法（<em>与动态注册广播流程基本一致</em>）</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">LocalBroadcastManager localBroadcastManager;<br>localBroadcastManager = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LocalBroadcastManager</span>.</span></span>get<span class="hljs-constructor">Instance(<span class="hljs-params">this</span>)</span>;	<span class="hljs-comment">// 获取实例</span><br>localBroadcastManager.send<span class="hljs-constructor">Broadcast(<span class="hljs-params">intent</span>)</span>;	<span class="hljs-comment">// 发送本地广播</span><br>localBroadcastManager.register<span class="hljs-constructor">Receiver(<span class="hljs-params">localReceiver</span>, <span class="hljs-params">intentFilter</span>)</span>; 	<span class="hljs-comment">// 注册本地广播监听器</span><br></code></pre></td></tr></table></figure>

















]]></content>
      <categories>
        <category>移动端</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发四：碎片（Fragment）</title>
    <url>/page/Android4-fragment.html</url>
    <content><![CDATA[<h2 id="碎片的基本使用"><a href="#碎片的基本使用" class="headerlink" title="碎片的基本使用"></a>碎片的基本使用</h2><blockquote>
<p>碎片是一种可嵌入在活动当中的UI片段，能让程序更加合理充分的利用大屏幕空间（常应用在平板上）</p>
</blockquote>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol>
<li>新建一个碎片布局（xml文件）</li>
<li>新建一个<code>LeftFragment</code>类，并让它继承自 <code>Fragment</code>，并重写<code>onCreateView()</code>方法（将刚刚新建的布局文件加载进来）</li>
</ol>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RightFragment</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fragment</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    public <span class="hljs-type">View</span> onCreateView(<span class="hljs-type">LayoutInflater</span> inflater, <span class="hljs-type">ViewGroup</span> container,<br>                             <span class="hljs-type">Bundle</span> savedInstanceState) &#123;<br>        <span class="hljs-type">View</span> view = inflater.inflate(<span class="hljs-type">R</span>.layout.right_fragment, container, <span class="hljs-literal">false</span>);<br>        <span class="hljs-keyword">return</span> view;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="3">
<li>使用<code>&lt;fragment&gt;</code>标签在<em>主布局</em>中添加碎片，通过 <code>android:name</code>属性来显式指明要添加的碎片类名</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;fragment<br>    android:<span class="hljs-attribute">id</span>=<span class="hljs-string">"@+id/right_fragment"</span><br>    android:<span class="hljs-attribute">name</span>=<span class="hljs-string">"com.example.fragmenttest.RightFragment"</span><br>    android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">"0dp"</span><br>    android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">"match_parent"</span><br>    android:<span class="hljs-attribute">layout_weight</span>=<span class="hljs-string">"1"</span> /&gt;<br></code></pre></td></tr></table></figure>



<h3 id="动态添加碎片"><a href="#动态添加碎片" class="headerlink" title="动态添加碎片"></a>动态添加碎片</h3><ol>
<li>创建待添加的碎片实例</li>
<li>获取 <code>FragmentManager</code> ，在活动中可以直接通过调用 <code>getSupportFragmentManager()</code> 方法得到</li>
<li>通过调用<code>beginTransaction()</code>方法开启一个事务</li>
<li>向容器内添加或替换碎片，一般使用<code>replace()</code>方法实现，需要传入<em>容器</em>的 id 和待添加的碎片实例</li>
<li>调用<code>commit()</code>方法来提交事务</li>
</ol>
<p><em>实现动态添加碎片如下：</em></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> void replace<span class="hljs-constructor">Fragment(Fragment <span class="hljs-params">fragment</span>)</span> &#123;<br>    FragmentManager fragmentManager = get<span class="hljs-constructor">SupportFragmentManager()</span>;<br>    FragmentTransaction transaction = fragmentManager.<span class="hljs-keyword">begin</span><span class="hljs-constructor">Transaction()</span>;<br>    transaction.replace(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>id.right_layout, fragment);<br>    <span class="hljs-comment">// transaction.addToBackStack(null);	// 将该事务添加到返回栈</span><br>    transaction.commit<span class="hljs-literal">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="碎片与活动之间的通信"><a href="#碎片与活动之间的通信" class="headerlink" title="碎片与活动之间的通信"></a>碎片与活动之间的通信</h3><h4 id="在碎片中获取活动"><a href="#在碎片中获取活动" class="headerlink" title="在碎片中获取活动"></a>在碎片中获取活动</h4><p>使用<code>getActivity()</code>方法来得到与当前碎片相关联的活动实例</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><code class="hljs lisp">MainActivity activity = (<span class="hljs-name">MainActivity</span>) getActivity()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h4 id="在活动中获取碎片"><a href="#在活动中获取碎片" class="headerlink" title="在活动中获取碎片"></a>在活动中获取碎片</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">RightFragment rightFragment = (RightFragment) get<span class="hljs-constructor">SupportFragmentManager()</span>.find<span class="hljs-constructor">FragmentById(R.<span class="hljs-params">id</span>.<span class="hljs-params">right_fragment</span>)</span>;<br></code></pre></td></tr></table></figure>



<h2 id="动态加载布局"><a href="#动态加载布局" class="headerlink" title="动态加载布局"></a>动态加载布局</h2><blockquote>
<p>使程序根据设备的分辨率或屏幕大小在运行时来决定加载哪个布局</p>
</blockquote>
<h3 id="限定符（Qualifiers）"><a href="#限定符（Qualifiers）" class="headerlink" title="限定符（Qualifiers）"></a>限定符（Qualifiers）</h3><p>可以简单理解为在资源文件夹名字之后添加的关键字</p>
<h4 id="常用限定符"><a href="#常用限定符" class="headerlink" title="常用限定符"></a>常用限定符</h4><table>
<thead>
<tr>
<th>屏幕特征</th>
<th>限定符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>大小</td>
<td>small</td>
<td>提供给小屏幕设备</td>
</tr>
<tr>
<td></td>
<td>large</td>
<td>提供给大屏幕设备</td>
</tr>
<tr>
<td>分辨率</td>
<td>ldpi</td>
<td>120dpi以下的设备</td>
</tr>
<tr>
<td></td>
<td>mdpi</td>
<td>120-160dpi的设备</td>
</tr>
<tr>
<td></td>
<td>hdpi</td>
<td>160-240dpi的设别</td>
</tr>
<tr>
<td>方向</td>
<td>land</td>
<td>横屏设备</td>
</tr>
<tr>
<td></td>
<td>port</td>
<td>竖屏设备</td>
</tr>
</tbody></table>
<h4 id="最小宽度限定符（Smallest-width-Qualifier）"><a href="#最小宽度限定符（Smallest-width-Qualifier）" class="headerlink" title="最小宽度限定符（Smallest-width Qualifier）"></a>最小宽度限定符（Smallest-width Qualifier）</h4><p><strong>以 dp 为单位</strong>，如新建<code>layout-sw 600dp</code>文件夹，当程序运行在屏幕宽度大于 600dp 的设备上时，则会加载 <code>layout-sw 600dp/activity_main</code>布局</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在 res 目录下新建<code>layout-large</code>文件夹，并新建布局<code>activity_main.xml</code>。之后在两个<code>activity_main.xml</code>中分别写入布局信息</p>
<ul>
<li>当使用平板运行时，会使用<code>layout-large</code>中的布局信息</li>
<li>当使用手机运行时，会使用<code>layout</code>中的布局信息</li>
</ul>
]]></content>
      <categories>
        <category>移动端</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发三：布局（layout）</title>
    <url>/page/Android3-layout.html</url>
    <content><![CDATA[<h2 id="Android常用控件"><a href="#Android常用控件" class="headerlink" title="Android常用控件"></a>Android常用控件</h2><h3 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h3><blockquote>
<p>在界面上显示一段文本信息</p>
</blockquote>
<h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h4> <figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">android:</span>text=<span class="hljs-string">"TextView"</span>		显示的文本<br><span class="hljs-symbol">android:</span>gravity=<span class="hljs-string">"center"</span>	对齐方式<br><span class="hljs-symbol">android:</span>textSize=<span class="hljs-string">"30sp"</span>		文字大小<br><span class="hljs-symbol">android:</span>textColor=<span class="hljs-string">"#03A9F4"</span>	文字颜色<br></code></pre></td></tr></table></figure>

<p><img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%B8%89%EF%BC%9A%E5%B8%83%E5%B1%80%EF%BC%88layout%EF%BC%89/TextView.png" alt=""></p>
<h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3><blockquote>
<p>配置一个按钮，默认全为大写</p>
</blockquote>
<h4 id="常用属性-1"><a href="#常用属性-1" class="headerlink" title="常用属性"></a>常用属性</h4><p>常用属性与TextView类似</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">android:</span>textAllCaps=<span class="hljs-string">"false"</span>		将默认文字全部大写关掉<br></code></pre></td></tr></table></figure>

<h4 id="绑定逻辑代码（注册监听器）"><a href="#绑定逻辑代码（注册监听器）" class="headerlink" title="绑定逻辑代码（注册监听器）"></a>绑定逻辑代码（注册监听器）</h4><p><strong>使用匿名类的写法，不需要对view进行判断</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">@Override<br>protected void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;<br>    super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span>;<br>    set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_main</span>)</span>;<br>    Button button = (Button) find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">button</span>)</span>;<br>    button.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">new</span> View.OnClickListener()</span> &#123;<br>        @Override<br>        public void on<span class="hljs-constructor">Click(View <span class="hljs-params">view</span>)</span> &#123;<br>            <span class="hljs-comment">// 添加逻辑代码</span><br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>使用实现View.OnClickListener接口的方法</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">View</span>.<span class="hljs-title">OnClickListener</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    setContentView(R.layout.activity_main);<br>    Button button = (Button) findViewById(R.id.button);<br>    button.setOnClickListener(<span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View v)</span> </span>&#123;<br>    <span class="hljs-keyword">switch</span> (v.getId()) &#123;	<span class="hljs-comment">// 判断触发监听器的是哪个按钮</span><br>        <span class="hljs-keyword">case</span> R.id.button:<br>            <span class="hljs-comment">// 添加逻辑代码</span><br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">default</span>:<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h3><blockquote>
<p>允许用户在控件里输入和编辑内容，并可以在程序中对这些内容进行处理</p>
</blockquote>
<h4 id="常用属性-2"><a href="#常用属性-2" class="headerlink" title="常用属性"></a>常用属性</h4><figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">android:</span>hint=<span class="hljs-string">"Type something here"</span>	输入时的提示信息<br><span class="hljs-symbol">android:</span>maxLines=<span class="hljs-string">"1"</span>	指定最大行数（如密码输入框最大行数为<span class="hljs-number">1</span>），大于最大行数向下滚动<br></code></pre></td></tr></table></figure>

<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">getText</span><span class="hljs-params">()</span></span>	<span class="hljs-comment">// 获取输入的内容</span><br></code></pre></td></tr></table></figure>



<h3 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h3><blockquote>
<p>在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此 AlertDialog 一般都是用于提示一些非常重要的内容或者警告信息</p>
</blockquote>
<h4 id="对话框使用流程"><a href="#对话框使用流程" class="headerlink" title="对话框使用流程"></a>对话框使用流程</h4><ol>
<li>通过<code>AlertDialog.Builder</code>创建一个 AlertDialog 的实例</li>
<li>为这个对话框设置标题、内容（<code>setMessage</code>）、可否用 Back 键关闭对话框（<code>setCancelable</code>）等属性</li>
<li>调用 setPositiveButton() 方法为对话框设置确定按钮的点击事件，调用 setNegativeButton() 方法设置取消按钮的点击事件</li>
<li>调用 show()方法将对话框显示出来</li>
</ol>
<h4 id="点击按钮将EditText在对话框中弹出"><a href="#点击按钮将EditText在对话框中弹出" class="headerlink" title="点击按钮将EditText在对话框中弹出"></a>点击按钮将EditText在对话框中弹出</h4><p>该示例需要使用到按钮点击事件，从EditText获取内容，及AlertDialog的相关操作。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> MainActivity extends AppCompatActivity implements View.OnClickListener &#123;<br><br>    <span class="hljs-keyword">private</span> EditText editText;<br><br>    @Override<br>    protected void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;<br>        super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span>;<br>        set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_main</span>)</span>;<br>        Button button = (Button) find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">button</span>)</span>;<br>        editText = (EditText) find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">edit_text</span>)</span>;<br>        button.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">this</span>)</span>;<br>    &#125;<br><br><br>    @Override<br>    public void on<span class="hljs-constructor">Click(View <span class="hljs-params">v</span>)</span> &#123;<br>        switch (v.get<span class="hljs-constructor">Id()</span>) &#123;<br>            case <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>id.button:<br>                String inputText = editText.get<span class="hljs-constructor">Text()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;	<span class="hljs-comment">// 获取输入内容</span><br>                AlertDialog.Builder dialog = <span class="hljs-keyword">new</span> AlertDialog.<span class="hljs-constructor">Builder(MainActivity.<span class="hljs-params">this</span>)</span>;<br>                dialog.set<span class="hljs-constructor">Message(<span class="hljs-params">inputText</span>)</span>;<br>                dialog.set<span class="hljs-constructor">Cancelable(<span class="hljs-params">false</span>)</span>;<br>                dialog.set<span class="hljs-constructor">PositiveButton(<span class="hljs-string">"OK"</span>, <span class="hljs-params">new</span> DialogInterface.OnClickListener()</span> &#123;<br>                    @Override<br>                    public void on<span class="hljs-constructor">Click(DialogInterface <span class="hljs-params">dialogInterface</span>, <span class="hljs-params">int</span> <span class="hljs-params">i</span>)</span> &#123;<br><br>                    &#125;<br>                &#125;);<br>                dialog.set<span class="hljs-constructor">NegativeButton(<span class="hljs-string">"Cancel"</span>, <span class="hljs-params">new</span> DialogInterface.OnClickListener()</span> &#123;<br>                    @Override<br>                    public void on<span class="hljs-constructor">Click(DialogInterface <span class="hljs-params">dialogInterface</span>, <span class="hljs-params">int</span> <span class="hljs-params">i</span>)</span> &#123;<br><br>                    &#125;<br>                &#125;);<br>                dialog.show<span class="hljs-literal">()</span>;<br>                break;<br>            default:<br>                break;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%B8%89%EF%BC%9A%E5%B8%83%E5%B1%80%EF%BC%88layout%EF%BC%89/%E8%BE%93%E5%85%A5%E6%A1%86%E5%BC%B9%E5%87%BA%E6%95%88%E6%9E%9C.png" style="zoom:67%;" />



<h3 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h3><blockquote>
<p>在界面上展示图片的一个控件</p>
<p>图片通常放置在以 “drawable” 开头的目录下（drawable后会跟具体的分辨率）</p>
</blockquote>
<h4 id="常用属性和方法"><a href="#常用属性和方法" class="headerlink" title="常用属性和方法"></a>常用属性和方法</h4><figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">android:</span>src=<span class="hljs-string">"@drawable/img_1 "</span>	指定显示图片的位置<br></code></pre></td></tr></table></figure>

<p>在代码中可以使用<code>setImageResource(R.drawable.img_2)</code>来指定图片的位置</p>
<h3 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h3><blockquote>
<p>在界面上显示一个进度条，表示我们的程序正在加载一些数据</p>
</blockquote>
<h4 id="常用属性-3"><a href="#常用属性-3" class="headerlink" title="常用属性"></a>常用属性</h4><figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">style</span>=<span class="hljs-string">"?android:attr/progressBarStyleHorizontal"</span>	使用<span class="hljs-built_in">style</span>属性改变进度条的样式（该行为指定为水平条状）<br>android:<span class="hljs-built_in">max</span>=<span class="hljs-string">"100"</span>	<span class="hljs-built_in">max</span>设置进度条最大值<br></code></pre></td></tr></table></figure>

<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">getVisibility</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">setVisibility</span><span class="hljs-params">(View.VISIBLE)</span></span>	<span class="hljs-comment">// 设置可见度</span><br><span class="hljs-function"><span class="hljs-title">getProgress</span><span class="hljs-params">()</span></span>	<span class="hljs-comment">// 获取进度条进度</span><br><span class="hljs-function"><span class="hljs-title">setProgress</span><span class="hljs-params">(progress)</span></span>	<span class="hljs-comment">// 更改进度条进度</span><br></code></pre></td></tr></table></figure>



<h3 id="ProgressDialog"><a href="#ProgressDialog" class="headerlink" title="ProgressDialog"></a>ProgressDialog</h3><blockquote>
<p>与<code>AlertDialog</code>类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力</p>
<p>不同的是，ProgressDialog 会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待</p>
<p><strong>用法和 AlertDialog 也相似</strong></p>
<p>可以使用<code>dismiss()</code> 方法来关闭对话框</p>
</blockquote>
<h2 id="滚动控件（ListView与RecyclerView）"><a href="#滚动控件（ListView与RecyclerView）" class="headerlink" title="滚动控件（ListView与RecyclerView）"></a>滚动控件（ListView与RecyclerView）</h2><h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><blockquote>
<p>ListView 允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕（如聊天记录等等）</p>
</blockquote>
<h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><ol>
<li>编写相关的布局代码</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;ListView<br>	android:<span class="hljs-attribute">id</span>=<span class="hljs-string">"@+id/list_view"</span><br>	android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">"match_parent"</span><br>	android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">"match_parent"</span> /&gt;<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>定义数据，并使用<code>ArrayAdapter</code>适配器将要适配的数据传入</li>
</ol>
<blockquote>
<p><code>ArrayAdapter</code>可以指定数据泛型。</p>
<p>参数分别为<code>(当前上下文, ListView 子项布局的 id, 要适配的数据)</code></p>
</blockquote>
<ol start="3">
<li>调用 ListView 的<code>setAdapter()</code>方法，将构建好的适配器对象传递进去，建立ListView与数据的关联</li>
</ol>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> String<span class="hljs-literal">[]</span> data = &#123; <span class="hljs-string">"Apple"</span>, <span class="hljs-string">"Banana"</span>, <span class="hljs-string">"Orange"</span>, <span class="hljs-string">"Watermelon"</span>,<br>            <span class="hljs-string">"Pear"</span>, <span class="hljs-string">"Grape"</span>, <span class="hljs-string">"Pineapple"</span>, <span class="hljs-string">"Strawberry"</span>, <span class="hljs-string">"Cherry"</span>, <span class="hljs-string">"Mango"</span>,<br>            <span class="hljs-string">"Apple"</span>, <span class="hljs-string">"Banana"</span>, <span class="hljs-string">"Orange"</span>, <span class="hljs-string">"Watermelon"</span>, <span class="hljs-string">"Pear"</span>, <span class="hljs-string">"Grape"</span>,<br>            <span class="hljs-string">"Pineapple"</span>, <span class="hljs-string">"Strawberry"</span>, <span class="hljs-string">"Cherry"</span>, <span class="hljs-string">"Mango"</span> &#125;;<br><br>@Override<br>protected void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;<br>    super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span>;<br>    set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">activity_main</span>)</span>;<br>	<span class="hljs-comment">// 使用适配器</span><br>    ArrayAdapter&lt;String&gt; adapter = <span class="hljs-keyword">new</span> ArrayAdapter&lt;&gt;(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">MainActivity</span>.</span></span>this,<br>                android.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>layout.simple_list_item_1, data);<br>    ListView listView = (ListView) find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">list_view</span>)</span>;<br>    listView.set<span class="hljs-constructor">Adapter(<span class="hljs-params">adapter</span>)</span>;	<span class="hljs-comment">// 传入适配器</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>显示效果如下</strong></p>
<img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%B8%89%EF%BC%9A%E5%B8%83%E5%B1%80%EF%BC%88layout%EF%BC%89/ListView%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.png" style="zoom: 50%;" />



<h4 id="自定义ListView界面"><a href="#自定义ListView界面" class="headerlink" title="自定义ListView界面"></a>自定义ListView界面</h4><blockquote>
<p>1、自定义 ListView 子项布局的样式（即写一个layout的xml）</p>
<p>2、写一个实例类，用于作为列表项的泛型</p>
<p>3、创建一个自定义的适配器，这个适配器继承自 ArrayAdapter。重写构造方法与getView()等方法</p>
<p>4、按ListView的基础用法在主活动中引入即可</p>
</blockquote>
<h4 id="ListView的点击事件"><a href="#ListView的点击事件" class="headerlink" title="ListView的点击事件"></a>ListView的点击事件</h4><p><strong>标准写法如下：<code>setOnItemClickListener</code></strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">listView.set<span class="hljs-constructor">OnItemClickListener(<span class="hljs-params">new</span> AdapterView.OnItemClickListener()</span> &#123;<br>    @Override<br>    public void on<span class="hljs-constructor">ItemClick(AdapterView&lt;?&gt; <span class="hljs-params">parent</span>, View <span class="hljs-params">view</span>, <span class="hljs-params">int</span> <span class="hljs-params">position</span>, <span class="hljs-params">long</span> <span class="hljs-params">id</span>)</span> &#123;<br>    	<span class="hljs-comment">// position指列表中点击的索引</span><br>        <span class="hljs-comment">// 添加逻辑代码</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>



<h3 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h3><blockquote>
<p>加强版的ListView，更推荐使用</p>
<p>ListView 的布局排列是由自身去管理的，而 RecyclerView 则将这个工作交给了<code>LayoutManager</code>等接口，因此在布局上非常方便</p>
</blockquote>
<h4 id="标准使用"><a href="#标准使用" class="headerlink" title="标准使用"></a>标准使用</h4><blockquote>
<p>与ListView相比不同之处在于<code>setLayoutManager</code>设置了“滚动方式”</p>
</blockquote>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">RecyclerView recyclerView = (RecyclerView) find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">recycler_view</span>)</span>;<br><br>LinearLayoutManager layoutManager = <span class="hljs-keyword">new</span> <span class="hljs-constructor">LinearLayoutManager(<span class="hljs-params">this</span>)</span>;<br>layoutManager.set<span class="hljs-constructor">Orientation(LinearLayoutManager.HORIZONTAL)</span>;	<span class="hljs-comment">// 设置滚动方式（此处设置为水平）</span><br>recyclerView.set<span class="hljs-constructor">LayoutManager(<span class="hljs-params">layoutManager</span>)</span>;	<span class="hljs-comment">// 设置LinearLayoutManager对象</span><br>FruitAdapter adapter = <span class="hljs-keyword">new</span> <span class="hljs-constructor">FruitAdapter(<span class="hljs-params">fruitList</span>)</span>;<br>recyclerView.set<span class="hljs-constructor">Adapter(<span class="hljs-params">adapter</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>除此之外，还可以通过<code>GridLayoutManager</code>与<code>StaggeredGridLayoutManager</code>这两种方式实现网格布局和瀑布流布局</p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="常用布局属性"><a href="#常用布局属性" class="headerlink" title="常用布局属性"></a>常用布局属性</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">android:layout_width=<span class="hljs-string">"match_parent"</span>		表示<span class="hljs-built_in">width</span>与父布局的<span class="hljs-built_in">width</span>相同<br>android:layout_height=<span class="hljs-string">"wrap_content"</span>	表示<span class="hljs-built_in">height</span>刚好能够容纳内容<br></code></pre></td></tr></table></figure>



<h3 id="线性布局（LinearLayout）"><a href="#线性布局（LinearLayout）" class="headerlink" title="线性布局（LinearLayout）"></a>线性布局（LinearLayout）</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span><br>    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"horizontal"</span>    <br>    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span><br>    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>&gt;</span><br>        <br>	<span class="hljs-comment">&lt;!-- 添加布局内部的组件 --&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="常用属性-4"><a href="#常用属性-4" class="headerlink" title="常用属性"></a>常用属性</h4><figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">android:</span>orientation=<span class="hljs-string">"horizontal"</span>	指定是水平还是垂直（horizontal与vertical可选）<br><span class="hljs-symbol">android:</span>layout _gravity		指定布局内控件的对齐方式<br><span class="hljs-symbol">android:</span>layout _weight		使用比例的方式来指定控件的大小（即将所有控件按比例指定长宽大小）<br></code></pre></td></tr></table></figure>

<h4 id="layout-weight示例"><a href="#layout-weight示例" class="headerlink" title="layout_weight示例"></a>layout_weight示例</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span><br>    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">"horizontal"</span><br>    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"match_parent"</span><br>    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"match_parent"</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">EditText</span><br>    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/edit_text"</span><br>    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"0dp"</span><br>    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span><br>    <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">"3"</span><br>    /&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span><br>    <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/button"</span><br>    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">"0dp"</span><br>    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">"wrap_content"</span><br>    <span class="hljs-attr">android:text</span>=<span class="hljs-string">"send"</span><br>    <span class="hljs-attr">android:layout_weight</span>=<span class="hljs-string">"1"</span><br>    /&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%B8%89%EF%BC%9A%E5%B8%83%E5%B1%80%EF%BC%88layout%EF%BC%89/layout-weight%E6%95%88%E6%9E%9C.png" alt="layout-weight：3比1的效果"></p>
<h3 id="相对布局（RelativeLayout）"><a href="#相对布局（RelativeLayout）" class="headerlink" title="相对布局（RelativeLayout）"></a>相对布局（RelativeLayout）</h3><blockquote>
<p>相对布局较为灵活，可以通过相对定位的方式让控件出现在布局的任何位置</p>
</blockquote>
<h4 id="相对于父布局定位"><a href="#相对于父布局定位" class="headerlink" title="相对于父布局定位"></a>相对于父布局定位</h4><img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%B8%89%EF%BC%9A%E5%B8%83%E5%B1%80%EF%BC%88layout%EF%BC%89/%E7%9B%B8%E5%AF%B9%E7%88%B6%E5%B8%83%E5%B1%80.png" style="zoom: 50%;" />



<h4 id="相对于控件定位"><a href="#相对于控件定位" class="headerlink" title="相对于控件定位"></a>相对于控件定位</h4><img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%B8%89%EF%BC%9A%E5%B8%83%E5%B1%80%EF%BC%88layout%EF%BC%89/%E7%9B%B8%E5%AF%B9%E6%8E%A7%E4%BB%B6.png" style="zoom:50%;" />



<h3 id="帧布局（FrameLayout）"><a href="#帧布局（FrameLayout）" class="headerlink" title="帧布局（FrameLayout）"></a>帧布局（FrameLayout）</h3><blockquote>
<p>所有的控件都会默认摆放在布局的左上角，应用很少</p>
</blockquote>
<h3 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h3><blockquote>
<p>百分比布局为 FrameLayout 和 RelativeLayout 进行了<strong>功能扩展</strong>，提供了 PercentFrameLayout 和 PercentRelativeLayout 这两个全新的布局</p>
</blockquote>
<h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><h3 id="引入布局"><a href="#引入布局" class="headerlink" title="引入布局"></a>引入布局</h3><blockquote>
<p>引入布局即新建一个布局文件，并在“主布局文件中”进行引用，达到<strong>重复应用某一布局的效果</strong></p>
</blockquote>
<p>引用布局使用include语句即可，示例：<code>&lt;include layout=&quot;@layout/title&quot; /&gt;</code>。即引入了一个<code>title.xml</code>的布局文件</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol>
<li>新建<code>title.xml</code>文件，并在其中编写相应控件代码。</li>
<li>在<code>activity_main.xml</code>中使用<code>include</code>语句将新建的布局添加进去（就像添加常规布局一样）</li>
</ol>
<h3 id="自定义控件-1"><a href="#自定义控件-1" class="headerlink" title="自定义控件"></a>自定义控件</h3><blockquote>
<p>引入布局解决了重复编写布局代码的问题，但布局中的响应事件常常还需要编写</p>
<p>自定义控件即编写布局中的响应事件，避免重复编写相同代码</p>
</blockquote>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>在之前自定义布局的基础上，新建一个Java类，继承自<code>LinearLayout</code>，代码如下（即实现了该布局中控件的相关功能）：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> TitleLayout extends LinearLayout &#123;<br>    public <span class="hljs-constructor">TitleLayout(Context <span class="hljs-params">context</span>, AttributeSet <span class="hljs-params">attrs</span>)</span> &#123;<br>        super(context, attrs);<br>        <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">LayoutInflater</span>.</span></span>from(context).inflate(<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">R</span>.</span></span>layout.title, this);	<span class="hljs-comment">// 进行加载</span><br><br>		<span class="hljs-comment">// 编写控件中的按钮代码</span><br>        Button titleBack = (Button) find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">title_back</span>)</span>;<br>        Button titleEdit = (Button) find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">title_edit</span>)</span>;<br>        titleBack.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">new</span> OnClickListener()</span> &#123;<br>            @Override<br>            public void on<span class="hljs-constructor">Click(View <span class="hljs-params">view</span>)</span> &#123;<br>                ((Activity) get<span class="hljs-constructor">Context()</span>).finish<span class="hljs-literal">()</span>;<br>            &#125;<br>        &#125;);<br>        titleEdit.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">new</span> OnClickListener()</span> &#123;<br>            @Override<br>            public void on<span class="hljs-constructor">Click(View <span class="hljs-params">view</span>)</span> &#123;<br>                <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Toast</span>.</span></span>make<span class="hljs-constructor">Text(<span class="hljs-params">getContext</span>()</span>, <span class="hljs-string">"You clicked Edit button"</span>,<br>                        Toast.LENGTH_SHORT).show<span class="hljs-literal">()</span>;<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%B8%89%EF%BC%9A%E5%B8%83%E5%B1%80%EF%BC%88layout%EF%BC%89/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6.png" style="zoom:67%;" />





<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>第一行代码——Android（郭霖）</p>
]]></content>
      <categories>
        <category>移动端</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发二：活动（Activity）</title>
    <url>/page/Android2-activity.html</url>
    <content><![CDATA[<h2 id="从0构建一个活动"><a href="#从0构建一个活动" class="headerlink" title="从0构建一个活动"></a>从0构建一个活动</h2><h3 id="构建活动及布局"><a href="#构建活动及布局" class="headerlink" title="构建活动及布局"></a>构建活动及布局</h3><ol>
<li>在创建项目时选择<strong>“Add no Activity”</strong></li>
<li>在项目架构中的app-&gt;src-&gt;main下的包中右击，选择新建一个Activity，命名为FirstActivity</li>
<li>在布局文件夹layout中新建一个布局，命名为first_layout，并修改加上一个按钮，代码如下</li>
</ol>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;Button<br>    android:<span class="hljs-attribute">id</span>=<span class="hljs-string">"@+id/button_1"</span>	&lt;!-- 定义id用于代码中使用 --&gt;<br>    android:<span class="hljs-attribute">layout_width</span>=<span class="hljs-string">"match_parent"</span><br>    android:<span class="hljs-attribute">layout_height</span>=<span class="hljs-string">"wrap_content"</span><br>    android:<span class="hljs-attribute">text</span>=<span class="hljs-string">"Button 1"</span><br>    /&gt;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>在<strong>AndroidManifest.xml</strong>文件中注册活动，使用<code>&lt;activity&gt;</code>标签注册活动（AS已经自动注册好了），并放在<code>&lt;application&gt;</code>标签内，之后</li>
</ol>
<h3 id="使用Toast完成消息提醒"><a href="#使用Toast完成消息提醒" class="headerlink" title="使用Toast完成消息提醒"></a>使用Toast完成消息提醒</h3><p><strong>Android中的Toast类似于其他GUI中的messagebox，“弹出”一条消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>    <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>    setContentView(R.layout.first_layout);<br>    Button button1 = (Button) findViewById(R.id.button_1);	<span class="hljs-comment">// 获取该活动中的按钮</span><br>    button1.setOnClickListener(<span class="hljs-keyword">new</span> View.OnClickListener() &#123;	<span class="hljs-comment">// 为按钮注册一个监听器</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onClick</span><span class="hljs-params">(View view)</span> </span>&#123;	<span class="hljs-comment">// 点击按钮，即执行监听器下的onClick方法</span><br>            Toast.makeText(FirstActivity.<span class="hljs-keyword">this</span>, <span class="hljs-string">"You clicked Button 1"</span>,<br>                    Toast.LENGTH_SHORT).show();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中makeText()包含三个参数，第一个是要求的上下文，第二个是显示的文本内容，第三个是显示的时长</p>
<img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%BA%8C%EF%BC%9A%E6%B4%BB%E5%8A%A8%EF%BC%88Activity%EF%BC%89/toast-demo.png" style="zoom: 50%;" />

<h3 id="使用menu"><a href="#使用menu" class="headerlink" title="使用menu"></a>使用menu</h3><ol>
<li>在res目录下创建一个menu文件，之后创建一个menu资源文件。</li>
<li>之后使用<code>&lt;item&gt;</code>标签创建一个菜单项，如下</li>
</ol>
<figure class="highlight django"><table><tr><td class="code"><pre><code class="hljs django"><span class="xml"><span class="hljs-meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">menu</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">"http://schemas.android.com/apk/res/android"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span><br>        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/add_item"</span>	&lt;!<span class="hljs-attr">--</span> 创建唯一标识符 <span class="hljs-attr">--</span>&gt;</span><br>        android:title="Add" /&gt;	<span class="hljs-comment">&lt;!-- 创建菜单项的名称 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">item</span><br>        <span class="hljs-attr">android:id</span>=<span class="hljs-string">"@+id/remove_item"</span><br>        <span class="hljs-attr">android:title</span>=<span class="hljs-string">"Remove"</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">menu</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>之后在相应活动中重写<code>onCreateOptionsMenu</code>函数，用以显示菜单，如下</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">onCreateOptionsMenu</span><span class="hljs-params">(Menu menu)</span> </span>&#123;<br>    getMenuInflater().inflate(R.menu.main, menu);	<span class="hljs-comment">// </span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;	<span class="hljs-comment">// 返回true表示允许菜单显示出来</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ol start="4">
<li>定义菜单响应事件，重写<code>onOptionsItemSelected()</code>方法</li>
</ol>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Override</span><br>public boolean onOptionsItemSelected(<span class="hljs-variable">@NonNull</span> MenuItem item) &#123;<br>    <span class="hljs-selector-tag">switch</span> (item.getItemId()) &#123;<br>        <span class="hljs-selector-tag">case</span> <span class="hljs-selector-tag">R</span><span class="hljs-selector-class">.id</span><span class="hljs-selector-class">.add_item</span>:<br>            <span class="hljs-selector-tag">Toast</span><span class="hljs-selector-class">.makeText</span>(this, <span class="hljs-string">"You clicked Add"</span>, Toast.LENGTH_SHORT)<span class="hljs-selector-class">.show</span>();<br>            <span class="hljs-selector-tag">break</span>;<br>        <span class="hljs-selector-tag">case</span> <span class="hljs-selector-tag">R</span><span class="hljs-selector-class">.id</span><span class="hljs-selector-class">.remove_item</span>:<br>            <span class="hljs-selector-tag">Toast</span><span class="hljs-selector-class">.makeText</span>(this, <span class="hljs-string">"You clicked remove"</span>, Toast.LENGTH_SHORT)<span class="hljs-selector-class">.show</span>();<br>            <span class="hljs-selector-tag">break</span>;<br>        <span class="hljs-selector-tag">default</span>:<br>    &#125;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%BA%8C%EF%BC%9A%E6%B4%BB%E5%8A%A8%EF%BC%88Activity%EF%BC%89/menu-demo.png" style="zoom:50%;" />



<h3 id="使用finish-销毁一个活动，类似于返回键"><a href="#使用finish-销毁一个活动，类似于返回键" class="headerlink" title="使用finish()销毁一个活动，类似于返回键"></a>使用finish()销毁一个活动，类似于返回键</h3><p>使用Activity类提供的<strong>finish()</strong>方法，取得的效果跟按下Back一致</p>
<h2 id="使用Intent构建不同活动间的联系"><a href="#使用Intent构建不同活动间的联系" class="headerlink" title="使用Intent构建不同活动间的联系"></a>使用Intent构建不同活动间的联系</h2><p>intent是Android程序中<strong>各组件之间进行交互的一种重要方式</strong>，一般可用于启动活动、启动服务以及发送广播。根据指定响应对象是否直接可以分为显式Intent和隐式Intent。</p>
<p>以下，像之前一样构建一个<code>SecondActivity</code>，用于响应实验。</p>
<h3 id="显式Intent"><a href="#显式Intent" class="headerlink" title="显式Intent"></a>显式Intent</h3><p><strong>直接指定响应对象</strong>，如下（点击按钮即可跳转到第二个页面）</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">button1.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">new</span> View.OnClickListener()</span> &#123;<br>    @Override<br>    public void on<span class="hljs-constructor">Click(View <span class="hljs-params">view</span>)</span> &#123;<br>        Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent(FirstActivity.<span class="hljs-params">this</span>, SecondActivity.<span class="hljs-params">class</span>)</span>;	<span class="hljs-comment">// 由上下文响应目标活动</span><br>        start<span class="hljs-constructor">Activity(<span class="hljs-params">intent</span>)</span>;	<span class="hljs-comment">// 启动传入的Intent参数</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><code>Intent(Context packageContext, Class &lt;?&gt; cls)</code>，第一个参数 Context 要求提供一个启动活动的上下文，第二个参数 Class 则是指定想要启动的目标活动</p>
<p>Activity 类中提供了一个 startActivity() 方法，这个方法是专门用于启动活动的，它接收一个 Intent 参数，这里我们将构建好的 Intent 传入 startActivity() 方法就可以启动目标活动了。</p>
<h3 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h3><p>隐式Intent<strong>并不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的 action 和 category 等信息，然后交由系统去分析这个 Intent，并帮我们找出合适的活动</strong>（即能够相应该隐式intent的活动）去启动</p>
<p>通过在<code>&lt;activity&gt;</code>标签下配置<code>&lt; intent-filter &gt;</code>的内容，可以指定当前活动能够响应的 action 和 category。同时，<strong>只有 <code>&lt;action&gt;</code> 和 <code>&lt;category&gt;</code> 中的内容同时能够匹配上 Intent 中指定的 action 和 category 时，这个活动才能响应该 Intent</strong>。</p>
<p>如下，在<strong>AndroidManifest.xml</strong>文件中配置SecondActivity的信息如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">".SecondActivity"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.example.activitytest.ACTION_START"</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.DEFAULT"</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"com.example.activitytest.MY_CATEGORY"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br></code></pre></td></tr></table></figure>

<p>在FirstActivity中使用隐式Intent，完成点击按钮跳转到第二个界面</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">button1.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">new</span> View.OnClickListener()</span> &#123;<br>    @Override<br>    public void on<span class="hljs-constructor">Click(View <span class="hljs-params">view</span>)</span> &#123;<br>        Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent(<span class="hljs-string">"com.example.activitytest.ACTION_START"</span>)</span>;<br>        intent.add<span class="hljs-constructor">Category(<span class="hljs-string">"com.example.activitytest.MY_CATEGORY"</span>)</span>;<br>        start<span class="hljs-constructor">Activity(<span class="hljs-params">intent</span>)</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>





<p>用隐式 Intent，我们<strong>不仅可以启动自己程序内的活动，还可以启动其他程序的活动（如调用浏览器）</strong>，这使得 Android 多个应用程序之间的功能共享成为了可能</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">button1.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">new</span> View.OnClickListener()</span> &#123;<br>    @Override<br>    public void on<span class="hljs-constructor">Click(View <span class="hljs-params">view</span>)</span> &#123;<br>        Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent(Intent.ACTION_VIEW)</span>;<br>        intent.set<span class="hljs-constructor">Data(Uri.<span class="hljs-params">parse</span>(<span class="hljs-string">"http://www.baidu.com"</span>)</span>);	<span class="hljs-comment">// 将Uri对象传递进去，可以使用浏览器打开</span><br>        start<span class="hljs-constructor">Activity(<span class="hljs-params">intent</span>)</span>;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%BA%8C%EF%BC%9A%E6%B4%BB%E5%8A%A8%EF%BC%88Activity%EF%BC%89/%E6%89%93%E5%BC%80%E6%B5%8F%E8%A7%88%E5%99%A8.png" style="zoom:50%;" />



<h3 id="Intent向下一个活动传递数据"><a href="#Intent向下一个活动传递数据" class="headerlink" title="Intent向下一个活动传递数据"></a>Intent向下一个活动传递数据</h3><p>Intent 中提供了一系列 <strong>putExtra()</strong> 方法的重载，可以把我们想要传递的数据暂存在 Intent 中，启动了另一个活动后，只需要把这些数据再从 Intent 中取出就可以了</p>
<p>putExtra() 方法接收两个参数，第一个参数是键，用于后面从 Intent 中取值，第二个参数才是真正要传递的数据。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在FirstActivity中相应位置填入以下代码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">String data = <span class="hljs-string">"Hello, Second Activity"</span>;<br>Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent(FirstActivity.<span class="hljs-params">this</span>, SecondActivity.<span class="hljs-params">class</span>)</span>;<br>intent.put<span class="hljs-constructor">Extra(<span class="hljs-string">"extra_data"</span>, <span class="hljs-params">data</span>)</span>;	<span class="hljs-comment">// 将data传入，同时键值为extra_dat</span><br>start<span class="hljs-constructor">Activity(<span class="hljs-params">intent</span>)</span>;<br></code></pre></td></tr></table></figure>

<p>在SecondActivity中相应位置填入以下代码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">@Override<br>protected void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;<br>    super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span>;<br>    set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">second_layout</span>)</span>;<br>    Intent intent = get<span class="hljs-constructor">Intent()</span>;<br>    String data = intent.get<span class="hljs-constructor">StringExtra(<span class="hljs-string">"extra_data"</span>)</span>;	<span class="hljs-comment">// 通过键值获取信息</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Toast</span>.</span></span>make<span class="hljs-constructor">Text(<span class="hljs-params">this</span>, <span class="hljs-params">data</span>, Toast.LENGTH_SHORT)</span>.show<span class="hljs-literal">()</span>;	<span class="hljs-comment">// 显示信息</span><br>&#125;<br></code></pre></td></tr></table></figure>

<img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%BA%8C%EF%BC%9A%E6%B4%BB%E5%8A%A8%EF%BC%88Activity%EF%BC%89/%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF%E7%BB%99%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8.png" style="zoom: 67%;" />

<h3 id="Intent返回数据给上一个活动"><a href="#Intent返回数据给上一个活动" class="headerlink" title="Intent返回数据给上一个活动"></a>Intent返回数据给上一个活动</h3><p><strong>1、 使用startActivityForResult() 方法启动活动，在活动销毁后即可将数据传递回来</strong></p>
<blockquote>
<p>startActivityForResult() 方法接收两个参数，第一个参数还是 Intent，第二个参数是<strong>请求码（requestCode）</strong>，用于在之后的回调中判断数据的来源。</p>
</blockquote>
<p><strong>2、在第二个活动中使用setResult() 方法将带有数据的Intent传递回去</strong></p>
<blockquote>
<p>setResult() 方法接收两个参数，第一个参数用于向上一个活动返回处理结果，一般只使用 RESULT_OK 或 RESULT_CANCELED 这两个值，第二个参数则把带有数据的 Intent 传递回去</p>
</blockquote>
<p><strong>3、使用startActivityForResult() 方法启动活动在活动销毁后会回调onActivityResult() 方法</strong>，因此在第一个活动中重写该方法。</p>
<blockquote>
<p> onActivityResult() 方法带有三个参数，第一个参数 requestCode ，即我们在启动活动时传入的请求码。第二个参数 resultCode ，即我们在返回数据时传入的处理结果。第三个参数 data，即携带着返回数据的 Intent</p>
</blockquote>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>在FirstActivity中相应位置填入以下代码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">@Override<br>protected void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;<br>    super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span>;<br>    set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">first_layout</span>)</span>;<br>    Button button1 = (Button) find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">button_1</span>)</span>;<br>    button1.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">new</span> View.OnClickListener()</span> &#123;<br>        @Override<br>        public void on<span class="hljs-constructor">Click(View <span class="hljs-params">view</span>)</span> &#123;<br>            Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent(FirstActivity.<span class="hljs-params">this</span>, SecondActivity.<span class="hljs-params">class</span>)</span>;<br>            start<span class="hljs-constructor">ActivityForResult(<span class="hljs-params">intent</span>, 1)</span>;	<span class="hljs-comment">// 请求码为1</span><br>        &#125;<br>    &#125;);<br>&#125;<br><br>@Override<br>protected void on<span class="hljs-constructor">ActivityResult(<span class="hljs-params">int</span> <span class="hljs-params">requestCode</span>, <span class="hljs-params">int</span> <span class="hljs-params">resultCode</span>, @Nullable Intent <span class="hljs-params">data</span>)</span> &#123;<br>    super.on<span class="hljs-constructor">ActivityResult(<span class="hljs-params">requestCode</span>, <span class="hljs-params">resultCode</span>, <span class="hljs-params">data</span>)</span>;<br>    <span class="hljs-keyword">if</span> (requestCode<span class="hljs-operator"> == </span><span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">if</span> (resultCode<span class="hljs-operator"> == </span>RESULT_OK) &#123;<br>            <span class="hljs-keyword">assert</span> data != null;<br>            String returnData = data.get<span class="hljs-constructor">StringExtra(<span class="hljs-string">"data_return"</span>)</span>;<br>            <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Toast</span>.</span></span>make<span class="hljs-constructor">Text(FirstActivity.<span class="hljs-params">this</span>, <span class="hljs-params">returnData</span>, Toast.LENGTH_SHORT)</span>.show<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在SecondActivity中相应位置填入以下代码</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">@Override<br>protected void on<span class="hljs-constructor">Create(Bundle <span class="hljs-params">savedInstanceState</span>)</span> &#123;<br>    super.on<span class="hljs-constructor">Create(<span class="hljs-params">savedInstanceState</span>)</span>;<br>    set<span class="hljs-constructor">ContentView(R.<span class="hljs-params">layout</span>.<span class="hljs-params">second_layout</span>)</span>;<br>    Button button2 = (Button) find<span class="hljs-constructor">ViewById(R.<span class="hljs-params">id</span>.<span class="hljs-params">button_2</span>)</span>;<br>    button2.set<span class="hljs-constructor">OnClickListener(<span class="hljs-params">new</span> View.OnClickListener()</span> &#123;<br>        @Override<br>        public void on<span class="hljs-constructor">Click(View <span class="hljs-params">view</span>)</span> &#123;<br>            Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent()</span>;<br>            intent.put<span class="hljs-constructor">Extra(<span class="hljs-string">"data_return"</span>, <span class="hljs-string">"Return message from SecondActivity"</span>)</span>;<br>            set<span class="hljs-constructor">Result(RESULT_OK, <span class="hljs-params">intent</span>)</span>;<br>            finish<span class="hljs-literal">()</span>;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%BA%8C%EF%BC%9A%E6%B4%BB%E5%8A%A8%EF%BC%88Activity%EF%BC%89/%E4%BB%8E%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E8%BF%94%E5%9B%9E%E6%B6%88%E6%81%AF.png" style="zoom:67%;" />



<h2 id="活动的生命周期"><a href="#活动的生命周期" class="headerlink" title="活动的生命周期"></a>活动的生命周期</h2><h3 id="活动状态"><a href="#活动状态" class="headerlink" title="活动状态"></a>活动状态</h3><p>每个活动在其生命周期最多可能有4种状态</p>
<h4 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h4><p>一个活动位于返回栈的<strong>栈顶</strong>时，这时活动就处于运行状态</p>
<h4 id="暂停状态"><a href="#暂停状态" class="headerlink" title="暂停状态"></a>暂停状态</h4><p>当一个活动<strong>不再处于栈顶位置，但仍然可见</strong>时，这时活动就进入了暂停状态。</p>
<h4 id="停止状态"><a href="#停止状态" class="headerlink" title="停止状态"></a>停止状态</h4><p>当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。（当其他地方需要内存时，处于停止状态的活动有可能会被系统回收）</p>
<h4 id="销毁状态"><a href="#销毁状态" class="headerlink" title="销毁状态"></a>销毁状态</h4><p>当一个活动<strong>从返回栈中移除后</strong>就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证手机的内存充足。</p>
<h3 id="活动的生存期"><a href="#活动的生存期" class="headerlink" title="活动的生存期"></a>活动的生存期</h3><p>Activity 类中定义了 7 个回调方法，覆盖了活动生命周期的每一个环节</p>
<h4 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate()"></a>onCreate()</h4><blockquote>
<p>在活动第一次被创建的时候调用</p>
<p>在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等</p>
</blockquote>
<h4 id="onStart"><a href="#onStart" class="headerlink" title="onStart()"></a>onStart()</h4><blockquote>
<p>活动由不可见变为可见的时候调用</p>
</blockquote>
<h4 id="onResume"><a href="#onResume" class="headerlink" title="onResume()"></a>onResume()</h4><blockquote>
<p>活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并且处于运行状态</p>
</blockquote>
<h4 id="onPause"><a href="#onPause" class="headerlink" title="onPause()"></a>onPause()</h4><blockquote>
<p>这个方法在系统准备去启动或者恢复另一个活动的时候调用</p>
</blockquote>
<h4 id="onStop"><a href="#onStop" class="headerlink" title="onStop()"></a>onStop()</h4><blockquote>
<p>这个方法在活动完全不可见的时候调用</p>
</blockquote>
<h4 id="onDestroy"><a href="#onDestroy" class="headerlink" title="onDestroy()"></a>onDestroy()</h4><blockquote>
<p>这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。</p>
</blockquote>
<h4 id="onRestart"><a href="#onRestart" class="headerlink" title="onRestart()"></a>onRestart()</h4><blockquote>
<p>这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。</p>
</blockquote>
<h2 id="活动的启动模式"><a href="#活动的启动模式" class="headerlink" title="活动的启动模式"></a>活动的启动模式</h2><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><blockquote>
<p>活动默认的启动模式，每次启动都会创建该活动的一个新的实例</p>
</blockquote>
<h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><blockquote>
<p>启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例</p>
<p><strong>不重复创建栈顶活动</strong></p>
</blockquote>
<p>在<code>AndroidManifest.xml</code>中<code>&lt;activity&gt;</code>标签内设置</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">android:</span>launchMode=<span class="hljs-string">"singleTop"</span><br></code></pre></td></tr></table></figure>



<h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><blockquote>
<p>让任意活动在整个应用程序的上下文中<strong>只存在一个实例</strong></p>
<p><code>android:launchMode=&quot;singleTask&quot;</code></p>
</blockquote>
<h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><blockquote>
<p>这种模式下会有一个<strong>单独的返回栈</strong>来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，解决了<strong>共享活动实例</strong>的问题</p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>第一行代码——Android（郭霖）</p>
]]></content>
      <categories>
        <category>移动端</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发一：HelloWorld</title>
    <url>/page/android-dev-helloworld.html</url>
    <content><![CDATA[<h2 id="HelloWorld程序运行"><a href="#HelloWorld程序运行" class="headerlink" title="HelloWorld程序运行"></a>HelloWorld程序运行</h2><h3 id="AS设置"><a href="#AS设置" class="headerlink" title="AS设置"></a>AS设置</h3><h4 id="gradle版本设置"><a href="#gradle版本设置" class="headerlink" title="gradle版本设置"></a>gradle版本设置</h4><p>在<code>gradle-wrapper.properties</code>文件中修改以下代码中的版本号即可</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir">distributionUrl=https\<span class="hljs-symbol">://services</span>.gradle.org/distributions/gradle<span class="hljs-number">-6.1</span>.<span class="hljs-number">1</span>-all.zip<br></code></pre></td></tr></table></figure>

<p>同时，可以去gradle官网上下载相关版本，避免下载缓慢的问题</p>
<h4 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h4><p>在<code>build.gradle</code>文件中的仓库前加上阿里镜像加快下载速度（两处都要进行更改）</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">repositories</span> &#123;<br>    <span class="hljs-variable">maven</span>&#123; <span class="hljs-variable">url</span> <span class="hljs-string">'http://maven.aliyun.com/nexus/content/groups/public/'</span>&#125;<br>    <span class="hljs-function"><span class="hljs-title">google</span>()</span><br>    <span class="hljs-function"><span class="hljs-title">jcenter</span>()</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>在AS设置正常的情况下，直接按运行健即可运行IDE自动创建的helloworld程序了，此时需要先在右上角的<code>AVD Manager</code>中创建虚拟机器，之后按运行按钮即可运行，运行效果如下</p>
<img src="http://cdn.ziyedy.top/%E4%B8%80%E3%80%81Android%E5%BC%80%E5%8F%91HelloWorld/helloworld.png" style="zoom:50%;" />

<h2 id="Android项目结构"><a href="#Android项目结构" class="headerlink" title="Android项目结构"></a>Android项目结构</h2><p>将项目结构模式设置为<strong>Project</strong>后（默认为Android），项目结构如下。</p>
<p>其中重点需要关注的是<strong>app</strong>文件，项目中的代码、资源等内容基本都在该文件夹下。而其他文件多半是自动生成的配置文件，一般情况下不需要进行修改</p>
<p><img src="http://cdn.ziyedy.top/%E4%B8%80%E3%80%81Android%E5%BC%80%E5%8F%91HelloWorld/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt=""></p>
<h3 id="app文件下的文件"><a href="#app文件下的文件" class="headerlink" title="app文件下的文件"></a>app文件下的文件</h3><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>包含了一些在编译时自动生成的文件，一般情况下不需要修改</p>
<h4 id="libs"><a href="#libs" class="headerlink" title="libs"></a>libs</h4><p>项目中需要用到的jar包都放置在该目录下</p>
<h4 id="androidTest"><a href="#androidTest" class="headerlink" title="androidTest"></a>androidTest</h4><p>用来编写Android Test测试用例的，可以对项目进行一些自动化测试</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><p>放置Java代码的文件夹</p>
<h4 id="res"><a href="#res" class="headerlink" title="res"></a>res</h4><p>项目中用到的所有图片、布局等资源都存放在该目录下（如：<strong>图片放在drawable下，布局放在layout下，字符串放在values下</strong>）</p>
<h4 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h4><p>整个Android项目的配置文件，在程序中定义的四大组件都需要在这个文件中注册，也可以在该文件中给应用程序添加权限声明。</p>
<p>如下是该文件中的部分代码，该段代码表示对MainActivity这个活动进行注册（未在该文件中进行注册的活动是不能使用的）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">".MainActivity"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.action.MAIN"</span> /&gt;</span>	<span class="hljs-comment">&lt;!--表示该活动是主活动--&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">"android.intent.category.LAUNCHER"</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>用来编写单元测试用例</p>
<h3 id="主活动代码"><a href="#主活动代码" class="headerlink" title="主活动代码"></a>主活动代码</h3><p>由于Android讲究<strong>逻辑和视图分离</strong>，因此应该在<strong>布局文件中编写界面，在活动中引入进来</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);	<span class="hljs-comment">// 引入了一个布局</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>因此，在<code>res/layout</code>中能够找到helloworld程序的布局样式如下</p>
<p><img src="http://cdn.ziyedy.top/%E4%B8%80%E3%80%81Android%E5%BC%80%E5%8F%91HelloWorld/%E5%B8%83%E5%B1%80.png" alt=""></p>
<h3 id="res中的资源文件"><a href="#res中的资源文件" class="headerlink" title="res中的资源文件"></a>res中的资源文件</h3><p>在之前已经简单叙述过了，现在简单讲讲如何使用这些资源</p>
<p>以<code>res/values/strings.xml</code>为例，该处定义了一个应用程序名的字符串</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">string</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"app_name"</span>&gt;</span>My Application<span class="hljs-tag">&lt;/<span class="hljs-name">string</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>在代码中通过<code>R.string.app_name</code>来引用</strong></p>
<p><strong>在XML中通过<code>@string/app_name</code>来引用</strong></p>
</blockquote>
<p>如AndroidManifest.xml中部分代码如下</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">android:</span>icon=<span class="hljs-string">"@mipmap/ic_launcher"</span><br><span class="hljs-symbol">android:</span>label=<span class="hljs-string">"@string/app_name"</span><br><span class="hljs-symbol">android:</span>roundIcon=<span class="hljs-string">"@mipmap/ic_launcher_round"</span><br></code></pre></td></tr></table></figure>



<h3 id="build-gradle文件"><a href="#build-gradle文件" class="headerlink" title="build.gradle文件"></a>build.gradle文件</h3><p>整个项目结构中有两个这个文件，一个是在项目最外层（之前添加阿里镜像就是在这儿添加的），一个则是在app文件夹下面</p>
<h4 id="外层build-gradle"><a href="#外层build-gradle" class="headerlink" title="外层build.gradle"></a>外层build.gradle</h4><p>其中<strong>jcenter()</strong>声明了一个代码托管仓库，很多开源项目都会选择将代码托管在jcenter中。</p>
<p>之后<strong>classpath</strong>声明了一个Gradle插件，该插件表示是使用Gradle来构建Android项目</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">buildscript</span> &#123;<br>    <span class="hljs-keyword">repositories</span> &#123;<br>        maven&#123; url <span class="hljs-string">'http://maven.aliyun.com/nexus/content/groups/public/'</span>&#125;<br>        google()<br>        jcenter()<br>    &#125;<br>    <span class="hljs-keyword">dependencies</span> &#123;<br>        <span class="hljs-keyword">classpath</span> <span class="hljs-string">"com.android.tools.build:gradle:4.0.1"</span><br><br>        <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Do not place your application dependencies here; they belong</span><br>        <span class="hljs-comment">// in the individual module build.gradle files</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="app文件下的build-gradle"><a href="#app文件下的build-gradle" class="headerlink" title="app文件下的build.gradle"></a>app文件下的build.gradle</h4><figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">apply</span> <span class="hljs-string">plugin: 'com.android.application'</span><br><br><span class="hljs-attr">android</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">compileSdkVersion</span> <span class="hljs-string">30</span><br>    <span class="hljs-attr">buildToolsVersion</span> <span class="hljs-string">"30.0.2"</span><br><br>    <span class="hljs-attr">defaultConfig</span> <span class="hljs-string">&#123;</span><br>        <span class="hljs-attr">applicationId</span> <span class="hljs-string">"com.example.myapplication"</span><br>        <span class="hljs-attr">minSdkVersion</span> <span class="hljs-string">15</span><br>        <span class="hljs-attr">targetSdkVersion</span> <span class="hljs-string">30</span><br>        <span class="hljs-attr">versionCode</span> <span class="hljs-string">1</span><br>        <span class="hljs-attr">versionName</span> <span class="hljs-string">"1.0"</span><br><br>        <span class="hljs-attr">testInstrumentationRunner</span> <span class="hljs-string">"androidx.test.runner.AndroidJUnitRunner"</span><br>    <span class="hljs-attr">&#125;</span><br><br>    <span class="hljs-attr">buildTypes</span> <span class="hljs-string">&#123;</span><br>        <span class="hljs-attr">release</span> <span class="hljs-string">&#123;</span><br>            <span class="hljs-attr">minifyEnabled</span> <span class="hljs-string">false</span><br>            <span class="hljs-attr">proguardFiles</span> <span class="hljs-string">getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'</span><br>        <span class="hljs-attr">&#125;</span><br>    <span class="hljs-attr">&#125;</span><br><span class="hljs-attr">&#125;</span><br><br><span class="hljs-attr">dependencies</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">implementation</span> <span class="hljs-string">fileTree(dir: "libs", include: ["*.jar"])</span><br>    <span class="hljs-attr">implementation</span> <span class="hljs-string">'androidx.appcompat:appcompat:1.2.0'</span><br>    <span class="hljs-attr">implementation</span> <span class="hljs-string">'androidx.constraintlayout:constraintlayout:2.0.1'</span><br>    <span class="hljs-attr">testImplementation</span> <span class="hljs-string">'junit:junit:4.12'</span><br>    <span class="hljs-attr">androidTestImplementation</span> <span class="hljs-string">'androidx.test.ext:junit:1.1.2'</span><br>    <span class="hljs-attr">androidTestImplementation</span> <span class="hljs-string">'androidx.test.espresso:espresso-core:3.3.0'</span><br><br><span class="hljs-attr">&#125;</span><br></code></pre></td></tr></table></figure>

<p><strong>apply plugin</strong>：</p>
<blockquote>
<p>应用了一个插件，通常是com.android.application与com.android.library二选一。</p>
<p>前者表示一个应用程序模块，后者表示一个库模块（不能直接运行）</p>
</blockquote>
<p><strong>android</strong></p>
<blockquote>
<p>配置项目构建的各种属性</p>
</blockquote>
<p><strong>dependencies</strong></p>
<blockquote>
<p>指定项目所有依赖关系：</p>
<p>1、本地依赖</p>
<p>2、库依赖</p>
<p>3、远程依赖：对jcenter库上的开源项目添加依赖关系</p>
</blockquote>
<h2 id="日志工具"><a href="#日志工具" class="headerlink" title="日志工具"></a>日志工具</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>第一行代码——Android（郭霖）</p>
]]></content>
      <categories>
        <category>移动端</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title>使用TensorFlow Hub进行迁移学习</title>
    <url>/page/TF-Hub-transfer-learning.html</url>
    <content><![CDATA[<p>使用<a href="https://tfhub.dev/" target="_blank" rel="noopener">TensorFlow Hub</a>中的模型能够很轻松的实现模型调用与迁移学习</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix"><span class="hljs-built_in">import</span> tensorflow_hub as hub<br><br><span class="hljs-comment"># 你所想使用的模型的链接</span><br><span class="hljs-attr">classifier_url</span> =<span class="hljs-string">"https://tfhub.dev/google/tf2-preview/mobilenet_v2/classification/2"</span><br><br><span class="hljs-comment"># 构建特征处理器</span><br><span class="hljs-attr">feature_extractor_layer</span> = hub.KerasLayer(classifier_url, <span class="hljs-attr">input_shape=(28,</span> <span class="hljs-number">28</span>, <span class="hljs-number">3</span>))<br><br><span class="hljs-comment"># 冻结特征提取层中的变量</span><br>feature_extractor_layer.<span class="hljs-attr">trainable</span> = False<br><br><span class="hljs-comment"># 构建自己的模型</span><br><span class="hljs-attr">classifier</span> = tf.keras.Sequential([<br>	feature_extractor_layer,<br>	layers.Dense(image_data.num_classes)	<span class="hljs-comment"># 全连接分类层</span><br>])<br><br><span class="hljs-comment"># 配置训练过程</span><br>model.compile(<br>  <span class="hljs-attr">optimizer=tf.keras.optimizers.Adam(),</span><br>  <span class="hljs-attr">loss=tf.keras.losses.CategoricalCrossentropy(from_logits=True),</span><br>  <span class="hljs-attr">metrics=['acc'])</span><br><br><br><br><span class="hljs-comment"># 使用该模型进行预测</span><br><span class="hljs-attr">result</span> = classifier.predict(input_data)<br></code></pre></td></tr></table></figure>



<p>进行迁移学习，只修改最后的分类层</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CollectBatchStats</span>(<span class="hljs-title">tf</span>.<span class="hljs-title">keras</span>.<span class="hljs-title">callbacks</span>.<span class="hljs-title">Callback</span>):</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:<br>    <span class="hljs-keyword">self</span>.batch_losses = []<br>    <span class="hljs-keyword">self</span>.batch_acc = []<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_train_batch_end</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, batch, logs=None)</span></span>:<br>    <span class="hljs-keyword">self</span>.batch_losses.append(logs[<span class="hljs-string">'loss'</span>])<br>    <span class="hljs-keyword">self</span>.batch_acc.append(logs[<span class="hljs-string">'acc'</span>])<br>    <span class="hljs-keyword">self</span>.model.reset_metrics()<br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>AI相关</category>
        <category>TensorFlow2</category>
      </categories>
      <tags>
        <tag>TensorFlow2</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章：计算机网络与英特网</title>
    <url>/page/no1-computer-network-and-the-internet.html</url>
    <content><![CDATA[<h2 id="什么是Internet"><a href="#什么是Internet" class="headerlink" title="什么是Internet"></a>什么是Internet</h2><p>计算机网络：通过<strong>通信信道</strong>，将地理上分布的多个计算机系统连接起来，在相应<strong>网络协议</strong>的支持下，实现信息传送、资源共享和网络计算功能的系统</p>
<h3 id="分类依据"><a href="#分类依据" class="headerlink" title="分类依据"></a>分类依据</h3><p>1、根据覆盖范围（Coverage）</p>
<p>2、根据节点移动性（Node Mobility）</p>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p><strong>端系统（End System）</strong>：与因特网相连的计算机和其它设备，往往处于网络的边缘，因此称为端系统，也被称为<strong>主机（host）</strong>，主机有时可以进一步被划分为<strong>客户（client）</strong>和<strong>服务器（server）</strong></p>
<h3 id="两种模型"><a href="#两种模型" class="headerlink" title="两种模型"></a>两种模型</h3><p>1、client/server model</p>
<p>2、peer-peer model</p>
<h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><p><strong>接入网</strong>：是指将端系统连入到边缘路由器的物理链路</p>
<p><strong>边缘路由器</strong>：是指端系统到任何其他远程端系统路径上的第一台路由器</p>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><blockquote>
<p> 网络核心即由网端系统的<strong>分组交换机（主要有路由器（router）和链路层交换机（link-layer switch））</strong>和<strong>链路</strong>构成的网状网络</p>
</blockquote>
<h3 id="网络核心两个主要功能"><a href="#网络核心两个主要功能" class="headerlink" title="网络核心两个主要功能"></a>网络核心两个主要功能</h3><ol>
<li><p><strong>路由（Routing）</strong>决定包的路径，包括路由算法等</p>
</li>
<li><p><strong>转发（Forwarding）</strong>将数据包从路由器的输入转移到输出</p>
</li>
</ol>
<p><img src="http://cdn.ziyedy.top/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E8%8B%B1%E7%89%B9%E7%BD%91/%E6%95%B0%E6%8D%AE%E7%9A%84%E7%A7%BB%E5%8A%A8.png" alt=""></p>
<h3 id="网络核心的数据传输模式"><a href="#网络核心的数据传输模式" class="headerlink" title="网络核心的数据传输模式"></a>网络核心的数据传输模式</h3><h4 id="电路交换（circuit-switching）"><a href="#电路交换（circuit-switching）" class="headerlink" title="电路交换（circuit switching）"></a>电路交换（circuit switching）</h4><blockquote>
<p>在电路交换网络中，在端系统通信会话期间，交换机会预留端系统间通信路径上的相关资源（缓存，链路传输速率），即先建立连接，然后通信；而在分组交换网络中，这些资源没有被预留；也就是说，在端系统进行通信时，其所需要的资源是被保持的，其他通信是无法使用这一部分资源的；也就说，端系统间真正建立了一条“连接”；而这一连接，用电话的术语被称为“电路”。传统的电话网络就是电路交换网络的例子。</p>
</blockquote>
<h4 id="分组交换（packet-switching）"><a href="#分组交换（packet-switching）" class="headerlink" title="分组交换（packet switching）"></a>分组交换（packet switching）</h4><p>从源端系统向目的端系统发送一个报文（message），要先<strong>将长报文划分为较小的数据块</strong>，称为分组（packet）。在传输过程中，每个分组都<strong>通过链路和分组交换机传送</strong>。</p>
<p><strong>存储转发</strong></p>
<blockquote>
<p> 存储转发是指<strong>交换机在收到一个完成的分组，才会向链路输出转发分组，否则就将收到的部分分组缓存起来（因为需要缓存分组，所以分组交换机需要一个缓冲队列）</strong>；因为缓存等待一个分组的全部数据而导致的时间开销被称为存储转发时延</p>
</blockquote>
<p><strong>排队时延与分组丢失</strong></p>
<p>发生在缓冲队列满的情况，具体见下一节</p>
<p><strong>转发表与路由选择协议</strong></p>
<p>实际上，分组交换机之所以能够知道往哪去是因为其内部有一个<strong>转发表</strong>，这个表维护了一个IP地址和链路的对应关系，所以处理流程为：</p>
<ol>
<li>通过分组的必要信息，获得目的端系统的<em>IP地址</em></li>
<li>通过IP地址<em>索引转发表</em>，从而确定输出链路</li>
</ol>
<h3 id="分组交换和电路交换的对比"><a href="#分组交换和电路交换的对比" class="headerlink" title="分组交换和电路交换的对比"></a>分组交换和电路交换的对比</h3><h4 id="分组交换的优点"><a href="#分组交换的优点" class="headerlink" title="分组交换的优点"></a>分组交换的优点</h4><p>提供了比电路交换更好的带宽共享；</p>
<p>比电路交换更简单、更有效、实现成本更低；</p>
<h4 id="分组交换的缺点"><a href="#分组交换的缺点" class="headerlink" title="分组交换的缺点"></a>分组交换的缺点</h4><p>分组交换不适合实时服务，因为端到端的时延是可变、不可预测的，这和整个网络的情况相关</p>
<h4 id="电路交换的优点"><a href="#电路交换的优点" class="headerlink" title="电路交换的优点"></a>电路交换的优点</h4><p>提供了端对端传输数据的速率保证</p>
<h4 id="电路交换的缺点"><a href="#电路交换的缺点" class="headerlink" title="电路交换的缺点"></a>电路交换的缺点</h4><p>电路交换存在静默期，这是指专用电路空闲时，其占用的资源并没有得到充分的利用</p>
<p>建立连接的过程比较复杂</p>
<p>总体上来说，分组交换的性能要好于电路交换的性能，但是不同类型的分组交换方式有不同的应用场景；比如一些对最低速率有着严格要求的应用，比如实时服务等，为了获得速率保证，牺牲网络的效率也是可以接受的。趋势向着分组交换发展</p>
<h2 id="分组交换中的时延、丢包、吞吐量"><a href="#分组交换中的时延、丢包、吞吐量" class="headerlink" title="分组交换中的时延、丢包、吞吐量"></a>分组交换中的时延、丢包、吞吐量</h2><h3 id="时延（delay）"><a href="#时延（delay）" class="headerlink" title="时延（delay）"></a>时延（delay）</h3><blockquote>
<p>一个分组在沿途<strong>每个节点</strong>承受不同类型的时延，这些时延中最为重要有四个的是：结点处理时延、排队时延、传输时延和传播时延.这些时延总体累加起来是结点总时延</p>
</blockquote>
<h4 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h4><p>处理时延是由于节点需要解析分组的必要信息然后<strong>决定其出链路</strong>而产生的，通常在微秒或者更低数量级。</p>
<p>常用耗时在查找比特错误、索引转发表等操作</p>
<h4 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h4><p>排队时延是因为分组所对应的出链路前面有其他分组正在传输，所以分组需要该链路的缓冲队列里等待其他分组传输完毕而产生的（即在分组交换机中<strong>等待其他分组处理发送完成</strong>造成的时延）；一般来说，排队时延是到达该队列的<strong>流量强度</strong>和性质的函数，通常可以达到毫秒级到微秒级。</p>
<blockquote>
<p>R：带宽</p>
<p>L：数据报长</p>
<p>a：平均到达速率</p>
</blockquote>
<h4 id="传输时延"><a href="#传输时延" class="headerlink" title="传输时延"></a>传输时延</h4><p>传输时延是将所有分组的比特推向链路所有需要的时间（<strong>即向外推的动作</strong>），实际的传输时延通常在毫秒到微秒数量级。用L（bit）表示分组的长度，用R（bps，b/s）表示从路由器A到B的链路传输速率。传输时延是<strong>L/R</strong>。影响因素也就是L与R的大小了</p>
<h4 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h4><p>传播时延是指比特进入链路后，从该链路的起点到下一个结点所用的时间（<strong>即在向外推之后，借链路速度到答下一个节点的事件</strong>）；一旦分组中的最后一个比特到达路由器就意味着该分组的所有比特都已到达路由器；广域网中，传播时延一般是毫秒级的。传播时延是d/s。d是路由器A到B的距离。s是链路的传播速率。</p>
<p>影响因素也就是物理链路的长度以及使用的介质的传播速度了</p>
<h4 id="端到端时延"><a href="#端到端时延" class="headerlink" title="端到端时延"></a>端到端时延</h4><p>假设源主机与目的地主机之间有N-1台路由器，且无拥塞（排队时延微不足道），则节点累计起来，得到端到端时延D=N(d)</p>
<h3 id="丢包（loss）"><a href="#丢包（loss）" class="headerlink" title="丢包（loss）"></a>丢包（loss）</h3><blockquote>
<p>到达的分组发现一个满的队列。由于没有地方存储这个分组，路由器将丢弃该分组，该分组将会丢失（<strong>即当分组交换机缓存满的情况</strong>）</p>
</blockquote>
<p>排队时延和丢包与网络的状况和结点的缓冲空间大小、处理速度相关；如果分组到达的速度高于结点的处理速度，那么分组就会在缓冲队列里排队等待。当缓冲空间用完后，如果还有到的分组，那么该分组将被迫丢弃，产生丢包</p>
<p><strong>流量强度 = 分组到达的速度 / 结点的处理速度，当流量强度大于1时，会出现丢包现象</strong></p>
<p>为降低丢包率，使用决定每个节点buffer的大小也需要进行考量</p>
<h3 id="吞吐量（throughput）"><a href="#吞吐量（throughput）" class="headerlink" title="吞吐量（throughput）"></a>吞吐量（throughput）</h3><blockquote>
<p>计算机网络的吞吐量实际上是一个<strong>速度指标</strong>，它描述了比特经过某个节点的速度（单位时间传输的文件bit/time）。网络的吞吐量可以衡量网络的性能。通常有<strong>瞬时吞吐量</strong>和<strong>平均吞吐量</strong>两个指标进行评价，在今天，因特网对吞吐率的限制因素通常是接入网。</p>
</blockquote>
<p>对于某条路径上的<strong>结点</strong>来说，和该结点有关的速度有两个：接收数据的速度和发送数据的速度，而该结点的吞吐量是这两个速度中较小的一个；</p>
<p>对于某条<strong>路径</strong>来说，该路径的吞吐量可以近似是<strong>所有节点的吞吐量的最小值（瓶颈）</strong>，该最小传输速率的链路为<strong>瓶颈链路</strong>。</p>
<h2 id="协议层次及服务模型"><a href="#协议层次及服务模型" class="headerlink" title="协议层次及服务模型"></a>协议层次及服务模型</h2><h3 id="分层体系结构"><a href="#分层体系结构" class="headerlink" title="分层体系结构"></a>分层体系结构</h3><p>计算机网络中的协议可以简单理解为两个端系统交流的语法与语义，即交流的规范。</p>
<p>总体来说，将各层的所有协议组合起来，称为<strong>协议栈</strong>。因特网的协议栈有5个层次组成<strong>：物理层、链路层、网络成、传输层、应用层</strong>（OSI七层模型相比之下还在应用层下添加了<strong>表示层、会话层</strong>两层）</p>
<p>同时，网络传输过程中，<strong>对等层间使用协议关系（Protocol），上下层间使用接口关系（Interface）</strong></p>
<h4 id="应用层（进程-进程process）"><a href="#应用层（进程-进程process）" class="headerlink" title="应用层（进程-进程process）"></a>应用层（进程-进程process）</h4><p>应用层协议分布在多个端系统，端系统中的应用程序使用该协议与另一个端系统中的应用程序通信。处于应用层的分组称为<strong>报文（message）</strong></p>
<ul>
<li>FTP、SMTP、HTTP</li>
</ul>
<h4 id="传输层（端-端end）"><a href="#传输层（端-端end）" class="headerlink" title="传输层（端-端end）"></a>传输层（端-端end）</h4><p>传输层在应<strong>用程序端点</strong>之间传输应用层报文，因特网中有两个传输层协议：TCP和UDP。处于传输层的分组称为<strong>报文段（segment）</strong>。TCP提供确保传递、流量控制、拥塞控制机制。UDP提供无连接服务，即不提供不必要服务的服务。没有可靠性、没有流量和拥塞控制。</p>
<ul>
<li>TCP、UDP</li>
</ul>
<h4 id="网络层（主机-主机host）"><a href="#网络层（主机-主机host）" class="headerlink" title="网络层（主机-主机host）"></a>网络层（主机-主机host）</h4><p>网络层将称为数据报的网络层分组从<strong>一台主机移动到另一台主机（任意两台机器）</strong>。网络层协议包含著名的IP协议以及其他一些路由选择协议。<strong>数据报</strong></p>
<ul>
<li>IP、routing protocols</li>
</ul>
<h4 id="数据链路层（节点-节点point）"><a href="#数据链路层（节点-节点point）" class="headerlink" title="数据链路层（节点-节点point）"></a>数据链路层（节点-节点point）</h4><p>链路层将称为<strong>帧（frame）</strong>的链路层分组从一个<strong>节点移动到路径上的下一个节点（两个节点要相邻）</strong>。一个帧可能被沿途不同链路上的不同链路层协议处理。</p>
<ul>
<li>PPP</li>
</ul>
<h4 id="物理层（比特流）"><a href="#物理层（比特流）" class="headerlink" title="物理层（比特流）"></a>物理层（比特流）</h4><p>物理层的任务是将<strong>帧中的比特</strong>从一个结点移动到下一个节点，它提供了传输信息的实际物理通道；</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>一个分组，在不同的层次有不同的称谓，是因为它们经过每一层的时候就被该层<strong>封装上了属于该层的相关信息</strong>，也就是前面提到的必要信息；于是，每一分层的分组有两种类型的字段：<strong>首部字段</strong>和<strong>有效负载</strong>；其中有效负载即为来自上一层的分组数据，而首部字段就是该层加上的必要信息；分组不断被封装以实现各层协议规定的相关功能</p>
<p><img src="http://cdn.ziyedy.top/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E8%8B%B1%E7%89%B9%E7%BD%91/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%E6%8E%A5%E5%8F%A3%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>《计算机网络——自顶向下方法》</p>
<p><a href="https://blog.csdn.net/qq_39326472/article/details/88089747" target="_blank" rel="noopener">https://blog.csdn.net/qq_39326472/article/details/88089747</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的魔法方法（Magic Method）</title>
    <url>/page/python-magic-method.html</url>
    <content><![CDATA[<h3 id="什么是魔法函数"><a href="#什么是魔法函数" class="headerlink" title="什么是魔法函数"></a>什么是魔法函数</h3><p>所谓魔法函数（Magic Methods），是Python的一种高级语法，允许你在类中自定义函数（函数名格式一般为__xx__），并绑定到类的特殊方法中。比如在类A中自定义<code>__str__()</code>函数，则在调用<code>str(A())</code>时，会自动调用<code>__str__()</code>函数，并返回相应的结果。在我们平时的使用中，可能经常使用<code>__init__</code>函数和<code>__del__</code>函数，其实这也是魔法函数的一种。</p>
<p>Python中每一个魔法函数都对应了一个Python内置函数或操作。比如<code>__str__</code>对应str函数。</p>
<h3 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h3><p>当创建一个对象时，<code>__new__</code>被调用创建类并返回这个类的实例，<code>__init__</code>将传入的参数来初始化该实例。</p>
<blockquote>
<ol>
<li><code>__new__</code>是一个静态方法，而<code>__init__</code>是一个实例方法.</li>
<li><code>__new__</code>方法会返回一个创建的实例，而<code>__init__</code>什么都不返回.</li>
<li>只有在<code>__new__</code>返回一个cls的实例时后面的<code>__init__</code>才能被调用.</li>
<li>当创建一个新实例时调用<code>__new__</code>，初始化一个实例时用<code>__init__</code>.</li>
</ol>
</blockquote>
<p>当对象生命周期结束时，<code>__del__</code>会被调用（作为析构函数）</p>
<h3 id="二元操作符"><a href="#二元操作符" class="headerlink" title="二元操作符"></a>二元操作符</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">+	object.<span class="hljs-constructor">__add__(<span class="hljs-params">self</span>, <span class="hljs-params">other</span>)</span><br>-	object.<span class="hljs-constructor">__sub__(<span class="hljs-params">self</span>, <span class="hljs-params">other</span>)</span><span class="hljs-operator"><br>*	</span>object.<span class="hljs-constructor">__mul__(<span class="hljs-params">self</span>, <span class="hljs-params">other</span>)</span><br><span class="hljs-comment">//	object.__floordiv__(self, other)</span><span class="hljs-operator"><br>/	</span>object.<span class="hljs-constructor">__div__(<span class="hljs-params">self</span>, <span class="hljs-params">other</span>)</span><br>%	object.<span class="hljs-constructor">__mod__(<span class="hljs-params">self</span>, <span class="hljs-params">other</span>)</span><span class="hljs-operator"><br>**	</span>object.<span class="hljs-constructor">__pow__(<span class="hljs-params">self</span>, <span class="hljs-params">other</span>[, <span class="hljs-params">modulo</span>])</span><br>&lt;&lt;	object.<span class="hljs-constructor">__lshift__(<span class="hljs-params">self</span>, <span class="hljs-params">other</span>)</span><br>&gt;&gt;	object.<span class="hljs-constructor">__rshift__(<span class="hljs-params">self</span>, <span class="hljs-params">other</span>)</span><br>&amp;	object.<span class="hljs-constructor">__and__(<span class="hljs-params">self</span>, <span class="hljs-params">other</span>)</span><br>^	object.<span class="hljs-constructor">__xor__(<span class="hljs-params">self</span>, <span class="hljs-params">other</span>)</span><br><span class="hljs-pattern-match">|	object.<span class="hljs-constructor">__or__(<span class="hljs-params">self</span>, <span class="hljs-params">other</span>)</span></span><br></code></pre></td></tr></table></figure>



<h3 id="扩展二元操作符"><a href="#扩展二元操作符" class="headerlink" title="扩展二元操作符"></a>扩展二元操作符</h3><figure class="highlight gml"><table><tr><td class="code"><pre><code class="hljs gml">+=	object.__iadd__(<span class="hljs-literal">self</span>, <span class="hljs-literal">other</span>)<br>-=	object.__isub__(<span class="hljs-literal">self</span>, <span class="hljs-literal">other</span>)<br>*=	object.__imul__(<span class="hljs-literal">self</span>, <span class="hljs-literal">other</span>)<br>/=	object.__idiv__(<span class="hljs-literal">self</span>, <span class="hljs-literal">other</span>)<br><span class="hljs-comment">//=	object.__ifloordiv__(self, other)</span><br>%=	object.__imod__(<span class="hljs-literal">self</span>, <span class="hljs-literal">other</span>)<br>**=	object.__ipow__(<span class="hljs-literal">self</span>, <span class="hljs-literal">other</span>[, modulo])<br>&lt;&lt;=	object.__ilshift__(<span class="hljs-literal">self</span>, <span class="hljs-literal">other</span>)<br>&gt;&gt;=	object.__irshift__(<span class="hljs-literal">self</span>, <span class="hljs-literal">other</span>)<br>&amp;=	object.__iand__(<span class="hljs-literal">self</span>, <span class="hljs-literal">other</span>)<br>^=	object.__ixor__(<span class="hljs-literal">self</span>, <span class="hljs-literal">other</span>)<br>|=	object.__ior__(<span class="hljs-literal">self</span>, <span class="hljs-literal">other</span>)<br></code></pre></td></tr></table></figure>



<h3 id="比较方法"><a href="#比较方法" class="headerlink" title="比较方法"></a>比较方法</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">&lt;	object.<span class="hljs-constructor">__lt__(<span class="hljs-params">self</span>, <span class="hljs-params">other</span>)</span><br>&lt;=	object.<span class="hljs-constructor">__le__(<span class="hljs-params">self</span>, <span class="hljs-params">other</span>)</span><span class="hljs-operator"><br>==	</span>object.<span class="hljs-constructor">__eq__(<span class="hljs-params">self</span>, <span class="hljs-params">other</span>)</span><br>!=	object.<span class="hljs-constructor">__ne__(<span class="hljs-params">self</span>, <span class="hljs-params">other</span>)</span><br>&gt;=	object.<span class="hljs-constructor">__ge__(<span class="hljs-params">self</span>, <span class="hljs-params">other</span>)</span><br>&gt;	object.<span class="hljs-constructor">__gt__(<span class="hljs-params">self</span>, <span class="hljs-params">other</span>)</span><br></code></pre></td></tr></table></figure>



<h3 id="类的表示、输出"><a href="#类的表示、输出" class="headerlink" title="类的表示、输出"></a>类的表示、输出</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">str</span><span class="hljs-params">()</span></span>	<span class="hljs-selector-tag">object</span>.__str__(self) <br><span class="hljs-function"><span class="hljs-title">repr</span><span class="hljs-params">()</span></span>	<span class="hljs-selector-tag">object</span>.__repr__(self)<br><span class="hljs-function"><span class="hljs-title">len</span><span class="hljs-params">()</span></span>	<span class="hljs-selector-tag">object</span>.__len__(self)<br><span class="hljs-function"><span class="hljs-title">hash</span><span class="hljs-params">()</span></span>	<span class="hljs-selector-tag">object</span>.__hash__(self) <br><span class="hljs-function"><span class="hljs-title">bool</span><span class="hljs-params">()</span></span>	<span class="hljs-selector-tag">object</span>.__nonzero__(self) <br><span class="hljs-function"><span class="hljs-title">dir</span><span class="hljs-params">()</span></span>	<span class="hljs-selector-tag">object</span>.__dir__(self)<br>sys.getsizeof()	<span class="hljs-selector-tag">object</span>.__sizeof__(self)<br></code></pre></td></tr></table></figure>



<h3 id="类容器"><a href="#类容器" class="headerlink" title="类容器"></a>类容器</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">len<span class="hljs-literal">()</span>	object.<span class="hljs-constructor">__len__(<span class="hljs-params">self</span>)</span><br>self<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span>	object.<span class="hljs-constructor">__getitem__(<span class="hljs-params">self</span>, <span class="hljs-params">key</span>)</span><br>self<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> = value	object.<span class="hljs-constructor">__setitem__(<span class="hljs-params">self</span>, <span class="hljs-params">key</span>, <span class="hljs-params">value</span>)</span><br>del<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> object.<span class="hljs-constructor">__delitem__(<span class="hljs-params">self</span>, <span class="hljs-params">key</span>)</span><br>iter<span class="hljs-literal">()</span>	object.<span class="hljs-constructor">__iter__(<span class="hljs-params">self</span>)</span><br>reversed<span class="hljs-literal">()</span>	object.<span class="hljs-constructor">__reversed__(<span class="hljs-params">self</span>)</span><br><span class="hljs-keyword">in</span>操作	object.<span class="hljs-constructor">__contains__(<span class="hljs-params">self</span>, <span class="hljs-params">item</span>)</span><br>字典key不存在时	object.<span class="hljs-constructor">__missing__(<span class="hljs-params">self</span>, <span class="hljs-params">key</span>)</span><br></code></pre></td></tr></table></figure>





<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/24567545" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24567545</a></p>
<p><a href="https://www.cnblogs.com/jhao/p/6022928.html" target="_blank" rel="noopener">https://www.cnblogs.com/jhao/p/6022928.html</a></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>使用TF2创建数据集</title>
    <url>/page/tf2-create-dataset.html</url>
    <content><![CDATA[<h3 id="使用数据集"><a href="#使用数据集" class="headerlink" title="使用数据集"></a>使用数据集</h3><p>本例中使用的数据集分布在图片文件夹中，一个文件夹含有一类图片。数据集存储格式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain">flower_photo&#x2F;<br>  daisy&#x2F;<br>  dandelion&#x2F;<br>  roses&#x2F;<br>  sunflowers&#x2F;<br>  tulips&#x2F;<br></code></pre></td></tr></table></figure>



<h3 id="下载并查看数据集"><a href="#下载并查看数据集" class="headerlink" title="下载并查看数据集"></a>下载并查看数据集</h3><h4 id="获取数据根目录"><a href="#获取数据根目录" class="headerlink" title="获取数据根目录"></a>获取数据根目录</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">import pathlib<br>data_url = <span class="hljs-string">'https://storage.googleapis.com/download.tensorflow.org/example_images/flower_photos.tgz'</span><br>data_root_orig = tf.keras.utils.get_file(<span class="hljs-attribute">origin</span>=data_url,<br>                                         <span class="hljs-attribute">fname</span>=<span class="hljs-string">'flower_photos'</span>, <br>                                         <span class="hljs-attribute">untar</span>=<span class="hljs-literal">True</span>)<br>data_root = pathlib.Path(data_root_orig)	# data_root存储数据的文件夹的根目录<br></code></pre></td></tr></table></figure>

<h4 id="获取所有图片路径并打乱"><a href="#获取所有图片路径并打乱" class="headerlink" title="获取所有图片路径并打乱"></a>获取所有图片路径并打乱</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">all_image_paths = list(data_root.glob(<span class="hljs-string">'*/*.jpg'</span>))	<span class="hljs-comment">## 获取所有图片路径</span><br>all_image_paths = [str(path) <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> all_image_paths]	<span class="hljs-comment"># 转化为str</span><br>random.shuffle(all_image_paths)	<span class="hljs-comment"># 打乱</span><br>image_count = len(all_image_paths)	<span class="hljs-comment"># 获取图片个数：3670</span><br><br>print(all_image_paths[<span class="hljs-number">99</span>])	<span class="hljs-comment"># 打印第100张图的路径</span><br><span class="hljs-comment"># C:\Users\lenovo\.keras\datasets\flower_photos\tulips\5704726114_a92f753514.jpg</span><br></code></pre></td></tr></table></figure>

<h4 id="获取图片标签信息"><a href="#获取图片标签信息" class="headerlink" title="获取图片标签信息"></a>获取图片标签信息</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">label_names = sorted(item.name <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data_root.glob(<span class="hljs-string">'*/'</span>) <span class="hljs-keyword">if</span> item.is_dir())	<span class="hljs-comment"># 根据文件夹名获取标签名</span><br>label_to_index = dict((name, index) <span class="hljs-keyword">for</span> index, name <span class="hljs-keyword">in</span> enumerate(label_names))	<span class="hljs-comment"># 从0开始给标签设置索引</span><br>all_image_labels = [label_to_index[pathlib.Path(path).parent.name]<br>                    <span class="hljs-keyword">for</span> path <span class="hljs-keyword">in</span> all_image_paths]	<span class="hljs-comment"># 将每张图片与标签一一对应</span><br><br>print(label_names)	<span class="hljs-comment"># ['daisy', 'dandelion', 'roses', 'sunflowers', 'tulips']</span><br>print(label_to_index)	<span class="hljs-comment"># &#123;'daisy': 0, 'dandelion': 1, 'roses': 2, 'sunflowers': 3, 'tulips': 4&#125;</span><br>print(all_image_labels[<span class="hljs-number">99</span>])	<span class="hljs-comment"># 打印第100张图的标签：4</span><br></code></pre></td></tr></table></figure>

<p>由此可见，已经完成了图片与标签一一对应的关系</p>
<h4 id="可视化图片与标签"><a href="#可视化图片与标签" class="headerlink" title="可视化图片与标签"></a>可视化图片与标签</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">import</span> matplotlib.pyplot as plt<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">200</span>, <span class="hljs-number">209</span>):<br>    plt.subplot(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, i<span class="hljs-number">-199</span>)<br>    img = plt.imread(all_image_paths[i])<br>    plt.imshow(img)<br>    plt.xlabel(label_names[all_image_labels[i]])<br>plt.show()<br></code></pre></td></tr></table></figure>

<p><img src="http://cdn.ziyedy.top/%E4%BD%BF%E7%94%A8TF2%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E7%89%87%E4%B8%8E%E6%A0%87%E7%AD%BE.png" alt=""></p>
<h3 id="加载和格式化图片"><a href="#加载和格式化图片" class="headerlink" title="加载和格式化图片"></a>加载和格式化图片</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_and_preprocess_image</span><span class="hljs-params">(path)</span>:</span><br>	<span class="hljs-string">""" 输入为图片路径列表，输出为图片处理后的列表 """</span><br>    images = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(path)):<br>        url = path[i]<br>        image = tf.io.read_file(url)<br>        image = tf.image.decode_jpeg(image, channels=<span class="hljs-number">3</span>)<br>        image = tf.image.resize(image, [<span class="hljs-number">192</span>, <span class="hljs-number">192</span>])<br>        image = image / <span class="hljs-number">255.0</span><br>        images.append(image)<br>    <span class="hljs-keyword">return</span> images<br></code></pre></td></tr></table></figure>

<p><img src="http://cdn.ziyedy.top/%E4%BD%BF%E7%94%A8TF2%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86/%E5%A4%84%E7%90%86%E5%90%8E%E6%95%B0%E6%8D%AE%E5%B1%95%E7%A4%BA.png" alt="处理后数据可视化"></p>
<h3 id="构建数据集"><a href="#构建数据集" class="headerlink" title="构建数据集"></a>构建数据集</h3><h4 id="tf-data-Dataset的基本使用"><a href="#tf-data-Dataset的基本使用" class="headerlink" title="tf.data.Dataset的基本使用"></a>tf.data.Dataset的基本使用</h4><p>tf.data.Dataset是TF2中专门用于数据输入的接口，可以高效的实现数据的读入、打乱（shuffle）、增强（augment）等功能，以下示例简单介绍该接口使用方法</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">data = np.<span class="hljs-built_in">array</span>([<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.05</span>])<br>label = np.<span class="hljs-built_in">array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>])<br>dataset = tf.data.Dataset.from_tensor_slices((data, label))	# 组合为数据集<br><br># 遍历打印<br># tf.Tensor(<span class="hljs-number">0.1</span>, shape=(), dtype=<span class="hljs-built_in">float</span>64) tf.Tensor(<span class="hljs-number">0</span>, shape=(), dtype=<span class="hljs-built_in">int</span>32)<br># tf.Tensor(<span class="hljs-number">0.2</span>, shape=(), dtype=<span class="hljs-built_in">float</span>64) tf.Tensor(<span class="hljs-number">1</span>, shape=(), dtype=<span class="hljs-built_in">int</span>32)<br># tf.Tensor(<span class="hljs-number">0.4</span>, shape=(), dtype=<span class="hljs-built_in">float</span>64) tf.Tensor(<span class="hljs-number">1</span>, shape=(), dtype=<span class="hljs-built_in">int</span>32)<br># tf.Tensor(<span class="hljs-number">0.05</span>, shape=(), dtype=<span class="hljs-built_in">float</span>64) tf.Tensor(<span class="hljs-number">0</span>, shape=(), dtype=<span class="hljs-built_in">int</span>32)<br><br>dataset = dataset.shuffle(buffer_size=image_count)	# 打乱数据<br>dataset = dataset.repeat()	# 使数据能够重复使用<br>dataset = dataset.batch(batch_size=<span class="hljs-number">32</span>)	# 每一个batch为<span class="hljs-number">32</span><br><br># 设置batch后遍历打印<br># tf.Tensor([<span class="hljs-number">0.1</span> <span class="hljs-number">0.2</span>], shape=(<span class="hljs-number">2</span>,), dtype=<span class="hljs-built_in">float</span>64) tf.Tensor([<span class="hljs-number">0</span> <span class="hljs-number">1</span>], shape=(<span class="hljs-number">2</span>,), dtype=<span class="hljs-built_in">int</span>32)<br># tf.Tensor([<span class="hljs-number">0.4</span>  <span class="hljs-number">0.05</span>], shape=(<span class="hljs-number">2</span>,), dtype=<span class="hljs-built_in">float</span>64) tf.Tensor([<span class="hljs-number">1</span> <span class="hljs-number">0</span>], shape=(<span class="hljs-number">2</span>,), dtype=<span class="hljs-built_in">int</span>32)<br></code></pre></td></tr></table></figure>

<p><strong>使用map函数</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">def func(data, label):<br>    data = data<span class="hljs-operator"> * </span><span class="hljs-number">100</span><br>    return data, label<br><br>dataset = dataset.map(func)<br><br># tf.<span class="hljs-constructor">Tensor(10.0, <span class="hljs-params">shape</span>=()</span>, dtype=float64) tf.<span class="hljs-constructor">Tensor(0, <span class="hljs-params">shape</span>=()</span>, dtype=<span class="hljs-built_in">int32</span>)<br># tf.<span class="hljs-constructor">Tensor(20.0, <span class="hljs-params">shape</span>=()</span>, dtype=float64) tf.<span class="hljs-constructor">Tensor(1, <span class="hljs-params">shape</span>=()</span>, dtype=<span class="hljs-built_in">int32</span>)<br># tf.<span class="hljs-constructor">Tensor(40.0, <span class="hljs-params">shape</span>=()</span>, dtype=float64) tf.<span class="hljs-constructor">Tensor(1, <span class="hljs-params">shape</span>=()</span>, dtype=<span class="hljs-built_in">int32</span>)<br># tf.<span class="hljs-constructor">Tensor(5.0, <span class="hljs-params">shape</span>=()</span>, dtype=float64) tf.<span class="hljs-constructor">Tensor(0, <span class="hljs-params">shape</span>=()</span>, dtype=<span class="hljs-built_in">int32</span>)<br></code></pre></td></tr></table></figure>

<p><strong>处理data的map函数的通用格式：</strong></p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">def</span> func(<span class="hljs-class"><span class="hljs-keyword">data</span>, label):</span><br>	# 对<span class="hljs-class"><span class="hljs-keyword">data</span>进行处理</span><br>	return <span class="hljs-class"><span class="hljs-keyword">data</span>, label</span><br></code></pre></td></tr></table></figure>



<h3 id="本次构建数据集"><a href="#本次构建数据集" class="headerlink" title="本次构建数据集"></a>本次构建数据集</h3><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">dataset</span> = tf.data.Dataset.from_tensor_slices((load_and_preprocess_image(all_image_paths), all_image_labels))<br><span class="hljs-attr">dataset</span> = dataset.shuffle(buffer_size=image_count)<br><span class="hljs-attr">dataset</span> = dataset.repeat()<br><span class="hljs-attr">dataset</span> = dataset.batch(batch_size=<span class="hljs-number">32</span>)<br></code></pre></td></tr></table></figure>



<h3 id="进行训练"><a href="#进行训练" class="headerlink" title="进行训练"></a>进行训练</h3><p>之后按照通用的构建网络的模板进行训练即可（构建网络的过程略）</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">history = model.fit(dataset, <span class="hljs-attribute">epochs</span>=10, <span class="hljs-attribute">steps_per_epoch</span>=115)<br></code></pre></td></tr></table></figure>



<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.tensorflow.org/tutorials/load_data/images?hl=zh-cn" target="_blank" rel="noopener">https://www.tensorflow.org/tutorials/load_data/images?hl=zh-cn</a></p>
]]></content>
      <categories>
        <category>AI相关</category>
        <category>TensorFlow2</category>
      </categories>
      <tags>
        <tag>TensorFlow2</tag>
      </tags>
  </entry>
  <entry>
    <title>TF2实现经典CNN架构</title>
    <url>/page/tf2-classic-cnn.html</url>
    <content><![CDATA[<h2 id="卷积神经网络经典操作"><a href="#卷积神经网络经典操作" class="headerlink" title="卷积神经网络经典操作"></a>卷积神经网络经典操作</h2><h3 id="卷积操作"><a href="#卷积操作" class="headerlink" title="卷积操作"></a>卷积操作</h3><figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix">tf.keras.layers.Conv2D (<br>	<span class="hljs-attr">filters</span> = 卷积核个数,<br>	<span class="hljs-attr">kernel_size</span> = 卷积核尺寸, <span class="hljs-comment"># 正方形写核长整数，或（核高h，核宽w）</span><br>	<span class="hljs-attr">strides</span> = 滑动步长, <span class="hljs-comment"># 横纵向相同写步长整数，或(纵向步长h，横向步长w)，默认1</span><br>	<span class="hljs-attr">padding</span> = “same” <span class="hljs-literal">or</span> “valid”, <span class="hljs-comment"># same表示全零填充，valid为默认值</span><br>	<span class="hljs-attr">activation</span> = <span class="hljs-string">"relu"</span> <span class="hljs-comment"># 激活函数，如有BN，此处不写</span><br>	<span class="hljs-attr">input_shape</span> = (高, 宽 , 通道数) <span class="hljs-comment"># 输入特征图维度，可省略</span><br>)<br></code></pre></td></tr></table></figure>



<h3 id="批标准化（Batch-Normalization，BN）"><a href="#批标准化（Batch-Normalization，BN）" class="headerlink" title="批标准化（Batch Normalization，BN）"></a>批标准化（Batch Normalization，BN）</h3><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tf</span><span class="hljs-selector-class">.keras</span><span class="hljs-selector-class">.layers</span><span class="hljs-selector-class">.BatchNormalization</span>()<br></code></pre></td></tr></table></figure>



<h3 id="激活函数（使用BN的情况下才要）"><a href="#激活函数（使用BN的情况下才要）" class="headerlink" title="激活函数（使用BN的情况下才要）"></a>激活函数（使用BN的情况下才要）</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Activation</span><span class="hljs-params">(对应激活函数)</span></span><br></code></pre></td></tr></table></figure>



<h3 id="池化（Pooling）"><a href="#池化（Pooling）" class="headerlink" title="池化（Pooling）"></a>池化（Pooling）</h3><figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix"><span class="hljs-comment"># 最大池化</span><br>tf.keras.layers.MaxPool2D(<br>	<span class="hljs-attr">pool_size=</span> 池化核尺寸,<br>	<span class="hljs-attr">strides=</span> 池化步长, <span class="hljs-comment"># 默认为pool_size</span><br>	<span class="hljs-attr">padding=‘valid’</span> <span class="hljs-literal">or</span> ‘same’<br>)<br><br><span class="hljs-comment"># 平均池化</span><br>tf.keras.layers.AveragePooling2D(<br>	<span class="hljs-attr">pool_size=</span> 池化核尺寸,<br>	<span class="hljs-attr">strides=</span> 池化步长, <span class="hljs-comment"># 默认为pool_size</span><br>	<span class="hljs-attr">padding=‘valid’or‘same’</span><br>)<br></code></pre></td></tr></table></figure>



<h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tf</span><span class="hljs-selector-class">.keras</span><span class="hljs-selector-class">.layers</span><span class="hljs-selector-class">.Dropout</span>(舍弃概率)<br></code></pre></td></tr></table></figure>



<h3 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h3>]]></content>
      <categories>
        <category>AI相关</category>
        <category>TensorFlow2</category>
      </categories>
      <tags>
        <tag>TensorFlow2</tag>
      </tags>
  </entry>
  <entry>
    <title>DS09.2:图的遍历及应用</title>
    <url>/page/graph-traverse-and-user.html</url>
    <content><![CDATA[<p>图的遍历思想是解决很多算法问题的关键，其中深度优先遍历可以使用栈（递归）进行实现，广度优先搜索可以使用队列进行实现。</p>
<p>图的遍历的实现其实和树基本一致，深度优先对应前序遍历，广度优先对应层序遍历</p>
<h2 id="遍历实现"><a href="#遍历实现" class="headerlink" title="遍历实现"></a>遍历实现</h2><h3 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphDFS</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Graph G;	<span class="hljs-comment">// 使用邻接表实现的图结构，参考图的概念与存储结构中的实现</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] visited;	<span class="hljs-comment">// 记录是否访问过</span><br>    <span class="hljs-keyword">private</span> ArrayList&lt;Integer&gt; order = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();	<span class="hljs-comment">// 存储遍历结果</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GraphDFS</span><span class="hljs-params">(Graph G)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.G = G;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[G.getVertex()];<br>        <span class="hljs-comment">// 超过一个连通分量时，进行完全遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v=<span class="hljs-number">0</span>; v&lt;G.getVertex(); v++) &#123;<br>            <span class="hljs-keyword">if</span>(!visited[v]) &#123;<br>                dfs(v);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        visited[v] = <span class="hljs-keyword">true</span>;<br>        order.add(v);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : G.adj(v)) &#123;<br>            <span class="hljs-keyword">if</span> (!visited[w]) &#123;<br>                dfs(w);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterable&lt;Integer&gt; <span class="hljs-title">order</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> order;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h3><p>广度优先遍历在图中有一条很重要的性质，即广度优先搜索能够直接得到<strong>无权图的最短路径</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GraphBFS</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Graph G;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[] visited;<br>    <span class="hljs-keyword">private</span> ArrayList&lt;Integer&gt; order = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GraphBFS</span><span class="hljs-params">(Graph G)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.G = G;<br>        visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[G.getVertex()];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v = <span class="hljs-number">0</span>; v&lt;G.getVertex(); v++) &#123;<br>            <span class="hljs-keyword">if</span>(!visited[v])<br>                bfs(v);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>        Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        queue.add(s);<br>        visited[s] = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty()) &#123;<br>            <span class="hljs-keyword">int</span> v = queue.remove();<br>            order.add(v);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> w : G.adj(v)) &#123;<br>                <span class="hljs-keyword">if</span> (!visited[w]) &#123;<br>                    queue.add(w);<br>                    visited[w] = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterable&lt;Integer&gt; <span class="hljs-title">order</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> order;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="利用遍历可以实现的简单操作"><a href="#利用遍历可以实现的简单操作" class="headerlink" title="利用遍历可以实现的简单操作"></a>利用遍历可以实现的简单操作</h2><p>利用遍历可以解决图结构中包括连通性等诸多问题，这些问题使用bfs和dfs都能够得到解决，以dfs为例。</p>
<h3 id="求图的连通分量"><a href="#求图的连通分量" class="headerlink" title="求图的连通分量"></a>求图的连通分量</h3><p>在遍历代码的基础上使用一个整型记录主函数调用dfs的次数即可（该类问题与常见的海岛个数问题&lt;floodfill算法&gt;思路完全一致）。思路如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v=<span class="hljs-number">0</span>; v&lt;G.getVertex(); v++) &#123;<br>    <span class="hljs-keyword">if</span>(!visited[v]) &#123;<br>        dfs(v);<br>        count++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="记录图中每个节点所属的连通分量"><a href="#记录图中每个节点所属的连通分量" class="headerlink" title="记录图中每个节点所属的连通分量"></a>记录图中每个节点所属的连通分量</h3><p>将记录是否访问过节点的boolean型数组visited改为整型数组，在不同连通分量递归时使用不同的值进行记录即可。大致思路如下半伪码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] visited;<br><span class="hljs-comment">// 遍历将visited的值全部设置为-1，表示没有进行访问</span><br><span class="hljs-keyword">int</span> record = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v=<span class="hljs-number">0</span>; v&lt;G.getVertex(); v++) &#123;<br>    <span class="hljs-keyword">if</span>(!visited[v]) &#123;<br>        dfs(v, record);	<span class="hljs-comment">// 将record值用于标记已访问该节点</span><br>        record++;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 此时visited中就已经记录了每个节点所属连通分量的信息</span><br></code></pre></td></tr></table></figure>



<h3 id="求两点间是否可达"><a href="#求两点间是否可达" class="headerlink" title="求两点间是否可达"></a>求两点间是否可达</h3><p>若两点在同一个连通分量，则代表可达，在上一个问题的基础上进行一下判断就行了。</p>
<h3 id="求两点间的任意一条路径"><a href="#求两点间的任意一条路径" class="headerlink" title="求两点间的任意一条路径"></a>求两点间的任意一条路径</h3><p>使用一个数组存储当前节点前面一个节点，之后根据数组信息即可得到两点间的一条路径，伪码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] pre;<br><span class="hljs-keyword">int</span> target;<br>dfs(v, v);	<span class="hljs-comment">// 求从v到target的任一路径</span><br><br><span class="hljs-comment">// v的上一个节点是parent</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(v, parent)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span>(v == target) <span class="hljs-keyword">return</span>;<br>	visited[v] = <span class="hljs-keyword">true</span>;<br>	pre[v] = parent;<br>	<span class="hljs-keyword">for</span>(w : G.adj(v))<br>		<span class="hljs-keyword">if</span>(!visited[w])<br>		dfs(w, v)<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="检查是否有环"><a href="#检查是否有环" class="headerlink" title="检查是否有环"></a>检查是否有环</h3><p>利用深度优先遍历，若访问到了一个已访问过的点，则有环，若遍历结束都没访问到，则无环。</p>
<h3 id="二分图检测"><a href="#二分图检测" class="headerlink" title="二分图检测"></a>二分图检测</h3><p>二分图就是<strong>顶点V可以分成不相交的两部分，且所有边的两个端点隶属于不同的部分</strong>的一种特殊图结构</p>
<p>二分图的检测也可以使用深度优先遍历进行检测，每遍历到一个点则对其进行染色操作，若相应点已染色，则检查其与其相邻顶点颜色是否匹配，若不匹配则直接返回false</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas库基本用法</title>
    <url>/page/pandas-basic-use.html</url>
    <content><![CDATA[<h2 id="Pandas基础"><a href="#Pandas基础" class="headerlink" title="Pandas基础"></a>Pandas基础</h2><p>Pandas是Python第三方库，提供高性能易用数据类型和分析工具，其基于NumPy实现，常与NumPy和Matplotlib一同使用.</p>
<p>器有两个主要数据类型：<strong>Series, DataFrame</strong></p>
<p>基于上述数据类型的各类操作<br>基本操作、运算操作、特征类操作、关联类操作</p>
<table>
<thead>
<tr>
<th>NumPy</th>
<th>Pandas</th>
</tr>
</thead>
<tbody><tr>
<td>基础数据类型</td>
<td>扩展数据类型</td>
</tr>
<tr>
<td>关注数据的结构表达</td>
<td>关注数据的应用表达</td>
</tr>
<tr>
<td>维度：数据间关系</td>
<td>数据与索引间关系</td>
</tr>
</tbody></table>
<h2 id="Series类型"><a href="#Series类型" class="headerlink" title="Series类型"></a>Series类型</h2><p>Series类型由一组数据及与之相关的数据索引组成（类似python的enumerate）</p>
<p>如下所示，Series为列表<strong>自动创建了索引</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">&gt;&gt;&gt; <span class="hljs-keyword">import</span> pandas as pd<br>&gt;&gt;&gt; p = pd.Series([<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>])<br>&gt;&gt;&gt; p<br><span class="hljs-number">0</span>    <span class="hljs-number">4</span><br><span class="hljs-number">1</span>    <span class="hljs-number">3</span><br><span class="hljs-number">2</span>    <span class="hljs-number">2</span><br><span class="hljs-number">3</span>    <span class="hljs-number">1</span><br>dtype: <span class="hljs-built_in">int</span>64<br></code></pre></td></tr></table></figure>

<p>也可以使用index参数<strong>手动指定索引</strong>（index可省略）</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-meta">&gt;&gt;</span>&gt; import pandas as pd<br><span class="hljs-meta">&gt;&gt;</span>&gt; a = pd.Series([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-string">'a'</span>,<span class="hljs-string">'b'</span>,<span class="hljs-string">'c'</span>])<br><span class="hljs-meta">&gt;&gt;</span>&gt; a<br>a    <span class="hljs-number">1</span><br>b    <span class="hljs-number">2</span><br>c    <span class="hljs-number">3</span><br><span class="hljs-symbol">dtype:</span> int64<br></code></pre></td></tr></table></figure>

<h3 id="Series类型的创建"><a href="#Series类型的创建" class="headerlink" title="Series类型的创建"></a>Series类型的创建</h3><blockquote>
<ul>
<li><p>Python列表，index与列表元素个数一致</p>
</li>
<li><p>标量值，index表达Series类型的尺寸</p>
</li>
<li><p>Python字典，键值对中的“键”是索引，index从字典中进行选择操作</p>
</li>
<li><p>ndarray，索引和数据都可以通过ndarray类型创建</p>
</li>
<li><p>其他函数，range()函数等</p>
</li>
</ul>
</blockquote>
<h3 id="Series类型的操作"><a href="#Series类型的操作" class="headerlink" title="Series类型的操作"></a>Series类型的操作</h3><h4 id="获得索引与数据"><a href="#获得索引与数据" class="headerlink" title="获得索引与数据"></a>获得索引与数据</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">&gt;&gt;&gt; <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.index</span><br><span class="hljs-function"><span class="hljs-title">Index</span><span class="hljs-params">([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>], dtype=<span class="hljs-string">'object'</span>)</span></span><br>&gt;&gt;&gt; <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.values</span><br><span class="hljs-function"><span class="hljs-title">array</span><span class="hljs-params">([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], dtype=int64)</span></span><br></code></pre></td></tr></table></figure>

<h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><p><strong>其他操作基本与numpy和Python中自带的字典一致，包括切片等功能，其中自定义索引与自动索引并存，但不能混用</strong></p>
<h2 id="DataFrame类型"><a href="#DataFrame类型" class="headerlink" title="DataFrame类型"></a>DataFrame类型</h2><p><strong>DataFrame类型由共用相同索引的一组列组成（一种表格型的数据类型）</strong></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>MOOC上北理工相关课程PPT</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>常用模块</category>
      </categories>
      <tags>
        <tag>Pandas</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib库基本使用</title>
    <url>/page/python-matplotlib-use.html</url>
    <content><![CDATA[<h2 id="matplotlib库的基本用法"><a href="#matplotlib库的基本用法" class="headerlink" title="matplotlib库的基本用法"></a>matplotlib库的基本用法</h2><p>这是一个图表可视化的工具，和matlab中对应的图表可视化很像</p>
<p>参考文档以及一些可视化效果可见：<a href="http://matplotlib.org/gallery.html" target="_blank" rel="noopener">http://matplotlib.org/gallery.html</a></p>
<p>导入：<code>import matplotlib.pyplot as plt</code></p>
<h3 id="绘图函数plot"><a href="#绘图函数plot" class="headerlink" title="绘图函数plot()"></a>绘图函数plot()</h3><p>与matlab中对应的绘图函数类似。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># X轴数据，列表或数组，（可选）</span><br><span class="hljs-comment"># Y轴数据，列表或数组，只写一个自动就是y轴数据</span><br><span class="hljs-comment"># 控制曲线的格式字符串，（可选）(颜色字符、风格字符、标记字符)</span><br><span class="hljs-comment"># 第二组或更多(x,y,format_string)</span><br>plt.plot(x, y, format_string, **kwargs)<br></code></pre></td></tr></table></figure>

<h3 id="plt-gca-获取修改坐标轴"><a href="#plt-gca-获取修改坐标轴" class="headerlink" title="plt.gca()获取修改坐标轴"></a>plt.gca()获取修改坐标轴</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br><br></code></pre></td></tr></table></figure>





<h3 id="pyplot的文本显示函数"><a href="#pyplot的文本显示函数" class="headerlink" title="pyplot的文本显示函数"></a>pyplot的文本显示函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>plt.xlabel()</td>
<td>对X轴增加文本标签</td>
</tr>
<tr>
<td>plt.ylabel()</td>
<td>对Y轴增加文本标签</td>
</tr>
<tr>
<td>plt.title()</td>
<td>对图形整体增加文本标签</td>
</tr>
<tr>
<td>plt.text()</td>
<td>在任意位置增加文本</td>
</tr>
<tr>
<td>plt.annotate()</td>
<td>在图形中增加带箭头的注解</td>
</tr>
</tbody></table>
<p>其中annotate()函数中：xy表示箭头指向的坐标，xytest表示文字坐标，之后的arrowprops传入箭头的粗细颜色等信息，具体如下。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>a = np.arange(<span class="hljs-number">0.0</span>, <span class="hljs-number">5.0</span>, <span class="hljs-number">0.02</span>)<br>plt.plot(a, np.cos(<span class="hljs-number">2</span>*np.pi*a))<br><br>plt.xlabel(<span class="hljs-string">"x-axis"</span>)<br>plt.ylabel(<span class="hljs-string">"y-axis"</span>)<br>plt.title(<span class="hljs-string">r'$y = cos(2 \pi x)$'</span>)	<span class="hljs-comment"># 使用latex</span><br>plt.annotate(<span class="hljs-string">r'$cos(2 \pi x)$'</span>, xy=(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>), xytext=(<span class="hljs-number">3</span>, <span class="hljs-number">1.5</span>),<br>            arrowprops=dict(facecolor=<span class="hljs-string">'black'</span>, shrink=<span class="hljs-number">0.1</span>, width=<span class="hljs-number">1</span>))<br><br>plt.axis([<span class="hljs-number">-1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">2</span>])<br>plt.grid(<span class="hljs-literal">True</span>)<br>plt.show()<br></code></pre></td></tr></table></figure>

<p><img src="http://cdn.ziyedy.top/image/matplotlib%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/plot%E7%A4%BA%E4%BE%8B.png" alt=""></p>
<h3 id="plt-figure"><a href="#plt-figure" class="headerlink" title="plt.figure()"></a>plt.figure()</h3><h4 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h4><img src="http://cdn.ziyedy.top/image/matplotlib%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/fig%E4%B8%8Eaxis.png" style="zoom:67%;" />

<h4 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h4><figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">figure(num=<span class="hljs-literal">None</span>, figsize=<span class="hljs-literal">None</span>, dpi=<span class="hljs-literal">None</span>, facecolor=<span class="hljs-literal">None</span>, edgecolor=<span class="hljs-literal">None</span>, frameon=<span class="hljs-literal">True</span>)<br><br><span class="hljs-string">"""<br>      num : 图像编号或名称，数字为编号，字符串为名称<br>  figsize : 指定figure的宽和高，单位为英寸<br>      dpi : 指定绘图对象的分辨率，即每英寸多少个像素，缺省值为80<br>facecolor : 背景的颜色<br>edgecolor : 边框颜色<br>  frameon : 是否显示边框<br>"""</span><br><br><span class="hljs-comment"># 示例</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>fig = plt.figure(figsize=(<span class="hljs-number">4</span>, <span class="hljs-number">3</span>), facecolor=<span class="hljs-string">'blue'</span>)<br>plt.plot([<span class="hljs-number">1</span> ,<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br>plt.show()<br></code></pre></td></tr></table></figure>

<p><img src="http://cdn.ziyedy.top/image/matplotlib%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/figure%E7%A4%BA%E4%BE%8B.png" alt=""></p>
<h3 id="plt-subplot-创建单个子图"><a href="#plt-subplot-创建单个子图" class="headerlink" title="plt.subplot()创建单个子图"></a>plt.subplot()创建单个子图</h3><p>即将绘图区域分为nrows行，ncols列，然后在从上向下从左到右第plot_number处进行绘图。使用与matlab中的函数基本一致，还有一些比较复杂的绘图函数，我个人认为没有什么必要（要是用在文章中放进ai再处理好了，没必要直接输出成图吧）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.subplot</span>(<span class="hljs-selector-tag">nrows</span>, <span class="hljs-selector-tag">ncols</span>, <span class="hljs-selector-tag">plot_number</span>)<br></code></pre></td></tr></table></figure>



<h3 id="plt-subplots-创建多个子图"><a href="#plt-subplots-创建多个子图" class="headerlink" title="plt.subplots()创建多个子图"></a>plt.subplots()创建多个子图</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">import</span> numpy as np<br><span class="hljs-keyword">import</span> matplotlib.pyplot as plt<br><br>x = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br>#划分子图<br>fig, axes = plt.subplots(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>ax1 = axes[<span class="hljs-number">0</span>, <span class="hljs-number">0</span>]<br>ax2 = axes[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>]<br>ax3 = axes[<span class="hljs-number">1</span>, <span class="hljs-number">0</span>]<br>ax4 = axes[<span class="hljs-number">1</span>, <span class="hljs-number">1</span>]<br><br>#作图<span class="hljs-number">1</span><br>ax1.plot(x, x)<br>#作图<span class="hljs-number">2</span><br>ax2.plot(x, x)<br>#作图<span class="hljs-number">3</span><br>ax3.plot(x, x ** <span class="hljs-number">2</span>)<br>#作图<span class="hljs-number">4</span><br>ax4.plot(x, np.log(x))<br>plt.show()<br></code></pre></td></tr></table></figure>

<p><img src="http://cdn.ziyedy.top/image/matplotlib%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/subplots%E7%A4%BA%E4%BE%8B.png" alt=""></p>
<h3 id="面向对象API"><a href="#面向对象API" class="headerlink" title="面向对象API"></a>面向对象API</h3><h4 id="add-subplot新增子图"><a href="#add-subplot新增子图" class="headerlink" title="add_subplot新增子图"></a>add_subplot新增子图</h4><p>该方法与subplot方法类似，如下代码即与plt.subplots()中绘制第一幅图和第三幅图等价</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">import</span> numpy as np<br><span class="hljs-keyword">import</span> matplotlib.pyplot as plt<br><br>x = np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">100</span>)<br>#新建figure对象<br>fig = plt.figure()<br>#新建子图<span class="hljs-number">1</span><br>ax1 = fig.add_subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>ax1.plot(x, x)<br>#新建子图<span class="hljs-number">3</span><br>ax3 = fig.add_subplot(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>ax3.plot(x, x ** <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>

<h4 id="add-axes新增子区域（图中图）"><a href="#add-axes新增子区域（图中图）" class="headerlink" title="add_axes新增子区域（图中图）"></a>add_axes新增子区域（图中图）</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">import</span> <span class="hljs-string">numpy</span> <span class="hljs-string">as</span> <span class="hljs-string">np</span><br><span class="hljs-string">import</span> <span class="hljs-string">matplotlib.pyplot</span> <span class="hljs-string">as</span> <span class="hljs-string">plt</span><br><br><span class="hljs-comment">#新建figure对象</span><br><span class="hljs-string">fig</span> <span class="hljs-string">=</span> <span class="hljs-string">plt.figure()</span><br><br><span class="hljs-comment">#定义数据</span><br><span class="hljs-string">x</span> <span class="hljs-string">=</span> <span class="hljs-string">[1,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">,</span> <span class="hljs-number">6</span><span class="hljs-string">,</span> <span class="hljs-number">7</span><span class="hljs-string">]</span><br><span class="hljs-string">y</span> <span class="hljs-string">=</span> <span class="hljs-string">[1,</span> <span class="hljs-number">3</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">5</span><span class="hljs-string">,</span> <span class="hljs-number">8</span><span class="hljs-string">,</span> <span class="hljs-number">6</span><span class="hljs-string">]</span><br><br><span class="hljs-comment">#新建区域ax1</span><br><span class="hljs-comment">#figure的百分比，从figure 10%的位置开始绘制，宽高是figure的80%</span><br><span class="hljs-string">left,</span> <span class="hljs-string">bottom,</span> <span class="hljs-string">width,</span> <span class="hljs-string">height</span> <span class="hljs-string">=</span> <span class="hljs-number">0.1</span><span class="hljs-string">,</span> <span class="hljs-number">0.1</span><span class="hljs-string">,</span> <span class="hljs-number">0.8</span><span class="hljs-string">,</span> <span class="hljs-number">0.8</span><br><span class="hljs-comment">#获得绘制的句柄</span><br><span class="hljs-string">ax1</span> <span class="hljs-string">=</span> <span class="hljs-string">fig.add_axes([left,</span> <span class="hljs-string">bottom,</span> <span class="hljs-string">width,</span> <span class="hljs-string">height])</span><br><span class="hljs-string">ax1.plot(x,</span> <span class="hljs-string">y,</span> <span class="hljs-string">'r'</span><span class="hljs-string">)</span><br><span class="hljs-string">ax1.set_title('area1')</span><br><br><br><span class="hljs-comment">#新增区域ax2，嵌套在ax1内</span><br><span class="hljs-string">left,</span> <span class="hljs-string">bottom,</span> <span class="hljs-string">width,</span> <span class="hljs-string">height</span> <span class="hljs-string">=</span> <span class="hljs-number">0.2</span><span class="hljs-string">,</span> <span class="hljs-number">0.6</span><span class="hljs-string">,</span> <span class="hljs-number">0.25</span><span class="hljs-string">,</span> <span class="hljs-number">0.25</span><br><span class="hljs-comment">#获得绘制的句柄</span><br><span class="hljs-string">ax2</span> <span class="hljs-string">=</span> <span class="hljs-string">fig.add_axes([left,</span> <span class="hljs-string">bottom,</span> <span class="hljs-string">width,</span> <span class="hljs-string">height])</span><br><span class="hljs-string">ax2.plot(x,</span> <span class="hljs-string">y,</span> <span class="hljs-string">'b'</span><span class="hljs-string">)</span><br><span class="hljs-string">ax2.set_title('area2')</span><br><span class="hljs-string">plt.show()</span><br></code></pre></td></tr></table></figure>

<p><img src="http://cdn.ziyedy.top/image/matplotlib%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/%E5%9B%BE%E4%B8%AD%E5%9B%BE.png" alt=""></p>
<h3 id="保存图像"><a href="#保存图像" class="headerlink" title="保存图像"></a>保存图像</h3><p>使用plt.savefig()能很容易的实现，但应当注意，<strong>必须写在plt.show()之前</strong>，否则保存的图像会是空白的</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.savefig</span>(<span class="hljs-string">'test.png'</span>)<br></code></pre></td></tr></table></figure>





<h2 id="常用可视化图表绘制"><a href="#常用可视化图表绘制" class="headerlink" title="常用可视化图表绘制"></a>常用可视化图表绘制</h2><p>常见可视化图表如下</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>plt.plot(x,y,fmt,…)</td>
<td>绘制一个坐标图</td>
</tr>
<tr>
<td>plt.scatter(x,y)</td>
<td>绘制散点图，其中，x和y长度相同</td>
</tr>
<tr>
<td>plt.bar(left,height,width,bottom)</td>
<td>绘制一个条形图</td>
</tr>
<tr>
<td>plt.contour(X,Y,Z,N)</td>
<td>绘制等值图</td>
</tr>
<tr>
<td>plt.pie(data, explode)</td>
<td>绘制饼图（explode传入一个元组，表示一块出来的比例）</td>
</tr>
<tr>
<td>plt.hist(x,bins)</td>
<td>绘制直方图（bins代表直方图个数）</td>
</tr>
<tr>
<td>plt.polar(theta, r)</td>
<td>绘制极坐标图</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<h3 id="饼图（pie）"><a href="#饼图（pie）" class="headerlink" title="饼图（pie）"></a>饼图（pie）</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">import</span> numpy as np<br><span class="hljs-keyword">import</span> matplotlib.pyplot as plt<br><br>labels = <span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>, <span class="hljs-string">'D'</span><br>sizes = [<span class="hljs-number">10</span>, <span class="hljs-number">20</span> ,<span class="hljs-number">30</span>, <span class="hljs-number">40</span>]<br>explode = (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0.15</span>)<br>plt.pie(sizes, explode=explode, labels=labels)<br>plt.show()<br></code></pre></td></tr></table></figure>

<p><img src="http://cdn.ziyedy.top/image/matplotlib%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/%E9%A5%BC%E5%9B%BE.png" alt=""></p>
<h3 id="直方图（hist）"><a href="#直方图（hist）" class="headerlink" title="直方图（hist）"></a>直方图（hist）</h3><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">import numpy <span class="hljs-keyword">as</span> np<br>import matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>np.<span class="hljs-built_in">random</span>.seed(<span class="hljs-number">0</span>)<br>mu, sigma = <span class="hljs-number">100</span>, <span class="hljs-number">20</span><br><span class="hljs-keyword">a</span> = np.<span class="hljs-built_in">random</span>.<span class="hljs-keyword">normal</span>(mu, sigma, size=<span class="hljs-number">100</span>)<br>plt.hist(<span class="hljs-keyword">a</span>, bins=<span class="hljs-number">40</span>, facecolor=<span class="hljs-string">'r'</span>)<br>plt.show()<br></code></pre></td></tr></table></figure>

<p><img src="http://cdn.ziyedy.top/image/matplotlib%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/%E7%9B%B4%E6%96%B9%E5%9B%BE.png" alt=""></p>
<h3 id="等值图（contour）"><a href="#等值图（contour）" class="headerlink" title="等值图（contour）"></a>等值图（contour）</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">import</span> numpy as np<br><span class="hljs-keyword">import</span> matplotlib.pyplot as plt<br><br>delta = <span class="hljs-number">0.025</span><br>x = np.arange(<span class="hljs-number">-3.0</span>, <span class="hljs-number">3.0</span>, delta)<br>y = np.arange(<span class="hljs-number">-3.0</span>, <span class="hljs-number">3.0</span>, delta)<br>X, Y = np.meshgrid(x, y)<br>Z = np.exp(-X**<span class="hljs-number">2</span>/<span class="hljs-number">12</span> - Y**<span class="hljs-number">2</span>/<span class="hljs-number">2</span>)<br>plt.contour(X, Y, Z)<br>plt.show()<br></code></pre></td></tr></table></figure>

<p><img src="http://cdn.ziyedy.top/image/matplotlib%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/%E7%AD%89%E5%80%BC%E5%9B%BE.png" alt=""></p>
<h2 id="matplotlib总结图（源于知乎）"><a href="#matplotlib总结图（源于知乎）" class="headerlink" title="matplotlib总结图（源于知乎）"></a>matplotlib总结图（源于知乎）</h2><p><img src="http://cdn.ziyedy.top/image/matplotlib%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/matplotlib%E6%80%BB%E7%BB%93.jpg" alt="图源自知乎"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.dazhuanlan.com/2020/01/19/5e24219f9ae61/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2020/01/19/5e24219f9ae61/</a></p>
<p>mooc北理工相关课程</p>
<p><a href="http://matplotlib.org/gallery.html" target="_blank" rel="noopener">http://matplotlib.org/gallery.html</a></p>
<p><a href="https://www.zhihu.com/question/51745620" target="_blank" rel="noopener">https://www.zhihu.com/question/51745620</a></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>常用模块</category>
      </categories>
      <tags>
        <tag>matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>Numpy常用属性与方法</title>
    <url>/page/numpy-basic-use.html</url>
    <content><![CDATA[<h2 id="n维数组对象：ndarray"><a href="#n维数组对象：ndarray" class="headerlink" title="n维数组对象：ndarray"></a>n维数组对象：ndarray</h2><p>ndarray对象主要由两部分构成，即实际的数据和描述这些数据的元数据（数据维度、类型）等。</p>
<h3 id="相比于Python列表的优势"><a href="#相比于Python列表的优势" class="headerlink" title="相比于Python列表的优势"></a>相比于Python列表的优势</h3><p><strong>1、数组对象可以去掉元素间运算所需的循环，使一维向量更像单个数据</strong>，如下：</p>
<p>Python中的数组对象进行平方：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">l = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(len(a));<br>	a[i] = a[i]**<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>ndarray进行平方</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">import</span> numpy as np<br>a = np.<span class="hljs-built_in">array</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br>a = a**<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>2、设置专门的数组对象，经过优化，可以提升这类应用的运算速度</p>
<p>3、数组对象采用相同的数据类型，有助于节省运算和存储空间</p>
<h3 id="ndarray对象属性"><a href="#ndarray对象属性" class="headerlink" title="ndarray对象属性"></a>ndarray对象属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.ndim</td>
<td>秩，即轴的数量或维度的数量</td>
</tr>
<tr>
<td>.shape</td>
<td>ndarray对象的尺度，对于矩阵，n行m列</td>
</tr>
<tr>
<td>.size</td>
<td>ndarray对象元素的个数，相当于.shape中n*m的值</td>
</tr>
<tr>
<td>.dtype</td>
<td>ndarray对象的元素类型</td>
</tr>
<tr>
<td>.itemsize</td>
<td>ndarray对象中每个元素的大小，以字节为单位</td>
</tr>
</tbody></table>
<h3 id="ndarray元素类型"><a href="#ndarray元素类型" class="headerlink" title="ndarray元素类型"></a>ndarray元素类型</h3><p>包括主要的一些类型，类型后面的数字代表长度，常见的如bool、int32、float32、complex64（虚数）等等。</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h3><h4 id="从Python中的列表、元组等类型创建"><a href="#从Python中的列表、元组等类型创建" class="headerlink" title="从Python中的列表、元组等类型创建"></a>从Python中的列表、元组等类型创建</h4><figure class="highlight sas"><table><tr><td class="code"><pre><code class="hljs sas"><span class="hljs-meta">x</span> = np.<span class="hljs-meta">array</span>(<span class="hljs-meta">list</span>/tuple)<br></code></pre></td></tr></table></figure>

<h4 id="使用相应函数创建"><a href="#使用相应函数创建" class="headerlink" title="使用相应函数创建"></a>使用相应函数创建</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>np.arange(n)</td>
<td>类似range()函数，返回ndarray类型，元素从0到n‐1</td>
</tr>
<tr>
<td>np.ones(shape)</td>
<td>根据shape生成一个全1数组，shape是元组类型</td>
</tr>
<tr>
<td>np.zeros(shape)</td>
<td>根据shape生成一个全0数组，shape是元组类型</td>
</tr>
<tr>
<td>np.full(shape,val)</td>
<td>根据shape生成一个数组，每个元素值都是val</td>
</tr>
<tr>
<td>np.eye(n)</td>
<td>创建一个正方的n*n单位矩阵，对角线为1，其余为0</td>
</tr>
<tr>
<td>np.ones_like(a)</td>
<td>根据数组a的形状生成一个全1数组</td>
</tr>
<tr>
<td>np.zeros_like(a)</td>
<td>根据数组a的形状生成一个全0数组</td>
</tr>
<tr>
<td>np.full_like(a,val)</td>
<td>根据数组a的形状生成一个数组，每个元素值都是val</td>
</tr>
</tbody></table>
<h4 id="创建网格（meshgrid）"><a href="#创建网格（meshgrid）" class="headerlink" title="创建网格（meshgrid）"></a>创建网格（meshgrid）</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br><br></code></pre></td></tr></table></figure>





<h4 id="其他方法创建"><a href="#其他方法创建" class="headerlink" title="其他方法创建"></a>其他方法创建</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>np.linspace(begin, end, bia)</td>
<td>根据起止数据等间距地填充数据，形成数组（从begin到end，共bia个数）</td>
</tr>
<tr>
<td>np.concatenate()</td>
<td>将两个或多个数组合并成一个新的数组</td>
</tr>
</tbody></table>
<p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">&gt;&gt;&gt; a = np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">3</span>)<br>&gt;&gt;&gt; a<br><span class="hljs-built_in">array</span>([ <span class="hljs-number">1.</span> ,  <span class="hljs-number">5.5</span>, <span class="hljs-number">10.</span> ])<br>&gt;&gt;&gt; b = np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">3</span>, endpoint=False)<br>&gt;&gt;&gt; b<br><span class="hljs-built_in">array</span>([<span class="hljs-number">1.</span>, <span class="hljs-number">4.</span>, <span class="hljs-number">7.</span>])<br>&gt;&gt;&gt; c = np.concatenate((a, b))<br>&gt;&gt;&gt; c<br><span class="hljs-built_in">array</span>([ <span class="hljs-number">1.</span> ,  <span class="hljs-number">5.5</span>, <span class="hljs-number">10.</span> ,  <span class="hljs-number">1.</span> ,  <span class="hljs-number">4.</span> ,  <span class="hljs-number">7.</span> ])<br></code></pre></td></tr></table></figure>



<h3 id="变换方法"><a href="#变换方法" class="headerlink" title="变换方法"></a>变换方法</h3><h4 id="维度变换"><a href="#维度变换" class="headerlink" title="维度变换"></a>维度变换</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.reshape(shape)</td>
<td>不改变数组元素，返回一个shape形状的数组，<strong>原数组不变</strong></td>
</tr>
<tr>
<td>.resize(shape)</td>
<td>与.reshape()功能一致，但<strong>修改原数组</strong></td>
</tr>
<tr>
<td>.flatten()</td>
<td>对数组进行降维，返回折叠后的一维数组，原数组不变</td>
</tr>
</tbody></table>
<p><strong>如果只想指示一个维度，而自动决定其他维度有多少个值，可以使用-1的写法（如果不能整除会报错）</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"># 想让数组有<span class="hljs-number">5</span>行，列数自动决定<br>x.reshape(<span class="hljs-number">5</span>, <span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure>



<h4 id="类型变换"><a href="#类型变换" class="headerlink" title="类型变换"></a>类型变换</h4><p>astype()方法一定会创建新的数组（原始数据的一个拷贝），即使两个类型一致</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-title">new_l</span> = l.<span class="hljs-keyword">as</span><span class="hljs-keyword">type</span>(new_type)<br></code></pre></td></tr></table></figure>

<h4 id="转换为列表"><a href="#转换为列表" class="headerlink" title="转换为列表"></a>转换为列表</h4><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">l</span> = n.tolist()<br></code></pre></td></tr></table></figure>



<h3 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h3><h4 id="索引与切片"><a href="#索引与切片" class="headerlink" title="索引与切片"></a>索引与切片</h4><p><strong>ndarray数组的索引与切片与Python中的索引与切片大致相同</strong></p>
<h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p><strong>ndarray数组与标量之间的运算作用于数组的每一个元素，包括平方立方等等，示例如下：</strong></p>
<figure class="highlight gml"><table><tr><td class="code"><pre><code class="hljs gml">np.<span class="hljs-built_in">abs</span>(n)	<span class="hljs-comment">// 各元素的绝对值</span><br>np.<span class="hljs-built_in">sqrt</span>(<span class="hljs-symbol">x</span>)	<span class="hljs-comment">// 各元素的平方根</span><br></code></pre></td></tr></table></figure>

<p>同时使用数组中进行大小比较等运算时，会返回一个数值为布尔类型的数组（<strong>也是每个元素进行比较</strong>）</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">X = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br>print(X &gt; <span class="hljs-number">3</span>)<br>#######################################<br>[[<span class="hljs-literal">False</span> <span class="hljs-literal">False</span> <span class="hljs-literal">False</span>]<br> [ <span class="hljs-literal">True</span>  <span class="hljs-literal">True</span>  <span class="hljs-literal">True</span>]]<br></code></pre></td></tr></table></figure>

<p>借用这个特性，可以完成对满足某一要求的元素进行如赋值等其他操作</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">X = np.array([[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>]])<br>X[X &gt; <span class="hljs-number">3</span>] = <span class="hljs-number">10</span><br>print(X)<br>####################################<br>[[ <span class="hljs-number">1</span>  <span class="hljs-number">2</span>  <span class="hljs-number">3</span>]<br> [<span class="hljs-number">10</span> <span class="hljs-number">10</span> <span class="hljs-number">10</span>]]<br></code></pre></td></tr></table></figure>





<h4 id="合并与分割"><a href="#合并与分割" class="headerlink" title="合并与分割"></a>合并与分割</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>np.concatenate([n1, n2], axis=1)</td>
<td>将矩阵n1、n2按照第1个维度合并（axis默认为0）。同时返回一个新的矩阵</td>
</tr>
<tr>
<td>np.vstack([n1, n2])</td>
<td>在垂直的维度合并n1，n2</td>
</tr>
<tr>
<td>np.hstack([n1, n2])</td>
<td>在水平方向合并n1,n2</td>
</tr>
<tr>
<td>x1, x2, x3 = np.split(x, [2,4], axis=1)</td>
<td>将x按照[0, 2)、[2, 4)、[4, end)进行分割并赋值（依此类推）</td>
</tr>
<tr>
<td>np.vsplit()、np.hsplit()</td>
<td></td>
</tr>
</tbody></table>
<h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>A.dot(B)</td>
<td>矩阵乘法</td>
</tr>
<tr>
<td>A.T</td>
<td>矩阵转置</td>
</tr>
<tr>
<td>np.linalg.inv(A)</td>
<td>矩阵的逆</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>np.random.shuffle(x)</td>
<td>对x进行乱序处理</td>
</tr>
<tr>
<td>np.sort(x)</td>
<td>返回排序后的x</td>
</tr>
</tbody></table>
<h3 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h3><p>在numpy的子库numpy.random中</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>rand(d0,d1,..,dn)</td>
<td>根据d0‐dn作为维度创建随机数数组，浮点数，[0,1)，均匀分布</td>
</tr>
<tr>
<td>randn(d0,d1,..,dn)</td>
<td>根据d0‐dn创建随机数数组，标准正态分布</td>
</tr>
<tr>
<td>randint(low, high, shape)</td>
<td>根据shape创建随机整数或整数数组，范围是[low, high)</td>
</tr>
<tr>
<td>seed(s)</td>
<td>随机数种子，s是给定的种子值（计算机中随机数都是“伪随机数”，依赖于该随机种子）</td>
</tr>
<tr>
<td>normal(均值, 方差, shape)</td>
<td>生成给定均值与方差的符合正态分布的数或矩阵，shape为(元组)</td>
</tr>
</tbody></table>
<h3 id="统计函数（聚合函数）"><a href="#统计函数（聚合函数）" class="headerlink" title="统计函数（聚合函数）"></a>统计函数（聚合函数）</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sum(a, axis=None)</td>
<td>根据给定轴axis计算数组a相关元素之和，axis整数或元组</td>
</tr>
<tr>
<td>mean(a, axis=None)</td>
<td>根据给定轴axis计算数组a相关元素的期望，axis整数或元组</td>
</tr>
<tr>
<td>average(a,axis=None,weights=None)</td>
<td>根据给定轴axis计算数组a相关元素的加权平均值，weights是列表</td>
</tr>
<tr>
<td>std(a, axis=None)</td>
<td>根据给定轴axis计算数组a相关元素的标准差</td>
</tr>
<tr>
<td>var(a, axis=None)</td>
<td>根据给定轴axis计算数组a相关元素的方差</td>
</tr>
<tr>
<td>min(a)  max(a)</td>
<td>计算数组a中元素的最小值、最大值</td>
</tr>
<tr>
<td>argmin(a)  argmax(a)</td>
<td>计算数组a中元素最小值、最大值的降一维后下标</td>
</tr>
</tbody></table>
<h3 id="梯度函数"><a href="#梯度函数" class="headerlink" title="梯度函数"></a>梯度函数</h3><p><code>np.gradient(f)</code>，计算数组f中元素的梯度（即连续值之间的变化率），当f为多维时，返回每个维度梯度</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">&gt;&gt;&gt; a = np.arange(<span class="hljs-number">5</span>)<br>&gt;&gt;&gt; a<br><span class="hljs-built_in">array</span>([<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br>&gt;&gt;&gt; np.gradient(a)<br><span class="hljs-built_in">array</span>([<span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>, <span class="hljs-number">1.</span>])<br></code></pre></td></tr></table></figure>

<p><strong>说明：</strong>以索引为2的值为例，该处梯度的计算值为(a[3] - a[1]) / 2 = 1</p>
<h3 id="ndarray数据的读写"><a href="#ndarray数据的读写" class="headerlink" title="ndarray数据的读写"></a>ndarray数据的读写</h3><h4 id="二维数据读写"><a href="#二维数据读写" class="headerlink" title="二维数据读写"></a>二维数据读写</h4><p><strong>CSV文件</strong>，以逗号作为分隔符的常见文件格式</p>
<p><strong>np.savetxt()</strong>：写入文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># frame : 文件、字符串或产生器</span><br><span class="hljs-comment"># array : 存入文件的数组</span><br><span class="hljs-comment"># fmt : 写入文件的格式</span><br><span class="hljs-comment"># delimiter : 分割字符串，默认是任何空格</span><br>np.savetxt(frame, array, fmt=<span class="hljs-string">'%.18e'</span>, delimiter=<span class="hljs-literal">None</span>)<br></code></pre></td></tr></table></figure>

<p>例:</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">np.savetxt(<span class="hljs-string">'a.csv'</span>, a, <span class="hljs-attribute">fmt</span>=<span class="hljs-string">'%d'</span>, <span class="hljs-attribute">delimiter</span>=<span class="hljs-string">','</span>)<br></code></pre></td></tr></table></figure>

<p><strong>np.loadtxt()</strong>：读取文件</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># unpack  : 如果True，读入属性将分别写入不同变量</span><br>np.loadtxt(frame, dtype=np.float, delimiter=<span class="hljs-literal">None</span>， unpack=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>

<h4 id="多维数据存取"><a href="#多维数据存取" class="headerlink" title="多维数据存取"></a>多维数据存取</h4><p><strong>a.tofile()</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># frame  : 文件、字符串</span><br><span class="hljs-comment"># sep : 数据分割字符串，如果是空串，写入文件为二进制</span><br><span class="hljs-comment"># format : 写入数据的格式</span><br>a.tofile(frame, <span class="hljs-attribute">sep</span>=<span class="hljs-string">''</span>, <span class="hljs-attribute">format</span>=<span class="hljs-string">'%s'</span>)<br></code></pre></td></tr></table></figure>

<p><strong>np.fromfile()</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># count  : 读入元素个数，‐1表示读入整个文件</span><br><span class="hljs-comment"># sep : 数据分割字符串，如果是空串，写入文件为二进制</span><br>np.fromfile(frame, <span class="hljs-attribute">dtype</span>=float, <span class="hljs-attribute">count</span>=‐1, <span class="hljs-attribute">sep</span>=<span class="hljs-string">''</span>)<br></code></pre></td></tr></table></figure>

<h4 id="便捷文件存取"><a href="#便捷文件存取" class="headerlink" title="便捷文件存取"></a>便捷文件存取</h4><p>其中文件名称通常以.npy为拓展名</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">np</span>.<span class="hljs-built_in">save</span>(fname, <span class="hljs-built_in">array</span>)<br><br><span class="hljs-built_in">np</span>.<span class="hljs-built_in">load</span>(fname)<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
        <category>常用模块</category>
      </categories>
      <tags>
        <tag>Numpy</tag>
      </tags>
  </entry>
  <entry>
    <title>vim基本用法</title>
    <url>/page/vim-basic-use.html</url>
    <content><![CDATA[<h3 id="启动vi"><a href="#启动vi" class="headerlink" title="启动vi"></a>启动vi</h3><figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">vi</span><br></code></pre></td></tr></table></figure>



<h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>退出vi，出现未保存文件等情况会无法退出</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><code class="hljs clojure"><span class="hljs-symbol">:q</span><br></code></pre></td></tr></table></figure>

<p>强制退出</p>
<figure class="highlight clojure"><table><tr><td class="code"><pre><code class="hljs clojure"><span class="hljs-symbol">:q!</span><br></code></pre></td></tr></table></figure>

<h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><figure class="highlight clojure"><table><tr><td class="code"><pre><code class="hljs clojure"><span class="hljs-symbol">:w</span><br></code></pre></td></tr></table></figure>



<blockquote>
<p>vi分为3种模式，一般命令模式、编辑模式、命令行模式</p>
</blockquote>
<h3 id="一般命令模式（commmand-mode）"><a href="#一般命令模式（commmand-mode）" class="headerlink" title="一般命令模式（commmand mode）"></a>一般命令模式（commmand mode）</h3><p>默认的模式，可以移动光标、删除字符删除整行、复制粘贴文件内容</p>
<h3 id="编辑模式（insert-mode）"><a href="#编辑模式（insert-mode）" class="headerlink" title="编辑模式（insert mode）"></a>编辑模式（insert mode）</h3><p>要在文件中添加文本，我们需要先进入插入模式。按下”i”键进入插入模式。</p>
<p>若要退出插入模式返回命令模式，按下 Esc 按键。</p>
<h3 id="命令行模式（command-line-mode）"><a href="#命令行模式（command-line-mode）" class="headerlink" title="命令行模式（command-line mode）"></a>命令行模式（command-line mode）</h3><p>输入<code>: / ?</code>任意一个字符则可以在底部输入命令，可以实现查找数据、读取保存批量替换字符、退出、显示行号等操作</p>
<p>常用命令记录</p>
<p>使用数字键 n⬇就代表向下移动n行</p>
<p>Ctrl + f  向下翻页</p>
<p>Ctrl + b 向上翻页</p>
<p>0 或 Home 移动到该行最前面</p>
<p>$ 或 End 移动到改行最后面</p>
<p>G 移动到文件最后一行</p>
<p>gg 1G 移动到文件第一行</p>
<p>nG 移动到文件第n行</p>
<p>n&lt;space&gt; 光标向后移动n个字符</p>
<p>n&lt;Enter&gt; n为数字，光标向下移动n行</p>
<p>/word 向光标之下查找名为word的字符串</p>
<p>?word 向光标之上查找名为word的字符串</p>
<p>n 此处n不代表数字，重复前一个查找操作</p>
<p>N 与n的查找方向相反</p>
<p>:1,10s/word1/word2/g 将第1到10行之间的word1替换为word2</p>
<p>:1,$s/word1/word2/g 全文替换</p>
<p>:1,$s/word1/word2/gc 全文替换，并在替换前让用户confirm</p>
<p>x 向后删除一个字符</p>
<p>nx 向后删除n个字符</p>
<p>dd 删除（剪切）光标所在行</p>
<p>ndd 处理后面n行</p>
<p>yy 复制光标所在行</p>
<p>nyy</p>
<p>p 在光标下一行粘贴</p>
<p>u 撤销上一步操作</p>
<p>Ctrl+r 重做上一个操作（撤销还原）</p>
<p>. 重复上一个操作</p>
<p>:! command 暂时退出vi到中断执行command命令：</p>
<p>:set nu 显示行号</p>
<p>:set nonu 取消行号</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>DS09.1:图的概念与存储结构</title>
    <url>/page/graph-basic-knowledge.html</url>
    <content><![CDATA[<h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><p>图是由顶点的集合和顶点之间的边的集合组成的，通常表示为G(V, E)。其中G表示一个图，V是图G中的顶点的集合，E是图G中边的集合。</p>
<p>图按照<strong>边是否有方向</strong>和<strong>边是否带权重</strong>可以分为四类，即有向无权图、有向有权图、无向无权图、无向有权图。</p>
<p><strong>无向图的边</strong>通常使用“()”表示，如A与B之间的边就是(A, B)或(B, A)</p>
<p><strong>有向边</strong>则通常使用“&lt;&gt;”表示，如A到B的边就是&lt;A, B&gt;，这时边有方向性，字母不能够替换。</p>
<p>图按照边的多少分为<strong>稀疏图</strong>和<strong>稠密图</strong>。若任意两个顶点之间都存在边叫<strong>完全图</strong>（无向完全图有n(n-1)/2条边）。没有自环边、没有平行边的图称为<strong>简单图</strong>。</p>
<p>无向图顶点的边数叫做“度”，有向图分为出度和入度</p>
<h3 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h3><p>在无向图G中，如果对于图中任意两个顶点都是连通的，则称G为连通图。</p>
<p>无向图中极大连通子图称为<strong>连通分量</strong>。其实就是有几个可以互相连通的块，类似于树结构中定义的森林。</p>
<p><strong>连通图的生成树</strong>是一个极小的连通子图，其含有图中全部的V个节点，但只有足以构成一棵树的v-1条边</p>
<h2 id="图的存储方法与实现"><a href="#图的存储方法与实现" class="headerlink" title="图的存储方法与实现"></a>图的存储方法与实现</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>在邻接矩阵实现中，由行和列都表示顶点，由两个顶点所决定的矩阵对应元素表示这里两个顶点是否相连。如果是无权图的话相连为1，不相连为0，如果是有权图的话该处的数组则为边上所带的权重。</p>
<p><img src="http://cdn.ziyedy.top/image/%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdjMatrix</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> V;  <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> E;  <span class="hljs-comment">// 边集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[][] adj;    <span class="hljs-comment">// 邻接矩阵</span><br>    <br>    <span class="hljs-comment">// 读入数据，构建图</span><br>    <span class="hljs-comment">// 先读入顶点数V，再读入边数E，最后读入边的信息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AdjMatrix</span><span class="hljs-params">(String filename)</span> </span>&#123;<br>        File file = <span class="hljs-keyword">new</span> File(filename);<br>        <span class="hljs-keyword">try</span>(Scanner scanner = <span class="hljs-keyword">new</span> Scanner(file)) &#123;<br>            V = scanner.nextInt();<br>            <span class="hljs-keyword">if</span>(V &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"V must be non-negative"</span>);<br>            E = scanner.nextInt();<br>            <span class="hljs-keyword">if</span>(E &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"E must be non-negative"</span>);<br>            adj = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[V][V];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;E; i++) &#123;<br>                <span class="hljs-keyword">int</span> a = scanner.nextInt();<br>                validateVertex(a);<br>                <span class="hljs-keyword">int</span> b = scanner.nextInt();<br>                validateVertex(b);<br>                <span class="hljs-keyword">if</span>(a == b)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Self Loop is Detected"</span>);<br>                <span class="hljs-keyword">if</span>(adj[a][b] == <span class="hljs-number">1</span>)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Parallel Edge is Detected"</span>);<br>                adj[a][b] = <span class="hljs-number">1</span>;<br>                adj[b][a] = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断输入数据是否合理</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validateVertex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(v &lt; <span class="hljs-number">0</span> || v &gt;=V)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Vertex"</span> + v + <span class="hljs-string">"is valid"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 输出顶点数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getVertex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> V;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出边数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getEdge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> E;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断v1与v2之间存不存在边</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2)</span> </span>&#123;<br>        validateVertex(v1);<br>        validateVertex(v2);<br>        <span class="hljs-keyword">return</span> adj[v1][v2] == <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取所有邻接的顶点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">adj</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        validateVertex(v);<br>        ArrayList&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;V; i++) &#123;<br>            <span class="hljs-keyword">if</span>(adj[v][i] == <span class="hljs-number">1</span>)<br>                res.add(i);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取顶点v的度</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">degree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> adj(v).size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>在邻接列表实现中，每一个顶点会存储一个从它这里开始的边的列表。这个“列表”的具体实现的数据结构可以是链表，也可以是红黑树与哈希表等等。</p>
<p><img src="http://cdn.ziyedy.top/image/%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/%E9%82%BB%E6%8E%A5%E8%A1%A8.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AdjList</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> V;  <span class="hljs-comment">// 顶点集合</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> E;  <span class="hljs-comment">// 边集合</span><br>    <span class="hljs-keyword">private</span> LinkedList&lt;Integer&gt;[] adj;  <span class="hljs-comment">// 邻接表</span><br><br>    <span class="hljs-comment">// 读入数据，构建图</span><br>    <span class="hljs-comment">// 先读入顶点数V，再读入边数E，最后读入边的信息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AdjList</span><span class="hljs-params">(String filename)</span> </span>&#123;<br>        File file = <span class="hljs-keyword">new</span> File(filename);<br>        <span class="hljs-keyword">try</span>(Scanner scanner = <span class="hljs-keyword">new</span> Scanner(file)) &#123;<br>            V = scanner.nextInt();<br>            <span class="hljs-keyword">if</span>(V &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"V must be non-negative"</span>);<br>            E = scanner.nextInt();<br>            <span class="hljs-keyword">if</span>(E &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"E must be non-negative"</span>);<br>            adj = <span class="hljs-keyword">new</span> LinkedList[V];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;V; i++) &#123;<br>                adj[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>            &#125;<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;E; i++) &#123;<br>                <span class="hljs-keyword">int</span> a = scanner.nextInt();<br>                validateVertex(a);<br>                <span class="hljs-keyword">int</span> b = scanner.nextInt();<br>                validateVertex(b);<br>                <span class="hljs-keyword">if</span>(a == b)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Self Loop is Detected"</span>);<br>                <span class="hljs-keyword">if</span>(adj[a].contains(b))<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Parallel Edge is Detected"</span>);<br>                adj[a].add(b);<br>                adj[b].add(a);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断输入数据是否合理</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validateVertex</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(v &lt; <span class="hljs-number">0</span> || v &gt;=V)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Vertex"</span> + v + <span class="hljs-string">"is valid"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 输出顶点数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getVertex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> V;<br>    &#125;<br><br>    <span class="hljs-comment">// 输出边数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getEdge</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> E;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断v1与v2之间存不存在边</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasEdge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v1, <span class="hljs-keyword">int</span> v2)</span> </span>&#123;<br>        validateVertex(v1);<br>        validateVertex(v2);<br>        <span class="hljs-keyword">return</span> adj[v1].contains(v2);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取所有邻接的顶点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LinkedList&lt;Integer&gt; <span class="hljs-title">adj</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        validateVertex(v);<br>        <span class="hljs-keyword">return</span> adj[v];<br>    &#125;<br><br>    <span class="hljs-comment">// 获取顶点v的度</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">degree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> v)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> adj(v).size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table>
<thead>
<tr>
<th>操作</th>
<th>邻接矩阵</th>
<th>邻接表（链表）</th>
<th>邻接表（红黑树）</th>
</tr>
</thead>
<tbody><tr>
<td>空间复杂度</td>
<td>O(V^2)</td>
<td>O(V+E)</td>
<td>O(V+E)</td>
</tr>
<tr>
<td>建图</td>
<td>O(E)</td>
<td>O(E*V)</td>
<td>O(E*log V)</td>
</tr>
<tr>
<td>查看是否相邻</td>
<td>O(1)</td>
<td>O(degree(V))，最差时O(V)</td>
<td>O(log V)</td>
</tr>
<tr>
<td>返回该点的所有相邻节点</td>
<td>O(V)</td>
<td>O(degree(V))，最差时O(V)</td>
<td>O(degree(V))，最差时O(V)</td>
</tr>
</tbody></table>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/bce71b2bdbc8" target="_blank" rel="noopener">https://www.jianshu.com/p/bce71b2bdbc8</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>2.1、JS事件处理</title>
    <url>/page/event-obj.html</url>
    <content><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件指的是一些特定的交互瞬间，如点击某个元素等等</p>
<p>JavaScript 是以<strong>事件驱动为核心</strong>的一门语言。JavaScript 与 HTML 之间的交互是通过事件实现的。</p>
<h3 id="事件的基本要素"><a href="#事件的基本要素" class="headerlink" title="事件的基本要素"></a>事件的基本要素</h3><ul>
<li><p>事件源：引发后续事件的html标签。</p>
</li>
<li><p>事件：js中已经定义好了（见下图）。</p>
</li>
<li><p>事件驱动程序：对样式和html的操作。也就是DOM。</p>
</li>
</ul>
<p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/js%E4%BA%8B%E4%BB%B6.png" alt=""></p>
<h3 id="事件程序的基本书写"><a href="#事件程序的基本书写" class="headerlink" title="事件程序的基本书写"></a>事件程序的基本书写</h3><h4 id="1、获取事件源"><a href="#1、获取事件源" class="headerlink" title="1、获取事件源"></a>1、获取事件源</h4><p>详见DOM操作中的相关操作，主要有<code>document.getElementById()</code>等方法</p>
<h4 id="2、绑定事件"><a href="#2、绑定事件" class="headerlink" title="2、绑定事件"></a>2、绑定事件</h4><p>以onclick事件为例：</p>
<p><strong>方法1（绑定匿名函数）：</strong></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">element.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>方法2（addEventListener）：</strong></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">element.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;<br><br>&#125;, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li><p>参数1：事件名的字符串(注意，没有on)</p>
</li>
<li><p>参数2：回调函数：当事件触发时，该函数会被执行</p>
</li>
<li><p>参数3：<strong>true表示捕获阶段触发，false表示冒泡阶段触发（默认）</strong>。如果不写，则默认为false。【重要】</p>
</li>
</ul>
<p><strong>方法3（行内绑定）：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--行内绑定--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"box1"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"fn()"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript"><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span><span class="hljs-params">()</span> </span>&#123;<br>        alert(<span class="hljs-string">"我是弹出的内容"</span>);<br>    &#125;<br></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>





<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>当事件的响应函数被触发时，会产生一个事件对象<code>event</code>。浏览器每次都会将这个事件<code>event</code>作为实参传进之前的响应函数。</p>
<p>这个对象中包含了与当前事件相关的一切信息。比如鼠标的坐标、键盘的哪个按键被按下、鼠标滚轮滚动的方向等。</p>
<p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/event%E4%BF%A1%E6%81%AF.png" alt=""></p>
<h3 id="获取event对象"><a href="#获取event对象" class="headerlink" title="获取event对象"></a>获取event对象</h3><p>除去以上直接使用event外，标准兼容写法如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><br>    <span class="hljs-comment">//点击页面的任何部分</span><br>    <span class="hljs-built_in">document</span>.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>        event = event || <span class="hljs-built_in">window</span>.event; <span class="hljs-comment">//兼容性写法</span><br>    &#125;<br></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="event属性"><a href="#event属性" class="headerlink" title="event属性"></a>event属性</h3><p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/event%E5%B1%9E%E6%80%A7.png" alt=""></p>
<p>除此之外，还有以下等信息：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">keyCode</span>	<span class="hljs-comment">// 返回响应的键盘信息</span><br></code></pre></td></tr></table></figure>





<h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>事件传播的三个阶段是：事件捕获、事件冒泡和目标。</p>
<ul>
<li>事件捕获阶段：事件从祖先元素往子元素查找（DOM树结构），直到捕获到事件目标 target。在这个过程中，默认情况下，事件相应的监听函数是不会被触发的。</li>
<li>事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。</li>
<li>事件冒泡阶段：事件从事件目标 target 开始，从子元素往冒泡祖先元素冒泡，直到页面的最上一级标签。</li>
</ul>
<p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%86%92%E6%B3%A1.png" alt=""></p>
<h3 id="捕获与冒泡实验"><a href="#捕获与冒泡实验" class="headerlink" title="捕获与冒泡实验"></a>捕获与冒泡实验</h3><p>addEventListener函数最后一个参数为true代表事件在捕获阶段执行，为false代表在冒泡阶段进行</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>click here<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><br>        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"div"</span>)[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">var</span> p = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>];<br>        div.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"div"</span>);<br>        &#125;, <span class="hljs-literal">true</span>);<br>        p.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"p"</span>);<br>        &#125;, <span class="hljs-literal">true</span>);<br>    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>实验结果</strong></p>
<p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/%E5%86%92%E6%B3%A1%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C.png" alt=""></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3：transition与transform</title>
    <url>/page/css3-transition-transform.html</url>
    <content><![CDATA[<h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p><strong>transition实现元素不同状态间的平滑过渡</strong>，可以用来制作动画效果</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-comment">/* 让哪些属性发生过渡，all表示所有属性 */</span><br><span class="hljs-selector-tag">transition-property</span>: <span class="hljs-selector-tag">all</span>;<br><br><span class="hljs-comment">/*过渡的持续时间*/</span><br><span class="hljs-selector-tag">transition-duration</span>: 1<span class="hljs-selector-tag">s</span>;<br><br><span class="hljs-comment">/*过渡的运动曲线<br>linear表示线性，ease表示减速，ease-in表示加速<br>也可以使用cubic-bezier，自定义曲线*/</span><br><span class="hljs-selector-tag">transition-timing-function</span>: <span class="hljs-selector-tag">linear</span>;<br><br><span class="hljs-comment">/*多长时间后执行过渡*/</span><br><span class="hljs-selector-tag">transition-delay</span>: 1<span class="hljs-selector-tag">s</span>;<br><br><span class="hljs-comment">/*综合写法*/</span><br><span class="hljs-selector-tag">transition</span>: 让哪些属性进行过度 过渡的持续时间 运动曲线 延迟时间;<br></code></pre></td></tr></table></figure>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>给<code>&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code>添加如下css代码。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"><br>    <span class="hljs-selector-class">.box</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>        <span class="hljs-attribute">background-color</span>: greenyellow;<br>        <span class="hljs-attribute">margin</span>: <span class="hljs-number">100px</span> auto;<br>        <span class="hljs-comment">/* 只渐变宽度，不渐变颜色 */</span><br>        <span class="hljs-attribute">transition</span>: width <span class="hljs-number">2s</span> linear <span class="hljs-number">0s</span>;<br>    &#125;<br>    <span class="hljs-selector-class">.box</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>        <span class="hljs-attribute">background-color</span>: blue;<br>    &#125;<br></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="transitionend（过渡完成事件）"><a href="#transitionend（过渡完成事件）" class="headerlink" title="transitionend（过渡完成事件）"></a>transitionend（过渡完成事件）</h3><p>transitionend 事件在 CSS <strong>完成过渡后触发</strong>。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>在过渡事件的代码中添加如下代码</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><br>    <span class="hljs-keyword">const</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">".box"</span>);<br>    div.addEventListener(<span class="hljs-string">"transitionend"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        alert(<span class="hljs-string">"过渡已完成！"</span>);<br>    &#125;)<br></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="转换（transform）"><a href="#转换（transform）" class="headerlink" title="转换（transform）"></a>转换（transform）</h2><h3 id="缩放：scale"><a href="#缩放：scale" class="headerlink" title="缩放：scale"></a>缩放：scale</h3><p>参数解释：</p>
<p> x：表示水平方向的缩放倍数；y：表示垂直方向的缩放倍数。大于1表示放大，小于1表示缩小</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">transform</span>: <span class="hljs-built_in">scale</span>(x, y);<br><span class="hljs-built_in">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.8</span>, <span class="hljs-number">1.2</span>)<br></code></pre></td></tr></table></figure>



<h3 id="位移：translate"><a href="#位移：translate" class="headerlink" title="位移：translate"></a>位移：translate</h3><p>参数为百分比，相对于自身移动。正值为向右和向下，只写一个值代表水平移动</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">transform</span>: <span class="hljs-built_in">translate</span>(水平位移, 垂直位移);<br><span class="hljs-built_in">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">30</span><span class="hljs-symbol">%</span>, <span class="hljs-number">30</span><span class="hljs-symbol">%</span>);<br></code></pre></td></tr></table></figure>



<h3 id="旋转：rotate"><a href="#旋转：rotate" class="headerlink" title="旋转：rotate"></a>旋转：rotate</h3><p>正值代表顺时针。</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">transform</span>: rotate(角度);<br><span class="hljs-attribute">transform</span>: rotate(<span class="hljs-number">45deg</span>);<br></code></pre></td></tr></table></figure>

<h4 id="旋转的坐标原点"><a href="#旋转的坐标原点" class="headerlink" title="旋转的坐标原点"></a>旋转的坐标原点</h4><p>参数可为百分比、长度以及定位位置的词（如left，center等）</p>
<figure class="highlight gml"><table><tr><td class="code"><pre><code class="hljs gml">transform-origin: <span class="hljs-symbol">x</span>-axis <span class="hljs-symbol">y</span>-axis z-axis;<br></code></pre></td></tr></table></figure>



<h3 id="3D转换"><a href="#3D转换" class="headerlink" title="3D转换"></a>3D转换</h3><h3 id="使用rotateX、rotateY、rotateZ进行旋转"><a href="#使用rotateX、rotateY、rotateZ进行旋转" class="headerlink" title="使用rotateX、rotateY、rotateZ进行旋转"></a>使用rotateX、rotateY、rotateZ进行旋转</h3><figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">transform</span>: rotateX(<span class="hljs-number">360deg</span>);<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端样式</tag>
      </tags>
  </entry>
  <entry>
    <title>Java算法题的常用语法</title>
    <url>/page/java-for-algorithm-test.html</url>
    <content><![CDATA[<h2 id="控制台输入与输出"><a href="#控制台输入与输出" class="headerlink" title="控制台输入与输出"></a>控制台输入与输出</h2><h3 id="控制台输入"><a href="#控制台输入" class="headerlink" title="控制台输入"></a>控制台输入</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Scanner sc = <span class="hljs-keyword">new</span> Scanner(System.in);<br></code></pre></td></tr></table></figure>

<h4 id="输入一整行数据"><a href="#输入一整行数据" class="headerlink" title="输入一整行数据"></a>输入一整行数据</h4><p>以换行为终止，返回一个String类型变量.</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">String s = sc.nextLine()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h4 id="输入单个数据（方法名为next后面跟基本数据类型名）"><a href="#输入单个数据（方法名为next后面跟基本数据类型名）" class="headerlink" title="输入单个数据（方法名为next后面跟基本数据类型名）"></a>输入单个数据（方法名为next后面跟基本数据类型名）</h4><p>如下为输入一个整型</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-built_in">int</span> a = sc.next<span class="hljs-constructor">Int()</span>;<br></code></pre></td></tr></table></figure>

<h4 id="输入一个字符串"><a href="#输入一个字符串" class="headerlink" title="输入一个字符串"></a>输入一个字符串</h4><figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">String </span><span class="hljs-keyword">str </span>= sc.next()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>



<h3 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>输出内容：<code>System.out.print(&quot;&quot;);</code></p>
<p>输出内容并换行：<code>System.out.println(&quot;&quot;);</code></p>
<p>格式化输出1： <code>System.out.format(String format, Object ... args);</code></p>
<p>格式化输出2：<code>System.out.printf((String format, Object ... args);</code></p>
<h4 id="格式化输出常用转换符"><a href="#格式化输出常用转换符" class="headerlink" title="格式化输出常用转换符"></a>格式化输出常用转换符</h4><table>
<thead>
<tr>
<th>转 换 符</th>
<th>说  明</th>
</tr>
</thead>
<tbody><tr>
<td>%s</td>
<td>字符串类型</td>
</tr>
<tr>
<td>%c</td>
<td>字符类型</td>
</tr>
<tr>
<td>%d</td>
<td>整数类型（十进制）</td>
</tr>
<tr>
<td>%f</td>
<td>浮点类型</td>
</tr>
<tr>
<td>%n 或 \n</td>
<td>换行符</td>
</tr>
</tbody></table>
<h4 id="搭配转换符的常用标志"><a href="#搭配转换符的常用标志" class="headerlink" title="搭配转换符的常用标志"></a>搭配转换符的常用标志</h4><table>
<thead>
<tr>
<th>标  志</th>
<th>说  明</th>
<th>示  例</th>
<th>结  果</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>为正数或者负数添加符号</td>
<td>(“%+d %+d”, -10, 10)</td>
<td>-10 +10</td>
</tr>
<tr>
<td>0</td>
<td>数字前面补0</td>
<td>(“%05d”, 10)</td>
<td>00010</td>
</tr>
</tbody></table>
<h4 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 输出带有五位小数的浮点型</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.printf(<span class="hljs-string">"%.5f"</span>, <span class="hljs-number">99.89</span>);	<span class="hljs-comment">// 99.89000</span><br><span class="hljs-comment">// 输出在前面补齐5位数</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.printf(<span class="hljs-string">"%05d"</span>, <span class="hljs-number">99</span>);	<span class="hljs-comment">// 00099</span><br></code></pre></td></tr></table></figure>



<h2 id="基本容器的使用"><a href="#基本容器的使用" class="headerlink" title="基本容器的使用"></a>基本容器的使用</h2><h3 id="常用容器的基本使用"><a href="#常用容器的基本使用" class="headerlink" title="常用容器的基本使用"></a>常用容器的基本使用</h3><p><img src="http://cdn.ziyedy.top/image/Java%E7%AE%97%E6%B3%95%E9%A2%98%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/Collection.png" alt=""></p>
<h2 id="容器的基本操作"><a href="#容器的基本操作" class="headerlink" title="容器的基本操作"></a>容器的基本操作</h2><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><h4 id="Arrays-sort-——排序"><a href="#Arrays-sort-——排序" class="headerlink" title="Arrays.sort()——排序"></a>Arrays.sort()——排序</h4><p>对所有数组元素进行排序（默认正序）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">2</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>&#125;;<br>Arrays.sort(a);	<span class="hljs-comment">// 默认升序： -3 -2 1 2 9</span><br></code></pre></td></tr></table></figure>

<p>使用<strong>lamda表达式</strong>更改排序方式，以倒序为例，此时需要注意<strong>声明数组必须使用其包装类</strong>，否则会报错</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Integer[] a = <span class="hljs-keyword">new</span> Integer[]&#123;-<span class="hljs-number">2</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>&#125;;<br>Arrays.sort(a, (a1, a2)-&gt;a2-a1);	<span class="hljs-comment">// 倒序：9 2 1 -2 -3</span><br></code></pre></td></tr></table></figure>

<p>对指定索引范围内元素进行排序</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>[] b = new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-comment">// 对[0, 2)范围内数组元素进行排序</span><br><span class="hljs-comment">// 之后也可更改排序方式</span><br>Arrays.sort(b, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);	<span class="hljs-comment">// -3 -2 2 1 9</span><br></code></pre></td></tr></table></figure>

<h4 id="Arrays-fill-——填充"><a href="#Arrays-fill-——填充" class="headerlink" title="Arrays.fill()——填充"></a>Arrays.fill()——填充</h4><p>为数组元素填充相同值</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>[] a = new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>&#125;;<br>Arrays.fill(a, <span class="hljs-number">10</span>);	<span class="hljs-comment">// 10 10 10 10 10</span><br></code></pre></td></tr></table></figure>

<p>为指定索引范围内数组填充相同值</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>[] a = new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-comment">// 在索引[1, 3)范围内填充5</span><br>Arrays.fill(a, <span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>);	<span class="hljs-comment">// -2 5 5 1 9</span><br></code></pre></td></tr></table></figure>

<h4 id="Arrays-equals-——判断两个数组各元素是否都相等"><a href="#Arrays-equals-——判断两个数组各元素是否都相等" class="headerlink" title="Arrays.equals()——判断两个数组各元素是否都相等"></a>Arrays.equals()——判断两个数组各元素是否都相等</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">2</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-keyword">int</span>[] b = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">2</span>,-<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>&#125;;<br>System.out.println(Arrays.equals(a, b));	<span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<h4 id="Arrays-binarySerch-——二分查找定位元素下标"><a href="#Arrays-binarySerch-——二分查找定位元素下标" class="headerlink" title="Arrays.binarySerch()——二分查找定位元素下标"></a>Arrays.binarySerch()——二分查找定位元素下标</h4><p>注意：数组一定要是<strong>排好序的</strong>，否则会出错，若没有搜索到返回一个负值</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>[] a = new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">-3</span>,<span class="hljs-number">-2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">9</span>&#125;;<br>System.<span class="hljs-keyword">out</span>.println(Arrays.binarySearch(a, <span class="hljs-number">2</span>));	<span class="hljs-comment">// 2</span><br></code></pre></td></tr></table></figure>

<h4 id="Arrays-copyOfRange-——截取数组"><a href="#Arrays-copyOfRange-——截取数组" class="headerlink" title="Arrays.copyOfRange()——截取数组"></a>Arrays.copyOfRange()——截取数组</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span>[] a = new <span class="hljs-built_in">int</span>[]&#123;<span class="hljs-number">-2</span>,<span class="hljs-number">-3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">9</span>&#125;;<br><span class="hljs-comment">// 截取[1, 3)的数组</span><br><span class="hljs-built_in">int</span>[] b = Arrays.copyOfRange(a,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> m : b) System.<span class="hljs-keyword">out</span>.print(m + <span class="hljs-string">" "</span>);	<span class="hljs-comment">// -3 2</span><br></code></pre></td></tr></table></figure>

<h4 id="Arrays-copyOf-——创建新数组"><a href="#Arrays-copyOf-——创建新数组" class="headerlink" title="Arrays.copyOf()——创建新数组"></a>Arrays.copyOf()——创建新数组</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Arrays.copyOf(arr, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure>





<h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>示例列表如下：</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><code class="hljs sas">ArrayList&lt;Integer&gt; <span class="hljs-meta">list</span> = new ArrayList&lt;&gt;();<br><span class="hljs-meta">list</span>.<span class="hljs-meta">add</span>(2);<br><span class="hljs-meta">list</span>.<span class="hljs-meta">add</span>(-2);<br><span class="hljs-meta">list</span>.<span class="hljs-meta">add</span>(5);<br><span class="hljs-meta">list</span>.<span class="hljs-meta">add</span>(99);<br><span class="hljs-meta">list</span>.<span class="hljs-meta">add</span>(-10);<br>for (int v : <span class="hljs-meta">list</span>) System.<span class="hljs-meta">out</span>.p<span class="hljs-meta">rint(</span>v + <span class="hljs-string">" "</span>);	// 2 -2 5 99 -10<br></code></pre></td></tr></table></figure>

<h4 id="void-reverse-List-list-：反转"><a href="#void-reverse-List-list-：反转" class="headerlink" title="void reverse(List list)：反转"></a>void reverse(List list)：反转</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//</span> <span class="hljs-string">反转整个列表</span><br><span class="hljs-string">Collections.reverse(list);</span>	<span class="hljs-string">//</span> <span class="hljs-number">-10</span> <span class="hljs-number">99</span> <span class="hljs-number">5</span> <span class="hljs-number">-2</span> <span class="hljs-number">2</span><br><br><span class="hljs-string">//</span> <span class="hljs-string">反转[1,</span> <span class="hljs-number">3</span><span class="hljs-string">)的列表</span><br><span class="hljs-string">Collections.reverse(list.subList(1,</span> <span class="hljs-number">3</span><span class="hljs-string">));</span>	<span class="hljs-string">//</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">-2</span> <span class="hljs-number">99</span> <span class="hljs-number">-10</span><br></code></pre></td></tr></table></figure>

<h4 id="void-sort-List-list-：排序"><a href="#void-sort-List-list-：排序" class="headerlink" title="void sort(List list)：排序"></a>void sort(List list)：排序</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 自然升序</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collections</span>.</span></span>sort(<span class="hljs-built_in">list</span>);	<span class="hljs-comment">// -10 -2 2 5 99</span><br><br><span class="hljs-comment">// 自定义排序方法（此处为降序）</span><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collections</span>.</span></span>sort(<span class="hljs-built_in">list</span>, (a, b)-&gt;b-a);	<span class="hljs-comment">// 99 5 2 -2 -10</span><br></code></pre></td></tr></table></figure>

<h4 id="void-swap-List-list-int-i-int-j-：交换两个索引位置的元素"><a href="#void-swap-List-list-int-i-int-j-：交换两个索引位置的元素" class="headerlink" title="void swap(List list, int i , int j)：交换两个索引位置的元素"></a>void swap(List list, int i , int j)：交换两个索引位置的元素</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">//</span> <span class="hljs-string">交换索引为0</span> <span class="hljs-string">和</span> <span class="hljs-number">4</span><span class="hljs-string">的元素</span><br><span class="hljs-string">Collections.swap(list,</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-number">4</span><span class="hljs-string">);</span>	<span class="hljs-string">//</span> <span class="hljs-number">-10</span> <span class="hljs-number">-2</span> <span class="hljs-number">5</span> <span class="hljs-number">99</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>DPOD：6D Pose Object Detector and Refiner</title>
    <url>/page/DPOD-summary.html</url>
    <content><![CDATA[<h3 id="DPOD-6D-Pose-Object-Detector-and-Refiner"><a href="#DPOD-6D-Pose-Object-Detector-and-Refiner" class="headerlink" title="DPOD: 6D Pose Object Detector and Refiner"></a>DPOD: 6D Pose Object Detector and Refiner</h3><p>提出了一种从RGB图像进行3D目标检测和6D位姿估计的深度学习方法（DPOD，Dense Pose Object Detector），即密集姿势目标检测器。</p>
<p>用于估计输入图像和可用3D模型之间的密集2D-3D对应图，使用RANSAC与PnP解算6dof姿态，同时基于深度学习的定制细化方案对初始姿态估计值进行细化</p>
<p>简单来讲两个贡献</p>
<p>1、密集的2D-3D点对，比传统8个框点的对应具有更好的鲁棒性</p>
<p>2、一个效果不错的优化器</p>
<h3 id="关键要素"><a href="#关键要素" class="headerlink" title="关键要素"></a>关键要素</h3><p>1、多类对象对应掩膜ID的预测（the pixel-wise prediction of the multi-class object ID masks）</p>
<p>2、直接提供图像像素和3D模型顶点之间关系的对应映射的分类（classification of correspondence maps that directly provide a relation between image pixels and 3D model vertices）</p>
<p><strong>其中第2点保证了本方法的大量的像素对应（相对于那些使用8个框点进行pnp求解的方法来讲），也是本文dense的由来吧</strong></p>
<p>其中应该使用了UV的贴图技术将图像点与3D点进行对应（<strong>UV map的使用应该是本文最大的亮点了</strong>），但UV我只在3dmax等软件中看到过，对其原理并不理解，因此对该部分没有完全看懂。</p>
<p><img src="http://cdn.ziyedy.top/image/DPOD/%E5%AF%B9%E5%BA%94%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="http://cdn.ziyedy.top/image/DPOD/%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt=""></p>
<p>输入：RGB图像（320×240×3）</p>
<p><strong>对应模块</strong>：编码器-解码器架构，编码器采用类似ResNet的12层架构（具有残差层，可加快收敛速度），解码器使用双线性内插和卷积层的堆叠进行上采样到原始大小</p>
<p>输出：目标ID掩码（标识是哪个物体）与其对应2D位置；UV对应图（提供了明确的2D-3D对应关系）</p>
<p><strong>姿态模块</strong>：基于PnP+RANSAC有效计算各个6D姿势</p>
<h3 id="Refinement"><a href="#Refinement" class="headerlink" title="Refinement"></a>Refinement</h3><p>图中绿色是已知的</p>
<p><img src="http://cdn.ziyedy.top/image/DPOD/refinement.png" alt=""></p>
<p>结构：</p>
<p>使用ResNet做backbone，用ImageNet权重初始化，两个分支提取完特征后相减，再送到 E2 中，然后三个分支分别回归旋转R、XY、Z，每个头都是两个FC层。</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>损失函数依然使用的加权的思想，充分考虑到了三个分支的状态</p>
<p><img src="http://cdn.ziyedy.top/image/DPOD/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0.png" alt=""></p>
]]></content>
      <categories>
        <category>AI相关</category>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>6dof姿态估计</tag>
      </tags>
  </entry>
  <entry>
    <title>DeepIM：Deep Iterative Matching for 6D Pose Estimation</title>
    <url>/page/deepim-summary.html</url>
    <content><![CDATA[<h3 id="DeepIM-Deep-Iterative-Matching-for-6D-Pose-Estimation"><a href="#DeepIM-Deep-Iterative-Matching-for-6D-Pose-Estimation" class="headerlink" title="DeepIM: Deep Iterative Matching for 6D Pose Estimation"></a>DeepIM: Deep Iterative Matching for 6D Pose Estimation</h3><p>这篇论文可以理解为6d姿态估计问题中的一个refinement行为，经过测试可以使RGB数据的精度达到RGB-D数据的程度。</p>
<p>具体可见该论文。</p>
<h3 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h3><p>鉴于直接从图像中回归得到的物体姿态精度不高，将输入图像和物体渲染得到的图像进行匹配，能够得到更加精确的结果。</p>
<p>本文提出的DeepIM深度神经网络：给定一个初始位姿，网络能将观测图像和渲染得到的图像匹配，迭代地优化位姿。网络训练后能够预测一个相对的姿态变换，使用了一种分开表示的3D坐标和3D朝向，并且是用了一种迭代的训练过程。</p>
<h3 id="算法综述"><a href="#算法综述" class="headerlink" title="算法综述"></a>算法综述</h3><p>给定图像中一个物体的初始6D位姿，DeepIM能够将物体渲染得到的图像和当前观测的图像匹配，预测一个相对的SE(3)变换；之后迭代地根据估计的更为精确的位姿重新渲染物体得到渲染图像，并和观测图像相匹配，从而会变得越来越相似，使网络得到越来越精确的位姿。整体框架如下图所示：</p>
<p><img src="http://cdn.ziyedy.top/image/DeepIM/%E7%BD%91%E7%BB%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><strong>输入：</strong>观测图像、渲染图像以及对应的蒙板区域串联形成一个8通道（观测和渲染图像各自具有3通道，蒙板具有1通道）的张量</p>
<p><strong>主干网络</strong>同时本文使用预测图像间光流的FlowNetSimple架构作为支撑网络；位姿估计分支将由FlowNetSimple网络的11层卷积层得到的特征图作为输入，之后经过2个256维的全连接层，再分别由两个全连接层得到四元数表示的3D旋转和3D平移。</p>
<p>主干网络如下（关于光流法我也不清楚，算一个坑吧）</p>
<p><img src="http://cdn.ziyedy.top/image/DeepIM/FlowNetSimple1.png" alt=""></p>
<p><img src="http://cdn.ziyedy.top/image/DeepIM/FlowNetSimple2.png" alt=""></p>
<p><strong>网络采用的分支（仅用于训练）：</strong>在训练过程中，增加了两个辅助的分支来归一化网络的特征表示以提高训练的稳定性。一个分支训练后预测渲染图像和观测图像的光流，另一个分支预测观测图像的前景蒙板；</p>
<p><img src="http://cdn.ziyedy.top/image/DeepIM/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png" alt=""></p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>以上三个分支分别对应一个损失函数，经过加权后共同构成了本文网络的损失函数，其中a=0.1，b=0.25，c=0.03<br>$$<br>L = aL_{pose} + bL_{flow} + cL_{mask}<br>$$</p>
]]></content>
      <categories>
        <category>AI相关</category>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>6dof姿态估计</tag>
      </tags>
  </entry>
  <entry>
    <title>TF2存储模型参数等基本操作</title>
    <url>/page/tf2-nn-basic-handle.html</url>
    <content><![CDATA[<h2 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h2>]]></content>
      <categories>
        <category>AI相关</category>
        <category>TensorFlow2</category>
      </categories>
      <tags>
        <tag>TensorFlow2</tag>
      </tags>
  </entry>
  <entry>
    <title>使用tf.keras快速搭建网络</title>
    <url>/page/tf2-keras-build-nn.html</url>
    <content><![CDATA[<p>主要在于与《TF2原生语法构建简单网络》的比较</p>
<h2 id="逐层搭建网络结构（使用Sequential-）"><a href="#逐层搭建网络结构（使用Sequential-）" class="headerlink" title="逐层搭建网络结构（使用Sequential()）"></a>逐层搭建网络结构（使用Sequential()）</h2><h3 id="tf-keras-models-Sequential"><a href="#tf-keras-models-Sequential" class="headerlink" title="tf.keras.models.Sequential()"></a>tf.keras.models.Sequential()</h3><p>Sequential 函数是一个容器，封装了神经网络结构，主要可以进行以下输入：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 直接在列表中加入各层</span><br>model = tf.keras.models.Sequential([layer1, layer2, <span class="hljs-built_in">..</span>.])<br><br><span class="hljs-comment"># 使用add加入各层</span><br>model = tf.keras.models.Sequential()<br>model.<span class="hljs-builtin-name">add</span>(layer1)<br>model.<span class="hljs-builtin-name">add</span>(layer2)<br></code></pre></td></tr></table></figure>

<h4 id="压平层"><a href="#压平层" class="headerlink" title="压平层"></a>压平层</h4><p>将输入特征拉直为一维向量</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tf</span><span class="hljs-selector-class">.keras</span><span class="hljs-selector-class">.layers</span><span class="hljs-selector-class">.Flatten</span>()<br></code></pre></td></tr></table></figure>

<h4 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">tf.keras.layers.Dense(输出神经元个数,<br>					  <span class="hljs-attribute">activation</span>=<span class="hljs-string">"激活函数"</span>,<br>					  <span class="hljs-attribute">kernel_regularizer</span>=<span class="hljs-string">"正则化方式"</span><br>)<br></code></pre></td></tr></table></figure>

<p><strong>activation可选</strong>：relu、softmax、sigmoid、tanh等</p>
<p><strong>kernel_regularizer可选</strong>：tf.keras.regularizers.l1()、tf.keras.regularizers.l2()</p>
<h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">tf.keras.layers.Conv2D(<span class="hljs-built_in"> filter </span>= 卷积核个数,<br>						kernel_size = 卷积核尺寸,<br>						strides = 卷积步长,<br>						padding = “valid” <span class="hljs-keyword">or</span> “same”)<br></code></pre></td></tr></table></figure>

<h4 id="LSTM层"><a href="#LSTM层" class="headerlink" title="LSTM层"></a>LSTM层</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tf</span><span class="hljs-selector-class">.keras</span><span class="hljs-selector-class">.layers</span><span class="hljs-selector-class">.LSTM</span>()<br></code></pre></td></tr></table></figure>

<h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>在TF2原生语法构建简单网络的例子中，改用该api可以简化为：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">model = tf<span class="hljs-selector-class">.keras</span><span class="hljs-selector-class">.models</span>.Sequential([<br>    tf<span class="hljs-selector-class">.keras</span><span class="hljs-selector-class">.layers</span>.Dense(<span class="hljs-number">3</span>, activation=<span class="hljs-string">'softmax'</span>, kernel_regularizer=tf<span class="hljs-selector-class">.keras</span><span class="hljs-selector-class">.regularizers</span>.l2())<br>])<br></code></pre></td></tr></table></figure>

<h3 id="使用model-layers查看模型信息"><a href="#使用model-layers查看模型信息" class="headerlink" title="使用model.layers查看模型信息"></a>使用model.layers查看模型信息</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">model<span class="hljs-selector-class">.layers</span><br><br>[&lt;tensorflow<span class="hljs-selector-class">.python</span><span class="hljs-selector-class">.keras</span><span class="hljs-selector-class">.layers</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.Flatten</span> at <span class="hljs-number">0</span>x2239c7f9888&gt;,<br> &lt;tensorflow<span class="hljs-selector-class">.python</span><span class="hljs-selector-class">.keras</span><span class="hljs-selector-class">.layers</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.Dense</span> at <span class="hljs-number">0</span>x2239c7f9f08&gt;,<br> &lt;tensorflow<span class="hljs-selector-class">.python</span><span class="hljs-selector-class">.keras</span><span class="hljs-selector-class">.layers</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.Dense</span> at <span class="hljs-number">0</span>x2239c800248&gt;,<br> &lt;tensorflow<span class="hljs-selector-class">.python</span><span class="hljs-selector-class">.keras</span><span class="hljs-selector-class">.layers</span><span class="hljs-selector-class">.core</span><span class="hljs-selector-class">.Dense</span> at <span class="hljs-number">0</span>x2239c800688&gt;]<br></code></pre></td></tr></table></figure>



<h3 id="model-summary"><a href="#model-summary" class="headerlink" title="model.summary()"></a>model.summary()</h3><blockquote>
<p> 同时，在最后可以使用<code>model.summary()</code>查看网络参数量等基本信息。</p>
</blockquote>
<h3 id="训练网络（在-model-compile-中配置训练方法）"><a href="#训练网络（在-model-compile-中配置训练方法）" class="headerlink" title="训练网络（在 model.compile()中配置训练方法）"></a>训练网络（在 model.compile()中配置训练方法）</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">model.compile(<span class="hljs-attribute">optimizer</span>=优化器,<br>			  <span class="hljs-attribute">loss</span>=损失函数,<br>			  metrics=[<span class="hljs-string">"准确率"</span>]<br>)<br></code></pre></td></tr></table></figure>

<h4 id="optimizer"><a href="#optimizer" class="headerlink" title="optimizer"></a>optimizer</h4><p><strong>optimizer 可以是字符串形式给出的优化器名字，也可以是函数形式 ，使用函数形式可以设置学习率、动量和超参数。</strong></p>
<p>可选项：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">‘sgd’<span class="hljs-keyword">or</span> tf.optimizers.SGD( <span class="hljs-attribute">lr</span>=学习率, <span class="hljs-attribute">decay</span>=学习率衰减率, <span class="hljs-attribute">momentum</span>=动量参数)<br><br>‘adagrad’<span class="hljs-keyword">or</span> tf.keras.optimizers.Adagrad(<span class="hljs-attribute">lr</span>=学习率, <span class="hljs-attribute">decay</span>=学习率衰减率)<br><br>‘adadelta’<span class="hljs-keyword">or</span> tf.keras.optimizers.Adadelta(<span class="hljs-attribute">lr</span>=学习率, <span class="hljs-attribute">decay</span>=学习率衰减率)<br><br>‘adam’<span class="hljs-keyword">or</span> tf.keras.optimizers.Adam (<span class="hljs-attribute">lr</span>=学习率, <span class="hljs-attribute">decay</span>=学习率衰减率)<br></code></pre></td></tr></table></figure>

<h4 id="loss"><a href="#loss" class="headerlink" title="loss"></a>loss</h4><p><strong>Loss 可以是字符串形式给出的损失函数的名字，也可以是函数形式。</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">‘mse’ <span class="hljs-keyword">or</span> tf.keras.losses.<span class="hljs-constructor">MeanSquaredError()</span><br><br>‘sparse_categorical_crossentropy' <span class="hljs-keyword">or</span> tf.keras.losses.<span class="hljs-constructor">SparseCategoricalCrossentropy(<span class="hljs-params">from_logits</span>=False)</span><br></code></pre></td></tr></table></figure>

<p>损失函数常需要经过 softmax 等函数将输出转化为概率分布的形式。<strong>from_logits 则用来标注该损失函数是否需要转换为概率的形式，取 False 时表示转化为概率分布，取 True 时表示没有转化为概率分布，直接输出</strong>。</p>
<h4 id="metrics"><a href="#metrics" class="headerlink" title="metrics"></a>metrics</h4><blockquote>
<p>‘accuracy’：y_和 y 都是数值，如 y_=[1] y=[1]。<br>‘categorical_accuracy’：y_和 y 都是以独热码和概率分布表示。如 y_=[0, 1, 0], y=[0.256, 0.695, 0.048]。<br>‘sparse_ categorical_accuracy’：y_是以数值形式给出，y 是以独热码形式给出。如 y_=[1],y=[0.256, 0.695, 0.048]。</p>
</blockquote>
<h4 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">model.compile(<span class="hljs-attribute">optimizer</span>=tf.keras.optimizers.SGD(lr=0.1),<br>              <span class="hljs-attribute">loss</span>=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),<br>              metrics=[<span class="hljs-string">'accuracy'</span>])<br></code></pre></td></tr></table></figure>



<h3 id="在model-fit-中执行训练过程"><a href="#在model-fit-中执行训练过程" class="headerlink" title="在model.fit()中执行训练过程"></a>在model.fit()中执行训练过程</h3><figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix"><span class="hljs-comment"># fit可以返回中间的一些数据结构</span><br><span class="hljs-comment"># 通常命名为history</span><br><span class="hljs-attr">history</span> = model.fit( 训练集的输入特征， 训练集的标签， batch _size, epochs,<br>		   <span class="hljs-attr">validation_data</span> = ( 测试集的输入特征，测试集的标签 ) ，<br>		   <span class="hljs-attr">validataion_split</span> = 从测试集划分多少比例给训练集，<br>		   <span class="hljs-attr">validation_freq</span> = 测试的 epoch 间隔次数<br>           )<br></code></pre></td></tr></table></figure>

<h4 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">history = model.fit(x_train, y_train, <span class="hljs-attribute">batch_size</span>=32, <span class="hljs-attribute">epochs</span>=500, <span class="hljs-attribute">validation_split</span>=0.2, <span class="hljs-attribute">validation_freq</span>=20)<br></code></pre></td></tr></table></figure>



<h3 id="使用history-history绘制训练图表"><a href="#使用history-history绘制训练图表" class="headerlink" title="使用history.history绘制训练图表"></a>使用history.history绘制训练图表</h3><h4 id="history类型"><a href="#history类型" class="headerlink" title="history类型"></a>history类型</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">type</span><span class="hljs-params">(history)</span></span><br>tensorflow<span class="hljs-selector-class">.python</span><span class="hljs-selector-class">.keras</span><span class="hljs-selector-class">.callbacks</span>.History<br></code></pre></td></tr></table></figure>

<h4 id=""><a href="#" class="headerlink" title=""></a></h4><figure class="highlight matlab"><table><tr><td class="code"><pre><code class="hljs matlab">print(history.history)<br><br>&#123;<span class="hljs-string">'loss'</span>: [<span class="hljs-built_in">nan</span>, <span class="hljs-built_in">nan</span>, <span class="hljs-built_in">nan</span>, <span class="hljs-built_in">nan</span>, <span class="hljs-built_in">nan</span>, <span class="hljs-built_in">nan</span>, <span class="hljs-built_in">nan</span>, <span class="hljs-built_in">nan</span>, <span class="hljs-built_in">nan</span>, <span class="hljs-built_in">nan</span>],<br> <span class="hljs-string">'accuracy'</span>: [<span class="hljs-number">0.101127274</span>,<br>  <span class="hljs-number">0.10078182</span>,<br>  <span class="hljs-number">0.10078182</span>,<br>  <span class="hljs-number">0.10078182</span>,<br>  <span class="hljs-number">0.10078182</span>,<br>  <span class="hljs-number">0.10078182</span>,<br>  <span class="hljs-number">0.10078182</span>,<br>  <span class="hljs-number">0.10078182</span>,<br>  <span class="hljs-number">0.10078182</span>,<br>  <span class="hljs-number">0.10078182</span>],<br> <span class="hljs-string">'val_loss'</span>: [<span class="hljs-built_in">nan</span>, <span class="hljs-built_in">nan</span>, <span class="hljs-built_in">nan</span>, <span class="hljs-built_in">nan</span>, <span class="hljs-built_in">nan</span>, <span class="hljs-built_in">nan</span>, <span class="hljs-built_in">nan</span>, <span class="hljs-built_in">nan</span>, <span class="hljs-built_in">nan</span>, <span class="hljs-built_in">nan</span>],<br> <span class="hljs-string">'val_accuracy'</span>: [<span class="hljs-number">0.0914</span>,<br>  <span class="hljs-number">0.0914</span>,<br>  <span class="hljs-number">0.0914</span>,<br>  <span class="hljs-number">0.0914</span>,<br>  <span class="hljs-number">0.0914</span>,<br>  <span class="hljs-number">0.0914</span>,<br>  <span class="hljs-number">0.0914</span>,<br>  <span class="hljs-number">0.0914</span>,<br>  <span class="hljs-number">0.0914</span>,<br>  <span class="hljs-number">0.0914</span>]&#125;<br></code></pre></td></tr></table></figure>





<h2 id="使用class搭建网络"><a href="#使用class搭建网络" class="headerlink" title="使用class搭建网络"></a>使用class搭建网络</h2><p>将上述流程封装到一个类中，即为：（<strong>只需要重写构造函数和call函数即可</strong>）</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-title">from</span> tensorflow.keras.layers <span class="hljs-keyword">import</span> Dense<br><span class="hljs-title">from</span> tensorflow.keras <span class="hljs-keyword">import</span> Model<br><span class="hljs-class"><br><span class="hljs-keyword">class</span> <span class="hljs-type">IrisModel</span>(<span class="hljs-type">Model</span>):<br>    def __init__(<span class="hljs-title">self</span>):<br>        super(<span class="hljs-type">IrisModel</span>, <span class="hljs-title">self</span>).__init__()<br>        self.d1 = <span class="hljs-type">Dense</span>(3, <span class="hljs-title">activation</span>='<span class="hljs-title">softmax'</span>, <span class="hljs-title">kernel_regularizer</span>=<span class="hljs-title">tf</span>.<span class="hljs-title">keras</span>.<span class="hljs-title">regularizers</span>.<span class="hljs-title">l2</span>())<br><br>    def call(<span class="hljs-title">self</span>, <span class="hljs-title">x</span>):<br>        y = self.d1(<span class="hljs-title">x</span>)<br>        return y<br><br>model = <span class="hljs-type">IrisModel</span>()<br>model.compile(<span class="hljs-title">optimizer</span>=<span class="hljs-title">tf</span>.<span class="hljs-title">keras</span>.<span class="hljs-title">optimizers</span>.<span class="hljs-type">SGD</span>(<span class="hljs-title">lr</span>=0.1),<br>              loss=tf.keras.losses.<span class="hljs-type">SparseCategoricalCrossentropy</span>(<span class="hljs-title">from_logits</span>=<span class="hljs-type">False</span>),<br>              metrics=['sparse_categorical_accuracy'])<br><br>model.fit(<span class="hljs-title">x_train</span>, <span class="hljs-title">y_train</span>, <span class="hljs-title">batch_size</span>=32, <span class="hljs-title">epochs</span>=500, <span class="hljs-title">validation_split</span>=0.2, <span class="hljs-title">validation_freq</span>=20)<br>model.summary()</span><br></code></pre></td></tr></table></figure>



<h2 id="实例（以Fashion-MNIST数据集）为例"><a href="#实例（以Fashion-MNIST数据集）为例" class="headerlink" title="实例（以Fashion MNIST数据集）为例"></a>实例（以Fashion MNIST数据集）为例</h2><h3 id="载入并可视化数据"><a href="#载入并可视化数据" class="headerlink" title="载入并可视化数据"></a>载入并可视化数据</h3><figure class="highlight xl"><table><tr><td class="code"><pre><code class="hljs xl"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br>from tensorflow <span class="hljs-keyword">import</span> keras<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>fashion_mnist = keras.datasets.fashion_mnist<br>(train_images, train_labels), (test_images, test_labels) = fashion_mnist.load_data()<br><br>class_names = [<span class="hljs-string">'T-shirt/top'</span>, <span class="hljs-string">'Trouser'</span>, <span class="hljs-string">'Pullover'</span>, <span class="hljs-string">'Dress'</span>, <span class="hljs-string">'Coat'</span>,<br>               <span class="hljs-string">'Sandal'</span>, <span class="hljs-string">'Shirt'</span>, <span class="hljs-string">'Sneaker'</span>, <span class="hljs-string">'Bag'</span>, <span class="hljs-string">'Ankle boot'</span>]<br><br>plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>))<br><span class="hljs-keyword">for</span> i <span class="hljs-built_in">in</span> range(<span class="hljs-number">100</span>, <span class="hljs-number">125</span>):<br>    plt.subplot(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, i-<span class="hljs-number">99</span>)<br>    plt.imshow(train_images[i])<br>    plt.<span class="hljs-built_in">title</span>(class_names[train_labels[i]])<br>plt.show()<br></code></pre></td></tr></table></figure>

<img src="http://cdn.ziyedy.top/image/%E4%BD%BF%E7%94%A8tf.keras%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96.png" style="zoom: 80%;" />

<h3 id="进行数据预处理，将值置于0-1范围内"><a href="#进行数据预处理，将值置于0-1范围内" class="headerlink" title="进行数据预处理，将值置于0-1范围内"></a>进行数据预处理，将值置于0-1范围内</h3><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">train_images</span> = train_images / <span class="hljs-number">255.0</span><br><span class="hljs-attr">test_images</span> = test_images / <span class="hljs-number">255.0</span><br></code></pre></td></tr></table></figure>

<h3 id="构建网络并进行训练"><a href="#构建网络并进行训练" class="headerlink" title="构建网络并进行训练"></a>构建网络并进行训练</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">model = keras.Sequential([<br>    keras.layers.Flatten(input_shape=(28, 28)),<br>    keras.layers.Dense(128, <span class="hljs-attribute">activation</span>=<span class="hljs-string">'relu'</span>),<br>    keras.layers.Dense(10)<br>])<br><br>model.compile(<span class="hljs-attribute">optimizer</span>=<span class="hljs-string">'adam'</span>,<br>              <span class="hljs-attribute">loss</span>=keras.losses.SparseCategoricalCrossentropy(from_logits=True),<br>              metrics=[<span class="hljs-string">'accuracy'</span>])<br><br>history = model.fit(train_images, train_labels, <span class="hljs-attribute">epochs</span>=10)<br></code></pre></td></tr></table></figure>

<h3 id="进行评估并绘制训练曲线"><a href="#进行评估并绘制训练曲线" class="headerlink" title="进行评估并绘制训练曲线"></a>进行评估并绘制训练曲线</h3><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">test_loss, test_acc = model.evaluate(test_images, test_labels)<br><br>plt.plot(history.history[<span class="hljs-string">'accuracy'</span>], <span class="hljs-attribute">label</span>=<span class="hljs-string">'accuracy'</span>)<br>plt.plot(history.history[<span class="hljs-string">'loss'</span>], <span class="hljs-attribute">label</span>=<span class="hljs-string">'loss'</span>)<br>plt.xlabel(<span class="hljs-string">'Epoch'</span>)<br>plt.ylabel(<span class="hljs-string">'Accuracy and Loss'</span>)<br>plt.legend(<span class="hljs-attribute">loc</span>=<span class="hljs-string">'lower left'</span>)<br>plt.show()<br></code></pre></td></tr></table></figure>

<img src="http://cdn.ziyedy.top/%E4%BD%BF%E7%94%A8tf.keras%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C/%E8%AE%AD%E7%BB%83%E6%9B%B2%E7%BA%BF.png" style="zoom:67%;" />

<h3 id="使用模型进行预测"><a href="#使用模型进行预测" class="headerlink" title="使用模型进行预测"></a>使用模型进行预测</h3><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">predict_model = keras.Sequential([<br>    model,<br>    tf.keras.layers.Softmax()<br>])<br>prediction = predict_model.predict(test_images)<br>print(prediction[<span class="hljs-number">0</span>])<br># [<span class="hljs-number">7.7702840e-05</span> <span class="hljs-number">5.1073805e-08</span> <span class="hljs-number">1.0888911e-05</span> <span class="hljs-number">1.1339294e-07</span> <span class="hljs-number">5.7997750e-06</span><br>#  <span class="hljs-number">1.0903468e-03</span> <span class="hljs-number">8.1863102e-05</span> <span class="hljs-number">2.4046257e-02</span> <span class="hljs-number">5.1835599e-07</span> <span class="hljs-number">9.7468650e-01</span>]<br><br>plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>)<br>plt.imshow(test_images[<span class="hljs-number">0</span>])<br>plt.title(class_names[tf.argmax(prediction[<span class="hljs-number">0</span>])])<br>plt.subplot(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>plt.bar(class_names, prediction[<span class="hljs-number">0</span>])<br>plt.show()<br></code></pre></td></tr></table></figure>

<img src="http://cdn.ziyedy.top/image/%E4%BD%BF%E7%94%A8tf.keras%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C/%E9%A2%84%E6%B5%8B%E7%BB%93%E6%9E%9C.png" style="zoom:80%;" />



<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.tensorflow.org/tutorials/" target="_blank" rel="noopener">https://www.tensorflow.org/tutorials/</a></p>
]]></content>
      <categories>
        <category>AI相关</category>
        <category>TensorFlow2</category>
      </categories>
      <tags>
        <tag>TensorFlow2</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络基础概念总结</title>
    <url>/page/nn-basic-concept-summary.html</url>
    <content><![CDATA[<h3 id="神经网络复杂度"><a href="#神经网络复杂度" class="headerlink" title="神经网络复杂度"></a>神经网络复杂度</h3><p><strong>NN复杂度：多用NN层数和NN参数的个数表示</strong></p>
<p>层数 = 隐藏层的层数+1个输出层</p>
<p>总参数 = 总w + 总b</p>
<p><strong>空间复杂度</strong>：即为总参数个数</p>
<p><strong>时间复杂度</strong>：即为乘加运算次数</p>
<p><img src="http://cdn.ziyedy.top/image/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt=""></p>
<h3 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h3><p><img src="http://cdn.ziyedy.top/image/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/%E5%AD%A6%E4%B9%A0%E7%8E%87.png" alt=""></p>
<h4 id="指数衰减学习率"><a href="#指数衰减学习率" class="headerlink" title="指数衰减学习率"></a>指数衰减学习率</h4><p>先用较大的学习率，快速得到较优解，然后逐步减小学习率，使模型在训练后期稳定。公式如下：</p>
<figure class="highlight fix"><table><tr><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">指数衰减学习率 </span>=<span class="hljs-string"> 初始学习率 * 学习率衰减率 (当前轮数 / 多少轮衰减一次)</span><br></code></pre></td></tr></table></figure>



<h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p><img src="http://cdn.ziyedy.top/image/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0.png" alt=""></p>
<h4 id="优秀的激活函数"><a href="#优秀的激活函数" class="headerlink" title="优秀的激活函数"></a>优秀的激活函数</h4><ul>
<li>非线性：激活函数非线性时，多层神经网络可逼近所有函数</li>
<li>可微性： 优化器大多用梯度下降更新参数</li>
<li>单调性： 当激活函数是单调的，能保证单层网络的损失函数是凸函数</li>
<li>近似恒等性： f(x)≈x 当参数初始化为随机小值时，神经网络更稳定</li>
</ul>
<h4 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h4><p>$$<br>f(x) = \frac {1} {1 + e^{-x}}<br>$$</p>
<p><img src="http://cdn.ziyedy.top/image/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/sigmoid.png" alt=""></p>
<p>特点：</p>
<p>（1）易造成梯度消失<br>（2）输出非0均值，收敛慢<br>（3）幂运算复杂，训练时间长</p>
<h4 id="Tanh函数"><a href="#Tanh函数" class="headerlink" title="Tanh函数"></a>Tanh函数</h4><p><img src="http://cdn.ziyedy.top/image/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/tanh.png" alt=""></p>
<p>特点<br>（1）输出是0均值<br>（2）易造成梯度消失<br>（3）幂运算复杂，训练时间长</p>
<h4 id="Relu函数（用的最多）"><a href="#Relu函数（用的最多）" class="headerlink" title="Relu函数（用的最多）"></a>Relu函数（用的最多）</h4><p>$$<br>f(x) = max(x, 0)<br>$$</p>
<p><img src="http://cdn.ziyedy.top/image/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/relu.png" alt=""></p>
<p>优点：</p>
<p>（1）解决了梯度消失问题 解决了梯度消失问题 (在正区间）</p>
<p>（2）只需判断输入是否大于 只需判断输入是否大于0，计算速度快</p>
<p>（3）收敛速度远快于 收敛速度远快于sigmoid 和tanh</p>
<p>缺点：</p>
<p>（1）输出非0均值，收敛慢</p>
<p>（2）Dead Relu问题：某些神经元永远不会被激活，导致相应的参数永远不会被更新</p>
<h4 id="Leaky-Relu函数"><a href="#Leaky-Relu函数" class="headerlink" title="Leaky Relu函数"></a>Leaky Relu函数</h4><p><img src="http://cdn.ziyedy.top/image/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/Leaky-relu.png" alt=""></p>
<h4 id="激活函数的使用"><a href="#激活函数的使用" class="headerlink" title="激活函数的使用"></a>激活函数的使用</h4><p>1、首选relu激活函数</p>
<p>2、学习率设置较小值</p>
<p>3、输入特征标准化，即让输入特征满足以0为均值，1为标准差的正态分布； </p>
<p>4、初始参数中心化，即让随机生成的参数满足以0为均值，$\frac {2} {当前层特征个数}$ 为标准差的正态分布</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>神经网络的优化目标就是使得损失函数最小</p>
<h4 id="自定义损失函数"><a href="#自定义损失函数" class="headerlink" title="自定义损失函数"></a>自定义损失函数</h4><p>可以根据具体的项目自定义损失函数</p>
<h4 id="均方误差（MSE）"><a href="#均方误差（MSE）" class="headerlink" title="均方误差（MSE）"></a>均方误差（MSE）</h4><p>很好理解，平时最基本的曲线拟合就是用的均方误差的损失函数。<br>$$<br>MSE(y_, y) = \frac {\sum^n_{i=1} (y-y_)^2} {n}<br>$$</p>
<h4 id="交叉熵损失函数（Cross-Entropy）"><a href="#交叉熵损失函数（Cross-Entropy）" class="headerlink" title="交叉熵损失函数（Cross Entropy）"></a>交叉熵损失函数（Cross Entropy）</h4><p>$$<br>H(y_, y) = - \sum y_ * ln y<br>$$</p>
<p>用来表征两个概率分布之间的距离，常与softmax函数结合</p>
<p><strong>输出先进行softmax函数，再计算y与y_的交叉熵损失函数</strong></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">tf.nn.softmax<span class="hljs-constructor">_cross_entropy_with_logits(<span class="hljs-params">y_</span> ，<span class="hljs-params">y</span>)</span><br></code></pre></td></tr></table></figure>





<h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>正则化一般用于<strong>缓解过拟合（训练准确性和测试准确性之间的差距代表<em>过度拟合</em> ）</strong>，即在损失函数中引入模型复杂度指标，利用给W加权值，弱化了训练数据的噪声</p>
<p><img src="http://cdn.ziyedy.top/image/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/%E6%AD%A3%E5%88%99%E5%8C%96.png" alt=""></p>
<h4 id="L1正则化"><a href="#L1正则化" class="headerlink" title="L1正则化"></a>L1正则化</h4><p>$$<br>loss_{L1}(w) = \sum_{i} |x|<br>$$</p>
<blockquote>
<p>L1正则化大概率会使很多参数变为0，因此该方法可通过稀疏参数，即减少参数的数量降低复杂度</p>
</blockquote>
<h4 id="L2正则化"><a href="#L2正则化" class="headerlink" title="L2正则化"></a>L2正则化</h4><p>$$<br>loss_{L1}(w) = \sum_{i} |x^2|<br>$$</p>
<blockquote>
<p>L2正则化会使参数很接近零但不为零，因此该方法可通过减小参数值的大小降低复杂度。</p>
</blockquote>
<h3 id="参数优化器"><a href="#参数优化器" class="headerlink" title="参数优化器"></a>参数优化器</h3><h4 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h4><h4 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h4>]]></content>
      <categories>
        <category>AI相关</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>TF2原生语法构建简单网络</title>
    <url>/page/tf2-basic-builder-simple-nn.html</url>
    <content><![CDATA[<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>本实验采用的数据为鸢尾属植物数据集，存储了150个样本的4个特征，分别对应了3类不同的鸢尾属植物。</p>
<h3 id="基本流程可视化"><a href="#基本流程可视化" class="headerlink" title="基本流程可视化"></a>基本流程可视化</h3><p>每个数据可以视为1×4的向量，且最后对应3类，那么权重w就应该是4×3，偏置量b就应该是1×3。</p>
<p><img src="http://cdn.ziyedy.top/image/AI/TF2/%E6%9D%83%E9%87%8D%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p>
<p>上述过程可以即可以视为一个全连接神经网络，可视化如下。</p>
<p><img src="http://cdn.ziyedy.top/image/AI/TF2/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p>
<h2 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h2><h3 id="一、数据准备"><a href="#一、数据准备" class="headerlink" title="一、数据准备"></a>一、数据准备</h3><h4 id="1、数据集读入"><a href="#1、数据集读入" class="headerlink" title="1、数据集读入"></a>1、数据集读入</h4><figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">from</span> sklearn.datasets <span class="hljs-keyword">import</span> datasets<br><span class="hljs-title">x_data</span> = datasets.load_iris().<span class="hljs-class"><span class="hljs-keyword">data</span></span><br><span class="hljs-title">y_data</span> = datasets.load_iris().target<br></code></pre></td></tr></table></figure>



<h4 id="2、数据集乱序"><a href="#2、数据集乱序" class="headerlink" title="2、数据集乱序"></a>2、数据集乱序</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">np</span><span class="hljs-selector-class">.random</span><span class="hljs-selector-class">.seed</span>(116)<br><span class="hljs-selector-tag">np</span><span class="hljs-selector-class">.random</span><span class="hljs-selector-class">.shuffle</span>(<span class="hljs-selector-tag">x_data</span>)<br><span class="hljs-selector-tag">np</span><span class="hljs-selector-class">.random</span><span class="hljs-selector-class">.seed</span>(116)<br><span class="hljs-selector-tag">np</span><span class="hljs-selector-class">.random</span><span class="hljs-selector-class">.shuffle</span>(<span class="hljs-selector-tag">y_data</span>)<br></code></pre></td></tr></table></figure>



<h4 id="3、生成训练集和测试集，并根据需要转换数据格式"><a href="#3、生成训练集和测试集，并根据需要转换数据格式" class="headerlink" title="3、生成训练集和测试集，并根据需要转换数据格式"></a>3、生成训练集和测试集，并根据需要转换数据格式</h4><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 取后30个为测试集，其余为训练集</span><br><span class="hljs-attr">x_train</span> = x_data[:-<span class="hljs-number">30</span>]<br><span class="hljs-attr">y_train</span> = y_data[:-<span class="hljs-number">30</span>]<br><span class="hljs-attr">x_test</span> = x_data[-<span class="hljs-number">30</span>:]<br><span class="hljs-attr">y_test</span> = y_data[-<span class="hljs-number">30</span>:]<br><br><span class="hljs-comment"># 转换x的数据类型，避免数据不一致的问题</span><br><span class="hljs-attr">x_train</span> = tf.cast(x_train, tf.float32)<br><span class="hljs-attr">x_test</span> = tf.cast(x_test, tf.float32)<br></code></pre></td></tr></table></figure>



<h4 id="4、将（输入特征，标签）组成对，每次读入一部分（batch）"><a href="#4、将（输入特征，标签）组成对，每次读入一部分（batch）" class="headerlink" title="4、将（输入特征，标签）组成对，每次读入一部分（batch）"></a>4、将（输入特征，标签）组成对，每次读入一部分（batch）</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">train_db = tf.data.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dataset</span>.</span></span>from<span class="hljs-constructor">_tensor_slices((<span class="hljs-params">x_train</span>, <span class="hljs-params">y_train</span>)</span>).batch(<span class="hljs-number">32</span>)<br>test_db = tf.data.<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Dataset</span>.</span></span>from<span class="hljs-constructor">_tensor_slices((<span class="hljs-params">x_test</span>, <span class="hljs-params">y_test</span>)</span>).batch(<span class="hljs-number">32</span>)<br></code></pre></td></tr></table></figure>



<h3 id="二、搭建网络，迭代进行训练"><a href="#二、搭建网络，迭代进行训练" class="headerlink" title="二、搭建网络，迭代进行训练"></a>二、搭建网络，迭代进行训练</h3><h4 id="1、定义神经网络中所有可训练参数"><a href="#1、定义神经网络中所有可训练参数" class="headerlink" title="1、定义神经网络中所有可训练参数"></a>1、定义神经网络中所有可训练参数</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">w1 = tf.<span class="hljs-constructor">Variable(<span class="hljs-params">tf</span>.<span class="hljs-params">random</span>.<span class="hljs-params">truncated_normal</span>([4, 3], <span class="hljs-params">stddev</span>=0.1, <span class="hljs-params">seed</span>=1)</span>)<br>b1 = tf.<span class="hljs-constructor">Variable(<span class="hljs-params">tf</span>.<span class="hljs-params">random</span>.<span class="hljs-params">truncated_normal</span>([3], <span class="hljs-params">stddev</span>=0.1, <span class="hljs-params">seed</span>=1)</span>)<br></code></pre></td></tr></table></figure>



<h4 id="2、定义一些超参数，及后续可能会用到的参数"><a href="#2、定义一些超参数，及后续可能会用到的参数" class="headerlink" title="2、定义一些超参数，及后续可能会用到的参数"></a>2、定义一些超参数，及后续可能会用到的参数</h4><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">lr</span> = <span class="hljs-number">0.1</span>  <span class="hljs-comment"># 学习率为0.1</span><br><span class="hljs-attr">train_loss_results</span> = []  <span class="hljs-comment"># 将每轮的loss记录在此列表中，为后续画loss曲线提供数据</span><br><span class="hljs-attr">test_acc</span> = []  <span class="hljs-comment"># 将每轮的acc记录在此列表中，为后续画acc曲线提供数据</span><br><span class="hljs-attr">epoch</span> = <span class="hljs-number">500</span>  <span class="hljs-comment"># 循环500轮</span><br><span class="hljs-attr">loss_all</span> = <span class="hljs-number">0</span>  <span class="hljs-comment"># 每轮分4个step，loss_all记录四个step生成的4个loss的和</span><br></code></pre></td></tr></table></figure>



<h4 id="3、嵌套循环迭代，with结构更新参数，显示loss等信息"><a href="#3、嵌套循环迭代，with结构更新参数，显示loss等信息" class="headerlink" title="3、嵌套循环迭代，with结构更新参数，显示loss等信息"></a>3、嵌套循环迭代，with结构更新参数，显示loss等信息</h4><figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix"><span class="hljs-comment"># 数据集级别的循环，每个epoch循环一次数据集</span><br>for epoch <span class="hljs-keyword">in</span> range(epoch):  <br>	<span class="hljs-comment"># batch级别的循环 ，每个step循环一个batch</span><br>    for step, (x_train, y_train) <span class="hljs-keyword">in</span> enumerate(train_db):<br>    	<span class="hljs-comment"># with结构记录梯度信息</span><br>        <span class="hljs-keyword">with</span> tf.GradientTape() as tape:<br>        	<span class="hljs-comment"># 前向传播计算y_</span><br>            <span class="hljs-attr">y</span> = tf.matmul(x_train, w1) + b1<br>            <span class="hljs-attr">y</span> = tf.nn.softmax(y)<br>            <span class="hljs-attr">y_</span> = tf.one_hot(y_train, <span class="hljs-attr">depth=3)</span><br>            <span class="hljs-comment"># 计算总loss</span><br>            <span class="hljs-attr">loss</span> = tf.reduce_mean(tf.square(y_ - y))<br>            loss_all += loss.numpy()<br>            <br>        <span class="hljs-comment"># 计算loss对各个参数的梯度</span><br>        <span class="hljs-attr">grads</span> = tape.gradient(loss, [w1, b1])<br><br>        <span class="hljs-comment"># 参数自更新</span><br>        w1.assign_sub(lr * grads[<span class="hljs-number">0</span>])  <span class="hljs-comment"># 参数w1自更新</span><br>        b1.assign_sub(lr * grads[<span class="hljs-number">1</span>])  <span class="hljs-comment"># 参数b自更新</span><br><br>    <span class="hljs-comment"># 每个epoch，打印loss信息并记录</span><br>    print(<span class="hljs-string">"Epoch &#123;&#125;, loss: &#123;&#125;"</span>.format(epoch, loss_all/<span class="hljs-number">4</span>))<br>    train_loss_results.append(loss_all / <span class="hljs-number">4</span>)<br>    <span class="hljs-attr">loss_all</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>



<h4 id="4、在该轮epoch中，计算当前参数前向传播的准确率并进行记录"><a href="#4、在该轮epoch中，计算当前参数前向传播的准确率并进行记录" class="headerlink" title="4、在该轮epoch中，计算当前参数前向传播的准确率并进行记录"></a>4、在该轮epoch中，计算当前参数前向传播的准确率并进行记录</h4><figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix"><span class="hljs-comment"># total_correct为预测对的样本个数, total_number为测试的总样本数，将这两个变量都初始化为0</span><br>total_correct, <span class="hljs-attr">total_number</span> = <span class="hljs-number">0</span>, <span class="hljs-number">0</span><br>for x_test, y_test <span class="hljs-keyword">in</span> test_db:<br>    <span class="hljs-comment"># 使用更新后的参数进行预测</span><br>    <span class="hljs-attr">y</span> = tf.matmul(x_test, w1) + b1<br>    <span class="hljs-attr">y</span> = tf.nn.softmax(y)<br>    <span class="hljs-attr">pred</span> = tf.argmax(y, <span class="hljs-attr">axis=1)</span>  <span class="hljs-comment"># 返回y中最大值的索引，即预测的分类</span><br>    <span class="hljs-comment"># 将pred转换为y_test的数据类型</span><br>    <span class="hljs-attr">pred</span> = tf.cast(pred, <span class="hljs-attr">dtype=y_test.dtype)</span><br>    <span class="hljs-comment"># 若分类正确，则correct=1，否则为0，将bool型的结果转换为int型</span><br>    <span class="hljs-attr">correct</span> = tf.cast(tf.equal(pred, y_test), <span class="hljs-attr">dtype=tf.int32)</span><br>    <span class="hljs-comment"># 将每个batch的correct数加起来</span><br>    <span class="hljs-attr">correct</span> = tf.reduce_sum(correct)<br>    <span class="hljs-comment"># 将所有batch中的correct数加起来</span><br>    total_correct += int(correct)<br>    <span class="hljs-comment"># total_number为测试的总样本数，也就是x_test的行数，shape[0]返回变量的行数</span><br>    total_number += x_test.shape[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 总的准确率等于total_correct/total_number</span><br><span class="hljs-attr">acc</span> = total_correct / total_number<br>test_acc.append(acc)<br>print(<span class="hljs-string">"Test_acc:"</span>, acc)<br>print(<span class="hljs-string">"--------------------------"</span>)<br></code></pre></td></tr></table></figure>



<h3 id="三、绘制相应训练曲线"><a href="#三、绘制相应训练曲线" class="headerlink" title="三、绘制相应训练曲线"></a>三、绘制相应训练曲线</h3><figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"># 绘制 <span class="hljs-selector-tag">loss</span> 曲线<br><span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.title</span>(<span class="hljs-string">'Loss Function Curve'</span>)  <br><span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.xlabel</span>(<span class="hljs-string">'Epoch'</span>) <br><span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.ylabel</span>(<span class="hljs-string">'Loss'</span>) <br><span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.plot</span>(train_loss_results, label=<span class="hljs-string">"$Loss$"</span>) <br><span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.legend</span>() <br><span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.show</span>() <br><br># 绘制 <span class="hljs-selector-tag">Accuracy</span> 曲线<br><span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.title</span>(<span class="hljs-string">'Acc Curve'</span>) <br><span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.xlabel</span>(<span class="hljs-string">'Epoch'</span>) <br><span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.ylabel</span>(<span class="hljs-string">'Acc'</span>) <br><span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.plot</span>(test_acc, label=<span class="hljs-string">"$Accuracy$"</span>) <br><span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.legend</span>()<br><span class="hljs-selector-tag">plt</span><span class="hljs-selector-class">.show</span>()<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>AI相关</category>
        <category>TensorFlow2</category>
      </categories>
      <tags>
        <tag>TensorFlow2</tag>
      </tags>
  </entry>
  <entry>
    <title>TF2的基础函数</title>
    <url>/page/TF2-basic-function.html</url>
    <content><![CDATA[<h3 id="张量生成"><a href="#张量生成" class="headerlink" title="张量生成"></a>张量生成</h3><h4 id="直接创建"><a href="#直接创建" class="headerlink" title="直接创建"></a>直接创建</h4><figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-title">tf</span>.constant(张量内容, d<span class="hljs-keyword">type</span>=数据类型&lt;可选&gt;)<br></code></pre></td></tr></table></figure>

<h4 id="创建全为0的张量"><a href="#创建全为0的张量" class="headerlink" title="创建全为0的张量"></a>创建全为0的张量</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tf</span><span class="hljs-selector-class">.zeros</span>(维度)<br></code></pre></td></tr></table></figure>



<h4 id="创建全为1的张量"><a href="#创建全为1的张量" class="headerlink" title="创建全为1的张量"></a>创建全为1的张量</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tf</span><span class="hljs-selector-class">.ones</span>(维度)<br></code></pre></td></tr></table></figure>

<h4 id="创建全为指定值的张量"><a href="#创建全为指定值的张量" class="headerlink" title="创建全为指定值的张量"></a>创建全为指定值的张量</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">tf.<span class="hljs-built_in">fill</span>(维度, 指定值)<br></code></pre></td></tr></table></figure>



<h4 id="将numpy数据转化为Tensor数据"><a href="#将numpy数据转化为Tensor数据" class="headerlink" title="将numpy数据转化为Tensor数据"></a>将numpy数据转化为Tensor数据</h4><figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-title">tf</span>.convert_to_tensor(数据名, d<span class="hljs-keyword">type</span>=数据类型&lt;可选&gt;)<br></code></pre></td></tr></table></figure>



<h4 id="生成正态分布的随机数，默认均值为0，标准差为1"><a href="#生成正态分布的随机数，默认均值为0，标准差为1" class="headerlink" title="生成正态分布的随机数，默认均值为0，标准差为1"></a>生成正态分布的随机数，默认均值为0，标准差为1</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">tf.random.normal(维度, <span class="hljs-attribute">mean</span>=均值, <span class="hljs-attribute">stddev</span>=标准差)<br></code></pre></td></tr></table></figure>



<h4 id="生成截断式正态分布随机数"><a href="#生成截断式正态分布随机数" class="headerlink" title="生成截断式正态分布随机数"></a>生成截断式正态分布随机数</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">tf.random.truncated_normal(维度, <span class="hljs-attribute">mean</span>=均值, <span class="hljs-attribute">stddev</span>=标准差)<br></code></pre></td></tr></table></figure>

<h4 id="生成均匀分布随机数（-minval-maxval-）"><a href="#生成均匀分布随机数（-minval-maxval-）" class="headerlink" title="生成均匀分布随机数（[minval, maxval)）"></a>生成均匀分布随机数（[minval, maxval)）</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">tf.random.uniform(维度, <span class="hljs-attribute">minval</span>=0, <span class="hljs-attribute">maxval</span>=1)<br></code></pre></td></tr></table></figure>



<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="将输入特征与标签配对（常用于构建数据集）"><a href="#将输入特征与标签配对（常用于构建数据集）" class="headerlink" title="将输入特征与标签配对（常用于构建数据集）"></a>将输入特征与标签配对（常用于构建数据集）</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tf</span><span class="hljs-selector-class">.data</span><span class="hljs-selector-class">.Dataset</span><span class="hljs-selector-class">.from_tensor_slices</span>( (输入特征, 标签) )<br></code></pre></td></tr></table></figure>



<h4 id="强制tensor转换为该数据类型"><a href="#强制tensor转换为该数据类型" class="headerlink" title="强制tensor转换为该数据类型"></a>强制tensor转换为该数据类型</h4><figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-title">tf</span>.cast(张量名, d<span class="hljs-keyword">type</span>=数据类型)<br></code></pre></td></tr></table></figure>



<h4 id="将变量标记为“可训练”"><a href="#将变量标记为“可训练”" class="headerlink" title="将变量标记为“可训练”"></a>将变量标记为“可训练”</h4><p>使用该方法标记的变量会在反向传播中记录梯度信息</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><code class="hljs coq">tf.<span class="hljs-keyword">Variable</span>(初始值)<br></code></pre></td></tr></table></figure>





<h4 id="某个函数对指定参数的求导运算"><a href="#某个函数对指定参数的求导运算" class="headerlink" title="某个函数对指定参数的求导运算"></a>某个函数对指定参数的求导运算</h4><p>with 结构记录计算过程，gradient求出张量的梯度</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">with</span> tf.<span class="hljs-constructor">GradientTape()</span> <span class="hljs-keyword">as</span> tape:<br>    若干个计算过程<br>grad = tape.gradient(函数, 对谁求导)<br></code></pre></td></tr></table></figure>



<h4 id="自减函数（常用于更新参数的值）"><a href="#自减函数（常用于更新参数的值）" class="headerlink" title="自减函数（常用于更新参数的值）"></a>自减函数（常用于更新参数的值）</h4><p>需要先用<code>tf.Variable(w)</code>定义w为可训练</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">w.assign<span class="hljs-constructor">_sub(<span class="hljs-params">w</span>要自减的内容)</span><br></code></pre></td></tr></table></figure>



<h4 id="独热编码"><a href="#独热编码" class="headerlink" title="独热编码"></a>独热编码</h4><p>分类问题中，常用独热码做标签标记类别，1表示是，2表示非</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">tf.one<span class="hljs-constructor">_hot(带转换数据, <span class="hljs-params">depth</span>=几分类)</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>one-hot编码，把正整数变为向量表达（生成一个不小于正整数的向量，只有正整数的位置为1，其余位置为0）</p>
<p>三分类：2 -&gt; one-hot -&gt; [0, 0, 1]</p>
</blockquote>
<h4 id="softmax：使数值变为0-1之间的概率分布"><a href="#softmax：使数值变为0-1之间的概率分布" class="headerlink" title="softmax：使数值变为0-1之间的概率分布"></a>softmax：使数值变为0-1之间的概率分布</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tf</span><span class="hljs-selector-class">.nn</span><span class="hljs-selector-class">.softmax</span>(张量名)<br></code></pre></td></tr></table></figure>



<h4 id="argmax：返回张量沿指定维度最大值的索引"><a href="#argmax：返回张量沿指定维度最大值的索引" class="headerlink" title="argmax：返回张量沿指定维度最大值的索引"></a>argmax：返回张量沿指定维度最大值的索引</h4><figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">tf.argmax(张量名, <span class="hljs-attribute">axis</span>=操作轴)<br></code></pre></td></tr></table></figure>







<h3 id="张量数值统计"><a href="#张量数值统计" class="headerlink" title="张量数值统计"></a>张量数值统计</h3><h4 id="计算张量元素最小值-最大值"><a href="#计算张量元素最小值-最大值" class="headerlink" title="计算张量元素最小值/最大值"></a>计算张量元素最小值/最大值</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tf</span><span class="hljs-selector-class">.reduce_min</span>()<br><span class="hljs-selector-tag">tf</span><span class="hljs-selector-class">.reduce_max</span>()<br></code></pre></td></tr></table></figure>

<h4 id="计算张量沿着指定维度的平均值（不指定维度对所有操作）"><a href="#计算张量沿着指定维度的平均值（不指定维度对所有操作）" class="headerlink" title="计算张量沿着指定维度的平均值（不指定维度对所有操作）"></a>计算张量沿着指定维度的平均值（不指定维度对所有操作）</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">tf.reduce<span class="hljs-constructor">_mean(张量名, <span class="hljs-params">axis</span>=操作轴)</span><br></code></pre></td></tr></table></figure>

<h4 id="计算张量沿着指定维度的和"><a href="#计算张量沿着指定维度的和" class="headerlink" title="计算张量沿着指定维度的和"></a>计算张量沿着指定维度的和</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">tf.reduce<span class="hljs-constructor">_sum(张量名, <span class="hljs-params">axis</span>=操作轴)</span><br></code></pre></td></tr></table></figure>



<h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><h4 id="两个张量对应元素相加"><a href="#两个张量对应元素相加" class="headerlink" title="两个张量对应元素相加"></a>两个张量对应元素相加</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">tf.add(张量<span class="hljs-number">1</span>, 张量<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>

<h4 id="相减"><a href="#相减" class="headerlink" title="相减"></a>相减</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tf</span><span class="hljs-selector-class">.subtract</span>()<br></code></pre></td></tr></table></figure>

<h4 id="相乘"><a href="#相乘" class="headerlink" title="相乘"></a>相乘</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tf</span><span class="hljs-selector-class">.multiply</span><br></code></pre></td></tr></table></figure>



<h4 id="相除"><a href="#相除" class="headerlink" title="相除"></a>相除</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tf</span><span class="hljs-selector-class">.divide</span><br></code></pre></td></tr></table></figure>



<h4 id="计算张量的平方"><a href="#计算张量的平方" class="headerlink" title="计算张量的平方"></a>计算张量的平方</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">tf</span><span class="hljs-selector-class">.square</span>(张量名)<br></code></pre></td></tr></table></figure>

<h4 id="n次方"><a href="#n次方" class="headerlink" title="n次方"></a>n次方</h4><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">tf</span>.<span class="hljs-built_in">pow</span>(张量名, n次方)<br></code></pre></td></tr></table></figure>

<h4 id="开方"><a href="#开方" class="headerlink" title="开方"></a>开方</h4><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">tf</span>.<span class="hljs-built_in">sqrt</span>(张量名)<br></code></pre></td></tr></table></figure>

<h4 id="两个矩阵相乘"><a href="#两个矩阵相乘" class="headerlink" title="两个矩阵相乘"></a>两个矩阵相乘</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">tf.matmul(矩阵<span class="hljs-number">1</span>, 矩阵<span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>AI相关</category>
        <category>TensorFlow2</category>
      </categories>
      <tags>
        <tag>TensorFlow2</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu常用快捷键</title>
    <url>/page/ubuntu-common-shortcut.html</url>
    <content><![CDATA[<p>记录一些比较常用的快捷键，一些如切屏之类的太常用的就没有记录</p>
<h3 id="系统操作"><a href="#系统操作" class="headerlink" title="系统操作"></a>系统操作</h3><p>Ctrl + Alt + T 启用终端：</p>
<p>Alt + F2 输入命令、启动程序（可以用于启动一些必须命令行启用的程序，网易云等）</p>
<p>Super + F10 打开程序菜单（用于退出程序等操作）</p>
<p>Super + A 展示所有程序及搜索框</p>
<p>Super + V 展示上方的日历和提醒列表</p>
<p>Super + L 锁定屏幕</p>
<h3 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h3><p>Super + H 隐藏窗口</p>
<p>Super + Up Arrow 最大化窗口</p>
<p>Super + Down Arrow 恢复窗口</p>
<p>Super + Right Arrow 将窗口置于屏幕右半侧</p>
<p>Super + Left Arrow 将窗口置于屏幕左半侧</p>
<p>Alt + F4 关闭当前窗口</p>
<p>Ctrl + W 关闭当前窗口</p>
<p>Alt + F7 移动窗口（用的比较少）</p>
<p>Alt + F8 改变窗口大小（用的比较少）</p>
<p>Alt + Space 激活窗口菜单</p>
<h3 id="桌面操作"><a href="#桌面操作" class="headerlink" title="桌面操作"></a>桌面操作</h3><p>Alt + Shift+ Up/Down Arrow 切换桌面</p>
<p>Ctrl + Alt + D 类似Windows下的Win + D组合键，显示桌面 ，隐藏全部窗口</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>Alt + Enter – 查看选择文件/文件夹的属性，代替单击右键选择属性</p>
<p>Alt + Up/Down Arrow – 移动到父文件夹/选择的文件夹（左右的用的多一些）</p>
<p>Alt + Left/Right Arrow – 在文件夹中后退/前进</p>
<p>Ctrl + L - 得到文件路径</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS基础</title>
    <url>/page/css-basic-knowledge.html</url>
    <content><![CDATA[<h2 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">选择器&#123;<br>	<span class="hljs-attribute">k</span>:v;<br>	<span class="hljs-attribute">k</span>:v;<br>	<span class="hljs-attribute">k</span>:v;<br>	<span class="hljs-attribute">k</span>:v;<br>&#125;<br><br><span class="hljs-comment">/*<br>	注释内容<br>*/</span><br></code></pre></td></tr></table></figure>

<h3 id="引用方式"><a href="#引用方式" class="headerlink" title="引用方式"></a>引用方式</h3><h4 id="1、行内样式"><a href="#1、行内样式" class="headerlink" title="1、行内样式"></a>1、行内样式</h4><p>在HTML标签里写</p>
<h4 id="2、内部样式"><a href="#2、内部样式" class="headerlink" title="2、内部样式"></a>2、内部样式</h4><p>在页面的head里采用<code>&lt;style&gt;</code>写</p>
<h4 id="3、链入外部样式：页面加载时，同时加载CSS样式"><a href="#3、链入外部样式：页面加载时，同时加载CSS样式" class="headerlink" title="3、链入外部样式：页面加载时，同时加载CSS样式"></a>3、链入外部样式：页面加载时，同时加载CSS样式</h4><figure class="highlight lasso"><table><tr><td class="code"><pre><code class="hljs lasso">&lt;<span class="hljs-keyword">link</span> rel = <span class="hljs-string">"stylesheet"</span> <span class="hljs-keyword">type</span> = <span class="hljs-string">"text/css"</span> href = <span class="hljs-string">"a.css"</span>&gt;&lt;/<span class="hljs-keyword">link</span>&gt;<br></code></pre></td></tr></table></figure>

<h4 id="4、导入式（-import）：读取完html文件后加载"><a href="#4、导入式（-import）：读取完html文件后加载" class="headerlink" title="4、导入式（@import）：读取完html文件后加载"></a>4、导入式（@import）：读取完html文件后加载</h4><p>写在<code>&lt;style&gt;</code>标签中，且必须是第一句。<code>@import url(a.css);</code></p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="1、标签选择器"><a href="#1、标签选择器" class="headerlink" title="1、标签选择器"></a>1、标签选择器</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="2、ID选择器"><a href="#2、ID选择器" class="headerlink" title="2、ID选择器"></a>2、ID选择器</h4><figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># id1 &#123;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3、类选择器"><a href="#3、类选择器" class="headerlink" title="3、类选择器"></a>3、类选择器</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.class1</span> &#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4、通用选择器（通配符）"><a href="#4、通用选择器（通配符）" class="headerlink" title="4、通用选择器（通配符）"></a>4、通用选择器（通配符）</h4><p>在初始化时常常使用该选择器将整个网页的边距等去掉</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="其他组合"><a href="#其他组合" class="headerlink" title="其他组合"></a>其他组合</h4><p>在父子间加上一个空格，如下表示设置div元素的p子元素的样式</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;div&gt;</span> <span class="hljs-params">&lt;p&gt;</span><span class="hljs-params">&lt;/p&gt;</span> <span class="hljs-params">&lt;/div&gt;</span><br><br>div <span class="hljs-class">p </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>还有交集和并集，分别使用 . 与 , 进行分隔</p>
<h4 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h4><p>同一个标签，根据其<strong>不同的种状态，有不同的样式</strong>。这就叫做“伪类”。伪类用冒号来表示。</p>
<p>比如div是属于box类，这一点很明确，就是属于box类。但是a属于什么类？不明确。因为需要看用户点击前是什么状态，点击后是什么状态。所以，就叫做“伪类”。</p>
<p>1、<strong>静态伪类：</strong>只能用于超链接的样式</p>
<ul>
<li><code>:link</code> 超链接点击之前</li>
<li><code>:visited</code> 链接被访问过之后</li>
</ul>
<p>2、<strong>动态伪类</strong>：针对<strong>所有标签</strong>都适用的样式。如下：</p>
<ul>
<li><code>:hover</code> “悬停”：鼠标放到标签上的时候</li>
<li><code>:active</code>    “激活”： 鼠标点击标签，但是不松手时。</li>
<li><code>:focus</code> 是某个标签获得焦点时的样式（比如某个输入框获得焦点）</li>
</ul>
<h3 id="继承与层叠"><a href="#继承与层叠" class="headerlink" title="继承与层叠"></a>继承与层叠</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>如文字样式等能够继承，如盒子、定位等不能继承</p>
<h4 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h4><p>层叠性就是css处理冲突的能力。</p>
<p><img src="http://cdn.ziyedy.top/image/CSS%E5%9F%BA%E7%A1%80/%E5%B1%82%E5%8F%A0.jpg" alt=""></p>
<p><strong>以下为计算权重的方法，即优先级</strong>，实际时分别查看以下有没有定义样式，如果有，比较优先级，如果优先级一致，<strong>就近原则（即最后一个进行覆盖）</strong></p>
<p>1、行内样式优先于内部样式，内部样式与链接样式取决于书写先后顺序（后定义覆盖新定义）</p>
<p>2、id选择器&gt;class选择器&gt;标签选择器</p>
<p>3、选择器有权值 ，使用<code>!important;</code>标记优先级最高</p>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>盒子模型如下，即包含外边距（margin）、边界（border）、内边距（padding）和内容的一种模型。</p>
<p><img src="http://cdn.ziyedy.top/image/CSS%E5%9F%BA%E7%A1%80%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3><p>padding为内边距，其区域有背景颜色（与内容区域相同），background-color将填充所有border以内的区域</p>
<h4 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h4><p>四个值：上、右、下、左</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">padding:<span class="hljs-number">30</span>px <span class="hljs-number">40</span>px <span class="hljs-number">30</span>px <span class="hljs-number">40</span>px;<br></code></pre></td></tr></table></figure>

<p>三个值：上、右、下、（左与右一样）</p>
<p>上下、左右</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">padding:<span class="hljs-number">30</span>px <span class="hljs-number">40</span>px;<br></code></pre></td></tr></table></figure>



<h3 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h3><p>注意：<strong><code>&lt;body&gt;</code>标签默认有margin，为8px，因此很多情况下都需要加上以下语句清除margin。</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">* &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其余操作与padding中差不多</p>
<h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><p>边框主要有三个要素：像素（粗细）、线型、颜色</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid red;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端样式</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS定位与浮动</title>
    <url>/page/css-float-position.html</url>
    <content><![CDATA[<p>传统布局方式：</p>
<blockquote>
<p>display + position + float</p>
</blockquote>
<h2 id="Web标准文档流"><a href="#Web标准文档流" class="headerlink" title="Web标准文档流"></a>Web标准文档流</h2><h3 id="行内元素与块级元素"><a href="#行内元素与块级元素" class="headerlink" title="行内元素与块级元素"></a>行内元素与块级元素</h3><h4 id="行内元素（p、span、a、b、i、u、em等）"><a href="#行内元素（p、span、a、b、i、u、em等）" class="headerlink" title="行内元素（p、span、a、b、i、u、em等）"></a>行内元素（p、span、a、b、i、u、em等）</h4><ul>
<li>与其他行内元素并排；</li>
<li>不能设置宽、高。默认的宽度，就是文字的宽度。</li>
</ul>
<h4 id="块级元素（div等）"><a href="#块级元素（div等）" class="headerlink" title="块级元素（div等）"></a>块级元素（div等）</h4><ul>
<li>霸占一行，不能与其他任何元素并列；</li>
<li>能接受宽、高。如果不设置宽度，那么宽度将默认变为父亲的100%。</li>
</ul>
<h4 id="块级元素转行内元素"><a href="#块级元素转行内元素" class="headerlink" title="块级元素转行内元素"></a>块级元素转行内元素</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-built_in">display</span>: <span class="hljs-keyword">inline</span>;<br></code></pre></td></tr></table></figure>

<h4 id="行内元素转块级元素"><a href="#行内元素转块级元素" class="headerlink" title="行内元素转块级元素"></a>行内元素转块级元素</h4><figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">display</span>: <span class="hljs-built_in">block</span>;<br></code></pre></td></tr></table></figure>

<h3 id="标准文档流"><a href="#标准文档流" class="headerlink" title="标准文档流"></a>标准文档流</h3><p>Web界面可以视为一个流，从上往下，主要有以下特性。</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p><strong>1、空白折叠</strong></p>
<p>无论多少个空格、换行、tab，都会折叠为一个空格。</p>
<p><strong>2、同行的元素底边对齐</strong></p>
<p><strong>3、一行空间不够，自动换行</strong></p>
<h4 id="使元素脱离标准文档流的方法"><a href="#使元素脱离标准文档流的方法" class="headerlink" title="使元素脱离标准文档流的方法"></a>使元素脱离标准文档流的方法</h4><ul>
<li>浮动</li>
<li>绝对定位</li>
<li>固定定位</li>
</ul>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">float</span>: left;<br></code></pre></td></tr></table></figure>

<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>1、浮动元素脱标</p>
<p>2、浮动元素相互贴靠（改变窗口大小即可看到，窗口够大，就会自动贴靠）</p>
<p>3、文字会自动包围浮动元素</p>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>避免如下情况导致的布局问题，应当进行浮动清除</p>
<img src="http://cdn.ziyedy.top/image/%E5%89%8D%E7%AB%AF/CSS/CSS%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8/%E6%B5%AE%E5%8A%A8%E5%87%BA%E9%94%99.png" style="zoom: 67%;" />

<h4 id="1、给浮动元素的祖先设置合适的高度（大于孩子的高度）"><a href="#1、给浮动元素的祖先设置合适的高度（大于孩子的高度）" class="headerlink" title="1、给浮动元素的祖先设置合适的高度（大于孩子的高度）"></a>1、给浮动元素的祖先设置合适的高度（大于孩子的高度）</h4><p>缺点：不能适应页面的快速变化</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;div&gt;</span>     <span class="hljs-comment">//设置height</span><br>	<span class="hljs-params">&lt;p&gt;</span><span class="hljs-params">&lt;/p&gt;</span><br><span class="hljs-params">&lt;/div&gt;</span><br><br><span class="hljs-params">&lt;div&gt;</span>    <span class="hljs-comment">//设置height</span><br>	<span class="hljs-params">&lt;p&gt;</span><span class="hljs-params">&lt;/p&gt;</span><br><span class="hljs-params">&lt;/div&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="2、clear-both-（即不允许左侧和右侧有浮动对象）"><a href="#2、clear-both-（即不允许左侧和右侧有浮动对象）" class="headerlink" title="2、clear: both; （即不允许左侧和右侧有浮动对象）"></a>2、clear: both; （即不允许左侧和右侧有浮动对象）</h4><p>缺点：margin失效，两个div之间没有间隙</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;div&gt;</span><br>	<span class="hljs-params">&lt;p&gt;</span><span class="hljs-params">&lt;/p&gt;</span><br><span class="hljs-params">&lt;/div&gt;</span><br><br><span class="hljs-params">&lt;div&gt;</span>   <span class="hljs-comment">//clear:both;</span><br>	<span class="hljs-params">&lt;p&gt;</span><span class="hljs-params">&lt;/p&gt;</span><br><span class="hljs-params">&lt;/div&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="3、在两个浮动元素之间插入一个div"><a href="#3、在两个浮动元素之间插入一个div" class="headerlink" title="3、在两个浮动元素之间插入一个div"></a>3、在两个浮动元素之间插入一个div</h4><h4 id="4、overflow-hidden"><a href="#4、overflow-hidden" class="headerlink" title="4、overflow: hidden;"></a>4、overflow: hidden;</h4><p>推荐使用，在父元素上添加该元素。</p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>即相对于元素自己<strong>原来的位置</strong>，进行位置调整。</p>
<p>相对定位<strong>不脱标</strong>，即相对定位的真实位置还在元素的原始位置，只不过影子出去了，可以到处飘。</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-attribute">position</span>: relative;<br></code></pre></td></tr></table></figure>

<ul>
<li><p>left：盒子右移</p>
</li>
<li><p>right：盒子左移</p>
</li>
<li><p>top：盒子下移</p>
</li>
<li><p>bottom：盒子上移</p>
</li>
</ul>
<p>负数表示相反的方向</p>
<h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><p>1、微调元素</p>
<p>2、作为绝对定位的参考，子绝父相</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>HTML元素</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">&lt;div <span class="hljs-keyword">class</span>="<span class="hljs-symbol">div1</span>"&gt;原始状态&lt;/<span class="hljs-symbol">div</span>&gt;<br>   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>="<span class="hljs-symbol">div2</span>"&gt;绝对定位<span class="hljs-symbol">left40px,<span class="hljs-symbol">top40px</span></span>&lt;/<span class="hljs-symbol">div</span>&gt;<br>   &lt;<span class="hljs-symbol">div</span> <span class="hljs-symbol">class</span>="<span class="hljs-symbol">div3</span>"&gt;原始状态&lt;/<span class="hljs-symbol">div</span>&gt;<br></code></pre></td></tr></table></figure>

<p>CSS样式</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>    <span class="hljs-attribute">background-color</span>: red;<br>&#125;<br><span class="hljs-selector-class">.div2</span>&#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">40px</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">40px</span>;<br>&#125;<br><span class="hljs-selector-class">.div3</span>&#123;<br>    <span class="hljs-attribute">background-color</span>: aqua;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>表现：</p>
<img src="http://cdn.ziyedy.top/image/%E5%89%8D%E7%AB%AF/CSS/CSS%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8/%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D.png" style="zoom: 67%;" />



<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>定义横纵坐标。原点在父容器的左上角或左下角。横坐标用left表示，纵坐标用top或者bottom表示。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-attribute">position</span>: absolute;  <span class="hljs-comment">/*绝对定位*/</span><br><span class="hljs-attribute">left</span>: <span class="hljs-number">10px</span>;  <span class="hljs-comment">/*横坐标*/</span><br><span class="hljs-attribute">top</span>/bottom: <span class="hljs-number">20px</span>;  <span class="hljs-comment">/*纵坐标*/</span><br></code></pre></td></tr></table></figure>

<h4 id="脱标特性"><a href="#脱标特性" class="headerlink" title="脱标特性"></a>脱标特性</h4><p>即所有的标准文档流的性质，绝对定位之后都不遵守了，标签也不区分所谓的行内元素、块级元素了</p>
<h4 id="参考点"><a href="#参考点" class="headerlink" title="参考点"></a>参考点</h4><p>（1）如果用<strong>top描述</strong>，那么参考点就是<strong>页面的左上角</strong>，而不是浏览器的左上角</p>
<img src="http://cdn.ziyedy.top/image/%E5%89%8D%E7%AB%AF/CSS/CSS%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8/%E5%AE%9A%E4%BD%8D1.png" style="zoom:75%;" />

<p>（2）如果用<strong>bottom描述</strong>，那么参考点就是<strong>浏览器首屏窗口尺寸</strong>（好好理解“首屏”二字），对应的页面的左下角</p>
<img src="http://cdn.ziyedy.top/image/%E5%89%8D%E7%AB%AF/CSS/CSS%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8/%E5%AE%9A%E4%BD%8D2.png" style="zoom:75%;" />

<p>（3）一个绝对定位的元素，如果父辈元素中也出现了已定位（无论是绝对定位、相对定位，还是固定定位）的元素，那么将以父辈这个元素，为参考点。</p>
<img src="http://cdn.ziyedy.top/image/%E5%89%8D%E7%AB%AF/CSS/CSS%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8/%E5%AE%9A%E4%BD%8D3.png" style="zoom:75%;" />

<p>子绝父相：使得整体不脱离文档流</p>
<p>同时，<strong>绝对定位是从父元素的border内侧为参考点，而不是以内容</strong></p>
<h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>相对浏览器窗口进行定位。<strong>无论页面如何滚动，这个盒子显示的位置不变</strong>。</p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>1、网页右下角的“返回到顶部”</p>
<p>2、顶部导航栏（假设顶部导航条的高度是60px，那么，为了防止其他的内容被导航条覆盖，我们要给body标签设置60px的padding-top）</p>
<h3 id="z-index属性"><a href="#z-index属性" class="headerlink" title="z-index属性"></a>z-index属性</h3><p>表示谁压着谁，数值大的压盖住数值小的。</p>
<p>1、默认的z-index值是0</p>
<p>2、定位了的元素，永远能够压住没有定位的元素</p>
<p>3、从父现象：父亲怂了，儿子再牛逼也没用</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端样式</tag>
      </tags>
  </entry>
  <entry>
    <title>DS05.4:红黑树</title>
    <url>/page/ds-RBTree.html</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="红黑树的定义与性质"><a href="#红黑树的定义与性质" class="headerlink" title="红黑树的定义与性质"></a>红黑树的定义与性质</h2><p>红黑树与AVL树一样，也是一个自平衡的二叉搜索树，其中节点使用“红”与“黑”进行标注。</p>
<p>关于对红黑树的理解，根据23树的相关定义可以很快的认识。</p>
<h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><ol>
<li>每个节点或者是红色的，或者是黑色的。</li>
<li>根节点是黑色的。</li>
<li>每一个叶子节点（最后的空节点）是黑色的。</li>
<li>如果一个节点是红色的，那么他的孩子节点都是黑色的</li>
<li>从任意一个节点到叶子节点，经过的黑色节点是一样的。</li>
</ol>
<p>显然，根据第5条性质，可以知道<strong>红黑树是保持“黑平衡”的二叉树</strong>。因此严格意义上不是平衡二叉树，最大高度2log n（每个黑节点都带个红节点）</p>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>红黑树执行查找、插入、删除等操作的时间复杂度为 <code>O(logN)</code></p>
<h2 id="与AVL树的比较"><a href="#与AVL树的比较" class="headerlink" title="与AVL树的比较"></a>与AVL树的比较</h2><p>显然，如果单纯按照树的高度这一标准看，红黑树似乎比不上AVL树的性能，但<strong>红黑树添加元素、删除元素较AVL树更快（由于没有AVL树要求那么严格，因此为维护平衡进行的旋转操作相对较少）</strong>，在整体性能上优于AVL树，所以这是一个相当重要的数据结构。</p>
<ul>
<li><p>当元素偏向于固定，主要进行查询等操作时，使用AVL树更优</p>
</li>
<li><p>当需要频繁的进行插入与删除操作时，则使用红黑树更优。</p>
</li>
</ul>
<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>红黑树的操作绝大部分与二叉搜索树相同，不同的地方与AVL树相同，主要在维护自平衡上，集中表现在插入与删除的过程。<strong>维护的时机也与AVL树一致，在添加节点后回溯向上维护（简单来讲就是代码应该写在插入的递归业务之后，采用后序的思想）</strong></p>
<h2 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h2><h3 id="基本Node类"><a href="#基本Node类" class="headerlink" title="基本Node类"></a>基本Node类</h3><p>设置插入节点的初始颜色：<strong>红色</strong>。</p>
<p>理由：红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。（得时刻记住，红黑树是一个黑节点平衡的树）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> RED = <span class="hljs-keyword">true</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> BLACK = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> E e;<br>    <span class="hljs-keyword">public</span> Node left, right;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> color;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.e = e;<br>        left = <span class="hljs-keyword">null</span>;<br>        right = <span class="hljs-keyword">null</span>;<br>        color = RED;	<span class="hljs-comment">// 初始节点设置为红色</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="判断当前节点是否为红色"><a href="#判断当前节点是否为红色" class="headerlink" title="判断当前节点是否为红色"></a>判断当前节点是否为红色</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRed</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> BLACK;<br>    <span class="hljs-keyword">return</span> RED;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//   node                     x</span><br><span class="hljs-comment">//  /   \     左旋转         /  \</span><br><span class="hljs-comment">// T1   x   ---------&gt;   node   T3</span><br><span class="hljs-comment">//     / \              /   \</span><br><span class="hljs-comment">//    T2 T3            T1   T2</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">leftRotate</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    Node x = node.right;<br><br>    node.right = x.left;<br>    x.left = node;<br><br>    x.color = node.color;<br>    node.color = RED;<br><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//     node                   x</span><br><span class="hljs-comment">//    /   \     右旋转       /  \</span><br><span class="hljs-comment">//   x    T2   -------&gt;   y   node</span><br><span class="hljs-comment">//  / \                       /  \</span><br><span class="hljs-comment">// y  T1                     T1  T2</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">rightRotate</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    Node x = node.left;<br>    node.left = x.right;<br>    x.right = node;<br><br>    x.color = node.color;<br>    node.color = RED;<br><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="颜色翻转"><a href="#颜色翻转" class="headerlink" title="颜色翻转"></a>颜色翻转</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flipColors</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    node.color = RED;<br>    node.left.color = BLACK;<br>    node.right.color = BLACK;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><p>插入时可能会遇到的情况下图已经总结的很清楚了。主要考虑情景4</p>
<img src="http://cdn.ziyedy.top/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5.png" style="zoom:;" />

<p>而情景4主要可以分为以下①②③三种插入情况，其实是可以分别转化的</p>
<img src="http://cdn.ziyedy.top/%E6%8F%92%E5%85%A5.jpg" style="zoom:80%;" />

<p>这三种操作具体可见辅助方法中的代码。同时应当注意，在这种代码实现下，<strong>红节点是只会出现在左孩子上的（由于颜色翻转的实现）</strong></p>
<h3 id="情况③"><a href="#情况③" class="headerlink" title="情况③"></a>情况③</h3><p>这种情况直接插入并进行<strong>颜色翻转</strong>操作。</p>
<h3 id="情况②"><a href="#情况②" class="headerlink" title="情况②"></a>情况②</h3><p>这种情况先进行右旋再进行颜色翻转</p>
<h3 id="情况①"><a href="#情况①" class="headerlink" title="情况①"></a>情况①</h3><p>先进行左旋转、再进行右旋转、最后进行颜色反转</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 向红黑树中添加新元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    root = add(root, e);<br>    root.color = BLACK;	<span class="hljs-comment">// 设置根节点为黑</span><br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">add</span><span class="hljs-params">(Node node, E e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) &#123;<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node(e);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(e.compareTo(node.e) &lt; <span class="hljs-number">0</span>) &#123;<br>        node.left = add(node.left, e);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e.compareTo(node.e) &gt;<span class="hljs-number">0</span>) &#123;<br>        node.right = add(node.right, e);<br>    &#125;<br><br>	<span class="hljs-comment">// 情况1</span><br>    <span class="hljs-keyword">if</span>(isRed(node.right) &amp;&amp; !isRed(node.left))<br>        node = leftRotate(node);<br>    <span class="hljs-comment">// 情况2</span><br>    <span class="hljs-keyword">if</span>(isRed(node.left) &amp;&amp; isRed(node.left.left))<br>        node = rightRotate(node);<br>    <span class="hljs-comment">// 情况3</span><br>    <span class="hljs-keyword">if</span>(isRed(node.left) &amp;&amp; isRed(node.right))<br>        flipColors(node);<br>        <br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>







<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">https://www.jianshu.com/p/e136ec79235c</a>    这篇文章对红黑树阐述的特别详细，其实要了解红黑树看这一篇就行了。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>DS08:哈希表</title>
    <url>/page/ds-hashtable.html</url>
    <content><![CDATA[<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表可以理解为是通过一个映射函数（哈希函数）直接得到存储地址的数据结构，通常基于数组实现（<strong>容量通常采用质数</strong>）。</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">存储地址 = f<span class="hljs-comment">(关键字)</span>	<span class="hljs-comment">// f为哈希函数</span><br></code></pre></td></tr></table></figure>

<p>根据这一基本特征可以看出，哈希表可以提供非常快速的插入-删除操作，理想状况下时间复杂度为0(1)级别。</p>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>哈希函数可以简单理解为是对需要存储的元素本身——&gt;存储下标的映射。</p>
<p>如对字符串可以分别取其符号进行运算（整型则通常使用取模得到），而对于相关类，也可以自己定义hashcode函数，来获取坐标方式。</p>
<h4 id="哈希函数的设计："><a href="#哈希函数的设计：" class="headerlink" title="哈希函数的设计："></a>哈希函数的设计：</h4><p>一致性：如果a==b,则hash(a)==hash(b)</p>
<p>高效性：计算高效简便</p>
<p>均匀性：哈希值均匀分布</p>
<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>比如我们的哈希函数是对7取余，那么元素14和元素77通过哈希函数得到的索引就是相同的，这种情况就叫哈希冲突。</p>
<p>解决哈希冲突的方法有很多，具体有：<strong>链地址法（数组中存链表、平衡二叉树等元素）</strong>、<strong>开放地址法（向下找没存元素的位置，个人认为很麻烦不适用）</strong>等方法。</p>
<p>也可以将实现哈希表的数组直接保存一个平衡二叉树，总之就是为了解决冲突问题。</p>
<h3 id="哈希表扩容"><a href="#哈希表扩容" class="headerlink" title="哈希表扩容"></a>哈希表扩容</h3><p>如果哈希函数设计的不好，很多元素都重叠在了一个地址，那么理论上O(1)的时间复杂度在以平衡二叉树为数组元素的哈希表中就会达到O(log n/m)，因此遇到这种时候，就应该对哈希表进行扩容。</p>
<p>平均每个地址承载的元素多过一定程度，就进行扩容，通常这个值是0.75。缩容同理。</p>
<p>由于哈希表的实现方法很多，而且并不算太难，所以不进行代码记录，主要思想就是<strong>以空间换时间</strong></p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://www.jianshu.com/p/6e88d63061f2" target="_blank" rel="noopener">https://www.jianshu.com/p/6e88d63061f2</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>DS05.3:AVL树</title>
    <url>/page/ds-avl-tree.html</url>
    <content><![CDATA[<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><h3 id="AVL树（平衡二叉树）"><a href="#AVL树（平衡二叉树）" class="headerlink" title="AVL树（平衡二叉树）"></a>AVL树（平衡二叉树）</h3><p>平衡二叉树是一种二叉搜索树，对于其中任意一个节点，左子树和右子树的高度差不能超过1。</p>
<p>两位俄罗斯数学家共同发明了一种解决平衡二叉树的算法，所以这种树也称为AVL树（取其名称）。</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.3%E3%80%81AVL%E6%A0%91/AVL.png" alt=""></p>
<p>注意的地方：<strong>平衡二叉树从叶子节点向上记录节点的高度</strong>，即叶子节点高度为1，向上依次类推。而使用<strong>平衡因子</strong>用来表示左右子树高度差。</p>
<h3 id="平衡二叉树的作用"><a href="#平衡二叉树的作用" class="headerlink" title="平衡二叉树的作用"></a>平衡二叉树的作用</h3><p>根据之前对二叉搜索树的时间复杂度分析可知，其各项操作的时间复杂度介于O(log n)与O(n)之间，在节点足够多的情况下这两者的效率相差很大。O(n)复杂度的BST实际上已经退化成了一个链表，而复杂度接近O(log n)的情况则就是平衡二叉树的状态了，因此对二叉树进行“平衡处理”是很重要的。</p>
<h3 id="平衡性分析"><a href="#平衡性分析" class="headerlink" title="平衡性分析"></a>平衡性分析</h3><p>由于AVL树仍然是一个二叉搜索树，所以二叉搜索树的一切操作都可以进行调用，唯一需要注意的就是<strong>当有破坏平衡的操作发生时，需要进行对应操作维护树的平衡性</strong>。</p>
<p>显然，BST的相关操作中添加元素与删除元素这两个操作可能会破坏树的平衡性，因此在add与remove中递归实现的基础上，应该在递归完成之后沿着节点向上维护平衡性（有点后续遍历的味道）。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="1、右旋（左左）"><a href="#1、右旋（左左）" class="headerlink" title="1、右旋（左左）"></a>1、右旋（左左）</h4><p>这种情况发生在<strong>向左子树的左孩子添加一个元素，且正好打破了平衡时（即二叉树向左倾斜）</strong>。这种情况我们可以称为<strong>左左</strong>，需要进行<strong>右旋</strong>操作维持平衡</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.3%E3%80%81AVL%E6%A0%91/%E5%8F%B3%E6%97%8B1.png" alt=""></p>
<p>右旋操作简单来讲如下伪码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">右旋(L):	<br>	temp = L.right;<br>	L.right = T;<br>	T.left = temp;<br></code></pre></td></tr></table></figure>

<p>如图所示：</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.3%E3%80%81AVL%E6%A0%91/%E5%8F%B3%E6%97%8B2.png" alt=""></p>
<h4 id="2、左旋（右右）"><a href="#2、左旋（右右）" class="headerlink" title="2、左旋（右右）"></a>2、左旋（右右）</h4><p>这种情况发生在<strong>向右子树的右孩子添加一个元素，且正好打破了平衡时（即二叉树向右倾斜）</strong>。这种情况我们可以称为<strong>右右</strong>，需要进行<strong>左旋</strong>操作维持平衡。</p>
<p><strong>左旋操作可以视为右旋的镜像</strong></p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.3%E3%80%81AVL%E6%A0%91/%E5%B7%A6%E6%97%8B1.png" alt=""></p>
<p>伪码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">左旋(R):<br>	temp = R.left;<br>	R.left = T;<br>	T.right = temp;<br></code></pre></td></tr></table></figure>

<p>如图所示：</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.3%E3%80%81AVL%E6%A0%91/%E5%B7%A6%E6%97%8B2.png" alt=""></p>
<h3 id="3、左右"><a href="#3、左右" class="headerlink" title="3、左右"></a>3、左右</h3><p>顾名思义，也就是向左子树的右孩子插入一个节点。</p>
<p>这种情况下，我们需要<strong>先对右孩子进行一次左旋，再对对应的“根节点”进行一次右旋</strong>。如图所示：</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.3%E3%80%81AVL%E6%A0%91/%E5%B7%A6%E5%8F%B31.png" alt=""></p>
<p>伪码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">左旋(R);<br>右旋(L);<br></code></pre></td></tr></table></figure>

<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.3%E3%80%81AVL%E6%A0%91/%E5%B7%A6%E5%8F%B32.png" alt=""></p>
<h4 id="4、右左"><a href="#4、右左" class="headerlink" title="4、右左"></a>4、右左</h4><p>与“左右”是镜像操作，故不再赘述</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.3%E3%80%81AVL%E6%A0%91/%E5%8F%B3%E5%B7%A6.png" alt=""></p>
<h2 id="操作实现"><a href="#操作实现" class="headerlink" title="操作实现"></a>操作实现</h2><h3 id="node中新增height用于记录高度"><a href="#node中新增height用于记录高度" class="headerlink" title="node中新增height用于记录高度"></a>node中新增height用于记录高度</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> E e;<br>    <span class="hljs-keyword">public</span> Node left, right;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> height;	<span class="hljs-comment">// 记录高度</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.e = e;<br>        left = <span class="hljs-keyword">null</span>;<br>        right = <span class="hljs-keyword">null</span>;<br>        height = <span class="hljs-number">1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="功能函数"><a href="#功能函数" class="headerlink" title="功能函数"></a>功能函数</h3><h4 id="获取节点的高度"><a href="#获取节点的高度" class="headerlink" title="获取节点的高度"></a>获取节点的高度</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取每个节点的高度</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> node.height;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="计算每个点的平衡因子"><a href="#计算每个点的平衡因子" class="headerlink" title="计算每个点的平衡因子"></a>计算每个点的平衡因子</h4><p>这个功能方法在AVL树的实现中至关重要，记住由于之后在维护平衡时需要判断是上述基本操作中的哪一种，因此<strong>该函数计算的平衡因子一定不能加上abs函数</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 计算每个点的平衡因子</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBalenceFactor</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> getHeight(node.left) - getHeight(node.right);	<span class="hljs-comment">// 不要加abs函数</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="右旋操作"><a href="#右旋操作" class="headerlink" title="右旋操作"></a>右旋操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 对节点y进行向右旋转操作，返回旋转后新的根节点x</span><br><span class="hljs-comment">//        y                              x</span><br><span class="hljs-comment">//       / \                           /   \</span><br><span class="hljs-comment">//      x   T4     向右旋转 (y)        z     y</span><br><span class="hljs-comment">//     / \       - - - - - - - -&gt;    / \   / \</span><br><span class="hljs-comment">//    z   T3                       T1  T2 T3 T4</span><br><span class="hljs-comment">//   / \</span><br><span class="hljs-comment">// T1   T2</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">rightRotate</span><span class="hljs-params">(Node y)</span> </span>&#123;<br>    Node x = y.left;<br>    Node T3 = x.right;<br><br>    <span class="hljs-comment">// 右旋转</span><br>    x.right = y;<br>    y.left = T3;<br><br>    <span class="hljs-comment">// 更新height</span><br>    y.height = Math.max(getHeight(y.left), getHeight(y.right)) + <span class="hljs-number">1</span>;<br>    x.height = Math.max(getHeight(x.left), getHeight(x.right)) + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="左旋操作"><a href="#左旋操作" class="headerlink" title="左旋操作"></a>左旋操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 对节点y进行向左旋转操作，返回旋转后新的根节点x</span><br><span class="hljs-comment">//    y                             x</span><br><span class="hljs-comment">//  /  \                          /   \</span><br><span class="hljs-comment">// T1   x      向左旋转 (y)       y     z</span><br><span class="hljs-comment">//     / \   - - - - - - - -&gt;   / \   / \</span><br><span class="hljs-comment">//   T2  z                     T1 T2 T3 T4</span><br><span class="hljs-comment">//      / \</span><br><span class="hljs-comment">//     T3 T4</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">leftRotate</span><span class="hljs-params">(Node y)</span> </span>&#123;<br>    Node x = y.right;<br>    Node T2 = x.left;<br><br>    x.left = y;<br>    y.right = T2;<br><br>    y.height = Math.max(getHeight(y.left), getHeight(y.right)) + <span class="hljs-number">1</span>;<br>    x.height = Math.max(getHeight(x.left), getHeight(x.right)) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="判断是否是平衡二叉树"><a href="#判断是否是平衡二叉树" class="headerlink" title="判断是否是平衡二叉树"></a>判断是否是平衡二叉树</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 判断是否是平衡二叉树</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> isBalanced(root);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isBalanced</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">int</span> balanceFactor = getBalenceFactor(node);<br>    <span class="hljs-keyword">if</span>(Math.abs(balanceFactor) &gt; <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">return</span> isBalanced(node.left) &amp;&amp; isBalanced(node.right);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="维护平衡与更新高度"><a href="#维护平衡与更新高度" class="headerlink" title="维护平衡与更新高度"></a>维护平衡与更新高度</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回进行平衡维护后的节点</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">keepBalence</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-comment">// 更新height</span><br>    node.height = <span class="hljs-number">1</span> + Math.max(getHeight(node.left), getHeight(node.right));<br><br>    <span class="hljs-comment">// 平衡维护</span><br>    <span class="hljs-keyword">int</span> balanceFactor = getBalenceFactor(node);<br>    <span class="hljs-keyword">if</span>(balanceFactor &gt; <span class="hljs-number">1</span> &amp;&amp; getBalenceFactor(node.left) &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> rightRotate(node);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(balanceFactor &lt; -<span class="hljs-number">1</span> &amp;&amp; getBalenceFactor(node.right) &lt;=<span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> leftRotate(node);<br>    &#125;<br>    <span class="hljs-comment">// LR</span><br>    <span class="hljs-keyword">if</span>(balanceFactor &gt; <span class="hljs-number">1</span> &amp;&amp; getBalenceFactor(node.left) &lt; <span class="hljs-number">0</span>) &#123;<br>        node.left = leftRotate(node.left);<br>        <span class="hljs-keyword">return</span> rightRotate(node);<br>    &#125;<br>    <span class="hljs-comment">// RL</span><br>    <span class="hljs-keyword">if</span>(balanceFactor &lt; -<span class="hljs-number">1</span> &amp;&amp; getBalenceFactor(node.right) &gt; <span class="hljs-number">0</span>) &#123;<br>        node.right = rightRotate(node.right);<br>        <span class="hljs-keyword">return</span> leftRotate(node);<br>    &#125;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">add</span><span class="hljs-params">(Node node, E e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>) &#123;<br>        size++;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Node(e);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(e.compareTo(node.e) &lt; <span class="hljs-number">0</span>) &#123;<br>        node.left = add(node.left, e);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e.compareTo(node.e) &gt;<span class="hljs-number">0</span>) &#123;<br>        node.right = add(node.right, e);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> keepBalence(node);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">remove</span><span class="hljs-params">(Node node, E e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    Node retNode;<br>    <span class="hljs-keyword">if</span>(e.compareTo(node.e) &lt; <span class="hljs-number">0</span>) &#123;<br>        node.left = remove(node.left, e);<br>        retNode = node;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e.compareTo(node.e) &gt; <span class="hljs-number">0</span>) &#123;<br>        node.right = remove(node.right, e);<br>        retNode = node;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span>(node.left == <span class="hljs-keyword">null</span> || node.right == <span class="hljs-keyword">null</span>) &#123;<br>            node = (node.left == <span class="hljs-keyword">null</span>) ? node.right : node.left;<br>            retNode = node;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            Node temp = node.right;<br>            <span class="hljs-keyword">while</span> (temp.left != <span class="hljs-keyword">null</span>)<br>                temp = temp.left;<br>            node.e = temp.e;<br>            node.right = remove(node.right, temp.e);<br>            retNode = node;<br>        &#125;<br>	&#125;<br><br>    <span class="hljs-comment">// 当前节点被删除时</span><br>    <span class="hljs-keyword">if</span>(retNode == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-keyword">return</span> keepBalence(retNode);<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://www.cnblogs.com/linhaostudy/p/11300556.html" target="_blank" rel="noopener">https://www.cnblogs.com/linhaostudy/p/11300556.html</a>    （图画的相当清楚，点赞！）</p>
<p><a href="https://github.com/liuyubobobo/Play-with-Data-Structures" target="_blank" rel="noopener">https://github.com/liuyubobobo/Play-with-Data-Structures</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/page/ds-Union-Find.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="并查集定义"><a href="#并查集定义" class="headerlink" title="并查集定义"></a>并查集定义</h3><p><strong>并查集(Union-Find Set)</strong>，顾名思义，是实现快速合并集合与查询元素所在集合的数据结构。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ol>
<li>合并两个不相交集合<strong>（Union）</strong></li>
<li>判断两个元素是否属于同一个集合<strong>（Find）</strong></li>
</ol>
<p>基于此，可以实现一个并查集的Java接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UF</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">// 获取元素个数</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>; <span class="hljs-comment">// 判断两个元素是否属于同一集合</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span></span>;   <span class="hljs-comment">// 合并两个不相交的集合</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="Quick-Find概述"><a href="#Quick-Find概述" class="headerlink" title="Quick Find概述"></a>Quick Find概述</h3><p>如图，使用一个数组id标识不同元素所属的集合。</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/quickfind.jpg" alt=""></p>
<p>则并查集的实现逻辑如下。由于可以直接通过索引得到某元素所属的集合，则<strong>Find操作的时间复杂度为O(1)</strong>，但Union操作由于要遍历整个数组，因此<strong>时间复杂度为O(n)</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UF</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] id;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        id = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;id.length;i++)<br>            id[i] = i;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id.length;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取元素所属集合</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getID</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (p &lt; <span class="hljs-number">0</span> || p &gt;=id.length)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"p is illegal"</span>);<br>        <span class="hljs-keyword">return</span> id[p];<br>    &#125;<br><br>    <span class="hljs-comment">// 查看元素p和元素q是否所属同一个集合</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getID(p) == getID(q);<br>    &#125;<br><br>    <span class="hljs-comment">// 合并元素p和元素q</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pID = getID(p);<br>        <span class="hljs-keyword">int</span> qID = getID(q);<br>        <span class="hljs-keyword">if</span>(pID == qID)<br>            <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;id.length;i++) &#123;<br>            <span class="hljs-keyword">if</span>(id[i] == qID)<br>                id[i] = pID;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Quick-Union概述"><a href="#Quick-Union概述" class="headerlink" title="Quick Union概述"></a>Quick Union概述</h3><p>很显然，之前的Quick Find中查找是否属于同一元素速度很快，而Quick Union则着重于合并的速度。</p>
<p>如图所示，Quick Union的设计思想采用树（森林）进行。每个集合都使用一个根节点进行标识（根节点的父节点为其自身），<strong>在具体存储时，也可以使用一个parent数组来标识其父节点的位置</strong>。因此：</p>
<p><strong>Find操作只需要找到对应节点的根节点判断是否相等即可；</strong></p>
<p><strong>Union操作只需要将一个元素的根节点指向Union操作的另一元素的根节点即可</strong>，具体如图将元素1与元素2进行合并的操作示意</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/quickunion.jpg" alt=""></p>
<p>具体实现如下（略去了不关键的几个方法）：这种方法下，find与union操作的时间复杂度都为O(h)，h为树的深度。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnionFind2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UF</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UnionFind2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span> </span>&#123;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[size];<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++) &#123;<br>            parent[i] = i;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getID</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (p &lt; <span class="hljs-number">0</span> || p &gt;= parent.length)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"p is out of bound"</span>);<br>        <span class="hljs-keyword">while</span> (p != parent[p])<br>            p = parent[p];<br>        <span class="hljs-keyword">return</span> p;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getID(p) == getID(q);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> pRoot = getID(p);<br>        <span class="hljs-keyword">int</span> qRoot = getID(q);<br><br>        <span class="hljs-keyword">if</span>(pRoot == qRoot)<br>            <span class="hljs-keyword">return</span>;<br><br>        parent[pRoot] = qRoot;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>Quick Union的效率与树的深度有关，因此需要尽可能的缩短树的深度，从而提高效率。</p>
<h4 id="思路1：记录每棵树的节点个数"><a href="#思路1：记录每棵树的节点个数" class="headerlink" title="思路1：记录每棵树的节点个数"></a>思路1：记录每棵树的节点个数</h4><p>节点个数多的树<strong>大概率</strong>深度高，因此让节点个数少的集合的根节点指向节点个数大的根节点即可。代码逻辑如下（sz[i]表示以i为根的集合中元素个数）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pRoot = getID(p);<br>    <span class="hljs-keyword">int</span> qRoot = getID(q);<br><br>    <span class="hljs-keyword">if</span>(pRoot == qRoot)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span>(sz[pRoot] &lt; sz[qRoot]) &#123;<br>        parent[pRoot] = qRoot;<br>        sz[qRoot] += sz[pRoot];<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        parent[qRoot] = pRoot;<br>        sz[pRoot] += sz[qRoot];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="思路2：记录没棵树的深度"><a href="#思路2：记录没棵树的深度" class="headerlink" title="思路2：记录没棵树的深度"></a>思路2：记录没棵树的深度</h4><p>思路1的主要漏洞在于节点个数多的树未必深度大，因此可以通过记录树的深度来进行判断，代码逻辑如下（rank[i]表示以i为根的集合的层数）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pRoot = getID(p);<br>    <span class="hljs-keyword">int</span> qRoot = getID(q);<br><br>    <span class="hljs-keyword">if</span>(pRoot == qRoot)<br>        <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-keyword">if</span>(rank[pRoot] &lt; rank[qRoot]) &#123;<br>        parent[pRoot] = qRoot;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(rank[qRoot] &lt; rank[pRoot])&#123;<br>        parent[qRoot] = pRoot;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        parent[pRoot] = qRoot;<br>        rank[qRoot]++;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="思路3：路径压缩（Path-Compression）"><a href="#思路3：路径压缩（Path-Compression）" class="headerlink" title="思路3：路径压缩（Path Compression）"></a>思路3：路径压缩（Path Compression）</h4><p>使用<code>parent[p] = parent[parent[p]]</code>这种逻辑在每次获取根节点时将树的高度缩减。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getID</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p &lt; <span class="hljs-number">0</span> || p &gt;= parent.length)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"p is out of bound"</span>);<br>    <span class="hljs-keyword">while</span> (p != parent[p]) &#123;<br>        parent[p] = parent[parent[p]];  <span class="hljs-comment">// 路径压缩</span><br>        p = parent[p];<br>    &#125;<br>    <span class="hljs-keyword">return</span> p;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用递归直接将，每个元素直接连接在集合的根节点上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getID2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (p &lt; <span class="hljs-number">0</span> || p &gt;= parent.length)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"p is out of bound"</span>);<br>    <span class="hljs-keyword">if</span>(p != parent[p]) &#123;<br>        parent[p] = getID2(p);<br>    &#125;<br>    <span class="hljs-keyword">return</span> parent[p];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/page/ds-segment-tree.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>线段树，也叫区间树，是一个完全二叉树，它在各个节点保存一条线段（即“子数组”），因而常用于解决<strong>数列维护问题</strong>，它基本能保证每个操作的复杂度为O(lgN)。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1、线段树是一棵高度平衡的二叉树，通常为完全二叉树（叶子节点不一定在同一层，但可以通过将最后一层非叶子节点的值视为null进行构造）</p>
<p>2、线段树的每一个结点都代表一个区间。父结点所代表的区间是两个子结点的和（或者其他操作，可以自己定义）。兄弟结点所代表的区间相互不重叠。根结点代表整个区间</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>线段树是一种基于分治算法的二叉树。每个结点维护一个区间，以及在该区间内的数据信息。在当前结点，它的区间是[left,right]，则它的两个子结点的区间分别为[left, mid]，[mid+1, right]。由于采用了分治的思想，在进行操作时每一层至多访问两个结点，极大优化了效率。</p>
<p>同时，根据完全二叉树的规律，<strong>如果原始数组有n个元素，则要使用数组对线段树进行存储的话，需要4n的空间</strong>。</p>
<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><p>1、构造线段树</p>
<p>2、区间查询</p>
<p>3、区间修改</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>1、构造用于定义线段树计算方法的接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Merger</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-function">E <span class="hljs-title">merge</span><span class="hljs-params">(E a, E b)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、线段树类的基本实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SegmentTree</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> E[] tree;	<span class="hljs-comment">// 存储线段树</span><br>    <span class="hljs-keyword">private</span> E[] data;	<span class="hljs-comment">// 存储原始数据</span><br>    <span class="hljs-keyword">private</span> Merger&lt;E&gt; merger;	<span class="hljs-comment">// 定义线段树计算方法</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SegmentTree</span><span class="hljs-params">(E[] arr, Merger&lt;E&gt; merger)</span> </span>&#123;<br><br>        <span class="hljs-keyword">this</span>.merger = merger;<br><br>        data = (E[])<span class="hljs-keyword">new</span> Object[arr.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; arr.length; i++) &#123;<br>            data[i] = arr[i];<br>        &#125;<br><br>        tree = (E[])<span class="hljs-keyword">new</span> Object[<span class="hljs-number">4</span> * arr.length];<br>        buildSegmentTree(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, data.length-<span class="hljs-number">1</span>);	<span class="hljs-comment">// 构造线段树</span><br><br>    &#125;<br><br>	<span class="hljs-comment">// 获取左孩子索引</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leftChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">1</span>;<br>    &#125;<br>	<br>	<span class="hljs-comment">// 获取右孩子索引</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rightChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span> * index + <span class="hljs-number">2</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="构造线段树"><a href="#构造线段树" class="headerlink" title="构造线段树"></a>构造线段树</h3><p>使用递归构造线段树，整个过程有点像使用一个有序数组构造二叉搜索树。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSegmentTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span> treeIndex, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l == r) &#123;<br>        tree[treeIndex] = data[l];<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> leftTreeIndex = leftChild(treeIndex);<br>    <span class="hljs-keyword">int</span> rightTreeIndex = rightChild(treeIndex);<br>    <span class="hljs-keyword">int</span> mid = l + (r - l) / <span class="hljs-number">2</span>;<br>    buildSegmentTree(leftTreeIndex, l, mid);<br>    buildSegmentTree(rightTreeIndex, mid+<span class="hljs-number">1</span>, r);<br>    tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p>也是使用递归进行查询，分三种情况进行讨论。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回[queryL, queryR]的值</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> queryL, <span class="hljs-keyword">int</span> queryR)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(queryL &lt; <span class="hljs-number">0</span> || queryL &gt;= data.length ||<br>        queryR &lt; <span class="hljs-number">0</span> || queryR &gt;= data.length || queryL &gt; queryR) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Index is illegal"</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> query(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, data.length-<span class="hljs-number">1</span>, queryL, queryR);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> E <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-keyword">int</span> treeIndex, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> queryL, <span class="hljs-keyword">int</span> queryR)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l == queryL &amp;&amp; r == queryR) &#123;<br>        <span class="hljs-keyword">return</span> tree[treeIndex];<br>    &#125;<br>    <span class="hljs-keyword">int</span> mid = l+(r-l)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> leftTreeIndex = leftChild(treeIndex);<br>    <span class="hljs-keyword">int</span> rightTreeIndex = rightChild(treeIndex);<br>    <span class="hljs-keyword">if</span>(queryL &gt;= mid + <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> query(rightTreeIndex, mid+<span class="hljs-number">1</span>, r, queryL, queryR);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(queryR &lt;= mid) &#123;<br>        <span class="hljs-keyword">return</span> query(leftTreeIndex, l, mid, queryL, queryR);<br>    &#125;<br>    E leftResult = query(leftTreeIndex, l, mid, queryL, mid);<br>    E rightResult = query(rightTreeIndex, mid+<span class="hljs-number">1</span>, r, mid+<span class="hljs-number">1</span>, queryR);<br>    <span class="hljs-keyword">return</span> merger.merge(leftResult, rightResult);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将index位置的值，更新为e</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt;= data.length)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Index is illegal"</span>);<br>    data[index] = e;<br>    set(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, data.length-<span class="hljs-number">1</span>, index, e);<br>&#125;<br><br><span class="hljs-comment">// 在以treeIndex为根的线段树中更新index的值为e</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-keyword">int</span> treeIndex, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> r, <span class="hljs-keyword">int</span> index, E e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(l == r) &#123;<br>        tree[treeIndex] = e;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> mid = l + (r-l)/<span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">int</span> leftTreeIndex = leftChild(treeIndex);<br>    <span class="hljs-keyword">int</span> rightTreeIndex = rightChild(treeIndex);<br>    <span class="hljs-keyword">if</span>(index &gt;= mid+<span class="hljs-number">1</span>)<br>        set(rightTreeIndex, mid+<span class="hljs-number">1</span>, r, index, e);<br>    <span class="hljs-keyword">else</span><br>        set(leftTreeIndex, l, mid, index, e);<br>    tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]);<br>&#125;<br></code></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>JS01-3：类与对象</title>
    <url>/page/js-class-object.html</url>
    <content><![CDATA[<h2 id="创建自定义对象"><a href="#创建自定义对象" class="headerlink" title="创建自定义对象"></a>创建自定义对象</h2><h3 id="使用键值对创建"><a href="#使用键值对创建" class="headerlink" title="使用键值对创建"></a>使用键值对创建</h3><p>举例如下</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">var</span> obj1 = &#123;<br>	<span class="hljs-comment">// 成员</span><br>	name: <span class="hljs-string">"ziye"</span>,<br>	<span class="hljs-comment">// 嵌套的对象</span><br>	obj2: &#123;<br>		name: <span class="hljs-string">"gg"</span><br>	&#125;<br>	<span class="hljs-comment">// 方法</span><br>	func1: <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123;<br>		alert(<span class="hljs-string">"gg"</span>)<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>即<strong>使用一个函数将创建好的对象作为返回值</strong>，举例如下</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createObj</span>(<span class="hljs-params">name</span>) </span>&#123;<br>	<span class="hljs-comment">// 创建一个对象</span><br>	<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>	<span class="hljs-comment">// 向对象中添加属性</span><br>	obj.name = name;<br>	obj.func = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>		alert(<span class="hljs-keyword">this</span>.name);<br>	&#125;<br>	<span class="hljs-comment">// 将创建的对象返回</span><br>	<span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>是一种特殊的函数，主要用来创建和初始化对象，也就是为对象的成员变量赋初始值。它与 <strong>new</strong> 一起使用才有意义。是js中从前最通用的构建构造函数的方法，<strong>其中this指的是当前对象的实例</strong></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Obj</span><span class="hljs-params">(name)</span> </span>&#123;<br>	<span class="hljs-keyword">this</span>.name = name;<br>	<span class="hljs-keyword">this</span>.func = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> </span>&#123;<br>		alert(<span class="hljs-keyword">this</span>.name);<br>	&#125;;<br>&#125;<br><br><span class="hljs-keyword">var</span> o1 = <span class="hljs-keyword">new</span> Obj(<span class="hljs-string">"xxx"</span>);<br></code></pre></td></tr></table></figure>

<h2 id="JS原型对象（prototype）"><a href="#JS原型对象（prototype）" class="headerlink" title="JS原型对象（prototype）"></a>JS原型对象（prototype）</h2><p>所有的 JavaScript 对象都会从一个 prototype（原型对象）中继承属性和方法。</p>
<h3 id="添加属性和方法"><a href="#添加属性和方法" class="headerlink" title="添加属性和方法"></a>添加属性和方法</h3><figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Obj</span>.proto<span class="hljs-keyword">type</span>.attr = newValue;<br><span class="hljs-type">Obj</span>.proto<span class="hljs-keyword">type</span>.func = function() &#123;&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>2.1、JS事件处理</title>
    <url>/page/js-event-handle.html</url>
    <content><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件指的是一些特定的交互瞬间，如点击某个元素等等</p>
<p>JavaScript 是以<strong>事件驱动为核心</strong>的一门语言。JavaScript 与 HTML 之间的交互是通过事件实现的。</p>
<h3 id="事件的基本要素"><a href="#事件的基本要素" class="headerlink" title="事件的基本要素"></a>事件的基本要素</h3><ul>
<li><p>事件源：引发后续事件的html标签。</p>
</li>
<li><p>事件：js中已经定义好了（见下图）。</p>
</li>
<li><p>事件驱动程序：对样式和html的操作。也就是DOM。</p>
</li>
</ul>
<p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/js%E4%BA%8B%E4%BB%B6.png" alt=""></p>
<h3 id="事件程序的基本书写"><a href="#事件程序的基本书写" class="headerlink" title="事件程序的基本书写"></a>事件程序的基本书写</h3><h4 id="1、获取事件源"><a href="#1、获取事件源" class="headerlink" title="1、获取事件源"></a>1、获取事件源</h4><p>详见DOM操作中的相关操作，主要有<code>document.getElementById()</code>等方法</p>
<h4 id="2、绑定事件"><a href="#2、绑定事件" class="headerlink" title="2、绑定事件"></a>2、绑定事件</h4><p>以onclick事件为例：</p>
<p><strong>方法1（绑定匿名函数）：</strong></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">element.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>方法2（addEventListener）：</strong></p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript">element.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">()</span> </span>&#123;<br><br>&#125;, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li><p>参数1：事件名的字符串(注意，没有on)</p>
</li>
<li><p>参数2：回调函数：当事件触发时，该函数会被执行</p>
</li>
<li><p>参数3：<strong>true表示捕获阶段触发，false表示冒泡阶段触发（默认）</strong>。如果不写，则默认为false。【重要】</p>
</li>
</ul>
<p><strong>方法3（行内绑定）：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--行内绑定--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"box1"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"fn()"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="actionscript"><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span><span class="hljs-params">()</span> </span>&#123;<br>        alert(<span class="hljs-string">"我是弹出的内容"</span>);<br>    &#125;<br></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>





<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>当事件的响应函数被触发时，会产生一个事件对象<code>event</code>。浏览器每次都会将这个事件<code>event</code>作为实参传进之前的响应函数。</p>
<p>这个对象中包含了与当前事件相关的一切信息。比如鼠标的坐标、键盘的哪个按键被按下、鼠标滚轮滚动的方向等。</p>
<p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/event%E4%BF%A1%E6%81%AF.png" alt=""></p>
<h3 id="获取event对象"><a href="#获取event对象" class="headerlink" title="获取event对象"></a>获取event对象</h3><p>除去以上直接使用event外，标准兼容写法如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><br>    <span class="hljs-comment">//点击页面的任何部分</span><br>    <span class="hljs-built_in">document</span>.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>        event = event || <span class="hljs-built_in">window</span>.event; <span class="hljs-comment">//兼容性写法</span><br>    &#125;<br></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="event属性"><a href="#event属性" class="headerlink" title="event属性"></a>event属性</h3><p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/event%E5%B1%9E%E6%80%A7.png" alt=""></p>
<p>除此之外，还有以下等信息：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">keyCode</span>	<span class="hljs-comment">// 返回响应的键盘信息</span><br></code></pre></td></tr></table></figure>





<h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>事件传播的三个阶段是：事件捕获、事件冒泡和目标。</p>
<ul>
<li>事件捕获阶段：事件从祖先元素往子元素查找（DOM树结构），直到捕获到事件目标 target。在这个过程中，默认情况下，事件相应的监听函数是不会被触发的。</li>
<li>事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。</li>
<li>事件冒泡阶段：事件从事件目标 target 开始，从子元素往冒泡祖先元素冒泡，直到页面的最上一级标签。</li>
</ul>
<p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%86%92%E6%B3%A1.png" alt=""></p>
<h3 id="捕获与冒泡实验"><a href="#捕获与冒泡实验" class="headerlink" title="捕获与冒泡实验"></a>捕获与冒泡实验</h3><p>addEventListener函数最后一个参数为true代表事件在捕获阶段执行，为false代表在冒泡阶段进行</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>click here<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><br>        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"div"</span>)[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">var</span> p = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"p"</span>)[<span class="hljs-number">0</span>];<br>        div.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"div"</span>);<br>        &#125;, <span class="hljs-literal">true</span>);<br>        p.addEventListener(<span class="hljs-string">"click"</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"p"</span>);<br>        &#125;, <span class="hljs-literal">true</span>);<br>    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>实验结果</strong></p>
<p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/%E5%86%92%E6%B3%A1%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C.png" alt=""></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>JS01-2：内置对象使用</title>
    <url>/page/js-buildin-obj.html</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组（Array）是内置对象（typeof返回值为object）。数组中的元素可以是任意的数据类型，也可以是对象，也可以是函数，也可以是数组</p>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> arr = [];<br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>();	<span class="hljs-comment">// 创建一个空数组</span><br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>(<span class="hljs-number">2</span>);	<span class="hljs-comment">// 创建一个长度为2的数组</span><br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-type">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)	<span class="hljs-comment">// 创建一个经过初始化的数组</span><br></code></pre></td></tr></table></figure>

<h3 id="元素的添加与删除"><a href="#元素的添加与删除" class="headerlink" title="元素的添加与删除"></a>元素的添加与删除</h3><p>在最后添加与删除（<strong>push  pop</strong>）</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-comment">// 向数组后插入一个或多个元素</span><br>新数组长度 = 数组.<span class="hljs-keyword">push</span>(元素);<br><br><span class="hljs-comment">// 删除数组中最后一个元素</span><br>被删除的元素 = 数组.<span class="hljs-keyword">pop</span>();<br></code></pre></td></tr></table></figure>

<p>在最前添加与删除（<strong>unshift  shift</strong>）</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">新数组的长度 = 数组.unshift(元素)<span class="hljs-comment">;</span><br><br>被删除的元素 = 数组.shift()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="数组的合并与拆分"><a href="#数组的合并与拆分" class="headerlink" title="数组的合并与拆分"></a>数组的合并与拆分</h3><p>数组的合并（使用cancat函数或使用…语法）</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 连接数组1和作为参数的数组</span><br>新数组 = 数组<span class="hljs-number">1.</span>concat(数组<span class="hljs-number">2</span>, 数组<span class="hljs-number">3</span> ...);<br></code></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br>b = [<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,...a]<br>alert(b)	<span class="hljs-comment">// [3,4,5,1,2,3]</span><br></code></pre></td></tr></table></figure>



<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">// 颠倒数组</span><br><span class="hljs-keyword">array</span>.reverse()	<br><br><span class="hljs-comment">// 对数组进行排序（默认升序）</span><br><span class="hljs-keyword">array</span>.sort()<br><br><span class="hljs-comment">// 传入比较函数，变为降序</span><br><span class="hljs-comment">// 作为参数的函数返回值大于0，则元素会交换位置</span><br><span class="hljs-keyword">array</span>.sort(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span> <span class="hljs-comment">&#123;return b-a&#125;</span>)<br><span class="hljs-title">array</span>.<span class="hljs-title">slice</span><span class="hljs-params">(start, <span class="hljs-keyword">end</span>)</span>	<span class="hljs-comment">// 从[start, end)的切片</span></span><br></code></pre></td></tr></table></figure>



<p>转化为字符串，默认无参数则用逗号“,”连接。</p>
<figure class="highlight lasso"><table><tr><td class="code"><pre><code class="hljs lasso">str = <span class="hljs-built_in">array</span>.<span class="hljs-keyword">join</span>()<br>str = <span class="hljs-built_in">array</span>.<span class="hljs-keyword">join</span>(<span class="hljs-string">""</span>)	<span class="hljs-comment">// 无连接符号直接连接</span><br></code></pre></td></tr></table></figure>



<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">// 删除从<span class="hljs-keyword">index</span>处开始的零个或多个元素<br><span class="hljs-keyword">array</span>.splice(<span class="hljs-keyword">index</span>, <span class="hljs-built_in">count</span>)<br>// 在<span class="hljs-keyword">index</span>后插入值<br><span class="hljs-keyword">array</span>.splice(<span class="hljs-keyword">index</span>, <span class="hljs-number">0</span>, item1.....)<br>// 替换<br><span class="hljs-keyword">array</span>.splice(<span class="hljs-keyword">index</span>, <span class="hljs-built_in">count</span>, item1.....)<br></code></pre></td></tr></table></figure>

<h3 id="元素的查找"><a href="#元素的查找" class="headerlink" title="元素的查找"></a>元素的查找</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 查找值为value的索引，没有则返回-1</span><br>array.indexOf(value)<br><br><span class="hljs-comment">// 找出第一个满足「指定条件返回 true」的元素</span><br><span class="hljs-function"><span class="hljs-title">find</span><span class="hljs-params">(func)</span></span><br><br><span class="hljs-comment">// 找出第一个满足「指定条件返回 true」的元素的 index</span><br><span class="hljs-function"><span class="hljs-title">findIndex</span><span class="hljs-params">(func)</span></span><br></code></pre></td></tr></table></figure>



<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>Math 和其他的对象不同，它不是一个构造函数，不需要创建对象。所以我们不需要 通过 new 来调用，而是<strong>直接使用里面的属性和方法</strong>即可（数学工具类）。</p>
<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Math.PI</td>
<td align="left">圆周率</td>
<td align="left">Math对象的属性</td>
</tr>
<tr>
<td align="left">Math.abs()</td>
<td align="left"><strong>返回绝对值</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Math.random()</td>
<td align="left">生成0-1之间的<strong>随机浮点数</strong></td>
<td align="left">取值范围是 [0，1)</td>
</tr>
<tr>
<td align="left">Math.floor()</td>
<td align="left"><strong>向下取整</strong>（往小取值）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Math.ceil()</td>
<td align="left"><strong>向上取整</strong>（往大取值）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Math.round()</td>
<td align="left">四舍五入取整（正数四舍五入，负数五舍六入）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Math.max(x, y, z)</td>
<td align="left">返回多个数中的最大值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Math.min(x, y, z)</td>
<td align="left">返回多个数中的最小值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Math.pow(x,y)</td>
<td align="left">乘方：返回 x 的 y 次幂</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Math.sqrt()</td>
<td align="left">开方：对一个数进行开方运算</td>
<td align="left"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>DS07:堆与优先队列</title>
    <url>/page/priority-queue-and-heap.html</url>
    <content><![CDATA[<h2 id="堆的基本概念"><a href="#堆的基本概念" class="headerlink" title="堆的基本概念"></a>堆的基本概念</h2><p>堆（二叉堆）就是用数组实现的二叉树（完全二叉树），所以它没有使用父指针或者子指针。堆根据“堆属性”来排序，“堆属性”决定了树中节点的位置。</p>
<h3 id="堆的用处"><a href="#堆的用处" class="headerlink" title="堆的用处"></a>堆的用处</h3><ul>
<li>构建优先队列</li>
<li>支持堆排序（O(n log n)）</li>
<li>快速找出一个集合中的最小值（或者最大值）</li>
</ul>
<h3 id="堆属性"><a href="#堆属性" class="headerlink" title="堆属性"></a>堆属性</h3><p>堆可以分为最大堆与最小堆等等，差别只在于节点的排序方法。</p>
<p>以最大堆为例，<strong>堆中某个节点的值总是不大于其父亲节点的值</strong> 。也就是说，最大堆总将最大的值放在树的根节点（也就是数组索引为0的位置）。根据堆的这一特性，堆能够作为优先队列的实现。</p>
<blockquote>
<p><strong>注意：</strong>堆的根节点中存放的是最大或者最小元素，但是其他节点的排序顺序是未知的。例如，在一个最大堆中，最大的那一个元素总是位于 index 0 的位置，但是最小的元素则未必是最后一个元素。–唯一能够保证的是最小的元素是一个叶节点，但是不确定是哪一个。</p>
</blockquote>
<h3 id="堆与普通树的区别"><a href="#堆与普通树的区别" class="headerlink" title="堆与普通树的区别"></a>堆与普通树的区别</h3><p><strong>节点的顺序。</strong>在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。<strong>且以最大堆举例，最下层的节点值未必一定小于上层节点的值</strong></p>
<p><strong>内存占用。</strong>普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配内存。<strong>堆仅仅使用一个数组来存储数据</strong>，且不使用指针。</p>
<p><strong>平衡。</strong>二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到<strong>O(log n)</strong>。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足堆属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证<strong>O(log n)</strong> 的性能。</p>
<p><strong>搜索。</strong>在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。</p>
<h2 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h2><h3 id="实现基础"><a href="#实现基础" class="headerlink" title="实现基础"></a>实现基础</h3><p>堆的底层可以使用动态数组进行实现，由于完全二叉树的特性，按照层序遍历对二叉树进行存储时父节点与子节点之间有以下的规律：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">parent = i/<span class="hljs-number">2</span>	<span class="hljs-comment">// i为子节点在数组中的索引</span><br><br>leftChild = <span class="hljs-number">2</span> * i + <span class="hljs-number">1</span>	<span class="hljs-comment">// i为父节点</span><br><br>rightChild = <span class="hljs-number">2</span> * i+ <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>因此可基于之前实现的动态数组进行最大堆的基本实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MaxHeap</span>&lt;<span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> Array&lt;E&gt; data;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxHeap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> Array&lt;&gt;(capacity);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxHeap</span><span class="hljs-params">()</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> Array&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxHeap</span><span class="hljs-params">(E[] arr)</span> </span>&#123;<br>        data = <span class="hljs-keyword">new</span> Array&lt;&gt;(arr);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=parent(arr.length - <span class="hljs-number">1</span>); i&gt;=<span class="hljs-number">0</span>; i--) &#123;<br>            siftDown(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data.getSize();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data.isEmpty();<br>    &#125;<br><br>	<span class="hljs-comment">// 获得父节点索引</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">parent</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(index == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Index 0 has no parent"</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> (index - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    &#125;<br><br>	<span class="hljs-comment">// 获得左子节点索引</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">leftChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> index * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>    &#125;<br><br>	<span class="hljs-comment">// 获得右子节点索引</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">rightChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> index * <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>向堆中添加元素首先将元素添加到数组最后，之后进行<strong>堆的上浮</strong>操作。</p>
<p>即当该元素的父节点值 &lt; 该元素值时：将这两个元素进行交换，知道到达根节点或不满足该条件。详见代码，复杂度为<strong>O(log n)</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 添加元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    data.addLast(e);<br>    shiftUp(data.getSize() - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 堆的上浮</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shiftUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span> &amp;&amp; data.get(parent(k)).compareTo(data.get(k)) &lt; <span class="hljs-number">0</span> ) &#123;<br>        data.swap(k, parent(k));<br>        k = parent(k);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="取出堆中最大元素"><a href="#取出堆中最大元素" class="headerlink" title="取出堆中最大元素"></a>取出堆中最大元素</h3><p>将第一个元素取出后，将最后一个元素放入根节点的位置（即将索引为0 与 索引为 size-1的元素互换），再进行<strong>堆的下沉</strong>的操作。</p>
<p>堆的下沉即为，如果当前节点小于其子节点中最大的那个，则将其替换。详见代码，复杂度为<strong>O(log n)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 返回堆中最大元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">findMax</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(data.getSize() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"heap is empty"</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> data.getFirst();<br>&#125;<br><br><span class="hljs-comment">// 取出堆中最大元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">extractMax</span><span class="hljs-params">()</span> </span>&#123;<br>    E ret = findMax();<br>    data.swap(<span class="hljs-number">0</span>, data.getSize()-<span class="hljs-number">1</span>);<br>    data.removeLast();<br>    siftDown(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">// 堆的下浮</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">siftDown</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (leftChild(k) &lt; data.getSize()) &#123;<br>        <span class="hljs-keyword">int</span> maxChild = leftChild(k);<br>        <span class="hljs-keyword">if</span>(maxChild +<span class="hljs-number">1</span> &lt; data.getSize() &amp;&amp; data.get(maxChild +<span class="hljs-number">1</span>).compareTo(data.get(maxChild)) &gt; <span class="hljs-number">0</span>) &#123;<br>            maxChild++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(data.get(k).compareTo(data.get(maxChild)) &gt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        data.swap(k, maxChild);<br>        k = maxChild;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="将输入数组变为堆（heapify）"><a href="#将输入数组变为堆（heapify）" class="headerlink" title="将输入数组变为堆（heapify）"></a>将输入数组变为堆（heapify）</h3><p>将输入数组变为堆结构，首先找到最后一个非叶子节点（即最后一个叶子节点的父节点），之后向前遍历，并分别进行下沉操作，如代码所示（作为maxHeap类的构造函数）</p>
<p>这样做的好处是时间复杂度只有O(n)，而将数组元素分别插入进堆的时间复杂度为O(n log n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MaxHeap</span><span class="hljs-params">(E[] arr)</span> </span>&#123;<br>    data = <span class="hljs-keyword">new</span> Array&lt;&gt;(arr);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=parent(arr.length - <span class="hljs-number">1</span>); i&gt;=<span class="hljs-number">0</span>; i--) &#123;<br>        siftDown(i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>优先队列也就是优先级最大的元素在队首的队列了，显而易见，其可以使用堆轻松实现，下面是简单的最大值在前的优先队列。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityQueue</span>&lt;<span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">E</span>&gt;&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> MaxHeap&lt;E&gt; maxHeap;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PriorityQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        maxHeap = <span class="hljs-keyword">new</span> MaxHeap&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> maxHeap.size();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> maxHeap.isEmpty();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        maxHeap.add(e);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> maxHeap.extractMax();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getFront</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> maxHeap.findMax();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://www.jianshu.com/p/6b526aa481b1" target="_blank" rel="noopener">https://www.jianshu.com/p/6b526aa481b1</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>JS01：语言基础</title>
    <url>/page/js-basic-grammer.html</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h3><p>1、解释性语言</p>
<p>2、单线程</p>
<p>3、遵从ECMAScript标准</p>
<p>对换行、缩进、空格不敏感。每一条语句以分号结尾。（分号不是必须加，如果不写分号，浏览器会自动添加，但是会消耗一些系统资源）</p>
<h3 id="JavaScript组成"><a href="#JavaScript组成" class="headerlink" title="JavaScript组成"></a>JavaScript组成</h3><p>JavaScript基础分为三个部分：</p>
<ul>
<li><p><strong>ECMAScript</strong>：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。</p>
</li>
<li><p><strong>DOM</strong>：文档对象模型（Document object Model），操作<strong>网页上的元素</strong>的API。比如让盒子移动、变色、轮播图等。</p>
</li>
<li><p><strong>BOM</strong>：浏览器对象模型（Browser Object Model），操作<strong>浏览器部分功能</strong>的API。比如让浏览器自动滚动。</p>
</li>
</ul>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>JavaScript中的输入输出主要用于调试</p>
<p>1、弹出警告框：<strong>alert(“str”)</strong></p>
<p>2、控制台输出：<strong>console.log(“str”)</strong></p>
<p>3、弹出输入框：<strong>var a = prompt(“str”)</strong></p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="变量基本类型"><a href="#变量基本类型" class="headerlink" title="变量基本类型"></a>变量基本类型</h3><p>ES6前，使用<code>var</code>关键字来声明一个变量</p>
<p><strong>JS中一共有六种数据类型：</strong></p>
<ul>
<li><strong>基本数据类型（值类型，传值）</strong>：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。</li>
<li><strong>引用数据类型（引用类型，传址）</strong>：Object 对象（除去五种基本数据类型之外，其他的，都称之为 Object类型）。</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>JS中运算符比较特殊的是<code>==</code>与<code>===</code>。</p>
<p>其中，<code>==</code>这个符号会自动进行隐式转换，将不同的数据类型，转为相同类型进行比较（大部分情况下，都是转换为数字）。而<code>===</code>这个符号在进行比较时不会进行类型转换，是绝对等于。</p>
<h3 id="debug方法"><a href="#debug方法" class="headerlink" title="debug方法"></a>debug方法</h3><p>JavaScript程序中添加断点，使用debugger。示例如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">&lt;script&gt;<br>    var a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>];<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>        console.log(a[i]);<br>        debugger;<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<p>刷新Google页面即可进行debug</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Java09：泛型</title>
    <url>/page/Java-generic.html</url>
    <content><![CDATA[<h1 id="泛型基础"><a href="#泛型基础" class="headerlink" title="泛型基础"></a>泛型基础</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>泛型的本质是<strong>参数化类型</strong>，也就是说所操作的数据类型被指定为一个参数。</p>
<p>Java的泛型是<strong>伪泛型</strong>，这是因为Java在编译期间，所有的泛型信息都会被擦掉</p>
<p>Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为<strong>类型擦除</strong>。</p>
<p>如在代码中定义<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译后都会变成<code>List</code>，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法在运行时刻出现的类型转换异常的情况，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。</p>
<h2 id="三种主要使用形式"><a href="#三种主要使用形式" class="headerlink" title="三种主要使用形式"></a>三种主要使用形式</h2><p>引入类型可以用来修饰成员变量/局部变量/参数/返回值</p>
<p>注：变量声明的类型必须匹配传递给实际对象的类型（即前后尖括号中的内容必须相同）</p>
<h3 id="1、泛型类"><a href="#1、泛型类" class="headerlink" title="1、泛型类"></a>1、泛型类</h3><blockquote>
<p>常见的如<code>ArrayList</code>、<code>HashSet</code>、<code>HashMap</code>等等</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class="hljs-comment">// 在实例化泛型类时，必须指定T的具体类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span>&lt;T&gt;&#123;</span> <br>   <br>    <span class="hljs-keyword">private</span> T key;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Generic</span><span class="hljs-params">(T key)</span> </span>&#123; <br>        <span class="hljs-keyword">this</span>.key = key;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getKey</span><span class="hljs-params">()</span></span>&#123; <br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2、泛型接口"><a href="#2、泛型接口" class="headerlink" title="2、泛型接口"></a>2、泛型接口</h3><blockquote>
<p>实现泛型的接口，如<code>Iterator</code>、<code>List</code>等即为泛型接口</p>
</blockquote>
<p><strong>泛型接口定义</strong></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>Generator&lt;T&gt; &#123;<br>    public T method();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="实现时不指定类型"><a href="#实现时不指定类型" class="headerlink" title="实现时不指定类型"></a>实现时不指定类型</h4><figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">GeneratorImpl</span>&lt;<span class="hljs-symbol">T</span>&gt; <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Generator</span>&lt;<span class="hljs-symbol">T</span>&gt;&#123;<br>    @Override<br>    <span class="hljs-keyword">public</span> T method() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="实现时指定类型"><a href="#实现时指定类型" class="headerlink" title="实现时指定类型"></a>实现时指定类型</h4><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs \">class GeneratorImpl&lt;T&gt; implements Generator&lt;String&gt;&#123;<br>    @Override<br>    public String method() &#123;<br>        return &quot;hello&quot;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="3、泛型方法"><a href="#3、泛型方法" class="headerlink" title="3、泛型方法"></a>3、泛型方法</h3><blockquote>
<p>具有泛型参数的方法，可位于普通类/泛型类中（<strong>泛型方法不一定要写在泛型类当中</strong>）</p>
<p>如<code>Arrays.sort()</code>等方法即是泛型方法</p>
<p>泛型参数&lt;T&gt;在修饰符后，返回类型前，如下示例</p>
<p>若传入参数不统一会寻找共同的<em>超类</em>，一般应该统一参数</p>
</blockquote>
<h4 id="泛型方法定义"><a href="#泛型方法定义" class="headerlink" title="泛型方法定义"></a>泛型方法定义</h4><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">( E[] inputArray )</span><br></span>&#123;         <br>	<span class="hljs-keyword">for</span> ( E element : inputArray )&#123;        <br>    	System.out.<span class="hljs-built_in">printf</span>( <span class="hljs-string">"%s "</span>, element );<br>    &#125;<br>        System.out.<span class="hljs-built_in">println</span>();<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="泛型方法调用"><a href="#泛型方法调用" class="headerlink" title="泛型方法调用"></a>泛型方法调用</h4><figure class="highlight oxygene"><table><tr><td class="code"><pre><code class="hljs oxygene">Target t = <span class="hljs-keyword">new</span> Target();<br>String s = t.&lt;String&gt;<span class="hljs-function"><span class="hljs-keyword">method</span><span class="hljs-params">()</span>;</span>	<span class="hljs-comment">// 调用时不省略泛型</span><br>String s = t<span class="hljs-function">.<span class="hljs-keyword">method</span><span class="hljs-params">()</span>;</span>	<span class="hljs-comment">// 调用时省略泛型</span><br></code></pre></td></tr></table></figure>



<h1 id="泛型限定"><a href="#泛型限定" class="headerlink" title="泛型限定"></a>泛型限定</h1><h2 id="泛型通配符"><a href="#泛型通配符" class="headerlink" title="泛型通配符"></a>泛型通配符</h2><h3 id="常用通配符"><a href="#常用通配符" class="headerlink" title="常用通配符"></a>常用通配符</h3><blockquote>
<p><strong>常用的有： T，E，K，V，？</strong>（通常只将?视为通配符）</p>
<p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。</p>
</blockquote>
<ul>
<li>？ 表示不确定的 Java类型</li>
<li>T (Template) 表示具体的一个Java类型，自定义泛型常用T</li>
<li>K V (Key Value) 分别代表Java键值中的Key Value</li>
<li>E (Element) 代表元素Element</li>
</ul>
<h3 id="上界通配符"><a href="#上界通配符" class="headerlink" title="上界通配符"></a>上界通配符</h3><p><code>&lt;? extends 类名&gt;</code>：表示能接受的参数类型可能是<em>所指定的类型本身，或者是此类型的子类</em></p>
<blockquote>
<p>使用上界通配符，编译器能够保证取出来的类型一定是指定类型的子类，但不保证放入的对象是什么类型</p>
<p>所以<strong>只能进行<code>get</code>操作，而不能进行<code>set</code>操作</strong></p>
</blockquote>
<p>举例说明：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe">Pair&lt;Apple&gt; apples = <span class="hljs-keyword">new</span> <span class="hljs-type">Pair</span>&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-type">Apple</span>(<span class="hljs-number">3</span>));<br>Pair&lt;? extends Fruit&gt; fruit = apples;<br>fruit.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">new</span> <span class="hljs-type">Orange</span>(<span class="hljs-number">3</span>));	<span class="hljs-comment">// 编译错误</span><br></code></pre></td></tr></table></figure>

<h3 id="下界通配符"><a href="#下界通配符" class="headerlink" title="下界通配符"></a>下界通配符</h3><p><code>&lt; ? super 类名&gt;</code>：表示参数化的类型可能是<em>所指定的类型本身，或者是此类型的父类型，直至 Object</em></p>
<blockquote>
<p>编译器能保证放入的是其本身或其超类（传入子类时进行类型转换），但无法保证取出的是哪个类。</p>
<p>所以<strong>只能进行<code>set</code>操作，而不能进行<code>get</code>操作</strong></p>
</blockquote>
<h3 id="泛型PECS原则"><a href="#泛型PECS原则" class="headerlink" title="泛型PECS原则"></a>泛型PECS原则</h3><blockquote>
<p>Producer Extends 泛型是生产者，向外输出，使用<code>Extends</code></p>
</blockquote>
<blockquote>
<p>Consumer Super 泛型是消费者，向内增加东西，使用<code>Super</code></p>
</blockquote>
<h3 id="？和T的区别"><a href="#？和T的区别" class="headerlink" title="？和T的区别"></a>？和T的区别</h3><blockquote>
<p><code>T</code>是一个<strong>确定</strong>的类型，而<code>?</code>是一个不确定的类型</p>
<p>可以对<code>T</code>进行操作，而不能对<code>?</code>进行操作</p>
</blockquote>
<h3 id="extends关键字"><a href="#extends关键字" class="headerlink" title="extends关键字"></a>extends关键字</h3><blockquote>
<p>使用<code>extends</code>关键字约定该类型必须是某某的<em>子类</em></p>
</blockquote>
<p>如<code>&lt;T extends Comparable&gt;</code>约定T必须是<code>Comparable</code>的子类</p>
<p><code>extends</code>后可跟多个，<strong>以<code>&amp;</code>拼接</strong>，同时该限定可以有多个接口，但只能有一个类，且类必须排第一位。</p>
<h3 id="泛型的类型关系"><a href="#泛型的类型关系" class="headerlink" title="泛型的类型关系"></a>泛型的类型关系</h3><blockquote>
<p>Java中的泛型是不变的，即List&lt;Object&gt;与List&lt;String&gt;并无父类与子类的关系</p>
</blockquote>
<h1 id="泛型实现的本质"><a href="#泛型实现的本质" class="headerlink" title="泛型实现的本质"></a>泛型实现的本质</h1><h2 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h2><p>泛型是JDK1.5引入的新特性，因此JVM中没有泛型对象，而是采用<strong>类型擦除</strong>技术，只有普通的类和方法</p>
<blockquote>
<p>擦除泛型对象，替换为原始类型（无限定则替换为为Object，有限定则替换为第一个类型），使得该类与引入泛型之前的类并无不同</p>
</blockquote>
<p>比如：<code>Pair&lt;T&gt;</code>则可视为<code>Pair&lt;Object&gt;</code>。因为T未指定类型</p>
<p><code>Pair&lt;T extends A &amp; B&gt;</code>则可视为<code>Pair&lt;A&gt;</code></p>
<h2 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h2><blockquote>
<p>擦除泛型后，编译时会进行自动类型转换</p>
<p>即先生成一个<code>Object</code>对象，再使用强制类型转化转换为对应的对象</p>
</blockquote>
<h2 id="自动桥方法"><a href="#自动桥方法" class="headerlink" title="自动桥方法"></a>自动桥方法</h2><blockquote>
<p>即泛型中自动生成的参数为<code>Object</code>方法会自动调用用户传入相关参数类型的对应方法</p>
</blockquote>
<blockquote>
<p>参考：</p>
<p>mooc华东师范大学：Java高级</p>
<p>类型擦除：<a href="https://www.cnblogs.com/wuqinglong/p/9456193.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuqinglong/p/9456193.html</a></p>
<p><a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9" target="_blank" rel="noopener">https://juejin.im/post/5d5789d26fb9a06ad0056bd9</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java06：异常与异常处理</title>
    <url>/page/Java-exception-handle.html</url>
    <content><![CDATA[<h2 id="异常分类"><a href="#异常分类" class="headerlink" title="异常分类"></a>异常分类</h2><h3 id="异常层次结构"><a href="#异常层次结构" class="headerlink" title="异常层次结构"></a>异常层次结构</h3><img src="http://cdn.ziyedy.top/6%E3%80%81Java%EF%BC%9A%E5%BC%82%E5%B8%B8%E4%B8%8E%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/exception-chart.png" style="zoom:67%;" />

<p> <code>java.lang</code>包中的<code>Throwable</code>类是所有异常的根类。它有两个重要的子类</p>
<p>1、<code>Error</code>。程序无法处理的错误。表示运行程序中较为严重的错误，通常是代码运行时JVM出现的问题</p>
<p>2、<code>Exception</code>。程序本身可以处理的异常。比如<code>RuntimeException</code>等等</p>
<p>除此之外，还可以分为<em>检查异常</em>与<em>非检查异常</em>。非检查异常包括Error与RuntimeException，而检查异常则包括其他相关的异常</p>
<p><strong>编译器会为检查异常配置相关处理，若没有处理会报错</strong></p>
<h3 id="Throwable-常用方法"><a href="#Throwable-常用方法" class="headerlink" title="Throwable 常用方法"></a>Throwable 常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> string <span class="hljs-title">getMessage</span><span class="hljs-params">()</span>	<span class="hljs-comment">// 返回异常发生时的简要描述</span><br><br><span class="hljs-keyword">public</span> string <span class="hljs-title">toString</span><span class="hljs-params">()</span>	<span class="hljs-comment">// 返回异常发生时的详细信息</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>	<span class="hljs-comment">// 在控制台上打印 Throwable 对象封装的异常信息</span></span><br></code></pre></td></tr></table></figure>



<h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><h3 id="try-catch-finally结构"><a href="#try-catch-finally结构" class="headerlink" title="try-catch-finally结构"></a>try-catch-finally结构</h3><ul>
<li><code>try</code>：正常业务逻辑代码</li>
<li><code>catch</code>：当<code>try</code>发生异常时执行的代码，可以有多个，从上到下进行匹配，一个异常只能进入一个<code>catch</code></li>
<li><code>finally</code>：当<code>try</code>或<code>catch</code>执行结束后必须要执行的代码块</li>
</ul>
<figure class="highlight julia"><table><tr><td class="code"><pre><code class="hljs julia"><span class="hljs-keyword">try</span> &#123;<br><br>&#125; <span class="hljs-keyword">catch</span>(<span class="hljs-built_in">Exception</span> <span class="hljs-literal">e</span>) &#123;<br>	<span class="hljs-literal">e</span>.printStackTrace();<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="try-with-Resources语句"><a href="#try-with-Resources语句" class="headerlink" title="try-with-Resources语句"></a>try-with-Resources语句</h3><blockquote>
<p>定义于JDK 7，对<strong>实现了<code>AutoCloseable</code>接口及其子接口的类（实现了其中的<code>close</code>方法）</strong>，在try之后会自动调用关闭方法</p>
<p>类似于Python中的<code>with</code>语句</p>
</blockquote>
<h3 id="throws关键字"><a href="#throws关键字" class="headerlink" title="throws关键字"></a>throws关键字</h3><blockquote>
<p>应用于方法存在可能异常的语句，但不想在此处进行处理，即可使用<code>throws</code></p>
<p>若一个方法可能出现异常，但没有能力处理异常，可以在方法声明处用throws子句来声明抛出异常</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception1, Exception2 </span>&#123;<br>	<span class="hljs-comment">// 可能产生异常的代码</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="throw关键字"><a href="#throw关键字" class="headerlink" title="throw关键字"></a>throw关键字</h3><blockquote>
<p>将产生的异常抛出</p>
</blockquote>
<h3 id="异常抛出的规律"><a href="#异常抛出的规律" class="headerlink" title="异常抛出的规律"></a>异常抛出的规律</h3><blockquote>
<p>1、一个方法被覆盖，则覆盖它的方法必须抛出相同的异常</p>
</blockquote>
<p>如下，method2抛出了Exception，那么调用它的method1也必须抛出相应的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    method2();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>如果父类的方法抛出了异常，那么重写的子类方法也<strong>必须抛出那些异常的子集，不能抛出新的异常</strong></p>
</blockquote>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><h3 id="Exception类"><a href="#Exception类" class="headerlink" title="Exception类"></a>Exception类</h3><blockquote>
<p>Exception类是所有待处理异常的父类</p>
<p>自定义异常需要继承<code>Exception</code>类或其子类</p>
<p>同时实现的关键在于其构造函数</p>
</blockquote>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Exception</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String returnCode;  <span class="hljs-comment">// 异常返回码</span><br>    <span class="hljs-keyword">private</span> String returnMsg;   <span class="hljs-comment">// 异常描述信息</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyException</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyException</span><span class="hljs-params">(String returnMsg)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(returnMsg);<br>        <span class="hljs-keyword">this</span>.returnMsg = returnMsg;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>







<p>本文参考：</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java05：接口与抽象类</title>
    <url>/page/java-interface-abstractclass.html</url>
    <content><![CDATA[<p>abstract关键字</p>
<p>抽象类，无法进行实例化的类（可以通过向上转型指向子类实例 ）</p>
<p>抽象方法：子类必须进行实现（或者子类也设置为抽象类），在父类定义时不能有方法体</p>
<p>包含抽象方法的类是抽象类</p>
<p>抽象类中可以没有抽象方法</p>
<p>static/final/private不能与abstract共存</p>
<p>接口：命名通常以“I”打头</p>
<p>接口定义了某一批类所需要遵守的规范</p>
<p>接口不关心这些类的内部数据，也不关心类中方法的实现细节，只规定这些类中必须提供某些方法</p>
<p>接口访问修饰符：public 默认</p>
<p>接口中抽象方法可以不写abstract关键字</p>
<p>作为接口的实现类必须实现接口中定义的所有方法，否则需要将该类设置为抽象类</p>
<p>接口中可以包含常量，默认public static final</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">public<span class="hljs-built_in"> interface </span>ITest &#123;<br>    public void func();<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ITest</span> </span>&#123;<br><br>    <span class="hljs-meta">@java</span>.lang.<span class="hljs-function">Override<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">INet net</span> = new A();<br></code></pre></td></tr></table></figure>



<p>default 关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ITest</span> </span>&#123;<br>	<span class="hljs-comment">// 默认方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;<br>		<br>	&#125;<br>	<span class="hljs-comment">// 静态方法</span><br>	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;<br>	<br>	&#125;<br>&#125;<br><br><span class="hljs-comment">// 调用接口中的默认方法</span><br>ITest.<span class="hljs-keyword">super</span>.func1();<br></code></pre></td></tr></table></figure>

<p>接口的继承，可以一对多</p>
<h3 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h3><p>1、 </p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java07：IO流读写</title>
    <url>/page/java-input-output-stream.html</url>
    <content><![CDATA[<h1 id="IO流概述"><a href="#IO流概述" class="headerlink" title="IO流概述"></a>IO流概述</h1><blockquote>
<p>Java程序中输入/输出操作以“流”（Stream方式进行），Java为获取不同种类的数据提供了各种各样的Stream类，基本位于<code>java.io</code>包中</p>
</blockquote>
<p>Java 的 I/O 大概可以分成以下几类：</p>
<ul>
<li>磁盘操作：File</li>
<li>字节操作：InputStream 和 OutputStream</li>
<li>字符操作：Reader 和 Writer</li>
<li>对象操作：Serializable</li>
<li>网络操作：Socket</li>
<li>新的输入/输出：NIO</li>
</ul>
<h2 id="IO流分类"><a href="#IO流分类" class="headerlink" title="IO流分类"></a>IO流分类</h2><h3 id="按流的方向分"><a href="#按流的方向分" class="headerlink" title="按流的方向分"></a>按流的方向分</h3><ul>
<li>输入流：数据源流向程序（以<code>InputStream</code>与<code>Reader</code>结尾）</li>
<li>输出流：程序流向目的目录（以<code>OutPutStream</code>、<code>Writer</code>结尾）</li>
</ul>
<h3 id="按处理的数据单元分"><a href="#按处理的数据单元分" class="headerlink" title="按处理的数据单元分"></a>按处理的数据单元分</h3><ul>
<li>字节流：以字节为单位获取数据，命名上以Stream结尾的流一般是字节流，顶级类InputStream、OutputStream。可以读取包括图像音频等一切数据</li>
<li>字符流：以字符为单位获取数据，命名上以Reader/Writer结尾的流一般是字符流，顶级类Reader、Writer。</li>
</ul>
<h3 id="按处理对象不同分"><a href="#按处理对象不同分" class="headerlink" title="按处理对象不同分"></a>按处理对象不同分</h3><ul>
<li>节点流：可以直接从数据源或目的地读写数据，如FileInputStream、FileReader等。</li>
<li>处理流（包装流）：不直接连接到数据源或目的地，是<strong>”处理流的流”</strong>。通过对其他流的处理提高程序的性能，如BufferedInputStream、BufferedReader等。</li>
</ul>
<h2 id="IO流体系结构"><a href="#IO流体系结构" class="headerlink" title="IO流体系结构"></a>IO流体系结构</h2><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>InputStream和OutputStream是Java语言中最基本的两个字节输入输出类。其他所有字节输入输出流类都继承自这两个基类。</p>
<p>l 这两个类都是抽象类，不能创建它们的实例，只能使用它们的子类.</p>
<p>l FilterInputStream和FilterOutputStream是所有包装流的父类</p>
<h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>Reader和Writer</p>
<p>l 这两个类都是抽象类，不能创建它们的实例，只能使用它们的子类.</p>
<h1 id="文件的常规读写"><a href="#文件的常规读写" class="headerlink" title="文件的常规读写"></a>文件的常规读写</h1><h2 id="File类的使用"><a href="#File类的使用" class="headerlink" title="File类的使用"></a>File类的使用</h2><blockquote>
<p>File类用来代表文件与路径及其相关处理，类似于Python中的<code>os.path</code>等相关功能</p>
</blockquote>
<p>File类能够实现获取文件或者文件夹的属性，以及实现对文件、文件夹的创建和删除</p>
<p>常见方法如下（都是路径处理的常用单词），File对象可以作为创建流对象的输入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"D:\PackageInfo.txt"</span>);	<span class="hljs-comment">// 输入绝对路径或相对路径</span><br>file.getName();			<span class="hljs-comment">// 文件名</span><br>file.getAbsolutePath();	<span class="hljs-comment">// 绝对路径</span><br>file.length();			<span class="hljs-comment">// 长度（字节）</span><br>file.exists();			<span class="hljs-comment">// 是否存在</span><br>file.canRead();			<span class="hljs-comment">// 是否可写</span><br>file.canWrite();		<span class="hljs-comment">// 是否可读</span><br>file.canExecute();		<span class="hljs-comment">// 是否可执行</span><br>file.isFile();			<span class="hljs-comment">// 是否是文件</span><br>file.isDirectory();		<span class="hljs-comment">// 是否是目录</span><br><br>file.getParentFile();	<span class="hljs-comment">// 获取上级文件夹</span><br>file.mkdirs();			<span class="hljs-comment">// 在该路径下创建文件夹</span><br></code></pre></td></tr></table></figure>

<h2 id="字节流常规读写"><a href="#字节流常规读写" class="headerlink" title="字节流常规读写"></a>字节流常规读写</h2><h3 id="常规使用"><a href="#常规使用" class="headerlink" title="常规使用"></a>常规使用</h3><p>1、创建流</p>
<p>2、使用流（通过循环，可以使用字符数组存储也可以使用一些包装流）</p>
<p>3、关闭流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFileStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 创建流</span><br>        File file1 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"e:/readme.txt"</span>);<br>        File file2 = <span class="hljs-keyword">new</span> File(<span class="hljs-string">"e:/readme2.txt"</span>);<br>        InputStream fis = <span class="hljs-keyword">new</span> FileInputStream(file1);<br>        OutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(file2);<br>        <br>        <span class="hljs-comment">// 使用流</span><br>        <span class="hljs-keyword">int</span> n;<br>        n = fis.read();<br>        <span class="hljs-keyword">while</span>(n!=-<span class="hljs-number">1</span>)&#123;	<span class="hljs-comment">// n==1表示读到了文件的末尾</span><br>            fos.write(n);	<span class="hljs-comment">// 写入</span><br>            n = fis.read();	<span class="hljs-comment">// 读出</span><br>        &#125;<br>        <br>        <span class="hljs-comment">// 关闭流</span><br>        fis.close();<br>        fos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="进行异常处理及使用字节数组"><a href="#进行异常处理及使用字节数组" class="headerlink" title="进行异常处理及使用字节数组"></a>进行异常处理及使用字节数组</h3><p>使用字节数组可以减少读写硬盘的次数，从而提高效率</p>
<p>而异常处理可以使用<code>try(resource)</code>简化代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFileStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>(InputStream  fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">"e:/readme.txt"</span>);<br>            OutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"e:/readme2.txt"</span>))&#123;<br><br>            <span class="hljs-comment">// 使用一个字节数组作为中转站</span><br>            <span class="hljs-keyword">byte</span> [] buf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">int</span> len = fis.read(buf);<br>            <span class="hljs-keyword">while</span>(len!=-<span class="hljs-number">1</span>)&#123;<br>                fos.write(buf,<span class="hljs-number">0</span>,len);	<span class="hljs-comment">// 防止字节数组没满造成的多写入问题</span><br>                len = fis.read(buf);<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (FileNotFoundException e)&#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="使用缓冲字节流"><a href="#使用缓冲字节流" class="headerlink" title="使用缓冲字节流"></a>使用缓冲字节流</h3><p>缓冲字节流<code>BufferedInputStream</code>与<code>BufferedOutputStream</code>可以创建缓冲区（默认缓冲区大小为8192）从而大大提高读写的效率。</p>
<p>缓冲字节流的常规使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      InputStream fis = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"e:/JDK_API.CHM"</span>));<br>      OutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"e:/JDK_API2.CHM"</span>));<br>      BufferedInputStream bis = <span class="hljs-keyword">new</span> BufferedInputStream(fis); <br>      BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fos);       <br><br>        <span class="hljs-keyword">int</span> n;<br>        n = bis.read();<br>        <span class="hljs-keyword">while</span>(n != -<span class="hljs-number">1</span>)&#123;<br>            bos.write(n);<br>            n = bis.read();<br>        &#125;<br>        bis.close();<br>        bos.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>缓冲字节流也可以传入所需构建缓冲区的大小：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建size大小的buffer</span><br>BufferedOutputStream(OutputStream out, <span class="hljs-keyword">int</span> size)<br></code></pre></td></tr></table></figure>

<p>同时需要注意缓冲流的<strong>刷新机制</strong>（刷新即将缓冲区内的数据写入程序）</p>
<p>默认当缓冲区满了就会自动刷新，关闭流的时候也会进行刷新，也可以使用<code>flush()</code>函数手动刷新</p>
<h2 id="字符流常规读写"><a href="#字符流常规读写" class="headerlink" title="字符流常规读写"></a>字符流常规读写</h2><h3 id="常规使用-1"><a href="#常规使用-1" class="headerlink" title="常规使用"></a>常规使用</h3><p>与使用字节流读写步骤基本一致，只是是用来读取字符流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestFileReaderWriter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>( Reader fr = <span class="hljs-keyword">new</span> FileReader(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"e:/readme.txt"</span>));<br>             Writer fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">"e:/readm22.txt"</span>);)&#123;<br>            <span class="hljs-keyword">char</span> [] cbuf = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">1024</span>];<br>            <span class="hljs-keyword">int</span> len = fr.read(cbuf);<br>            <span class="hljs-keyword">while</span>(len!= -<span class="hljs-number">1</span>)&#123;<br>                fw.write(cbuf,<span class="hljs-number">0</span>,len);<br>                len = fr.read(cbuf);<br>            &#125;<br>        &#125;<span class="hljs-keyword">catch</span> (FileNotFoundException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="使用缓冲字符流"><a href="#使用缓冲字符流" class="headerlink" title="使用缓冲字符流"></a>使用缓冲字符流</h3><p>与缓冲字节流使用类似，但可以使用<code>readLine()</code>等方法简化编程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        BufferedReader br = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> FileReader(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"e:/sqlnet.log"</span>)));<br>        BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(<span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">"e:/sqlnet2.log"</span>));        <br><br>        String str =  br.readLine();	<span class="hljs-comment">// 读一行数据</span><br>        <span class="hljs-keyword">while</span>(str != <span class="hljs-keyword">null</span> )&#123;<br>            bw.write(str);<br>            bw.newLine();	<span class="hljs-comment">// 写入换行符</span><br>            str = br.readLine();<br>        &#125;<br>        br.close();<br>        bw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="数据流与对象流"><a href="#数据流与对象流" class="headerlink" title="数据流与对象流"></a>数据流与对象流</h1><h2 id="数据流"><a href="#数据流" class="headerlink" title="数据流"></a>数据流</h2><p>数据流<code>DataInputStream</code>与<code>DataOutputStream</code></p>
<p>可以使用不同类型的函数实现不同类型的读写操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDataStream</span> </span>&#123;<br>	<span class="hljs-comment">// 写操作函数 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//创建输出流</span><br>    	OutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"e:/readme.txt"</span>);<br>        BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fos);<br>        DataOutputStream dos = <span class="hljs-keyword">new</span> DataOutputStream(bos);        <br>        <span class="hljs-comment">//使用输出流</span><br>        dos.writeInt(<span class="hljs-number">123</span>);<br>        dos.writeDouble(<span class="hljs-number">3.14</span>);<br>        dos.writeChar(<span class="hljs-string">'A'</span>);<br>        dos.writeBoolean(<span class="hljs-keyword">true</span>);<br>        dos.writeUTF(<span class="hljs-string">"bjsxt"</span>);        <br>        <span class="hljs-comment">//关闭输出流</span><br>        dos.close();<br>    &#125;    <br>    <br>    <span class="hljs-comment">// 读操作函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//创建输入流</span><br>        DataInputStream dis = <span class="hljs-keyword">new</span> DataInputStream(<span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"e:/readme.txt"</span>))));        <br>        <span class="hljs-comment">//使用输入流</span><br>        <span class="hljs-keyword">int</span> a = dis.readInt();<br>        <span class="hljs-keyword">double</span> b = dis.readDouble();<br>        <span class="hljs-keyword">char</span> c = dis.readChar();<br>        <span class="hljs-keyword">boolean</span> d = dis.readBoolean();<br>        System.out.println(dis.readUTF());<br>        <span class="hljs-comment">//关闭输入流</span><br>        dis.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="对象流"><a href="#对象流" class="headerlink" title="对象流"></a>对象流</h2><p>对象流 <code>ObjectInputStream</code> 和 <code>ObjectOutputStream</code> ，可以将Java类与对象写出到文件，实现对象的持久存储</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestObjectStream</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//创建输出流</span><br>        OutputStream fos = <span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">"e:/readme.txt"</span>);<br>        BufferedOutputStream bos = <span class="hljs-keyword">new</span> BufferedOutputStream(fos);<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);        <br>        <span class="hljs-comment">//使用输出流</span><br>        oos.writeInt(<span class="hljs-number">123</span>);<br>        oos.writeDouble(<span class="hljs-number">3.14</span>);<br>        oos.writeChar(<span class="hljs-string">'A'</span>);<br>        oos.writeBoolean(<span class="hljs-keyword">true</span>);<br>        oos.writeUTF(<span class="hljs-string">"bjsxt"</span>);<br>        oos.writeObject(<span class="hljs-keyword">new</span> Date());<br>        oos.writeObject(<span class="hljs-keyword">new</span> Student(“ziye”));    <span class="hljs-comment">// 写入自己创建的对象    </span><br>        <span class="hljs-comment">//关闭输出流</span><br>        oos.close();<br>    &#125;   <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//创建输入流</span><br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> BufferedInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-keyword">new</span> File(<span class="hljs-string">"e:/readme2.txt"</span>))));        <br>        <span class="hljs-comment">//使用输入流</span><br>        System.out.println(ois.readInt());<br>        <span class="hljs-keyword">double</span> d = ois.readDouble();<br>        System.out.println(d);<br>        System.out.println(ois.readChar());<br>        System.out.println(ois.readBoolean());<br>        System.out.println(ois.readUTF());<br>        Object date = (Date)ois.readObject();<br>        System.out.println(date);<br>        System.out.println(ois.readObject());    <span class="hljs-comment">// 读出自己创建的对象    </span><br>        <span class="hljs-comment">//关闭输入流</span><br>        ois.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h2><p>存储与传输时，需要将Java程序中的类对象等信息序列化为<strong>二进制字节流</strong>进行传输，该字节序列包含对象的数据、对象的类型和对象中存储的属性等信息。字节序列写出到文件后，相当于文件中<strong>持久保存</strong>了一个对象的信息。</p>
<ul>
<li>序列化：<code>Serialization</code> 将对象的状态信息转换为可以存储或传输的形式的过程</li>
<li>反序列化：从文件中读取出来，重构对象，对其进行反序列化</li>
</ul>
<h3 id="序列化实现条件"><a href="#序列化实现条件" class="headerlink" title="序列化实现条件"></a>序列化实现条件</h3><p>1、该类必须实现java.io.Serializable 接口，Serializable是一个标记接口，不实现此接口的类将不会使任何状态序列化或者反序列化，会抛出NotSerializableException异常</p>
<p>2、该类的所有属性必须是可序列化的。如果有一个属性不需要可序列化的，则该属性必须注明是瞬态的，使用transient关键字修饰</p>
<p><a href="https://blog.csdn.net/Luojun13Class/article/details/88529622" target="_blank" rel="noopener">https://blog.csdn.net/Luojun13Class/article/details/88529622</a></p>
<h3 id="输入字节流：InputStream"><a href="#输入字节流：InputStream" class="headerlink" title="输入字节流：InputStream"></a>输入字节流：InputStream</h3><blockquote>
<p><code>InputStream</code>是一个抽象类，是所有输入流的超类，最重要的方法为<code>int read()</code>方法，返回字节的int值，返回<code>-1</code>表示无法继续读取。</p>
<p>常用的子类有<code>FileInputStream</code>，从文件流中读取数据。</p>
</blockquote>
<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://zhuanlan.zhihu.com/p/25418336" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25418336</a></p>
<p><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java03：字符串</title>
    <url>/page/Java-string.html</url>
    <content><![CDATA[<h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>在Java中，所有类似“ABC”的字面值，都是String类的实例；</p>
<p>String类位于<code>java.lang</code>包下，是Java语言的核心类，提供了字符串的比较、查找、截取、大小写转换等操作；</p>
<p>Java语言为<code>“+”</code>连接符（字符串连接符）以及对象转换为字符串提供了特殊的支持，字符串对象可以使用<code>“+”</code>连接其他对象</p>
<h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>String被声明为<code>final</code>，因此不可被继承，同时也说明<strong>String具有不可变特性</strong>。在<strong>Java8</strong>中，String内部使用char数组存储数据。</p>
<p><em>注：也正是因为这种不可变性，String类的大多数操作方法都会返回新的String，而不是在原字符串上进行更改</em></p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><code class="hljs zephir"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">char</span> value[];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在<strong>Java9</strong>之后，<em>String类的实现改用byte数组存储字符串，同时使用coder来标识使用哪种编码</em>。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">String</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span>, <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">String</span>&gt;, <span class="hljs-title">CharSequence</span> </span>&#123;<br>    <span class="hljs-comment">/** The value is used for character storage. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> byte[] value;<br><br>    <span class="hljs-comment">/** The identifier of the encoding used to encode the bytes in &#123;<span class="hljs-doctag">@code</span> value&#125;. */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> byte coder;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获取字符串长度</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">length</span><span class="hljs-params">()</span><br><br><span class="hljs-comment">// 获取从 beginIndex 到 endIndex 的字符串</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title">substring</span><span class="hljs-params">(<span class="hljs-keyword">int</span> beginIndex, <span class="hljs-keyword">int</span> endIndex)</span><br><br><span class="hljs-comment">// 获取指定位置的字符</span><br><span class="hljs-keyword">char</span> <span class="hljs-title">charAt</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span><br><br><span class="hljs-comment">// 将字符串分割为子字符串</span><br>String[] <span class="hljs-title">split</span><span class="hljs-params">(String regex, <span class="hljs-keyword">int</span> limit)</span>	<br>    <br><span class="hljs-comment">// 替换所有 a 字符串为 b</span><br>String <span class="hljs-title">replace</span><span class="hljs-params">(<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>)</span><br><br><span class="hljs-comment">// 将该字符串转换为byte数组</span><br><span class="hljs-keyword">byte</span>[] <span class="hljs-title">getBytes</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<h2 id="“-”连接符"><a href="#“-”连接符" class="headerlink" title="“+”连接符"></a>“+”连接符</h2><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><blockquote>
<p>“+”连接符实现字符串连接是通过<strong>StringBuilder（或 StringBuffer）类及其append 方法实现的</strong></p>
</blockquote>
<p>Java在使用“+”连接字符串时，会创建一个<code>StringBuilder</code>对象，并调用<code>append()</code>方法进行拼接，最后调用<code>toString()</code>方法返回拼接好的字符串</p>
<h3 id="效率"><a href="#效率" class="headerlink" title="效率"></a>效率</h3><blockquote>
<p>由于使用“+”连接符时，JVM会隐式创建StringBuilder对象</p>
<p>因此在大规模进行字符串拼接时还是构建一个<code>StringBuilder</code>对象手动调用<code>append</code>方法比较好</p>
<p>但同时，当”+”两端均为编译期确定的字符串常量时，编译器会进行相应的<strong>优化</strong>，直接将两个字符串常量拼接好</p>
</blockquote>
<p>比如：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"a"</span> + <span class="hljs-string">"b"</span>);<br><br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">"ab"</span>);	<span class="hljs-comment">// 反编译后直接拼接好</span><br></code></pre></td></tr></table></figure>





<h2 id="String、StringBuilder、StringBuffer"><a href="#String、StringBuilder、StringBuffer" class="headerlink" title="String、StringBuilder、StringBuffer"></a>String、StringBuilder、StringBuffer</h2><h3 id="主要区别"><a href="#主要区别" class="headerlink" title="主要区别"></a>主要区别</h3><ol>
<li>String是不可变字符序列，StringBuilder和StringBuffer是可变字符序列</li>
<li>执行速度StringBuilder &gt; StringBuffer &gt; String</li>
<li>StringBuilder是非线程安全的，StringBuffer是线程安全的</li>
</ol>
<h3 id="StringBuild类"><a href="#StringBuild类" class="headerlink" title="StringBuild类"></a>StringBuild类</h3><p>String具有不可变性（变化都是通过赋值完成的，类内方法不能使当前对象中的字符串进行改变），而StringBuild不具备</p>
<p>当频繁操作字符串时，应该使用StringBuild</p>
<h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">// 追加内容到当前StringBuild对象的末尾<br>StringBuild append(字符串)	<br><br>// 将内容插入到指定的位置<br>StringBuild <span class="hljs-keyword">insert</span>(位置， 字符串)<br><br>// 将之转化为<span class="hljs-keyword">String</span>对象<br><span class="hljs-keyword">String</span> toString()<br><br>// 删除<span class="hljs-keyword">start</span>到<span class="hljs-keyword">end</span>的字符串。[<span class="hljs-keyword">start</span>, <span class="hljs-keyword">end</span>)<br><span class="hljs-keyword">String</span> <span class="hljs-keyword">delete</span>(<span class="hljs-keyword">start</span>, <span class="hljs-keyword">end</span>)<br><br>// 将<span class="hljs-keyword">start</span>到<span class="hljs-keyword">end</span>之间的字符串替换为<span class="hljs-keyword">str</span><br><span class="hljs-keyword">String</span> <span class="hljs-keyword">replace</span>(<span class="hljs-keyword">start</span>, <span class="hljs-keyword">end</span>, <span class="hljs-keyword">str</span>)<br><br>// 获取字符串长度<br><span class="hljs-built_in">int</span> <span class="hljs-keyword">length</span>()<br></code></pre></td></tr></table></figure>





<h2 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h2><p>暂略</p>
<blockquote>
<p>参考：</p>
<p><a href="https://blog.csdn.net/ifwinds/article/details/80849184" target="_blank" rel="noopener">https://blog.csdn.net/ifwinds/article/details/80849184</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>DS06:集合与映射</title>
    <url>/page/ds-set-and-map.html</url>
    <content><![CDATA[<h2 id="集合特点"><a href="#集合特点" class="headerlink" title="集合特点"></a>集合特点</h2><p>集合通常由一组无序的，<strong>不能重复</strong>的元素构成。</p>
<p>封装的集合接口如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Set</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(E e)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(E e)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="集合实现"><a href="#集合实现" class="headerlink" title="集合实现"></a>集合实现</h2><p>基于BST实现的集合为有序集合，基于链表实现的集合为无序集合</p>
<h3 id="基于二叉树"><a href="#基于二叉树" class="headerlink" title="基于二叉树"></a>基于二叉树</h3><p>由之前构建二叉树可知，当元素数值在二叉树中存在时，我们并没有对其进行处理，因此利用二叉树（或者说二叉搜索树）构建集合具有天然的优势。Java代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTSet</span>&lt;<span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">E</span>&gt;&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Set</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> BST&lt;E&gt; bst;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BSTSet</span><span class="hljs-params">()</span> </span>&#123;<br>        bst = <span class="hljs-keyword">new</span> BST&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        bst.add(e);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        bst.remove(e);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> bst.contains(e);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> bst.getSize();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> bst.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="基于链表等线性结构"><a href="#基于链表等线性结构" class="headerlink" title="基于链表等线性结构"></a>基于链表等线性结构</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedListSet</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Set</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> LinkedList&lt;E&gt; list;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedListSet</span><span class="hljs-params">()</span> </span>&#123;<br>        list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!list.contains(e)) &#123;<br>            list.addFirst(e);   <span class="hljs-comment">// 在头部添加复杂度为O(1)</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        list.removeElement(e);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> list.contains(e);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> list.getSize();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> list.isEmpty();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>基于链表的增删改查复杂度都为O(n)级别</p>
<p>而基于二叉搜索树的则为O(h)级别（h为二叉树的高度）。依据二叉树的性质，最好的情况（平衡）为O(log n) ，最差为O(n)。</p>
<h2 id="映射特点"><a href="#映射特点" class="headerlink" title="映射特点"></a>映射特点</h2><p>映射通俗来讲就是存储（键，值）数据对的数据结构，可以根据键（Key）来寻找值（Value）。</p>
<p>如下是映射的接口及需要实现的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(K key, V value)</span></span>;<br>    <span class="hljs-function">V <span class="hljs-title">remove</span><span class="hljs-params">(K key)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(K key)</span></span>;<br>    <span class="hljs-function">V <span class="hljs-title">get</span><span class="hljs-params">(K key)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(K key, V newValue)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="基于二叉树-1"><a href="#基于二叉树-1" class="headerlink" title="基于二叉树"></a>基于二叉树</h3><p>实现基本框架</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BSTMap</span>&lt;<span class="hljs-title">K</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">K</span>&gt;, <span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> K key;<br>        <span class="hljs-keyword">public</span> V value;<br>        <span class="hljs-keyword">public</span> Node left, right;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.value = value;<br>            left = <span class="hljs-keyword">null</span>;<br>            right = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node root;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BSTMap</span><span class="hljs-params">()</span> </span>&#123;<br>        root = <span class="hljs-keyword">null</span>;<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其余诸如添加元素、删除元素等操作，与二叉搜索树中的相应操作完全一致，只是每个节点中有两个值而已。</p>
<h3 id="基于链表的实现"><a href="#基于链表的实现" class="headerlink" title="基于链表的实现"></a>基于链表的实现</h3><p>将链表中存储的值由一个变为两个，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> K key;<br>    <span class="hljs-keyword">public</span> V value;<br>    <span class="hljs-keyword">public</span> Node next;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(K key, V value, Node next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.key = key;<br>        <span class="hljs-keyword">this</span>.value = value;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(K key, V value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(key, value, <span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其余增删操作与链表中逻辑一致，只是增加元素的时候需要判断元素是否存在。</p>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>基于链表实现的映射的增删改查都为O(n)级别</p>
<p>基于BST实现的映射的增删改查为O(h)级别，这与集合中的复杂度分析是一致的。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>DS05.2:二叉搜索树</title>
    <url>/page/ds-bst.html</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>二叉搜索树（Binary Search Tree），即对任意节点，其值大于其左子树中任意一个节点的值，而小于其右子树中任意一个节点的值。</p>
<p>是一种特殊的二叉树，因此继承了二叉树的所有特性</p>
<p>二叉搜索树的相关分析见：<a href="https://www.jianshu.com/p/ff4b93b088eb" target="_blank" rel="noopener">https://www.jianshu.com/p/ff4b93b088eb</a></p>
<h2 id="操作实现"><a href="#操作实现" class="headerlink" title="操作实现"></a>操作实现</h2><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>题目来源：<a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/</a></p>
<p>利用二叉树的递归特性可以很简单的构造出相应的递归函数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) &#123;<br>            root = <span class="hljs-keyword">new</span> TreeNode(val);<br>            <span class="hljs-keyword">return</span> root;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(val&lt;root.val) &#123;<br>            root.left = insertIntoBST(root.left, val);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            root.right = insertIntoBST(root.right, val);<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="查找某元素是否存在"><a href="#查找某元素是否存在" class="headerlink" title="查找某元素是否存在"></a>查找某元素是否存在</h3><p>使用递归进行判断，如果待判断元素比当前节点值小，则向左递归，否则向右递归。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(Node node, E e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(node==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span>(e.compareTo(node.e) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(e.compareTo(node.e) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> contains(node.left, e);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> contains(node.right, e);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h3><p>这个思路很简单，使用递归与迭代都可以，就是向左或右一直搜索即可。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 寻找二分搜索树最小值</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">minimum</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"BST is empty"</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> minimun(root).e;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">minimun</span><span class="hljs-params">(Node node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(node.left == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> node;<br>    <span class="hljs-keyword">return</span> minimun(node.left);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中若要删除最小值或最大值，就可以对应以下“删除元素”中的第一或者第二种情况，十分方便。</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>图片来源：<a href="https://www.jianshu.com/p/ff4b93b088eb" target="_blank" rel="noopener">https://www.jianshu.com/p/ff4b93b088eb</a></p>
<p>对二叉搜索树进行删除主要要考虑以下三种情况。</p>
<p><strong>1、要删除的是叶子节点</strong></p>
<p>这种情况只需要直接将其设置为空即可</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.2%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/d1_1.png" alt="删除前"></p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.2%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/d1_2.png" alt="删除后"></p>
<p><strong>2、要删除的节点有左节点但没有右节点，或有右节点但没有左节点</strong></p>
<p>这种情况下只需要将其右（左）节点放置在要删除的节点的位置上即可。</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.2%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/d2_1.png" alt="删除前"></p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.2%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/d2_2.png" alt="删除后"></p>
<p><strong>3、要删除的节点既有左节点又有右节点</strong></p>
<p>这种情况下，只需要找到待删节点的右子树中最小的节点（或左子树最大的节点），将其删除并将其值赋给待删节点即可（直接操作相应的指针也行）</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.2%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/d3_1.png" alt="删除前"></p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.2%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/d3_2.png" alt="删除后"></p>
<p>删除二叉搜索树的代码：来源于<a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-node-in-a-bst/submissions/</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root==<span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root;<br>        <span class="hljs-keyword">if</span>(key &gt; root.val) &#123;<br>            root.right = deleteNode(root.right, key);<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key &lt; root.val) &#123;<br>            root.left = deleteNode(root.left, key);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span>(root.left==<span class="hljs-keyword">null</span> || root.right==<span class="hljs-keyword">null</span>) &#123;<br>                root = (root.left==<span class="hljs-keyword">null</span>) ? root.right : root.left;<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                TreeNode temp = root.right;<br>                <span class="hljs-keyword">while</span>(temp.left != <span class="hljs-keyword">null</span>) &#123;<br>                    temp = root.left;<br>                &#125;<br>                root.val = temp.val;<br>                root.right = deleteNode(root.right, temp.val);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其中可见：</p>
<p>若是上述第一种和第二种情况，则直接对二叉树节点进行赋值操作即可。</p>
<p>若是第三种情况，则将找到的节点的val值赋给对应“根”节点，之后对其子树进行递归，删除对应的节点即可（此时需要删除的节点必满足一二两种情况）</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>DS05.1:树与二叉树</title>
    <url>/page/ds-tree-binarytree.html</url>
    <content><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="基本名词"><a href="#基本名词" class="headerlink" title="基本名词"></a>基本名词</h3><h4 id="1、度"><a href="#1、度" class="headerlink" title="1、度"></a>1、度</h4><p>节点拥有的子树的数目称为度</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.1%E3%80%81%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%BA%A6.png" alt=""></p>
<h4 id="4、层次与深度"><a href="#4、层次与深度" class="headerlink" title="4、层次与深度"></a>4、层次与深度</h4><p>从根开始定义，根为第一层，根的孩子为第二层，以此类推</p>
<p>树中结点的最大层次数称为树的深度或高度</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><h4 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h4><p>1、每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。</p>
<p>2、左子树和右子树是有顺序的，次序不能任意颠倒。</p>
<p>3、即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。</p>
<h4 id="特殊的树"><a href="#特殊的树" class="headerlink" title="特殊的树"></a>特殊的树</h4><p>1、满二叉树：如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.1%E3%80%81%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt=""></p>
<p>2、完全二叉树：对一颗具有n个结点的二叉树按层编号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.1%E3%80%81%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt=""></p>
<p>完全二叉树有以下特性（按层编号作为索引），可以用来构建堆结构:</p>
<blockquote>
<p>（1）父节点的编号为i/2。i为孩子节点的编号</p>
<p>（2）左子节点编号为2*i+1。i为父节点编号</p>
</blockquote>
<h4 id="数学性质"><a href="#数学性质" class="headerlink" title="数学性质"></a>数学性质</h4><p>1、在二叉树的第i层上最多有2i-1个节点 （i&gt;=1）</p>
<p>2、二叉树中如果深度为k，那么最多有2k-1个节点(k&gt;=1）</p>
<h3 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h3><p>二叉树的节点，与之前提到的链表的节点很相似，只不过有两个引用，在Java中可以作为一个类中类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>	E e;<br>	Node left;<br>	Node right;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>二叉树所需要的基础方法如下，该基础实现与之后要讲的二叉搜索树是一致的，因此此处类名直接采用BST。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BST</span>&lt;<span class="hljs-title">E</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">E</span>&gt;&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> E e;<br>        <span class="hljs-keyword">public</span> Node left, right;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(E e)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.e = e;<br>            left = <span class="hljs-keyword">null</span>;<br>            right = <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node root;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BST</span><span class="hljs-params">()</span> </span>&#123;<br>        root = <span class="hljs-keyword">null</span>;<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size==<span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>遍历操作就是把所有节点都访问一遍，由于树的定义天生就带有递归特性，因此使用递归进行遍历是最简单的，但也可以使用普通的迭代方法。</p>
<h4 id="二叉树中的几种遍历"><a href="#二叉树中的几种遍历" class="headerlink" title="二叉树中的几种遍历"></a>二叉树中的几种遍历</h4><p>PreOrder Traversal （前序遍历）<br>InOrder Traversal    （中序遍历）<br>PostOrder Traversal    （后序遍历）<br>LevelOrder Traversal    （层序遍历）</p>
<p><strong>规律：</strong>显然，中序遍历可以与其余三种遍历方法的任何一种完成对二叉树的重建（唯一），而其余三种遍历方法任何一种两两结合都无法构建唯一的二叉树。<br>这很好理解，其余三种遍历方法告知了我们根节点的位置，而根据这一点我们可以由中序遍历确定左右子树，然后根据二叉树的递归定义完成重建</p>
<p>前三种遍历方法可以依靠递归轻松实现，其不同之处仅在于递归语句中用于遍历当前节点的语句所处的位置，如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 前序遍历处理当前节点位置</span><br>递归（左子树）;<br><span class="hljs-comment">// 中序遍历处理当前节点位置</span><br>递归（右子树）;<br><span class="hljs-comment">// 后续遍历处理当前节点位置</span><br></code></pre></td></tr></table></figure>

<p>其中具体代码可见<strong>迭代实现</strong>中所示。</p>
<p>前三种遍历都可以依靠递归进行简单的实现，可以简单理解为<strong>深度优先</strong>，而最后一种层序遍历则为<strong>广度优先</strong>，依靠队列即可进行实现，其实现方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">levelOrder</span><span class="hljs-params">()</span> </span>&#123;<br>    Queue&lt;Node&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    q.add(root);<br>    <span class="hljs-keyword">while</span> (!q.isEmpty()) &#123;<br>        Node cur = q.remove();<br>        System.out.println(cur.e);<br>        <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-keyword">null</span>) q.add(cur.left);<br>        <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-keyword">null</span>) q.add(cur.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><p>具体可见（写的很详细）：<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/</a></p>
<p>1、前序遍历</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs java\">private void preOrder(Node node) &#123;<br>    if(node &#x3D;&#x3D; null) return;<br>    System.out.println(node.e);<br>    preOrder(node.left);<br>    preOrder(node.right);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>中序遍历和后序遍历如上所述，只是改变操作位置</p>
<h4 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h4><p>前序遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preOrderNR</span><span class="hljs-params">()</span> </span>&#123;<br>    Stack&lt;Node&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    stack.push(root);<br>    <span class="hljs-keyword">while</span>(!stack.isEmpty()) &#123;<br>        Node cur = stack.pop();<br>        System.out.println(cur.e);<br>        <span class="hljs-keyword">if</span>(cur.right != <span class="hljs-keyword">null</span>) stack.push(cur.right);<br>        <span class="hljs-keyword">if</span>(cur.left != <span class="hljs-keyword">null</span>) stack.push(cur.left);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://www.jianshu.com/p/bf73c8d50dc2" target="_blank" rel="noopener">https://www.jianshu.com/p/bf73c8d50dc2</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>DS04:链表</title>
    <url>/page/ds_linked_list.html</url>
    <content><![CDATA[<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>链表是一个物理存储结构非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的引用链接次序实现，其示意图如下：</p>
<img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4%E3%80%81%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" style="zoom: 80%;" />

<p>数据存储在节点（Node）中，主要模型如下：包括该节点存储的<strong>元素</strong>以及下一个节点的<strong>地址</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>	E e;<br>	Node next;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="与顺序表的对比"><a href="#与顺序表的对比" class="headerlink" title="与顺序表的对比"></a>与顺序表的对比</h3><h4 id="1、顺序表"><a href="#1、顺序表" class="headerlink" title="1、顺序表"></a>1、顺序表</h4><p>优点：</p>
<p>a、空间利用率高。因为是连续存放，所以如果查找一个元素速度很快。</p>
<p>b、存取速度快，通过下标来直接存储。</p>
<p>缺点：</p>
<p>a、插入/删除比较麻烦。插入或者删除的时候，整个表需要遍历挪动元素来实现。</p>
<p>b、空间有限制。因为数组长度是固定的，当需要存取的元素个数多于顺序表的个数时，就会出现溢出问题，而当元素个数远远小于当初分配的空间时，又会造成空间的浪费（动态数组进行扩容同样消耗大量运算）。</p>
<h4 id="2、链表"><a href="#2、链表" class="headerlink" title="2、链表"></a>2、链表</h4><p>优点：相对于动态数组通过“扩容”等操作实现动态，链表是真正的动态，不需要处理固定容量的问题。</p>
<p>缺点：丧失了随机访问的能力（即无法通过索引进行访问）</p>
<h2 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h2><h3 id="类内基本元素"><a href="#类内基本元素" class="headerlink" title="类内基本元素"></a>类内基本元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> E e;<br>        <span class="hljs-keyword">public</span> Node next;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(E e, Node next)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.e = e;<br>            <span class="hljs-keyword">this</span>.next = next;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(E e)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>(e, <span class="hljs-keyword">null</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node dummyHead;	<span class="hljs-comment">// 哑节点，指向链表头节点</span><br>    <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedList</span><span class="hljs-params">()</span> </span>&#123;<br>        dummyHead = <span class="hljs-keyword">new</span> Node(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>时间复杂度为O(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 在链表中间添加元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index, E e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; size) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Add failed"</span>);<br>    &#125;<br>    Node prev = dummyHead;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;index;i++) &#123;<br>        prev = prev.next;<br>    &#125;<br>    prev.next = <span class="hljs-keyword">new</span> Node(e, prev.next);<br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>时间复杂度为O(n)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 删除索引为index的元素</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; size) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Add failed"</span>);<br>        &#125;<br>    Node prev = dummyHead;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;index;i++) &#123;<br>        prev = prev.next;<br>    &#125;<br>    Node res = prev.next;<br>    prev.next = res.next;<br>    res.next = <span class="hljs-keyword">null</span>;<br>    size--;<br>    <span class="hljs-keyword">return</span> res.e;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>还有其他的一些诸如查找、修改等方法，均只需要通过遍历链表即可实现。</p>
<p>同时需要注意，<strong>在头部处不管插入还是删除元素都是O(1)级别</strong>。因此使用链表作为底层结构实现栈和队列是很优越的，这在之前已经提过了。</p>
<h2 id="改进方案（跳表）"><a href="#改进方案（跳表）" class="headerlink" title="改进方案（跳表）"></a>改进方案（跳表）</h2><p>由于链表的插入与查找元素等操作基本都需要对链表进行遍历操作，时间复杂度较高，所以可以有如下改进思路：</p>
<blockquote>
<p>跳表是基于链表实现的有序列表，跳表通过维护一个多层级的链表实现了快速查询效果将平均时间复杂度降到了 <code>O(logn)</code> ，是一个典型的用空间换时间数据结构</p>
</blockquote>
<p>参考：<a href="https://www.cnblogs.com/Laymen/p/14084664.html" target="_blank" rel="noopener">https://www.cnblogs.com/Laymen/p/14084664.html</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>DS03:队列</title>
    <url>/page/ds-queue.html</url>
    <content><![CDATA[<h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>与栈相反，队列的基本特性为<strong>先入先出（FIFO）</strong>。</p>
<p>其与栈相同，也是一种线性表，允许在队尾插入元素，在队头删除元素。</p>
<h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><p>首先想到的就是操作系统中的进程调度方法？还有当然就是广度优先遍历了。</p>
<h4 id="需要实现的基本内容"><a href="#需要实现的基本内容" class="headerlink" title="需要实现的基本内容"></a>需要实现的基本内容</h4><p>实现队列可以构建相应的接口，其需要实现的方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(E e)</span></span>;	<span class="hljs-comment">// 入队列</span><br>    <span class="hljs-function">E <span class="hljs-title">dequeue</span><span class="hljs-params">()</span></span>;	<span class="hljs-comment">// 出队列</span><br>    <span class="hljs-function">E <span class="hljs-title">getFront</span><span class="hljs-params">()</span></span>;	<span class="hljs-comment">// 获取队首元素</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>队列有三种实现方法，分别是线性存储（底层数据结构为动态数组，根据实现思路区别可分为<strong>顺序队列</strong>与<strong>循环队列</strong>），链式存储（底层数据结构为链表）</p>
<h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p>与栈的相应实现方法相同。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Array&lt;E&gt; array;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        array = <span class="hljs-keyword">new</span> Array&lt;&gt;(capacity);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        array = <span class="hljs-keyword">new</span> Array&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> array.getSize();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> array.isEmpty();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        array.addLast(e);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> array.removeFirst();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getFront</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> array.getFirst();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>顺序队列有一个弊端，就是当出队列操作后，动态数组的前面会产生很大的空隙，造成内存的浪费。为了解决这个问题，提出了循环队列的思想，其核心思想就是分别使用<strong>front</strong>和<strong>tail</strong>记录队列的队头和队尾，具体思路见如下示意图（图来源于网上）。</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E9%98%9F%E5%88%97%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.jpg" alt=""></p>
<p>其中，为避免队列为空与队列为满产生的条件判断重叠（即都为front==tail），我们可以将队列满的条件设置为tail+1==front（即留出一个空间不进行使用）。</p>
<p>除此之外，由于是“循环”队列，因此tail可能小于front，因此需要使用(tail) % (data.length)的形式对相关逻辑进行判断</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>具体实现如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoopQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> E[] data;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> front, tail;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoopQueue</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        data = (E[])<span class="hljs-keyword">new</span> Object[capacity+<span class="hljs-number">1</span>];<br>        front = <span class="hljs-number">0</span>;<br>        tail = <span class="hljs-number">0</span>;<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoopQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCapacity</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data.length - <span class="hljs-number">1</span>;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> front==tail;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    	<span class="hljs-comment">// 判断队列满了的条件</span><br>        <span class="hljs-keyword">if</span>((tail+<span class="hljs-number">1</span>)%data.length == front) &#123;<br>            resize(getCapacity() * <span class="hljs-number">2</span>);<br>        &#125;<br>        data[tail] = e;<br>        tail = (tail + <span class="hljs-number">1</span>) % data.length;	<span class="hljs-comment">// 对tail进行更新</span><br>        size++;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(isEmpty()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Queue is empty"</span>);<br>        &#125;<br>        E res = data[front];<br>        data[front] = <span class="hljs-keyword">null</span>;<br>        front = (front+<span class="hljs-number">1</span>) % data.length;<br>        size--;<br>        <span class="hljs-keyword">if</span>(size == getCapacity() / <span class="hljs-number">4</span> &amp;&amp; getCapacity() / <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>            resize(getCapacity() / <span class="hljs-number">2</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">getFront</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data[front];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(<span class="hljs-keyword">int</span> newCapacity)</span> </span>&#123;<br>        E[] newData = (E[])<span class="hljs-keyword">new</span> Object[newCapacity + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;size;i++) &#123;<br>            newData[i] = data[(i + front) % data.length];<br>        &#125;<br>        data = newData;<br>        front = <span class="hljs-number">0</span>;<br>        tail = size;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><h4 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h4><p>需要记录队列的队首head与队尾tail。其中队首对应链表头（删除方便），队尾对应链表尾。</p>
<h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><p>1、类中基础属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedListQueue</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Queue</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>	<span class="hljs-comment">// 定义链表的节点，作为内部类</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>        <span class="hljs-keyword">public</span> E e;<br>        <span class="hljs-keyword">public</span> Node next;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(E e, Node next)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.e = e;<br>            <span class="hljs-keyword">this</span>.next = next;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(E e)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>(e, <span class="hljs-keyword">null</span>);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Node head, tail;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedListQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        head = <span class="hljs-keyword">null</span>;<br>        tail = <span class="hljs-keyword">null</span>;<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、入队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">enqueue</span><span class="hljs-params">(E e)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(tail==<span class="hljs-keyword">null</span>) &#123;<br>        tail = <span class="hljs-keyword">new</span> Node(e);<br>        head = tail;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        tail.next = <span class="hljs-keyword">new</span> Node(e);<br>        tail = tail.next;<br>    &#125;<br>    size++;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、出队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">dequeue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(isEmpty()) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">"Can not"</span>);<br>    &#125;<br>    Node res = head;<br>    head = head.next;<br>    res.next = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>) &#123;<br>        tail = <span class="hljs-keyword">null</span>;<br>    &#125;<br>    size--;<br>    <span class="hljs-keyword">return</span> res.e;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其余方法略</p>
<h3 id="复杂度分析与测试"><a href="#复杂度分析与测试" class="headerlink" title="复杂度分析与测试"></a>复杂度分析与测试</h3><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>不同队列实现方式的差距主要体现在出队中。</p>
<p>其中顺序队列的出队的时间复杂度为O(n)，而循环队列与链接队列出队的时间复杂度为O(1)。</p>
<h4 id="复杂度测试"><a href="#复杂度测试" class="headerlink" title="复杂度测试"></a>复杂度测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>	<span class="hljs-comment">// 用于计算运行时间</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">double</span> <span class="hljs-title">testQueue</span><span class="hljs-params">(Queue&lt;Integer&gt; q, <span class="hljs-keyword">int</span> opCount)</span> 	   </span>&#123;<br>        <span class="hljs-keyword">long</span> startTime = System.nanoTime();<br><br>        Random random = <span class="hljs-keyword">new</span> Random();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;opCount;i++) &#123;<br>            q.enqueue(random.nextInt(Integer.MAX_VALUE));<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i&lt;opCount;i++) &#123;<br>            q.dequeue();<br>        &#125;<br><br>        <span class="hljs-keyword">long</span> endTime = System.nanoTime();<br>        <span class="hljs-keyword">return</span> (endTime - startTime) / <span class="hljs-number">1000000000.0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> opCount = <span class="hljs-number">100000</span>;<br>        ArrayQueue&lt;Integer&gt; arrayQueue = <span class="hljs-keyword">new</span> ArrayQueue&lt;&gt;();<br>        <span class="hljs-keyword">double</span> time1 = testQueue(arrayQueue, opCount);<br>        LoopQueue&lt;Integer&gt; loopQueue = <span class="hljs-keyword">new</span> LoopQueue&lt;&gt;();<br>        <span class="hljs-keyword">double</span> time2 = testQueue(loopQueue,opCount);<br>        LinkedListQueue&lt;Integer&gt; linkedListQueue = <span class="hljs-keyword">new</span> LinkedListQueue&lt;&gt;();<br>        <span class="hljs-keyword">double</span> time3 = testQueue(linkedListQueue,opCount);<br>        System.out.println(<span class="hljs-string">"ArrayQueue: "</span>+time1+<span class="hljs-string">" s"</span>);<br>        System.out.println(<span class="hljs-string">"LoopQueue: "</span>+time2+<span class="hljs-string">" s"</span>);<br>        System.out.println(<span class="hljs-string">"LinkListQueue: "</span>+time3+<span class="hljs-string">" s"</span>);<br>    &#125;<br>&#125;<br><span class="hljs-comment">///////////////////////////////////////////</span><br>ArrayQueue: <span class="hljs-number">45.9780233</span> s<br>LoopQueue: <span class="hljs-number">0.0132119</span> s<br>LinkListQueue: <span class="hljs-number">0.0092766</span> s<br></code></pre></td></tr></table></figure>

<p>由此可以看出，当操作数达到一定级别时，顺序队列的实现方式的速度要远小于其他两种实现方法。这与之前的分析是吻合的。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java08：集合与容器</title>
    <url>/page/java-collection.html</url>
    <content><![CDATA[<h1 id="集合框架体系"><a href="#集合框架体系" class="headerlink" title="集合框架体系"></a>集合框架体系</h1><p>Set是无序的，相比Collection没有增加任何方法，List相比Collection增加和索引相关的方法</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="迭代器的使用"><a href="#迭代器的使用" class="headerlink" title="迭代器的使用"></a>迭代器的使用</h3><p>Iterator接口可以以统一的方式对各种集合元素进行遍历，调用各种集合元素的<code>iterator()</code>方法得到迭代器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Iterator it = set.iterator();<br><span class="hljs-keyword">while</span> (it.hasNext()) &#123;	<span class="hljs-comment">// 检测集合中是否还有下一个元素</span><br>	System.out.println(it.next());	<span class="hljs-comment">// 返回集合中的下一个元素</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Iterator与Iterable"><a href="#Iterator与Iterable" class="headerlink" title="Iterator与Iterable"></a>Iterator与Iterable</h3><ul>
<li><p>Iterator为Java中的迭代器对象，实现了对List这样的集合进行迭代遍历的底层依赖（使用迭代器设计模式实现）</p>
</li>
<li><p>Iterable接口里定义了返回iterator的方法，相当于<strong>对Iterator的封装</strong>，如下所示。所以实现<code>Iterable</code>接口的集合类都可以使用迭代器遍历</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function">Iterator&lt;T&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span></span>;	<span class="hljs-comment">// 获取Iterator的方法</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="for-each与Iterator"><a href="#for-each与Iterator" class="headerlink" title="for-each与Iterator"></a>for-each与Iterator</h3><ul>
<li><p>联系：for-each循环的底层使用的也是迭代器<code>Iterator</code>，因此凡是能够使用for-each进行循环的也一定能够使用迭代器进行遍历</p>
</li>
<li><p>区别：但for-each能够遍历数组，而<code>Iterator</code>不行；同时使用for-each遍历集合时不能够删除元素</p>
</li>
</ul>
<h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><blockquote>
<p>List是元素有序并且可以重复的集合，称为序列，其中<strong>元素有序、不唯一</strong></p>
</blockquote>
<p>List集合的主要实现类有 <code>ArrayList</code> 和 <code>LinkedList</code> ，分别是数据结构中顺序表和链表的实现。</p>
<p>另外还包括栈和队列的实现类或接口：<code>Stack</code>、<code>Deque</code>和<code>Queue</code>。</p>
<p>针对Collection增加了一些关于索引位置操作的方法<code>get(i) add(i,elem),remove(i),set(i,elem)</code></p>
<h2 id="主要使用方法"><a href="#主要使用方法" class="headerlink" title="主要使用方法"></a>主要使用方法</h2><h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">ArrayList <span class="hljs-built_in">list</span> = <span class="hljs-keyword">new</span> ArrayList();<br><span class="hljs-built_in">list</span>.add(<span class="hljs-number">1</span>);	<span class="hljs-comment">// 在最后添加1</span><br><br><span class="hljs-built_in">list</span>.<span class="hljs-built_in">size</span>();	<span class="hljs-comment">// 获取元素数量</span><br><span class="hljs-built_in">list</span>.<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>);	<span class="hljs-comment">// 取出索引值为1的元素</span><br><span class="hljs-built_in">list</span>.<span class="hljs-built_in">remove</span>(<span class="hljs-number">2</span>);	<span class="hljs-comment">// 移除索引为2的元素</span><br></code></pre></td></tr></table></figure>

<h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方法1：for循环</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size() ; i++) &#123;<br>    <span class="hljs-keyword">int</span> elem = list.get(i);<br>&#125;<br><br><span class="hljs-comment">// 方法2：for-each循环</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> elem:list)&#123;<br>    <br>&#125;<br><br><span class="hljs-comment">// 方法3：Iterator</span><br>Iterator&lt;Integer&gt; it = list.iterator();<br><span class="hljs-keyword">while</span>(it.hasNext()) &#123;	<span class="hljs-comment">// 判断是否还有元素</span><br>    <span class="hljs-keyword">int</span> elem = it.next();	<span class="hljs-comment">// 取出元素</span><br>&#125;<br><br><span class="hljs-comment">// 方法4：Lambda表达式+流式编程（JDK1.8）</span><br>list.forEach((elem)-&gt;System.out.println(elem2));<br>list.forEach(System.out::println);<br></code></pre></td></tr></table></figure>



<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><blockquote>
<p>ArrayList底层由数组（<code>Object[]</code>）实现，在内存中分配连续的空间，实现了长度可变的数组</p>
</blockquote>
<ul>
<li><p>优点：遍历元素和随机访问元素的效率比较高</p>
</li>
<li><p>缺点：添加和删除需大量移动元素，效率低</p>
</li>
</ul>
<h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><blockquote>
<p>采用<strong>双向链表</strong>方式存储</p>
</blockquote>
<p>相对于<code>ArrayList</code>，添加了添加、删除、获取首尾元素的方法<code>addFirst()、addLast()、removeFirst()、removeLast()、getFirst()、getLast()</code></p>
<ul>
<li><p>优点：插入、删除元素效率比较高</p>
</li>
<li><p>缺点：遍历和随机访问元素效率低下</p>
</li>
</ul>
<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列使用<code>Queue</code>接口实现，<code>Queue</code>直接继承<code>Collection</code>接口</p>
<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈可以使用<code>Stack</code>也可以使用<code>Deque</code>实现，其中<code>Deque</code>是双向队列（即可以作为栈使用）</p>
<p><code>Stack</code>继承了<code>Vector</code></p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Stack&lt;E&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Vector&lt;E&gt;</span> </span>&#123; &#125;<br></code></pre></td></tr></table></figure>

<p><code>Deque</code>继承了<code>Queue</code>，同时有<code>ArrayDeque</code>和<code>LinkedList</code>两个实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建</span><br>Stack&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();	<span class="hljs-comment">// 栈实现类</span><br>Deque&lt;Integer&gt; deque = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();	<span class="hljs-comment">// 双向队列</span><br><br><span class="hljs-comment">// 入栈</span><br>deque.push(<span class="hljs-number">1</span>);<br><span class="hljs-comment">// 获取栈顶元素</span><br><span class="hljs-keyword">int</span> top = deque.peek();<br><span class="hljs-comment">// 出栈并返回栈顶元素</span><br><span class="hljs-keyword">int</span> top = deque.pop();<br></code></pre></td></tr></table></figure>



<h1 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h1><blockquote>
<p>集合：元素无序，且不可以重复</p>
</blockquote>
<p>set针对Collection没有增加任何方法</p>
<h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><blockquote>
<p>HashSet是Set的一个重要元素，称为哈希集，其中元素无序且不可以重复，只允许一个null元素。底层采用<strong>哈希表</strong>存储集合元素</p>
</blockquote>
<ul>
<li><p>优点：添加速度快，查询速度快，删除速度快</p>
</li>
<li><p>缺点：无序</p>
</li>
</ul>
<p>针对无序的缺点，有<code>LinkedHashSet</code>作为HashSet的子类，该结构采用哈希表存储结构，同时使用链表维护次序（此处的次序指元素添加的次序）</p>
<h3 id="重复元素的检查"><a href="#重复元素的检查" class="headerlink" title="重复元素的检查"></a>重复元素的检查</h3><p>1、首先计算<code>hashcode</code>来判断对象加入的位置，并与其他加入的对象进行比较，如果没有重复的<code>hashcode</code>，则假设对象没有重复出现</p>
<p>2、若有重复的<code>hashcode</code>，则调用<code>equals()</code>方法进行重复检查</p>
<p>因此：</p>
<p>要使用自定义类作为元素存储在<code>HashSet</code>与<code>LinkedHashSet</code>中时，<strong>自定义类必须实现<code>hashCode()</code>和<code>equals()</code></strong>，否则会存储“相同的元素”。</p>
<h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p><strong>HashSet的底层使用的是HashMap</strong>，所以底层结构也是哈希表 ，如下所示</p>
<p>HashSet的元素到HashMap中做key，value统一是同一个Object()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashSet</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Set</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> HashMap&lt;E, Object&gt; map;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashSet</span><span class="hljs-params">()</span> </span>&#123;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> map.put(e, <span class="hljs-keyword">new</span> Object()) == <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">return</span> map.put(e, PRESENT) == <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> map.size();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> map.keySet().iterator();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h2><blockquote>
<p>采用二叉树（红黑树）的存储结构</p>
</blockquote>
<ul>
<li><p>优点：有序（此处指的是自然顺序，也可以自己定义），查询速度比List快（按照内容查询）</p>
</li>
<li><p>缺点：查询速度没有HashSet快</p>
</li>
</ul>
<p><strong>使用自定义类作为元素存储在<code>TreeSet</code>中时，自定义类需要实现<code>Comparable</code>接口并指定比较的规则</strong>，否则会抛出异常。</p>
<h3 id="底层实现-1"><a href="#底层实现-1" class="headerlink" title="底层实现"></a>底层实现</h3><blockquote>
<p><strong>TreeSet的底层使用的是TreeMap</strong>，所以底层结构也是红黑树 ，如下所示</p>
<p>TreeSet的元素e是作为TreeMap的key存在的，value统一为同一个 Object()</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeSet</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractSet</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">NavigableSet</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> NavigableMap&lt;E, Object&gt; m; <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Object PRESENT = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeSet</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">new</span> TreeMap&lt;E, Object&gt;()); <br>    &#125;<br>	TreeSet(NavigableMap&lt;E, Object&gt; m) &#123;<br>        <span class="hljs-keyword">this</span>.m = m;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m.put(e, PRESENT) == <span class="hljs-keyword">null</span>;<br>    &#125;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> m.size();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h1><blockquote>
<p>存储的键值对映射关系，根据key可以找到value</p>
</blockquote>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><blockquote>
<p>采用哈希表存储的键值对</p>
</blockquote>
<ul>
<li>优点：添加速度快、查询速度快、删除速度快</li>
<li>缺点：key值无序</li>
</ul>
<p>与<code>HashSet</code>对应，其也有<code>LinkedHashMap</code>保证键值按添加顺序使用链表维护</p>
<h2 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h2><blockquote>
<p>底层由红黑树实现</p>
</blockquote>
<ul>
<li>优点：key有序，查询速度比List快</li>
<li>缺点：查询速度没有HashMap快</li>
</ul>
<h3 id="底层实现-2"><a href="#底层实现-2" class="headerlink" title="底层实现"></a>底层实现</h3><p>每个节点的结构如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-title">K</span>,<span class="hljs-title">V</span>&gt; </span>&#123;<br>    K key;<br>    V value;<br>    Entry&lt;K,V&gt; left;<br>    Entry&lt;K,V&gt; right;<br>    Entry&lt;K,V&gt; parent;<br>    <span class="hljs-keyword">boolean</span> color = BLACK;<br>&#125;<br></code></pre></td></tr></table></figure>









<h3 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h3><p>排序</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Collections</span>.</span></span>sort(<span class="hljs-built_in">list</span>);<br></code></pre></td></tr></table></figure>

<p>使用Comparable或Comparator接口对自定义类进行排序</p>
<p>Comparator接口</p>
<p>强行对某个对象进行整体排序的比较函数</p>
<p>可以将Comparator传递给sort方法（Collections.sort()或Arrays.sort）</p>
<p>int compare()</p>
<p>Comparable接口</p>
<p>此接口强行对实现它的每个类的对象进行整体排序</p>
<p>参考：</p>
<blockquote>
<p><a href="https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/java/collection/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>DS02:栈</title>
    <url>/page/ds-stack.html</url>
    <content><![CDATA[<h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>栈的特性无非也就是<strong>后进先出（LIFO）</strong>。</p>
<p>其为操作受限的线性表，其主要特点就是栈的插入与删除只能在栈顶进行，分别对应进栈（push）与出栈（pop）两个操作。</p>
<h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><p>首先想到的当然就是系统栈、递归、深度优先搜索了，除此之外还有很多。</p>
<h4 id="需要实现的基本内容"><a href="#需要实现的基本内容" class="headerlink" title="需要实现的基本内容"></a>需要实现的基本内容</h4><p>在Java语言中，实现一个栈的接口表示一个栈需要的基本方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span></span>;	<span class="hljs-comment">// 获取元素个数</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span></span>;	<span class="hljs-comment">// 判断栈是否为空</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(E e)</span></span>;	<span class="hljs-comment">// 入栈操作</span><br>    <span class="hljs-function">E <span class="hljs-title">pop</span><span class="hljs-params">()</span></span>;	<span class="hljs-comment">// 出栈操作</span><br>    <span class="hljs-function">E <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;	<span class="hljs-comment">// 获取栈顶元素</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>栈主要有两种存储方法，即<strong>线性存储</strong>（底层是动态数组）与<strong>链接存储</strong>（底层为链表），之后分别记录这两种栈的实现方法。</p>
<h3 id="线性存储"><a href="#线性存储" class="headerlink" title="线性存储"></a>线性存储</h3><p>存储实现如下，直接套用之前在《1、动态数组》实现的动态数组即可，之后按照类的定义进行实现，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayStack</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    Array&lt;E&gt; array;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack</span><span class="hljs-params">(<span class="hljs-keyword">int</span> caoacity)</span> </span>&#123;<br>        array = <span class="hljs-keyword">new</span> Array&lt;&gt;(caoacity);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ArrayStack</span><span class="hljs-params">()</span> </span>&#123;<br>        array = <span class="hljs-keyword">new</span> Array&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> array.getSize();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> array.isEmpty();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        array.addLast(e);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> array.removeLast();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> array.getLast();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCapacity</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> array.getCapacity();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="链接存储"><a href="#链接存储" class="headerlink" title="链接存储"></a>链接存储</h3><p>套用在《4、链表》中实现的链表作为底层数据结构即可进行实现，代码如下：</p>
<p>使用链接存储时栈顶为链表的头，这是由于删除链表的头元素的时间复杂度为O(1)，而要删除链表最后一个元素时间复杂度为O(n)。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedListStack</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Stack</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> LinkedList&lt;E&gt; list;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LinkedListStack</span><span class="hljs-params">()</span> </span>&#123;<br>        list = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> list.getSize();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> list.isEmpty();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(E e)</span> </span>&#123;<br>        list.addFirst(e);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> list.removeFirst();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">peek</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> list.getFirst();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>DS01:动态数组</title>
    <url>/page/ds-dynamic-array.html</url>
    <content><![CDATA[<h3 id="数组的缺陷"><a href="#数组的缺陷" class="headerlink" title="数组的缺陷"></a>数组的缺陷</h3><h4 id="静态数组的缺陷"><a href="#静态数组的缺陷" class="headerlink" title="静态数组的缺陷"></a>静态数组的缺陷</h4><p>目前为止所实现的数组类，有一个非常严重的局限性，就是这个数组实际使用的还是一个静态数组，内部容量有限。在实际使用的时候，我们往往<strong>无法预估</strong>要在这个数组中存入<strong>多少个元素</strong>。</p>
<h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>构建动态数组，使得数组的容量能够随着存入的元素进行伸缩。其实现底层仍为<strong>静态数组</strong>。</p>
<p>即：当元素超过数组当前容量时，对数组进行<strong>扩容</strong>（重新声明一个更大的数组，并将原数组中的元素迁移过去）。当元素由于删除操作远小于当前容量时，对数组容量进行缩小。</p>
<h3 id="动态数组实现"><a href="#动态数组实现" class="headerlink" title="动态数组实现"></a>动态数组实现</h3><h4 id="类内基本信息"><a href="#类内基本信息" class="headerlink" title="类内基本信息"></a>类内基本信息</h4><p>类中使用泛型&lt;E&gt;，同时使用静态数组data作为底层容器，并记录数组中元素的个数size。</p>
<p>同时，构建实现一些基本的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Array</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> E[] data;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-comment">// 有参构造函数</span><br>    <span class="hljs-comment">// 传入预先设置的容量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Array</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        data = (E[])<span class="hljs-keyword">new</span> Object[capacity];<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 无参构造函数，默认容量为10</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Array</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取数组中元素个数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getSize</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size;<br>    &#125;<br><br>    <span class="hljs-comment">// 获取Array中数组容量</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getCapacity</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> data.length;<br>    &#125;<br><br>    <span class="hljs-comment">// 判断是否为空</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> size == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="实现数组的伸缩"><a href="#实现数组的伸缩" class="headerlink" title="实现数组的伸缩"></a>实现数组的伸缩</h4><p>实现数组的伸缩其实就是重新声明一个容量符合要求的数组，并将原数组中的元素拷贝进去，如下：</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 改变数组中容量大小</span><br><span class="hljs-comment">// 传入新容量</span><br><span class="hljs-keyword">private</span> void resize(int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>) &#123;<br>    E[] <span class="hljs-keyword">new</span><span class="hljs-type">Data</span> = (E[])<span class="hljs-keyword">new</span> <span class="hljs-type">Object</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>];<br>    <span class="hljs-keyword">for</span> (int i=<span class="hljs-number">0</span>;i&lt;size;i++) &#123;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Data</span>[i] = data[i];<br>    &#125;<br>    data = <span class="hljs-keyword">new</span><span class="hljs-type">Data</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="向数组中添加元素"><a href="#向数组中添加元素" class="headerlink" title="向数组中添加元素"></a>向数组中添加元素</h4><p>1、对输入参数进行判断，不合理抛出异常</p>
<p>2、若原数组已经容纳不下新元素，进行上述resize操作，将新数组容量变为之前的2倍（可以指定为其他倍数）</p>
<p>3、进行添加操作</p>
<figure class="highlight stan"><table><tr><td class="code"><pre><code class="hljs stan"><span class="hljs-comment">// 向数组中index位置加入元素e</span><br>public <span class="hljs-keyword">void</span> add(<span class="hljs-keyword">int</span> index, E <span class="hljs-built_in">e</span>) &#123;<br>    <span class="hljs-keyword">if</span>(index &lt; <span class="hljs-number">0</span> || index &gt; <span class="hljs-built_in">size</span>) &#123;<br>        throw new IllegalArgumentException(<span class="hljs-string">"Add failed."</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">size</span> == <span class="hljs-title">data</span>.length) &#123;<br>        resize(<span class="hljs-number">2</span> * <span class="hljs-title">data</span>.length);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-built_in">size</span>-<span class="hljs-number">1</span>;i&gt;=index;i--) &#123;<br>        <span class="hljs-title">data</span>[i+<span class="hljs-number">1</span>] = <span class="hljs-title">data</span>[i];<br>    &#125;<br>    <span class="hljs-title">data</span>[index] = <span class="hljs-built_in">e</span>;<br>    <span class="hljs-built_in">size</span>++;<br>&#125;<br><br><span class="hljs-comment">// 向最后添加一个元素</span><br>public <span class="hljs-keyword">void</span> addLast(E <span class="hljs-built_in">e</span>) &#123;<br>    add(<span class="hljs-built_in">size</span>, <span class="hljs-built_in">e</span>);<br>&#125;<br><br><span class="hljs-comment">// 向最前添加一个元素</span><br>public <span class="hljs-keyword">void</span> addFirst(E <span class="hljs-built_in">e</span>) &#123;<br>    add(<span class="hljs-number">0</span>, <span class="hljs-built_in">e</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>1、对输入参数进行判断，不合理抛出异常</p>
<p>2、若删除元素后数组容量为含有元素个数的4倍，则使用resize将数组容量改为原来的1/2（与add中倍数不同是为了避免<strong>复杂度震荡</strong>）</p>
<p>3、进行删除操作</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><code class="hljs fortran">// 删除索引为<span class="hljs-built_in">index</span>的元素<br><span class="hljs-keyword">public</span> E remove(<span class="hljs-built_in">int</span> <span class="hljs-built_in">index</span>) &#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">index</span>&lt;<span class="hljs-number">0</span> || <span class="hljs-built_in">index</span> &gt;= <span class="hljs-built_in">size</span>) &#123;<br>        throw new IllegalArgumentException(<span class="hljs-string">"Set failed"</span>);<br>    &#125;<br>    E res = <span class="hljs-keyword">data</span>[<span class="hljs-built_in">index</span>];<br>    for (<span class="hljs-built_in">int</span> i=<span class="hljs-built_in">index</span>+<span class="hljs-number">1</span>;i&lt;<span class="hljs-built_in">size</span>;i++) &#123;<br>        <span class="hljs-keyword">data</span>[i-<span class="hljs-number">1</span>] = <span class="hljs-keyword">data</span>[i];<br>    &#125;<br>    <span class="hljs-built_in">size</span>--;<br>    <span class="hljs-keyword">data</span>[<span class="hljs-built_in">size</span>] = null;<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">size</span> == <span class="hljs-keyword">data</span>.length / <span class="hljs-number">4</span>) &#123;<br>        resize(<span class="hljs-keyword">data</span>.length / <span class="hljs-number">2</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br>// 删除第一个元素<br><span class="hljs-keyword">public</span> E removeFirst() &#123;<br>    <span class="hljs-keyword">return</span> remove(<span class="hljs-number">0</span>);<br>&#125;<br><br>// 删除最后一个元素<br><span class="hljs-keyword">public</span> E removeLast() &#123;<br>    <span class="hljs-keyword">return</span> remove(<span class="hljs-built_in">size</span>-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><p>其余诸如查找索引等操作就是基本的数组操作了，直接进行实现即可。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h4 id="复杂度震荡"><a href="#复杂度震荡" class="headerlink" title="复杂度震荡"></a>复杂度震荡</h4><p>在之前提到过，在此进行记录其产生的具体过程：</p>
<p>1、假设现在我们有一个数组，容量是n，并且装满了元素。</p>
<p>2、这时候，我想添加一个元素，显然是需要进行扩容，容量变为2n，耗时O(n)的时间。</p>
<p>3、但是此时，我又删除了一个元素触发了缩容操作，耗时O(n)的时间。</p>
<p>4、当我们每次触发缩容或扩容操作，都会耗费O(n)额复杂度，那么这便是复杂度的震荡</p>
<p><strong>解决方法：</strong>即将缩容与扩容触发的阈值设置的不同即可。</p>
]]></content>
      <categories>
        <category>学习笔记</category>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>Java04：类、对象与方法</title>
    <url>/page/java-orient-object.html</url>
    <content><![CDATA[<h1 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h1><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
<h3 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h3><p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。<strong>所以Java的访问权限应该有四个</strong></p>
<table>
<thead>
<tr>
<th align="center">作用范围/关键字</th>
<th align="center">当前类</th>
<th align="center">同一package</th>
<th align="center">子孙类</th>
<th align="center">其他package</th>
</tr>
</thead>
<tbody><tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">不使用关键字</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center">×</td>
<td align="center">×</td>
<td align="center">×</td>
</tr>
</tbody></table>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><blockquote>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</p>
</blockquote>
<p>通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高开发效率。同时，<strong>Java语言中的继承是单继承</strong>。</p>
<p>1、子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</p>
<p>2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>
<p>3、子类可以用自己的方式实现父类的方法（方法重写）。</p>
<h3 id="继承的常用关键字"><a href="#继承的常用关键字" class="headerlink" title="继承的常用关键字"></a>继承的常用关键字</h3><p>this：当前类对象的引用</p>
<p>super：父类对象的引用，可用于访问父类成员方法与属性</p>
<p><code>super()</code> 访问父类构造方法，必须位于子类构造方法的<strong>第一行</strong></p>
<p>子类的构造过程必须调用其父类的构造方法，若子类构造方法中没有显式标注，则系统默认调用父类无参构造方法（若子类构造方法无显式标值且父类中没有无参构造方法，则编译出错），因此Java中每个类中都应该尽量写一个无参构造函数。</p>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><blockquote>
<p>多态通俗意义上来讲就是：不同类的对象对同一消息做出不同响应，</p>
</blockquote>
<p>可以分为：</p>
<ul>
<li>编译时多态：即方法重载</li>
<li>运行时多态：程序运行时动态决定调用哪个方法</li>
</ul>
<h3 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h3><blockquote>
<p>向上转型，即父类（或者父接口）引用指向子类实例，是Java语言中多态的常见表现形式</p>
</blockquote>
<p>如下即为向上转型的示例，声明的是父类（父接口），实际指向的是子类的一个对象。这使得对象既可以<strong>使用子类强大的功能</strong>，又可以<strong>抽取父类的共性</strong>。</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">List</span> l1 = <span class="hljs-keyword">new</span> ArrayList();<br><span class="hljs-built_in">List</span> l2 = <span class="hljs-keyword">new</span> LinkedList();<br></code></pre></td></tr></table></figure>

<h3 id="向上转型规则"><a href="#向上转型规则" class="headerlink" title="向上转型规则"></a>向上转型规则</h3><p>向上转型<strong>可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法</strong>，示例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * 父类<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;<br>    <span class="hljs-comment">// 父类中的func1方法</span><br>    <span class="hljs-comment">// 由于子类中对该方法只是进行了重载而没有进行重写</span><br>    <span class="hljs-comment">// 因此该方法仍然有效</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"Father func1"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 父类中的func2方法</span><br>    <span class="hljs-comment">// 由于在子类中重写了该方法</span><br>    <span class="hljs-comment">// 所以在“向上转型”中，该方法不再有效</span><br>    <span class="hljs-comment">// 取而代之的是子类中的fun2方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"Father func2"</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**<br> * 子类<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;<br>    <span class="hljs-comment">// 对func1方法的一个重载</span><br>    <span class="hljs-comment">// 由于在父类中没有定义该方法，所以该方法不能被父类的引用调用</span><br>    <span class="hljs-comment">// 如果进行调用即会报错</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"Child func1"</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 对父类方法的重写</span><br>    <span class="hljs-comment">// 能够起作用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func2</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">"Child func2"</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**<br> * 主函数<br> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>	<span class="hljs-comment">// write your code here</span><br>        Father test = <span class="hljs-keyword">new</span> Child();<br>        test.func1();   <span class="hljs-comment">// Father func1</span><br>        test.func2();   <span class="hljs-comment">// Child func2</span><br>        test.func1(<span class="hljs-number">10</span>); <span class="hljs-comment">// 报错</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h3><blockquote>
<p>向下转型，子类引用指向父类实例，此处要求必须进行强转</p>
</blockquote>
<p>Java中向上转型是安全的，由JVM自动实现，而向下转型是不安全的，需要强制类型转换。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Father father = <span class="hljs-keyword">new</span> Father();<br><span class="hljs-keyword">if</span>(father <span class="hljs-keyword">instanceof</span> Child) &#123;	<span class="hljs-comment">// instanceof 运算符，返回 true false</span><br>	Child temp = (Child)father;	<span class="hljs-comment">// 强制类型转换</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h1><blockquote>
<p>一个类定义在另一个类（或方法）内部</p>
</blockquote>
<p>嵌套类的作用：</p>
<p>1、实现更细粒度的访问权限控制</p>
<p>2、避免过多的类定义</p>
<h2 id="静态嵌套类"><a href="#静态嵌套类" class="headerlink" title="静态嵌套类"></a>静态嵌套类</h2><blockquote>
<p>第三方需要通过外部包围类才能够访问</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;<br>    <span class="hljs-comment">// 静态嵌套类</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="非静态嵌套类（内部类）"><a href="#非静态嵌套类（内部类）" class="headerlink" title="非静态嵌套类（内部类）"></a>非静态嵌套类（内部类）</h2><h3 id="普通内部类（成员内部类）"><a href="#普通内部类（成员内部类）" class="headerlink" title="普通内部类（成员内部类）"></a>普通内部类（成员内部类）</h3><blockquote>
<p>定义后在类中均可以使用，类似于结构体的作用</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;<br>    <span class="hljs-comment">// 成员内部类</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><blockquote>
<p>定义在代码块（如方法、for/if语句中）中的非静态的类</p>
<p>只存活于该代码块内部，<strong>代码块结束后外界无法使用该类</strong></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 局部内部类</span><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>            <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><blockquote>
<p>没有类名的内部类，必须继承一个父类/实现一个父接口，同时在实例化后迅速转为父类/父接口</p>
</blockquote>
<p>匿名内部类通常只使用一次</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Outer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 匿名内部类</span><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Inner</span> </span>&#123;<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="四种嵌套类的比较"><a href="#四种嵌套类的比较" class="headerlink" title="四种嵌套类的比较"></a>四种嵌套类的比较</h2><table>
<thead>
<tr>
<th></th>
<th>访问权限修饰</th>
<th>作用范围</th>
<th>可访问外部包围类内容</th>
<th>和外部类关系</th>
</tr>
</thead>
<tbody><tr>
<td>匿名内部类</td>
<td>无</td>
<td>所在代码块内，外部无法访问</td>
<td>访问外部的所有成员</td>
<td>在外部类对象内部</td>
</tr>
<tr>
<td>局部内部类</td>
<td>无</td>
<td>所在代码块内，外部无法访问</td>
<td>访问外部的所有成员</td>
<td>在外部类对象内部</td>
</tr>
<tr>
<td>普通内部类</td>
<td>有</td>
<td>包围类内可以访问，外部可以访问</td>
<td>访问外部的所有成员</td>
<td>外界可以new，但必须依附于一个外部类对象</td>
</tr>
<tr>
<td>静态内部类</td>
<td>有</td>
<td>包围类内可以访问，外部可以访问</td>
<td>访问外部的所有静态成员</td>
<td>外界可以new，可独立进行工作</td>
</tr>
</tbody></table>
<h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><h2 id="参数传递方式"><a href="#参数传递方式" class="headerlink" title="参数传递方式"></a>参数传递方式</h2><h3 id="Java形参的传递方法（值传递）"><a href="#Java形参的传递方法（值传递）" class="headerlink" title="Java形参的传递方法（值传递）"></a>Java形参的传递方法（值传递）</h3><blockquote>
<p>总体而言，Java总是采用按值传递的方式进行传参，即<em>方法得到的是所有参数值的一个拷贝</em>，方法不能修改传递给它的任何参数的内容</p>
</blockquote>
<p><strong>1、一个方法不能修改一个基本数据类型的参数</strong></p>
<p>示例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>    <span class="hljs-type">int</span> num1 = <span class="hljs-number">10</span>;<br>    <span class="hljs-type">int</span> num2 = <span class="hljs-number">20</span>;<br><br>    swap(num1, num2);<br><br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println("num1 = " + num1);<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println("num2 = " + num2);<br>&#125;<br><br><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> swap(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b) &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-keyword">temp</span> = a;<br>    a = b;<br>    b = <span class="hljs-keyword">temp</span>;<br><br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println("a = " + a);<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println("b = " + b);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = <span class="hljs-number">20</span><br><span class="hljs-attr">b</span> = <span class="hljs-number">10</span><br><span class="hljs-attr">num1</span> = <span class="hljs-number">10</span><br><span class="hljs-attr">num2</span> = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure>

<p>说明：</p>
<p>在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的（<strong>值传递</strong>）。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>
<p><strong>2、一个方法可以改变一个对象参数的状态</strong></p>
<p>示例：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> main(String[] args) &#123;<br>	<span class="hljs-built_in">int</span>[] arr = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br>	System.<span class="hljs-keyword">out</span>.println(arr[<span class="hljs-number">0</span>]);<br>	change(arr);<br>	System.<span class="hljs-keyword">out</span>.println(arr[<span class="hljs-number">0</span>]);<br>&#125;<br><br><span class="hljs-keyword">public</span> static <span class="hljs-built_in">void</span> change(<span class="hljs-built_in">int</span>[] <span class="hljs-built_in">array</span>) &#123;<br>	<span class="hljs-comment">// 将数组的第一个元素变为0</span><br>	<span class="hljs-built_in">array</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">1</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>说明：</p>
<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上（类似于C++ 的引用传递）。</p>
<p><strong>3、一个方法不能让对象参数引用一个新的对象</strong></p>
<p>示例：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> Test &#123;<br><br>	<span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>		// TODO Auto-<span class="hljs-keyword">generated</span> <span class="hljs-keyword">method</span> stub<br>		Student s1 = <span class="hljs-built_in">new</span> Student("小张");<br>		Student s2 = <span class="hljs-built_in">new</span> Student("小李");<br>		Test.swap(s1, s2);<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println("s1:" + s1.getName());<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println("s2:" + s2.getName());<br>	&#125;<br><br>	<span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> swap(Student x, Student y) &#123;<br>		Student <span class="hljs-keyword">temp</span> = x;<br>		x = y;<br>		y = <span class="hljs-keyword">temp</span>;<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println("x:" + x.getName());<br>		<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println("y:" + y.getName());<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<figure class="highlight avrasm"><table><tr><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">x:</span>小李<br><span class="hljs-symbol">y:</span>小张<br><span class="hljs-symbol">s1:</span>小张<br><span class="hljs-symbol">s2:</span>小李<br></code></pre></td></tr></table></figure>

<p>说明：</p>
<p>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</p>
<h3 id="深拷贝、浅拷贝"><a href="#深拷贝、浅拷贝" class="headerlink" title="深拷贝、浅拷贝"></a>深拷贝、浅拷贝</h3><p>1、<strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</p>
<p>2、<strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p>
<p><img src="http://cdn.ziyedy.top/4%E3%80%81Java%EF%BC%9A%E7%B1%BB%E3%80%81%E5%AF%B9%E8%B1%A1%E4%B8%8E%E6%96%B9%E6%B3%95/java-deep-and-shallow-copy.jpg" alt=""></p>
<h2 id="方法重载（Overload）"><a href="#方法重载（Overload）" class="headerlink" title="方法重载（Overload）"></a>方法重载（Overload）</h2><blockquote>
<p>同样的方法根据输入数据的不同，做出不同处理（同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理）</p>
<p><strong>每个重载的方法都有独一无二的参数列表</strong>，包括参数的类型、顺序、参数数量等等</p>
<p>重载是发生在<strong>编译时</strong>的，由编译器根据参数的类型来选择使用哪个方法</p>
</blockquote>
<h3 id="重载的条件"><a href="#重载的条件" class="headerlink" title="重载的条件"></a>重载的条件</h3><ol>
<li><p>位于同一个类中，且方法名必须相同</p>
</li>
<li><p>参数列表必须不同（个数、类型、参数类型排列顺序不同）</p>
</li>
<li><p>返回值可以不同，<strong>仅返回值不同不能构成重载</strong></p>
</li>
<li><p>可以有不同的访问修饰符，可以抛出不同的异常</p>
</li>
</ol>
<h3 id="为何不能根据返回值不同来区分重载"><a href="#为何不能根据返回值不同来区分重载" class="headerlink" title="为何不能根据返回值不同来区分重载"></a>为何不能根据返回值不同来区分重载</h3><p> 在Java语言中，要重载一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个<strong>与原方法不同的特征签名</strong></p>
<p>特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名之中，因此Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载。</p>
<h2 id="方法重写（Override）"><a href="#方法重写（Override）" class="headerlink" title="方法重写（Override）"></a>方法重写（Override）</h2><blockquote>
<p>重写发生在<strong>运行期</strong>，是子类对父类的允许访问的方法的实现过程进行重新编写（重写就是<strong>子类对父类方法的重新改造</strong>，外部样子不能改变，内部逻辑可以改变）</p>
</blockquote>
<h3 id="重写的原则"><a href="#重写的原则" class="headerlink" title="重写的原则"></a>重写的原则</h3><ol>
<li><p>发生有继承关系的<em>父类与子类</em>中，且父类方法的<em>访问修饰符为private/final/static则表示该方法不能重写</em>，但是使用static修饰的方法能够被再次声明，同时构造方法不能被重写。</p>
</li>
<li><p>重写的方法必须要和父类保持一致</p>
</li>
<li><p>子类方法的<em>访问权限必须大于等于</em>父类方法；</p>
</li>
<li><p>子类方法的返回类型必须是父类方法返回类型或为其子类型。</p>
</li>
<li><p>子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</p>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**<br> * 1、子类的访问权限public &gt; 父类访问权限protected<br> * 2、子类返回值是父类接口的一个类实现（父类的子类型）<br> * 3、子类抛出的异常为父类抛出异常的子类<br> * 使用 <span class="hljs-doctag">@Override</span> 注解，可以让编译器帮忙检查是否满足上面的限制条件*<br> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SuperClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Integer&gt; <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SuperClass</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ArrayList&lt;Integer&gt; <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="所有类的父类——Object"><a href="#所有类的父类——Object" class="headerlink" title="所有类的父类——Object"></a>所有类的父类——Object</h1><h2 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h2><p><strong>Object类是所有类的父类</strong>，主要提供11个方法。</p>
<p>其中native方法即为调用非Java代码的接口，一个native方法是指该方法的实现由非Java语言实现。</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 用于返回当前运行时对象的Class对象。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br><br><span class="hljs-comment">// 用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-built_in">int</span> hashCode()<br><br><span class="hljs-comment">// 用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> equals(<span class="hljs-keyword">Object</span> obj)<br><br><span class="hljs-comment">// 用于创建并返回当前对象的一份拷贝。</span><br><span class="hljs-comment">// 一般情况下，对于任何对象 x</span><br><span class="hljs-comment">// 表达式 x.clone() != x 为true</span><br><span class="hljs-comment">// x.clone().getClass() == x.getClass() 为true</span><br><span class="hljs-comment">// Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会产生异常。</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">Object</span> clone() <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><br><span class="hljs-comment">// 返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> toString()<br><br><span class="hljs-comment">// 不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> notify()<br><br><span class="hljs-comment">// 不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> notifyAll()<br><br><span class="hljs-comment">// 不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> wait(<span class="hljs-keyword">long</span> timeout) <span class="hljs-keyword">throws</span> InterruptedException<br><br><span class="hljs-comment">// 多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> wait(<span class="hljs-keyword">long</span> timeout, <span class="hljs-built_in">int</span> nanos) <span class="hljs-keyword">throws</span> InterruptedException<br><br><span class="hljs-comment">// 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> wait() <span class="hljs-keyword">throws</span> InterruptedException<br><br><span class="hljs-comment">// 实例被垃圾回收器回收的时候触发的操作</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> finalize() <span class="hljs-keyword">throws</span> Throwable<br></code></pre></td></tr></table></figure>

<h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><h3 id="与equals"><a href="#与equals" class="headerlink" title="==与equals"></a>==与equals</h3><ul>
<li><strong>==</strong>：判断两个对象在内存中的地址是不是相等（基本数据类型==比较的是值，引用数据类型==比较的是内存地址）</li>
<li><strong>equals()</strong>：通常用于判断两个对象的“值”是否相等（若类没有重写该方法，则等价于使用“==”，但通常都会对equals进行重写）</li>
</ul>
<h3 id="hashCode与equals"><a href="#hashCode与equals" class="headerlink" title="hashCode与equals"></a>hashCode与equals</h3><ul>
<li><p>使用<code>equals()</code>进行对比是绝对可靠的：equals()相等的两个对象它们的hashCode()也一定相等</p>
</li>
<li><p>使用<code>hashCode()</code>进行对比不是绝对可靠的：hashCode()相等的两个对象equals()不一定相等（有时不同对象hashcode会一样）</p>
</li>
</ul>
<p>在使用<code>Set</code>等hash结构的类中存储该类时，<strong>equals 方法被重写，则 hashCode 方法也必须被重写</strong></p>
<p>如<code>String</code>重写了这两个方法，则可以在<code>HashMap</code>等类似结构中使用<code>String</code>对象。</p>
<p>参考：</p>
<blockquote>
<p><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java01：基本概念与语言特点</title>
    <url>/page/java-basic-grammar.html</url>
    <content><![CDATA[<h2 id="常见名词解释"><a href="#常见名词解释" class="headerlink" title="常见名词解释"></a>常见名词解释</h2><h3 id="JVM（Java-Virtual-Machine）"><a href="#JVM（Java-Virtual-Machine）" class="headerlink" title="JVM（Java Virtual Machine）"></a>JVM（Java Virtual Machine）</h3><p>Java虚拟机，用于运行Java字节码，其针对不同的操作系统有着特定的实现，使得相同的字节码运行会给出相同的结果。</p>
<p>在Java中，JVM能够理解的代码就叫做<strong>字节码</strong>（.class文件）。其不面向任何特定的处理器，只面向虚拟机。</p>
<h3 id="JDK（Java-Development-Kit）"><a href="#JDK（Java-Development-Kit）" class="headerlink" title="JDK（Java Development Kit）"></a>JDK（Java Development Kit）</h3><p>JDK是功能齐全的Java软件开发包，拥有JRE所拥有的一切，有编译器（javac）和一些其他工具，能够创建和编译程序。</p>
<h3 id="JRE（Java-Runtime-Environment）"><a href="#JRE（Java-Runtime-Environment）" class="headerlink" title="JRE（Java Runtime Environment）"></a>JRE（Java Runtime Environment）</h3><p>即Java运行时环境。其为运行已编译Java程序所需要的所有内容的集合，包括Java虚拟机、Java类库、Java命令和其他一些基础的构建。但是，其不能用于创建新程序。</p>
<h3 id="Java-SE（Standard-Edition）"><a href="#Java-SE（Standard-Edition）" class="headerlink" title="Java SE（Standard Edition）"></a>Java SE（Standard Edition）</h3><p>即Java标准版，包括Java语言规范等等</p>
<h3 id="Java-EE（J2EE）"><a href="#Java-EE（J2EE）" class="headerlink" title="Java EE（J2EE）"></a>Java EE（J2EE）</h3><p>Java平台企业版，可以理解为为企业级应用开发的一些Java Web框架等内容。</p>
<h2 id="Java语言特点"><a href="#Java语言特点" class="headerlink" title="Java语言特点"></a>Java语言特点</h2><h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><blockquote>
<p>1、面向对象（具有封装、继承、多态等特性）</p>
<p>2、平台无关性（JVM的实现使得Java具有平台无关性）</p>
<p>3、可靠性、安全性</p>
<p>4、提供了多线程支持</p>
<p>5、支持网络编程且十分方便</p>
<p>6、编译与解释并存：Java程序要经过先编译、后解释两个步骤。（<code>.java</code>源文件先经过JDK中的<code>javac</code>命令<strong>编译</strong>生成字节码文件<code>*.class</code>，再经过JVM<strong>解释</strong>进行执行）</p>
</blockquote>
<h3 id="与C-的区别"><a href="#与C-的区别" class="headerlink" title="与C++的区别"></a>与C++的区别</h3><blockquote>
<p>1、Java不提供指针来直接访问内存，程序内存更安全</p>
<p>2、Java的类是单继承的，而C++支持多继承</p>
<p>3、Java有自动内存管理垃圾回收机制（GC），不需要手动释放无用内存</p>
<p>4、Java的字符串与字符数组最后没有一个额外的字符<code>\0</code>来表示结束（Java字符串与数组都可以理解为类，预先知道大小，所以不需要结束字符）</p>
</blockquote>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="命令行编译"><a href="#命令行编译" class="headerlink" title="命令行编译"></a>命令行编译</h3><p>利用<code>javac</code>和<code>java</code>能够实现对<code>.java</code>文件进行编译和运行</p>
<p><code>javac</code>程序是一个Java编译器，将<code>*.java</code>编译成<code>*.class</code>（需要<code>.java</code>后缀）</p>
<p><code>java</code>程序启动Java虚拟机（只需要指定类名）</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">javac </span>Main.<span class="hljs-keyword">java<br></span><span class="hljs-keyword">java </span>Main<br></code></pre></td></tr></table></figure>

<p>如下编译运行一个helloworld程序：</p>
<p><img src="http://cdn.ziyedy.top/1%E3%80%81Java%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9/javac.png" alt=""></p>
<h3 id="反编译"><a href="#反编译" class="headerlink" title="反编译"></a>反编译</h3><p>使用<code>javap</code>能够对<code>.class</code>文件进行反编译，通过该命令能够有效了解JVM的内部原理</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">javap	</span><span class="hljs-comment"># 对其进行反编译（得到近似的Java源码）</span><br><span class="hljs-keyword">javap </span>-c	<span class="hljs-comment"># 对其进行反汇编</span><br><span class="hljs-keyword">javap </span>-verbose	<span class="hljs-comment"># 最常用，显示附加信息</span><br></code></pre></td></tr></table></figure>

<p>如下反编译之前的helloworld程序</p>
<p><img src="http://cdn.ziyedy.top/1%E3%80%81Java%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9/javap.png" alt=""></p>
<p>而加上<code>-verbose</code>则可以显示详细信息，辅助代码分析</p>
<p><img src="http://cdn.ziyedy.top/1%E3%80%81Java%EF%BC%9A%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E8%AF%AD%E8%A8%80%E7%89%B9%E7%82%B9/javap-v.png" alt=""></p>
<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>Java编译器在编译代码之前会把代码中的所有注释抹掉，字节码中不保留注释</p>
<ol>
<li><p>单行注释：<code>//</code></p>
</li>
<li><p>多行注释：<code>/* */</code></p>
</li>
<li><p>文档注释：<code>/** */</code></p>
</li>
</ol>
<h2 id="常用关键字"><a href="#常用关键字" class="headerlink" title="常用关键字"></a>常用关键字</h2><h3 id="final——（最终，不可改变）"><a href="#final——（最终，不可改变）" class="headerlink" title="final——（最终，不可改变）"></a>final——（最终，不可改变）</h3><h4 id="修饰数据"><a href="#修饰数据" class="headerlink" title="修饰数据"></a>修饰数据</h4><blockquote>
<p>声明数据为常量（不能再次赋值），可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
</blockquote>
<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
</ul>
<h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><blockquote>
<p>声明方法不能被子类重写。</p>
</blockquote>
<p>其中，<strong>private方法隐式的被指定为final</strong>。如果在子类中定义的方法和父类中的一个private方法相同，则视为子类中定义了一个新方法。</p>
<h4 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h4><blockquote>
<p>声明类不能被继承</p>
</blockquote>
<h3 id="static——（静态）"><a href="#static——（静态）" class="headerlink" title="static——（静态）"></a>static——（静态）</h3><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><blockquote>
<p>又称为类变量，类所有的实例都共享静态变量，可以直接通过类名来访问它（<em>只依赖于类存在，不依赖于对象实例存在</em>）。</p>
<p>静态变量在内存中<strong>只存在一份</strong>，所有的对象实例共享。</p>
</blockquote>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">A</span>() &#123;<br>	<span class="hljs-keyword">private</span> static <span class="hljs-built_in">int</span> x;	<span class="hljs-comment">// 静态变量</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><blockquote>
<p>静态方法在类加载的时候就存在了，它<strong>不依赖于任何实例</strong>。所以静态方法<strong>必须有实现</strong>，也就是说它不能是抽象方法。</p>
<p>同时，静态方法<em>只能访问所属类的静态字段和静态方法</em>。</p>
<p>main方法就是静态方法</p>
</blockquote>
<p><strong>方法中不能有this和super关键字</strong>（这两个关键字与具体对象关联，而静态方法是不依赖于实例的）</p>
<h4 id="静态语句块"><a href="#静态语句块" class="headerlink" title="静态语句块"></a>静态语句块</h4><blockquote>
<p>只在类第一次被加载时调用（程序运行期间，这段代码只运行一次）</p>
<p>执行顺序：static块 &gt; 普通匿名块 &gt; 构造函数</p>
</blockquote>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">test</span> &#123;</span><br>    static &#123;<br>        System.out.println(<span class="hljs-string">"gg"</span>);<br>    &#125;<br><br>    public static void main(String[] args) &#123;<br>    &#125;<br>&#125;<br>/<span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span><span class="hljs-regexp">//</span> <br>gg<br></code></pre></td></tr></table></figure>

<h4 id="静态内部类（使用的很少）"><a href="#静态内部类（使用的很少）" class="headerlink" title="静态内部类（使用的很少）"></a>静态内部类（使用的很少）</h4><p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法。</p>
<h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h3><p>该关键字常用来修饰类变量，其所修饰的变量是不需要序列化的（在序列化时会自动忽略该变量）</p>
<p>比如 <code>ArrayList</code> 中存储数据的数组就使用了该关键字修饰：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">transient</span> Object[] elementData; <span class="hljs-comment">// non-private to simplify nested class access</span><br></code></pre></td></tr></table></figure>



<h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><h3 id="package关键字"><a href="#package关键字" class="headerlink" title="package关键字"></a>package关键字</h3><blockquote>
<p>package包与C++中的<code>namespace</code>类似</p>
<p>Java中常用域名倒序的方法来定义包名，一个Java源文件中只能有一个package语句</p>
</blockquote>
<h3 id="import关键字"><a href="#import关键字" class="headerlink" title="import关键字"></a>import关键字</h3><blockquote>
<p>用于引入Java不同包中的类，放置在<code>package</code>之后，类定义之前</p>
</blockquote>
<h3 id="jar文件"><a href="#jar文件" class="headerlink" title="jar文件"></a>jar文件</h3><blockquote>
<p>jar文件是一组class文件的压缩包，易于传播（其中可以包含很多Java类），且能够有效保护源码（其中不包含.java文件）</p>
<p>可以利用IDE打包jar文件，也可以使用<code>jar.exe</code>命令进行打包</p>
</blockquote>
<blockquote>
<p>参考：</p>
<p><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p>
<p>《Java核心技术卷1》</p>
<p>mooc华东师范大学Java核心技术课程</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>python常见问题</title>
    <url>/page/python-common-method.html</url>
    <content><![CDATA[<h2 id="项目常用"><a href="#项目常用" class="headerlink" title="项目常用"></a>项目常用</h2><h3 id="生成requirements-txt"><a href="#生成requirements-txt" class="headerlink" title="生成requirements.txt"></a>生成requirements.txt</h3><p>使用<code>pipreqs</code>生成requirements</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 安装</span><br>pip install pipreqs<br><span class="hljs-comment"># 在当前目录生成（若存在即覆盖）</span><br>pipreqs . <span class="hljs-params">--encoding=utf8</span> <span class="hljs-params">--force</span><br></code></pre></td></tr></table></figure>

<p>使用requirement.txt安装依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs \">pip install -r requirements.txt<br></code></pre></td></tr></table></figure>



<h2 id="pythonic的编码方式"><a href="#pythonic的编码方式" class="headerlink" title="pythonic的编码方式"></a>pythonic的编码方式</h2><h3 id="变量的交换"><a href="#变量的交换" class="headerlink" title="变量的交换"></a>变量的交换</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span>, <span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">b</span>, a<br></code></pre></td></tr></table></figure>



<h3 id="利用百分号语法进行字符串格式化"><a href="#利用百分号语法进行字符串格式化" class="headerlink" title="利用百分号语法进行字符串格式化"></a>利用百分号语法进行字符串格式化</h3><figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">a = <span class="hljs-string">'Curry'</span><br>b = <span class="hljs-string">'Player'</span><br>print(<span class="hljs-string">"%s is the best %s"</span> % (a,b))<br>#################<br>Curry is the best Player<br></code></pre></td></tr></table></figure>



<h3 id="将两个字典合并（解包操作）"><a href="#将两个字典合并（解包操作）" class="headerlink" title="将两个字典合并（解包操作）"></a>将两个字典合并（解包操作）</h3><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">a</span> = &#123;&#125;<br><span class="hljs-attr">b</span> = &#123;&#125;<br><span class="hljs-attr">c</span> = &#123;**a, **b&#125;	<span class="hljs-comment"># 解包</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>BOM基本内容</title>
    <url>/page/js-bom-basic-handle.html</url>
    <content><![CDATA[<h2 id="常见的BOM对象"><a href="#常见的BOM对象" class="headerlink" title="常见的BOM对象"></a>常见的BOM对象</h2><p>BOM可以让我们通过JS来操作浏览器。BOM中为我们提供了一些对象，来完成对浏览器相关的操作。</p>
<p>常见的 BOM对象有：</p>
<ul>
<li><p>Window：代表整个浏览器的窗口，同时 window 也是<strong>网页中的全局对象</strong>。</p>
</li>
<li><p>Navigator：代表当前浏览器的信息，通过该对象可以识别不同的浏览器。</p>
</li>
<li><p>Location：代表当前浏览器的地址栏信息，通过 Location 可以获取地址栏信息，或者操作浏览器跳转页面。</p>
</li>
<li><p>History：代表浏览器的历史记录，通过该对象可以操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效。</p>
</li>
<li><p>Screen：代表用户的屏幕信息，通过该对象可以获取用户的显示器的相关信息。</p>
</li>
</ul>
<p>备注：这些 BOM 对象都是<strong>作为 window 对象的属性</strong>保存的，可以通过window对象来使用，也可以直接使用。比如说，我可以使用 <code>window.location.href</code>，也可以直接使用 <code>location.href</code>，二者是等价的。</p>
<p>备注2：不要忘了，之前学习过的<code>document</code>也是在<code>window</code>中保存的。</p>
<h2 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h2><p>Navigator代表当前浏览器的信息，通过该对象可以识别不同的浏览器。</p>
<p>通常使用<code>navigator.userAgent</code>来获取浏览器信息</p>
<h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><p>History对象：可以用来操作浏览器的向前或向后翻页。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>获取浏览器历史列表中的 url 数量。注意，只是统计当次的数量，如果浏览器关了，数量会重置为1。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">history.<span class="hljs-built_in">length</span><br></code></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>回退到上一个页面，作用和浏览器的「回退按钮」一样。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">history.back()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>跳转下一个页面，作用和浏览器的「前进按钮」一样。</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">history.forward()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><strong>go方法</strong></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// 向前跳转2个页面</span><br>history.go( <span class="hljs-number">2</span> );<br><br><span class="hljs-comment">// 向后跳转2个页面</span><br>history.go( <span class="hljs-number">-2</span> );<br><br><span class="hljs-comment">// 刷新当前页面</span><br>history.go( <span class="hljs-number">0</span> );<br></code></pre></td></tr></table></figure>



<h2 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h2><p>Location 对象：封装了浏览器地址栏的 URL 信息。</p>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><p>获取当前页面的 url 路径</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">location</span><span class="hljs-selector-class">.href</span><br></code></pre></td></tr></table></figure>

<p>也可以通过设置该属性的方法使页面跳转</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">location.href</span> = <span class="hljs-string">'ziyedy.top'</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>用来跳转到其他的页面，作用和直接修改<code>location.href</code>一样。</p>
<figure class="highlight openscad"><table><tr><td class="code"><pre><code class="hljs openscad">location.<span class="hljs-built_in">assign</span>(<span class="hljs-built_in">str</span>);<br></code></pre></td></tr></table></figure>

<p>用于重新加载当前页面，作用和刷新按钮一样。在方法的参数中传递一个true，则会强制清空缓存刷新页面.</p>
<figure class="highlight glsl"><table><tr><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">location</span>.reload();<br><span class="hljs-keyword">location</span>.reload(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure>

<p>使用一个新的页面替换当前页面，调用完毕也会跳转页面。但不会生成历史记录，不能使用「后退按钮」后退。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">location</span>.replace();<br></code></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>2、DOM节点基本操作</title>
    <url>/page/js-dom-basic-handle.html</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p><strong>节点</strong>（Node）：构成 HTML 网页的最基本单元。网页中的每一个部分都可以称为是一个节点，比如：html标签、属性、文本、注释、整个文档等都是一个节点。</p>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p><strong>DOM</strong>：Document Object Model，文档对象模型。DOM 为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构。目的其实就是为了能让js操作html元素而制定的一个规范。</p>
<p><strong>解析过程</strong>：HTML加载完毕，渲染引擎会在内存中把HTML文档，生成一个DOM树。</p>
<h3 id="文档的加载"><a href="#文档的加载" class="headerlink" title="文档的加载"></a>文档的加载</h3><p>浏览器在加载一个页面时，是按照自上向下的顺序加载的，读取到一行就运行一行。如果将script标签写到页面的上边，在代码执行时，页面及DOM对象还没有加载，会导致无法获取到DOM对象。</p>
<p>onload 事件会在整个页面加载完成之后才触发。为 window 绑定一个onload事件，该事件对应的响应函数将会在页面加载完成之后执行，这样可以确保我们的代码执行时所有的DOM对象已经加载完毕了。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h2><h3 id="通过元素获取节点"><a href="#通过元素获取节点" class="headerlink" title="通过元素获取节点"></a>通过元素获取节点</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 获取id为“id1”的元素（id唯一）</span><br><span class="hljs-keyword">var</span> id1 = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"id1"</span>);<br></code></pre></td></tr></table></figure>

<h3 id="通过标签名获取节点"><a href="#通过标签名获取节点" class="headerlink" title="通过标签名获取节点"></a>通过标签名获取节点</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 获取标签名为div的 元素节点数组（标签名不唯一）</span><br><span class="hljs-keyword">var</span> div1 = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"div"</span>);<br><span class="hljs-comment">// 获取该数组中第一个元素</span><br><span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">"div1"</span>)[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure>

<h3 id="通过类名获取节点"><a href="#通过类名获取节点" class="headerlink" title="通过类名获取节点"></a>通过类名获取节点</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 获取类名为 class1 的元素节点数组</span><br><span class="hljs-keyword">var</span> class1 = <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">"class1"</span>);<br><span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">"class1"</span>)[<span class="hljs-number">0</span>];<br></code></pre></td></tr></table></figure>

<h3 id="querySelector-方法"><a href="#querySelector-方法" class="headerlink" title="querySelector()方法"></a>querySelector()方法</h3><figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(css选择器);<br><br><span class="hljs-comment">// 获取文档中有 "target" 属性的第一个 &lt;a&gt; 元素</span><br><span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelector</span>(<span class="hljs-string">"a[target]"</span>);<br><br><span class="hljs-comment">// 找到符合条件的所有元素</span><br><span class="hljs-built_in">document</span>.<span class="hljs-built_in">querySelectorAll</span>(css选择器);<br></code></pre></td></tr></table></figure>





<h2 id="遍历节点"><a href="#遍历节点" class="headerlink" title="遍历节点"></a>遍历节点</h2><p>遍历操作如下，用红框圈起来的方法功能是一样的，只是在不同版本的浏览器中兼容不同，建议使用红框中第二种方法</p>
<p><img src="http://cdn.ziyedy.top/image/DOM%E8%8A%82%E7%82%B9%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/%E9%81%8D%E5%8E%86%E8%8A%82%E7%82%B9.png" alt=""></p>
<h3 id="获取父节点"><a href="#获取父节点" class="headerlink" title="获取父节点"></a>获取父节点</h3><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">节点<span class="hljs-selector-class">.parentNode</span><br></code></pre></td></tr></table></figure>

<h3 id="获取兄弟节点"><a href="#获取兄弟节点" class="headerlink" title="获取兄弟节点"></a>获取兄弟节点</h3><h4 id="下一个兄弟节点"><a href="#下一个兄弟节点" class="headerlink" title="下一个兄弟节点"></a>下一个兄弟节点</h4><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">下一个兄弟节点 = 节点<span class="hljs-string">.nextElementSibling</span> || 节点<span class="hljs-string">.nextSibling</span><br></code></pre></td></tr></table></figure>

<h4 id="上一个兄弟节点"><a href="#上一个兄弟节点" class="headerlink" title="上一个兄弟节点"></a>上一个兄弟节点</h4><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">上一个兄弟节点 = 节点<span class="hljs-string">.previousElementSibling</span> || 节点<span class="hljs-string">.previousSibling</span><br></code></pre></td></tr></table></figure>

<h4 id="任意兄弟节点"><a href="#任意兄弟节点" class="headerlink" title="任意兄弟节点"></a>任意兄弟节点</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">节点<span class="hljs-selector-class">.parentNode</span><span class="hljs-selector-class">.children</span><span class="hljs-selector-attr">[index]</span>;<br></code></pre></td></tr></table></figure>

<h3 id="获取子节点"><a href="#获取子节点" class="headerlink" title="获取子节点"></a>获取子节点</h3><h4 id="第一个-最后一个"><a href="#第一个-最后一个" class="headerlink" title="第一个/最后一个"></a>第一个/最后一个</h4><figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli">第一个子元素节点 = 节点<span class="hljs-string">.firstElementChild</span> || 节点<span class="hljs-string">.firstChild</span><br><br>最后一个子元素节点 = 节点<span class="hljs-string">.lastElementChild</span> || 节点<span class="hljs-string">.lastChild</span><br></code></pre></td></tr></table></figure>

<h4 id="获取所有子节点"><a href="#获取所有子节点" class="headerlink" title="获取所有子节点"></a>获取所有子节点</h4><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">子节点数组 = 父节点.childNodes<span class="hljs-comment">; </span><br><br>子节点数组 = 父节点.children<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>



<h2 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">新的标签(元素节点) = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"标签名"</span>);<br><br>文本节点 = <span class="hljs-built_in">document</span>.createTextNode(文本)<br><br>文本片段 = <span class="hljs-built_in">document</span>.createDocumentFragment();<br></code></pre></td></tr></table></figure>

<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"myList"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><br>        <span class="hljs-keyword">var</span> fragment = <span class="hljs-built_in">document</span>.createDocumentFragment();<br>        <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"myList"</span>);<br>        <span class="hljs-keyword">var</span> li = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++) &#123;<br>            li = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">"li"</span>);<br>            li.appendChild(<span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">"Item"</span> + (i+<span class="hljs-number">1</span>)));<br>            fragment.appendChild(li);<br>        &#125;<br>        ul.appendChild(fragment);<br>    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="http://cdn.ziyedy.top/image/DOM%E8%8A%82%E7%82%B9%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9.png" alt=""></p>
<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><h4 id="在最后插入一个子节点"><a href="#在最后插入一个子节点" class="headerlink" title="在最后插入一个子节点"></a>在最后插入一个子节点</h4><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">父节点.appendChild(新的子节点)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h4 id="在参考节点前插入一个新的节点"><a href="#在参考节点前插入一个新的节点" class="headerlink" title="在参考节点前插入一个新的节点"></a>在参考节点前插入一个新的节点</h4><figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">父节点<span class="hljs-selector-class">.insertBefore</span>(新的子节点,作为参考的子节点)<br></code></pre></td></tr></table></figure>



<h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">父节点.removeChild(子节点)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>



<h2 id="操作节点属性"><a href="#操作节点属性" class="headerlink" title="操作节点属性"></a>操作节点属性</h2><p>操作节点属性都有以下两种方法，但一定不能混用，</p>
<h3 id="获取节点的属性值"><a href="#获取节点的属性值" class="headerlink" title="获取节点的属性值"></a>获取节点的属性值</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">元素节点.属性名<span class="hljs-comment">;</span><br>元素节点[属性名]<span class="hljs-comment">;</span><br>	<br>元素节点.getAttribute(<span class="hljs-string">"属性名称"</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="设置节点属性值"><a href="#设置节点属性值" class="headerlink" title="设置节点属性值"></a>设置节点属性值</h3><figure class="highlight pf"><table><tr><td class="code"><pre><code class="hljs pf">元素节点.属性名 = 新属性值;<br>元素节点[属性名] = 新属性值;<br><br>元素节点.<span class="hljs-built_in">set</span>Attribute(<span class="hljs-string">"属性名"</span>, <span class="hljs-string">"新的属性值"</span>);<br></code></pre></td></tr></table></figure>

<h3 id="删除节点的属性"><a href="#删除节点的属性" class="headerlink" title="删除节点的属性"></a>删除节点的属性</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">元素节点.removeAttribute(属性名)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="类名的增删操作"><a href="#类名的增删操作" class="headerlink" title="类名的增删操作"></a>类名的增删操作</h3><figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">Node</span>.<span class="hljs-title">classList</span>.add(<span class="hljs-string">"class"</span>) // 添加class<br><br><span class="hljs-keyword">Node</span>.<span class="hljs-title">classList</span>.remove(<span class="hljs-string">"class"</span>) // 移除class<br><br><span class="hljs-keyword">Node</span>.<span class="hljs-title">classList</span>.toggle(<span class="hljs-string">"class"</span>) // 切换class，有则移除，无则添加<br><br><span class="hljs-keyword">Node</span>.<span class="hljs-title">classList</span>.contains(<span class="hljs-string">"class"</span>) // 检测是否存在class<br></code></pre></td></tr></table></figure>





<h2 id="DOM的一些常见属性"><a href="#DOM的一些常见属性" class="headerlink" title="DOM的一些常见属性"></a>DOM的一些常见属性</h2><h3 id="nodeType属性"><a href="#nodeType属性" class="headerlink" title="nodeType属性"></a>nodeType属性</h3><ul>
<li><p>nodeType == 1  表示的是元素节点（标签） 。记住：在这里，元素就是标签。</p>
</li>
<li><p>nodeType == 2  表示是属性节点。</p>
</li>
<li><p>nodeType == 3  是文本节点。</p>
</li>
</ul>
<h3 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h3><p>获取标签本身的html，也可以<strong>通过赋值变相的添加节点</strong></p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"content"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><span class="xml"><br>    </span><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"><br>        <span class="hljs-keyword">var</span> content = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"content"</span>);<br>        <span class="hljs-keyword">var</span> str = <span class="hljs-string">"ui * 2 li"</span><br>                    + <span class="hljs-string">"</span></span></span><span class="xml"><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>"<br>                    + "</span></span></span><span class="xml"><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span> Item 1 <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span></span><span class="xml">"<br>                    + "</span><span class="xml"><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span> Item 2 <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span></span></span><span class="xml"><span class="handlebars"><span class="xml">"<br>                    + "<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span></span></span><span class="xml">";<br>        content.innerHTML = str;<br>        alert(content.innerHTML);<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><span class="xml"><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>如图可见，div内部已经多出了我们添加的元素</p>
<p><img src="http://cdn.ziyedy.top/image/DOM%E8%8A%82%E7%82%B9%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/innerHTML.png" alt=""></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>路径操作常用模块（os与pathlib）</title>
    <url>/page/Python-path-operation.html</url>
    <content><![CDATA[<h2 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h2><h3 id="模块简介"><a href="#模块简介" class="headerlink" title="模块简介"></a>模块简介</h3><blockquote>
<p>os模块是Python标准库中的一个用于<strong>访问操作系统功能</strong>的模块。使用os模块中提供的接口可以实现跨平台访问。</p>
</blockquote>
<h3 id="系统操作"><a href="#系统操作" class="headerlink" title="系统操作"></a>系统操作</h3><p>os.sep：用于系统路径的分隔符。Windows为“\\”，Linux为“/”。</p>
<p>os.name：指示正在使用的工作平台。Windows为‘nt’，Linux为‘posix’。</p>
<p>os.getenv(‘path’)：读取环境变量名称</p>
<p>os.getcwd()：获取当前路径</p>
<p>os.getpid()：获取当前进程ID</p>
<h4 id="os-system"><a href="#os-system" class="headerlink" title="os.system"></a>os.system</h4><blockquote>
<p>将字符串转化为命令行在操作系统上执行。每次执行system函数，会创建一个子进程在系统上执行命令（<strong>子进程的执行结果无法影响主进程</strong>）</p>
</blockquote>
<h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p><strong>os.listdir(path)</strong>：列出指定目录下的所有文件和子目录，包括隐藏文件；参数为空，为当前目录，返回一个列表。</p>
<p>os.mkdir()：创建一个目录。</p>
<p>os.rmdir()：删除一个空目录，如果该目录中有文件则删除不了。</p>
<p>*<em>os.rename(src, dst) *</em>：用于重命名文件或目录，从src改为dst。若运行出错会抛出OSError。</p>
<h3 id="Path模块"><a href="#Path模块" class="headerlink" title="Path模块"></a>Path模块</h3><p>os.path.exists(path)：判断文件或者目录是否存在。存在返回True，不存在返回False。</p>
<p>os.path.isfile(path)：判断是否为文件。是返回True，不是返回False。</p>
<p>os.path.isdir(path)：判断是否为目录。是返回True，不是返回False。</p>
<p>os.path.abspath()：返回绝对路径</p>
<p>os.path.realpath(_<em>file_</em>)：获取当前.py文件的目录</p>
<p>os.path.dirname()：返回文件路径</p>
<p>os.path.basename(path) ：返回文件名</p>
<p>os.path.split(path) ：拆分路径dirname和basename，返回为元组</p>
<p><strong>os.path.splitext(‘’)</strong>：将文件名与后缀名分开</p>
<p><strong>os.path.join(path, name)</strong>：连接目录与文件名或目录</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> os<br><br>file_path = os.path.realpath(__file__)  # 该py文件目录<br>print(file_path)<br>print(os.path.dirname(file_path))   # 上级目录<br>print(os.path.basename(file_path))  # py文件名称<br>print(os.path.split(file_path)) # 分割目录与名称<br><br>##############################################<br>C:\Users\lenovo\Desktop\vega\gg.py<br>C:\Users\lenovo\Desktop\vega<br>gg.py<br>(<span class="hljs-string">'C:\\Users\\lenovo\\Desktop\\vega'</span>, <span class="hljs-string">'gg.py'</span>)<br></code></pre></td></tr></table></figure>



<h3 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h3><p>1、将某一路径下的文件名称中的广告部分去除并填上文件后缀名</p>
<figure class="highlight lua"><table><tr><td class="code"><pre><code class="hljs lua">def <span class="hljs-built_in">rename</span>():<br>    <span class="hljs-built_in">path</span> = <span class="hljs-string">'你的路径'</span><br>    file_list = <span class="hljs-built_in">os</span>.listdir(<span class="hljs-built_in">path</span>)	# 得到文件名列表<br>    <span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> file_list:<br>        old_dir = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(<span class="hljs-built_in">path</span>, file)	#得到初始路径<br>        # 若该文件名为路径，则继续遍历<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.isdir(old_dir):<br>            continue<br>        file_name = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.splitext(file)[<span class="hljs-number">0</span>]<br>        # 在该处进行文件名的字符串更改操作<br>        file_type = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.splitext(file)[<span class="hljs-number">1</span>]<br>        # 在该处变更文件的后缀<br>        file_name = file_name+file_type<br>        new_dir = <span class="hljs-built_in">os</span>.<span class="hljs-built_in">path</span>.join(<span class="hljs-built_in">path</span>, file_name)	# 新的路径<br>        <span class="hljs-built_in">os</span>.<span class="hljs-built_in">rename</span>(old_dir, new_dir)	# 完成文件的重命名<br></code></pre></td></tr></table></figure>



<h2 id="pathlib模块"><a href="#pathlib模块" class="headerlink" title="pathlib模块"></a>pathlib模块</h2><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">from</span> pathlib <span class="hljs-keyword">import</span> <span class="hljs-type">Path</span><br></code></pre></td></tr></table></figure>

<h4 id="列出子目录"><a href="#列出子目录" class="headerlink" title="列出子目录"></a>列出子目录</h4><figure class="highlight sml"><table><tr><td class="code"><pre><code class="hljs sml"><span class="hljs-type">In</span>[<span class="hljs-number">5</span>]: p = <span class="hljs-type">Path</span>(<span class="hljs-symbol">'C</span>:\\<span class="hljs-type">Users</span>\\lenovo\\.keras\\datasets\\flower_photos')<br><span class="hljs-type">In</span>[<span class="hljs-number">6</span>]: [x for x <span class="hljs-keyword">in</span> p.iterdir<span class="hljs-literal">()</span> <span class="hljs-keyword">if</span> x.is_dir<span class="hljs-literal">()</span>]<br><span class="hljs-type">Out</span>[<span class="hljs-number">6</span>]: <br>[<span class="hljs-type">WindowsPath</span>(<span class="hljs-symbol">'C</span>:/<span class="hljs-type">Users</span>/lenovo/.keras/datasets/flower_photos/daisy'),<br> <span class="hljs-type">WindowsPath</span>(<span class="hljs-symbol">'C</span>:/<span class="hljs-type">Users</span>/lenovo/.keras/datasets/flower_photos/dandelion'),<br> <span class="hljs-type">WindowsPath</span>(<span class="hljs-symbol">'C</span>:/<span class="hljs-type">Users</span>/lenovo/.keras/datasets/flower_photos/roses'),<br> <span class="hljs-type">WindowsPath</span>(<span class="hljs-symbol">'C</span>:/<span class="hljs-type">Users</span>/lenovo/.keras/datasets/flower_photos/sunflowers'),<br> <span class="hljs-type">WindowsPath</span>(<span class="hljs-symbol">'C</span>:/<span class="hljs-type">Users</span>/lenovo/.keras/datasets/flower_photos/tulips')]<br></code></pre></td></tr></table></figure>

<h4 id="获取当前目录下所有文件与文件夹"><a href="#获取当前目录下所有文件与文件夹" class="headerlink" title="获取当前目录下所有文件与文件夹"></a>获取当前目录下所有文件与文件夹</h4><figure class="highlight sml"><table><tr><td class="code"><pre><code class="hljs sml"><span class="hljs-type">In</span>[<span class="hljs-number">7</span>]: <span class="hljs-built_in">list</span>(p.glob(<span class="hljs-string">'*/'</span>))<br><span class="hljs-type">Out</span>[<span class="hljs-number">7</span>]: <br>[<span class="hljs-type">WindowsPath</span>(<span class="hljs-symbol">'C</span>:/<span class="hljs-type">Users</span>/lenovo/.keras/datasets/flower_photos/daisy'),<br> <span class="hljs-type">WindowsPath</span>(<span class="hljs-symbol">'C</span>:/<span class="hljs-type">Users</span>/lenovo/.keras/datasets/flower_photos/dandelion'),<br> <span class="hljs-type">WindowsPath</span>(<span class="hljs-symbol">'C</span>:/<span class="hljs-type">Users</span>/lenovo/.keras/datasets/flower_photos/<span class="hljs-type">LICENSE</span>.txt'),<br> <span class="hljs-type">WindowsPath</span>(<span class="hljs-symbol">'C</span>:/<span class="hljs-type">Users</span>/lenovo/.keras/datasets/flower_photos/roses'),<br> <span class="hljs-type">WindowsPath</span>(<span class="hljs-symbol">'C</span>:/<span class="hljs-type">Users</span>/lenovo/.keras/datasets/flower_photos/sunflowers'),<br> <span class="hljs-type">WindowsPath</span>(<span class="hljs-symbol">'C</span>:/<span class="hljs-type">Users</span>/lenovo/.keras/datasets/flower_photos/tulips')]<br></code></pre></td></tr></table></figure>

<h4 id="路径拼接"><a href="#路径拼接" class="headerlink" title="路径拼接"></a>路径拼接</h4><figure class="highlight taggerscript"><table><tr><td class="code"><pre><code class="hljs taggerscript">In[9]: q = p / 'daisy'<br>In[10]: print(q)<br>C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\l</span>enovo<span class="hljs-symbol">\.</span>keras<span class="hljs-symbol">\d</span>atasets<span class="hljs-symbol">\f</span>lower_photos<span class="hljs-symbol">\d</span>aisy<br></code></pre></td></tr></table></figure>

<h4 id="查询属性"><a href="#查询属性" class="headerlink" title="查询属性"></a>查询属性</h4><p>路径是否存在与是否是路径</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">In</span><span class="hljs-selector-attr">[11]</span>: <span class="hljs-selector-tag">q</span><span class="hljs-selector-class">.exists</span>()<br><span class="hljs-selector-tag">Out</span><span class="hljs-selector-attr">[11]</span>: <span class="hljs-selector-tag">True</span><br><span class="hljs-selector-tag">In</span><span class="hljs-selector-attr">[12]</span>: <span class="hljs-selector-tag">q</span><span class="hljs-selector-class">.is_dir</span>()<br><span class="hljs-selector-tag">Out</span><span class="hljs-selector-attr">[12]</span>: <span class="hljs-selector-tag">True</span><br></code></pre></td></tr></table></figure>





<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://docs.python.org/zh-cn/3/library/pathlib.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/pathlib.html</a></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>常用模块</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的一些语言特性与机制</title>
    <url>/page/python8.html</url>
    <content><![CDATA[<p>代码高效、程序健壮</p>
<p>值的类型，引用类型</p>
<p>内存共享机制</p>
<p>垃圾回收机制</p>
<p>以引用计数为主，分代收集为辅</p>
<p>每个对象都有指向该对象的引用总数</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">sys</span><span class="hljs-selector-class">.getrefcount</span>()<br></code></pre></td></tr></table></figure>

<p>满足特定条件，自动启动垃圾回收</p>
<p>Python运行时，会记录分配对象与取消分配对象的次数。当两者差值高过阈值时。</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 查看阈值</span><br>gc.get_threshold()<br></code></pre></td></tr></table></figure>

<p>所有新建对象都是0代对象。所有对象分为0，1，2代。当某一代对象经历过垃圾回收，依然存活，则被归入下一代</p>
<p>若一个对象的引用数为0，Python虚拟机就会回收这个对象的内存</p>
<p>引用计数的缺陷是循环引用的问题</p>
<p>递归运行时报错“RecursionError”。这是python默认的递归深度是很有限的（默认是1000），因此当递归深度超过999的样子，就会引发这样的一个异常。</p>
<p>解决方法：首先考虑对代码进行优化，其次也可以考虑将递归深度的数值调大一些。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">import</span> sys<br>sys.setrecursionlimit(<span class="hljs-number">100000</span>) #你想设置的递归深度（可为任意值）<br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Git出现的报错合集</title>
    <url>/page/git_error.html</url>
    <content><![CDATA[<h3 id="Git-fatal-refusing-to-merge-unrelated-histories解决"><a href="#Git-fatal-refusing-to-merge-unrelated-histories解决" class="headerlink" title="Git: fatal: refusing to merge unrelated histories解决"></a>Git: fatal: refusing to merge unrelated histories解决</h3><p>今天<code>git pull</code>时出现这个错误（在连接远程库与本地库时在远程库上进行了一些删除操作）。原因是两个分支为两个不同的版本，有不同的提交历史，使用以下语句进行强制合并即可解决这个问题。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">$git pull origin <span class="hljs-keyword">master</span> <span class="hljs-title">--allow-unrelated-histories</span><br></code></pre></td></tr></table></figure>



<h3 id="fatal-remote-origin-already-exists"><a href="#fatal-remote-origin-already-exists" class="headerlink" title="fatal: remote origin already exists"></a>fatal: remote origin already exists</h3><p>先将存在的库删除，再进行连接</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">git remote rm origin</span><br></code></pre></td></tr></table></figure>



<h3 id="non-fast-forward"><a href="#non-fast-forward" class="headerlink" title="non-fast-forward"></a>non-fast-forward</h3><p>没有对代码进行及时的同步产生的问题，应该先合并之前的历史，再进行提交</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">git fetch origin <span class="hljs-keyword">master</span><br><span class="hljs-title">git</span> merge origin FETCH_HEAD<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Python操作MySQL数据库</title>
    <url>/page/python-mysql-handle.html</url>
    <content><![CDATA[<p><strong>使用<code>mysql.connector</code>模块实现MySQL与Python的交互</strong></p>
<h3 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h3><p>代码示例如下</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">import mysql.connector<br><span class="hljs-built_in"><br>config </span>= &#123;<br>    <span class="hljs-string">"host"</span>: <span class="hljs-string">"localhost"</span>,<br>    <span class="hljs-string">"port"</span>: <span class="hljs-string">"3306"</span>,<br>    <span class="hljs-string">"user"</span>: <span class="hljs-string">"root"</span>,<br>    <span class="hljs-string">"password"</span>: <span class="hljs-string">"password"</span>,<br>    <span class="hljs-string">"database"</span>: <span class="hljs-string">"demo"</span><br>&#125;<br><br>con = mysql.connector.connect(*<span class="hljs-number">*c</span>onfig)<br><br>con.close()<br></code></pre></td></tr></table></figure>





<h3 id="游标（Cursor）"><a href="#游标（Cursor）" class="headerlink" title="游标（Cursor）"></a>游标（Cursor）</h3><p><code>mysql.connector</code>中使用游标来执行SQL语句，并且查询结果也会保存在游标中</p>
<h4 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h4><figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">curser = <span class="hljs-keyword">con</span>.<span class="hljs-built_in">cursor</span>()<br>curser.<span class="hljs-keyword">execute</span>()<br></code></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim">curser = <span class="hljs-keyword">con</span>.<span class="hljs-built_in">cursor</span>()<br>sql = <span class="hljs-string">"SELECT ename FROM t_emp;"</span><br>curser.<span class="hljs-keyword">execute</span>(sql)<br><span class="hljs-keyword">for</span> one in curser:<br>    <span class="hljs-keyword">print</span>(one[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure>



<p>事务控制</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">con</span><span class="hljs-selector-class">.start_transaction</span>()<br><span class="hljs-selector-tag">con</span><span class="hljs-selector-class">.commit</span>()<br><span class="hljs-selector-tag">con</span><span class="hljs-selector-class">.rollback</span>()<br></code></pre></td></tr></table></figure>

<p>异常处理</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-keyword">con</span> = mysql.connector.connect(**config)<br>    <span class="hljs-keyword">con</span>.start_transaction()<br>    <span class="hljs-keyword">con</span>.commit()<br>except Exception <span class="hljs-keyword">as</span> <span class="hljs-keyword">e</span>:<br>    <span class="hljs-keyword">con</span>.rollback()<br><span class="hljs-keyword">finally</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">"con"</span> in dir():<br>        <span class="hljs-keyword">con</span>.<span class="hljs-keyword">close</span>()<br></code></pre></td></tr></table></figure>



<p>数据库连接池</p>
<figure class="highlight nix"><table><tr><td class="code"><pre><code class="hljs nix"><span class="hljs-attr">pool</span> = mysql.connector.pooling.MySQLConnectionPool(<br>    **config,<br>    <span class="hljs-attr">pool_size=10</span><br>)<br><span class="hljs-attr">con</span> = pool.get_connection()<br></code></pre></td></tr></table></figure>



<h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3>]]></content>
      <categories>
        <category>编程相关</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>数据查询语言（DQL）</title>
    <url>/page/DQL.html</url>
    <content><![CDATA[<h2 id="SELECT——查询"><a href="#SELECT——查询" class="headerlink" title="SELECT——查询"></a>SELECT——查询</h2><h3 id="SELECT-FROM——基本句式（从XX表选择XX字段）"><a href="#SELECT-FROM——基本句式（从XX表选择XX字段）" class="headerlink" title="SELECT-FROM——基本句式（从XX表选择XX字段）"></a>SELECT-FROM——基本句式（从XX表选择XX字段）</h3><p>1、基本使用框架</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 数据表<br>[<span class="hljs-keyword">WHERE</span>]<br>[<span class="hljs-keyword">LIMIT</span>]<br>[<span class="hljs-keyword">OFFSET</span>]<br></code></pre></td></tr></table></figure>

<p>2、使用别名</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span><br>	字段名 <span class="hljs-keyword">AS</span> 别名<br><span class="hljs-keyword">FROM</span> 数据表 <span class="hljs-keyword">AS</span> 别名<br></code></pre></td></tr></table></figure>

<p>3、查询语句的执行顺序：</p>
<p>先进行语法分析和优化，找到关键字优先级，先执行FROM，再执行SELECT</p>
<h3 id="LIMIT-OFFSET——限制查询返回数量，跳过的数据条数"><a href="#LIMIT-OFFSET——限制查询返回数量，跳过的数据条数" class="headerlink" title="LIMIT-OFFSET——限制查询返回数量，跳过的数据条数"></a>LIMIT-OFFSET——限制查询返回数量，跳过的数据条数</h3><p>注意：<strong>检索出来的第一行是行0</strong></p>
<p>同时若指定的行数不够，则返回最多能返回的行。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># 返回n条数据</span><br>LIMIT n<br>LIMIT 0, n<br><span class="hljs-comment"># 跳过x条数据，之后返回n条数据（两者等价）</span><br>LIMIT x, n<br>LIMIT n OFFSET x<br></code></pre></td></tr></table></figure>





<h3 id="DISTINCT——去重"><a href="#DISTINCT——去重" class="headerlink" title="DISTINCT——去重"></a>DISTINCT——去重</h3><p>去除结果中的<strong>重复记录</strong>，在字段名称前加上<code>DISTINCT</code>字段，只支持一个字段名。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> 字段名 <span class="hljs-keyword">FROM</span> *;<br></code></pre></td></tr></table></figure>



<h3 id="ORDER-BY——排序"><a href="#ORDER-BY——排序" class="headerlink" title="ORDER BY——排序"></a>ORDER BY——排序</h3><p>注意：<strong><code>ORDER BY</code>必须位于<code>WHERE</code></strong>之后</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># 按照相关信息进行排序</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> * <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 列名 [<span class="hljs-keyword">ASC</span>|<span class="hljs-keyword">DESC</span>]<br><span class="hljs-comment"># 多个排序信息</span><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> * <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> 列名 [<span class="hljs-keyword">ASC</span>|<span class="hljs-keyword">DESC</span>],列名 [<span class="hljs-keyword">ASC</span>|<span class="hljs-keyword">DESC</span>]<br></code></pre></td></tr></table></figure>



<h2 id="GROUP-BY——分组查询"><a href="#GROUP-BY——分组查询" class="headerlink" title="GROUP BY——分组查询"></a>GROUP BY——分组查询</h2><h3 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h3><p>使用<strong>聚合函数</strong>。所谓聚合函数，也就是平均值、最大值等函数，以下为求该字段名下的平均值函数（AVG），其他函数使用方法与此类似。该类方法在实际使用时可以将统计结果作为一个子表进行查询。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">AVG</span>(字段名) <span class="hljs-keyword">FROM</span> 表名<br></code></pre></td></tr></table></figure>

<p><strong>COUNT(*)</strong>用于获得包含空值的记录数，<strong>COUNT(字段名)</strong>用于获取包含非空值的记录数。</p>
<h3 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h3><p><strong>分组查询</strong>，使用<code>GROUP BY</code>子句。即通过一定规则将数据集分为若干个部分进行查询处理。以下即为使用字段1进行分组统计每一组中字段2的平均值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,<span class="hljs-keyword">AVG</span>(字段<span class="hljs-number">2</span>) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 字段<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>使用分组查询SELECT语句中只能出现用以分组的字段以及其他字段的聚合函数，否则会报错（由于产生了<strong>一对多</strong>的关系）。为解决这个问题，可以使用<code>GROUP_CONCAT</code>函数，这个函数可以将符合条件的值连接起来进行输出，可以理解为将“多”的部分进行了字符串拼接。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,<span class="hljs-keyword">GROUP_CONCAT</span>(字段<span class="hljs-number">2</span>) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 字段<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<p>同时可以加上<code>WITH ROLLUP</code>再进行一次汇总运算（即在返回的查询结果之下再加上一条汇总记录）。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> 字段<span class="hljs-number">1</span>,<span class="hljs-keyword">AVG</span>(字段<span class="hljs-number">2</span>) <span class="hljs-keyword">FROM</span> 表名 <span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> 字段<span class="hljs-number">1</span> <span class="hljs-keyword">WITH</span> <span class="hljs-keyword">ROLLUP</span>;<br></code></pre></td></tr></table></figure>



<h3 id="HAVING——分组查询条件"><a href="#HAVING——分组查询条件" class="headerlink" title="HAVING——分组查询条件"></a>HAVING——分组查询条件</h3><p>为何要使用HAVING子句（与WHERE的区别）</p>
<p><strong>WHERE子句执行在GROUP BY子句之前</strong>，因此如果WHERE子句中出现了如平均值等信息时SQL会不知道在哪个范围内进行平均，即报错。所以需要使用<code>HAVING</code>子句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># 使用错误，WHERE不知道AVG作用范围</span><br><span class="hljs-keyword">SELECT</span> f1<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span><br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">AVG</span>(f2) &gt; <span class="hljs-number">10</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> f1;<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment"># 使用正确</span><br><span class="hljs-keyword">SELECT</span> f1<br><span class="hljs-keyword">FROM</span> <span class="hljs-keyword">table</span><br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> f1 <span class="hljs-keyword">HAVING</span> <span class="hljs-keyword">AVG</span>(f2) &gt; <span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure>



<h2 id="WHERE——条件查询"><a href="#WHERE——条件查询" class="headerlink" title="WHERE——条件查询"></a>WHERE——条件查询</h2><p>过滤数据，使用<code>WHERE</code>语句指定查询的条件逻辑，中间使用AND|OR等逻辑连接符连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> * <span class="hljs-keyword">WHERE</span> 条件<span class="hljs-number">1</span> [<span class="hljs-keyword">AND</span>|<span class="hljs-keyword">OR</span>] 条件<span class="hljs-number">2</span> ......;<br></code></pre></td></tr></table></figure>

<p>同时注意判断相等的条件是<code>=</code>而不是<code>==</code>；不等于通常写成<code>&lt;&gt;</code>。</p>
<p>除此之外还有BETWEEN，LIKE，IN等常用运算符</p>
<h3 id="语句基本执行顺序"><a href="#语句基本执行顺序" class="headerlink" title="语句基本执行顺序"></a>语句基本执行顺序</h3><p>1、from</p>
<p>2、where</p>
<p>3、group by</p>
<p>4、having</p>
<p>5、select</p>
<p>6、order by</p>
<p>7、limit</p>
<h2 id="JOIN——表连接"><a href="#JOIN——表连接" class="headerlink" title="JOIN——表连接"></a>JOIN——表连接</h2><p>表连接即把多个表通过表之间的共用字段连接起来，可以将其视为一张表进行操作。</p>
<h3 id="INNER-JOIN"><a href="#INNER-JOIN" class="headerlink" title="INNER JOIN"></a>INNER JOIN</h3><p>如果表中有至少一个匹配，则返回行。结果集中只保留符合连接条件的记录。</p>
<p><strong>使用WHERE语句连接默认也是INNER JOIN</strong>，如下面第3条语句</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [<span class="hljs-keyword">INNER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">ON</span> 连接条件;<br><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span> [<span class="hljs-keyword">INNER</span>] <span class="hljs-keyword">JOIN</span> 表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 连接条件;<br><br><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> 表<span class="hljs-number">1</span>, 表<span class="hljs-number">2</span> <span class="hljs-keyword">WHERE</span> 连接条件;<br></code></pre></td></tr></table></figure>



<h3 id="LEFT-JOIN——左连接"><a href="#LEFT-JOIN——左连接" class="headerlink" title="LEFT JOIN——左连接"></a>LEFT JOIN——左连接</h3><p>即使右表中没有匹配，联结结果也保留左表的全部数据。同时<em>右表中对应数据视为NULL</em></p>
<h3 id="RIGHT-JOIN——右连接"><a href="#RIGHT-JOIN——右连接" class="headerlink" title="RIGHT JOIN——右连接"></a>RIGHT JOIN——右连接</h3><p>与左连接相反，联结结果保留右表的全部数据</p>
<p>应用在<a href="https://leetcode-cn.com/problems/combine-two-tables/" target="_blank" rel="noopener">175.组合两个表中</a>。该题需要满足“无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息”，所以当person表在左时采用左连接。</p>
<h3 id="on和where的区别"><a href="#on和where的区别" class="headerlink" title="on和where的区别"></a>on和where的区别</h3><ol>
<li>对<code>INNER JOIN</code>，条件放在ON和WHERE中结果集是相同的</li>
<li>对外连接，条件放在ON中，则不管一些条件是否为真，都会返回对应表中的记录</li>
</ol>
<p>比如在<code>LEFT JOIN</code>中写上右表的条件，则不论是否满足有些行都会返回NULL</p>
<p>而</p>
<blockquote>
<p>具体参考：<a href="https://www.runoob.com/w3cnote/sql-different-on-and-where.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/sql-different-on-and-where.html</a></p>
</blockquote>
<p><strong>几种条件查询语句执行顺序：ON &gt; WHERE &gt; 聚合函数 &gt; having</strong></p>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>以下不推荐，因为查询速度会很慢，每一次都会执行WHERE语句中的内容。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> ename <br><span class="hljs-keyword">FROM</span> t_emp<br><span class="hljs-keyword">WHERE</span> deptno = (<span class="hljs-keyword">SELECT</span> deptno <span class="hljs-keyword">FROM</span> t_emp <span class="hljs-keyword">WHERE</span> ename=<span class="hljs-string">"SCOTT"</span>)<br></code></pre></td></tr></table></figure>



<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e2.ename<br><span class="hljs-keyword">FROM</span> t_emp e1 <span class="hljs-keyword">JOIN</span> t_emp e2 <span class="hljs-keyword">ON</span> e1.deptno=e2.deptno<br><span class="hljs-keyword">WHERE</span> e1.ename = <span class="hljs-string">"SCOTT"</span><br></code></pre></td></tr></table></figure>



<p>将AVG的结果视为一个表，与原表进行连接。</p>
<p>错误</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e2.ename<br><span class="hljs-keyword">FROM</span> t_emp e1 <span class="hljs-keyword">JOIN</span> t_emp e2 <span class="hljs-keyword">ON</span> e2.sal &gt;= <span class="hljs-keyword">AVG</span>(e1.sal)<br></code></pre></td></tr></table></figure>

<p>正确</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> e.ename<br><span class="hljs-keyword">FROM</span> t_emp e <br><span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">AVG</span>(sal) <span class="hljs-keyword">avg</span> <span class="hljs-keyword">FROM</span> t_emp) t<br><span class="hljs-keyword">ON</span> e.sal &gt;= t.avg;<br></code></pre></td></tr></table></figure>



<h2 id="组合查询"><a href="#组合查询" class="headerlink" title="组合查询"></a>组合查询</h2>]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>数据操纵语言（DML）</title>
    <url>/page/DML.html</url>
    <content><![CDATA[<p>逻辑库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">DATABASE</span>; 逻辑库名称<br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">DATABASES</span>;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">DATABASE</span> 逻辑库名称;<br><span class="hljs-keyword">USE</span> 逻辑库名称;<br></code></pre></td></tr></table></figure>

<p>数据表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 数据表(<br>			列名 数据类型 [约束] [<span class="hljs-keyword">COMMENT</span> 注释],<br>			列名 数据类型 [约束] [<span class="hljs-keyword">COMMENT</span> 注释],<br>			)[<span class="hljs-keyword">COMMENT</span> 注释];<br></code></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SHOW</span> 表名;<br>DESC 表名; // 查看表的情况<br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> 表名;	// 查看创建该表时的SQL语句<br><span class="hljs-keyword">DROP</span> TABLEE 表名;	// 删除数据表<br></code></pre></td></tr></table></figure>



<p>添加字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名<br><span class="hljs-keyword">ADD</span> 列名 数据类型 [约束] [<span class="hljs-keyword">COMMENT</span> 注释],<br>...<br><span class="hljs-keyword">ADD</span> 列名 数据类型 [约束] [<span class="hljs-keyword">COMMENT</span> 注释];<br></code></pre></td></tr></table></figure>

<p>修改字段数据类型等信息</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名<br><span class="hljs-keyword">MODIFY</span> 列名 数据类型 [约束] [<span class="hljs-keyword">COMMENT</span> 注释],<br>...<br><span class="hljs-keyword">MODIFY</span> 列名 数据类型 [约束] [<span class="hljs-keyword">COMMENT</span> 注释];<br></code></pre></td></tr></table></figure>

<p>修改字段名称</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名<br><span class="hljs-keyword">CHANGE</span> 列名 新列名 数据类型 [约束] [<span class="hljs-keyword">COMMENT</span> 注释],<br>...<br><span class="hljs-keyword">CHANGE</span> 列名 新列名 数据类型 [约束] [<span class="hljs-keyword">COMMENT</span> 注释];<br></code></pre></td></tr></table></figure>

<p>删除字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名<br><span class="hljs-keyword">DROP</span> 字段名称,<br>...<br><span class="hljs-keyword">DROP</span> 字段名称;<br></code></pre></td></tr></table></figure>



<p>添加索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> *(<br>		<span class="hljs-keyword">INDEX</span> 索引名称 (字段名称),<br>		);<br></code></pre></td></tr></table></figure>

<p>添加、显示、删除索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">INDEX</span> 索引名称 <span class="hljs-keyword">ON</span> 表名(字段);<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> 表名 <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> [索引名](字段);<br><br><span class="hljs-keyword">SHOW</span> <span class="hljs-keyword">INDEX</span> <span class="hljs-keyword">FROM</span> 表名;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">INDEX</span> 索引名称 <span class="hljs-keyword">ON</span> 表名;<br></code></pre></td></tr></table></figure>



<h2 id="添加数据-INSERT"><a href="#添加数据-INSERT" class="headerlink" title="添加数据 INSERT"></a>添加数据 INSERT</h2><p>向数据表中写入记录</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">INSERT INTO 表名(字段1,字段2<span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>)<br>VALUES(值1,值2<span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span>);<br></code></pre></td></tr></table></figure>



<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql">// 当插入数据有问题时直接忽略<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">IGNORE</span> <span class="hljs-keyword">INTO</span><br></code></pre></td></tr></table></figure>

<h2 id="修改数据-UPDATE"><a href="#修改数据-UPDATE" class="headerlink" title="修改数据 UPDATE"></a>修改数据 UPDATE</h2><p>修改表的记录</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">UPDATE [IGNORE] 表名<br><span class="hljs-builtin-name">SET</span> 字段<span class="hljs-attribute">1</span>=值1, 字段<span class="hljs-attribute">2</span>=值2 <span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><span class="hljs-built_in">..</span><br>WHERE<br>ORDER BY<br>LIMIT<br></code></pre></td></tr></table></figure>



<h2 id="删除数据-DELETE"><a href="#删除数据-DELETE" class="headerlink" title="删除数据 DELETE"></a>删除数据 DELETE</h2><figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">DELETE</span> [<span class="hljs-keyword">IGNORE</span>] <span class="hljs-keyword">FROM</span> 表名<br>[<span class="hljs-keyword">WHERE</span>]<br>[<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span>]<br>[<span class="hljs-keyword">LIMIT</span>]<br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>数据库</category>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL语言</tag>
      </tags>
  </entry>
  <entry>
    <title>JS01-1:基本数据类型</title>
    <url>/page/js-basic-datatype.html</url>
    <content><![CDATA[<h2 id="字符串：String"><a href="#字符串：String" class="headerlink" title="字符串：String"></a>字符串：String</h2><p>js中的字符串使用” “或者’ ‘进行包裹（跟python相同）。</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">str1</span> = <span class="hljs-string">"str"</span><span class="hljs-comment">;</span><br><span class="hljs-attr">str2</span> = <span class="hljs-string">'str'</span><span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h3><p>字符串里面的值不可被改变。虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间（与Java中的String类很像）。</p>
<p>如下，看上去str 的值变了，其实’aaaa’仍然保存在内存中，str只是改为指向了’bbbb’。</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">var str</span> = <span class="hljs-string">'aaaa'</span>;<br><span class="hljs-attribute">str</span> = <span class="hljs-string">'bbbb'</span>;<br></code></pre></td></tr></table></figure>

<h3 id="字符串常用操作（长度、拼接）"><a href="#字符串常用操作（长度、拼接）" class="headerlink" title="字符串常用操作（长度、拼接）"></a>字符串常用操作（长度、拼接）</h3><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">// 获取长度</span><br><span class="hljs-keyword">str</span>.length<br></code></pre></td></tr></table></figure>

<p>拼接字符串使用 “+”即可，很方便。</p>
<h3 id="字符串的查找与替换"><a href="#字符串的查找与替换" class="headerlink" title="字符串的查找与替换"></a>字符串的查找与替换</h3><figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">// 返回子字符串的位置，若没有，返回-1</span><br><span class="hljs-keyword">str</span>.indexOf(<span class="hljs-string">"char"</span>)<br><br><span class="hljs-comment">// 从后向前检索</span><br><span class="hljs-keyword">str</span>.lastIndexOf(<span class="hljs-string">"char"</span>)<br><br><span class="hljs-comment">// 替换字符串，将a替换为b</span><br><span class="hljs-keyword">str</span>.replace(a,b)<br></code></pre></td></tr></table></figure>

<h3 id="子字符串的截取"><a href="#子字符串的截取" class="headerlink" title="子字符串的截取"></a>子字符串的截取</h3><figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">str.<span class="hljs-keyword">slice</span>(<span class="hljs-keyword">start</span>, <span class="hljs-keyword">end</span>) // 截取字符串（<span class="hljs-keyword">end</span>索引不在截取范围之内）<br><br>str.substring(<span class="hljs-keyword">start</span>, <span class="hljs-keyword">end</span>) // 功能与<span class="hljs-keyword">slice</span>一致<br><br>str.substr(<span class="hljs-keyword">start</span>, len) // 从<span class="hljs-keyword">start</span>处截取长为len的字符串<br></code></pre></td></tr></table></figure>

<h3 id="字符串分割为数组"><a href="#字符串分割为数组" class="headerlink" title="字符串分割为数组"></a>字符串分割为数组</h3><figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing"><span class="hljs-built_in">str</span>.<span class="hljs-built_in">split</span>(separate) <span class="hljs-comment">// 把字符串分割为字符串数组，参数为分隔符</span><br></code></pre></td></tr></table></figure>

<p>示例</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><code class="hljs processing">a = <span class="hljs-string">"a,b,b,df,s"</span>;<br>console.<span class="hljs-built_in">log</span>(a);<br>b = a.<span class="hljs-built_in">split</span>(<span class="hljs-string">','</span>);<br>console.<span class="hljs-built_in">log</span>(b);<br></code></pre></td></tr></table></figure>



<h2 id="数值型：Number"><a href="#数值型：Number" class="headerlink" title="数值型：Number"></a>数值型：Number</h2><h3 id="最大值与最小值"><a href="#最大值与最小值" class="headerlink" title="最大值与最小值"></a>最大值与最小值</h3><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">max</span> = Number.MAX_VALUE<span class="hljs-comment">;</span><br><span class="hljs-attr">min</span> = Number.MIN_VALUE<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>1、使用 Number 表示的变量超过了最大值，则会返回Infinity。<code>typeof Infinity</code>的返回结果是number。</p>
<p>2、<strong>NaN（Not a Number）</strong>，非数值</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">"a"</span> / <span class="hljs-number">10</span>);	<span class="hljs-comment">// NaN</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">NaN</span>);	<span class="hljs-comment">// number</span><br></code></pre></td></tr></table></figure>

<p>3、在JS中，<strong>浮点数的运算无法保证较高的精度</strong></p>
<h2 id="布尔型：Boolean"><a href="#布尔型：Boolean" class="headerlink" title="布尔型：Boolean"></a>布尔型：Boolean</h2><p>就是简单的true与false，与数字相加时，<strong>true为1，false为0</strong></p>
<h2 id="Null和Undefined"><a href="#Null和Undefined" class="headerlink" title="Null和Undefined"></a>Null和Undefined</h2><h3 id="Null：空值"><a href="#Null：空值" class="headerlink" title="Null：空值"></a>Null：空值</h3><p>专门用来表示空对象，同时<code>typeof null</code>会返回object。（<strong>null视为空对象</strong>）</p>
<h3 id="undefined：未定义"><a href="#undefined：未定义" class="headerlink" title="undefined：未定义"></a>undefined：未定义</h3><h4 id="1、变量已声明，但是没有赋值"><a href="#1、变量已声明，但是没有赋值" class="headerlink" title="1、变量已声明，但是没有赋值"></a>1、变量已声明，但是没有赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<h4 id="2、变量未定义"><a href="#2、变量未定义" class="headerlink" title="2、变量未定义"></a>2、变量未定义</h4><figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">console.<span class="hljs-built_in">log</span>(typeof <span class="hljs-keyword">a</span>);<span class="hljs-comment">	// undefined</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-keyword">a</span>);<span class="hljs-comment"> // 打印结果：Uncaught ReferenceError: a is not defined</span><br></code></pre></td></tr></table></figure>

<h4 id="3、函数无返回值"><a href="#3、函数无返回值" class="headerlink" title="3、函数无返回值"></a>3、函数无返回值</h4><p>如果一个函数没有返回值，那么，这个函数的返回值就是 undefined。</p>
<p>或者，也可以这样理解：在定义一个函数时，如果末尾没有 return 语句，那么，其实就是 <code>return undefined</code>。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">()</span> <span class="hljs-comment">&#123;&#125;</span><br><span class="hljs-title">console</span>.<span class="hljs-title">log</span><span class="hljs-params">(foo()</span>);</span> <span class="hljs-comment">// 打印结果：undefined</span><br></code></pre></td></tr></table></figure>

<h4 id="4、调用函数时，未传参"><a href="#4、调用函数时，未传参" class="headerlink" title="4、调用函数时，未传参"></a>4、调用函数时，未传参</h4><p>调用函数时，如果没有传参，那么，这个参数的值就是 undefined。</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span><span class="hljs-params">(<span class="hljs-keyword">name</span>)</span> <span class="hljs-comment">&#123;<br>    console.log(name);<br>&#125;</span><br><br><span class="hljs-title">foo</span><span class="hljs-params">()</span>;</span> <span class="hljs-comment">// 调用函数时，未传参。执行函数后的打印结果：undefined</span><br></code></pre></td></tr></table></figure>

<h3 id="两者之间的差别"><a href="#两者之间的差别" class="headerlink" title="两者之间的差别"></a>两者之间的差别</h3><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> == <span class="hljs-literal">undefined</span>);		<span class="hljs-regexp">//</span> <span class="hljs-literal">true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">null</span> === <span class="hljs-literal">undefined</span>);	<span class="hljs-regexp">//</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<p><strong>和数字运算时，null相当于0，而undefined相当于NaN</strong></p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="其他类型–-gt-String"><a href="#其他类型–-gt-String" class="headerlink" title="其他类型–&gt;String"></a>其他类型–&gt;String</h3><h4 id="1、通过字符串拼接隐式转换"><a href="#1、通过字符串拼接隐式转换" class="headerlink" title="1、通过字符串拼接隐式转换"></a>1、通过字符串拼接隐式转换</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br>a = a + <span class="hljs-string">''</span>;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> a);	<span class="hljs-comment">// string</span><br></code></pre></td></tr></table></figure>

<h4 id="2、调用toString-方法"><a href="#2、调用toString-方法" class="headerlink" title="2、调用toString()方法"></a>2、调用toString()方法</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">变量.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span><br></code></pre></td></tr></table></figure>

<p>该方法不会影响到原变量，它会将转换的结果返回，同时，null与undefined没有toString方法。</p>
<h4 id="3、使用String-函数强制转换"><a href="#3、使用String-函数强制转换" class="headerlink" title="3、使用String()函数强制转换"></a>3、使用String()函数强制转换</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">String</span><span class="hljs-params">(变量)</span></span><br></code></pre></td></tr></table></figure>

<ul>
<li><p>对于 Number 和 Boolean 而言，本质上就是调用 toString()方法。</p>
</li>
<li><p>对于 null 和 undefined，它会将 null 直接转换为 “null”。将 undefined 直接转换为 “undefined”。</p>
</li>
</ul>
<h3 id="其他类型–-gt-Number"><a href="#其他类型–-gt-Number" class="headerlink" title="其他类型–&gt;Number"></a>其他类型–&gt;Number</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">parseInt(<span class="hljs-string">"str"</span>)<span class="hljs-comment">;</span><br>parseFloat(<span class="hljs-string">"str"</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<h3 id="typeof总结"><a href="#typeof总结" class="headerlink" title="typeof总结"></a>typeof总结</h3><table>
<thead>
<tr>
<th align="left">typeof 的代码写法</th>
<th align="center">返回结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">typeof 数字</td>
<td align="center">number</td>
</tr>
<tr>
<td align="left">typeof 字符串</td>
<td align="center">string</td>
</tr>
<tr>
<td align="left">typeof 布尔型</td>
<td align="center">boolean</td>
</tr>
<tr>
<td align="left">typeof 对象</td>
<td align="center">object</td>
</tr>
<tr>
<td align="left">typeof 方法</td>
<td align="center">function</td>
</tr>
<tr>
<td align="left">typeof null</td>
<td align="center">object</td>
</tr>
<tr>
<td align="left">typeof undefined</td>
<td align="center">undefined</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端</category>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的线程与进程</title>
    <url>/page/python7.html</url>
    <content><![CDATA[<p>内存池机制：当创建大量消耗小内存的对象时，频繁调用new/malloc会导致大量的内存碎片，使效率降低。</p>
<p>内存池就是预先在内存中申请一定数量的、大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了再申请新的内存，这样做最显著的优势就是能够减小内存碎片，提升效率</p>
<p>pymalloc</p>
<p>针对小对象，pymalloc会在内存池中申请内存空间</p>
<p>大对象，申请新的内存空间</p>
<h3 id="Python多线程"><a href="#Python多线程" class="headerlink" title="Python多线程"></a>Python多线程</h3><p>进程：一个执行中的程序，每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据。操作系统管理其上所有进程，并为这些进程合理分配时间。</p>
<p>threading模块</p>
<p>线程：在同一个进程下执行，并共享相同的上下文。一个进程中的各个线程与主线程共享同一片数据空间。</p>
<p>线程包括开始、执行顺序、结束三部分</p>
<p>可以被抢占（中断）和临时挂起（睡眠）</p>
<p>一般以并发方式执行（是一种属性，并行只是并发问题的可能方法之一，若两个事件互不影响，则两个事件是并发的）</p>
<p>对多核CPU的应用</p>
<p>GIL——全局解释器锁（强制在任何时候只有一个线程可以执行python代码）</p>
<p>I/O密集型应用（如网页之类），CPU密集型应用（数据分析，可借助C或CPP的拓展）</p>
<p>GIL执行顺序</p>
<p>实现一个线程</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">class</span> LoopThread(threading.Thread):<br>    n = <span class="hljs-number">0</span><br>    def run(self) -&gt; None:<br>        while self.n &lt; <span class="hljs-number">5</span>:<br>            now_thread = threading.current_thread()<br>            print(<span class="hljs-string">'loop now: &#123;0&#125;'</span>.format(now_thread.name))<br>            print(self.n)<br>            time.sleep(<span class="hljs-number">1</span>)<br>            self.n += <span class="hljs-number">1</span><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    now_thread = threading.current_thread()<br>    print(<span class="hljs-string">'now: &#123;0&#125;'</span>.format(now_thread.name))<br><br>    t = LoopThread(name=<span class="hljs-string">'loop_thread'</span>)<br>    t.start()<br>    t.join()<br>    <br>############################################<br>now: MainThread<br>loop now: loop_thread<br><span class="hljs-number">0</span><br>loop now: loop_thread<br><span class="hljs-number">1</span><br>loop now: loop_thread<br><span class="hljs-number">2</span><br>loop now: loop_thread<br><span class="hljs-number">3</span><br>loop now: loop_thread<br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>



<p>多线程并发</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br>num = <span class="hljs-number">0</span><br><br>def test(n):<br>    global num<br>    num += n<br>    time.sleep(<span class="hljs-number">2</span>)<br>    num -= n<br>    time.sleep(<span class="hljs-number">1</span>)<br>    print(<span class="hljs-string">'----------------&#123;0&#125;'</span>.format(num))<br><br><span class="hljs-keyword">class</span> testThread(threading.Thread):<br>    def __init__(self, n, *args, **kwargs):<br>        super().__init__(*args, **kwargs)<br>        self.n = n<br><br>    def run(self) -&gt; None:<br>        for i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):<br>            test(self.n)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    t1 = testThread(<span class="hljs-number">1</span>)<br>    t2 = testThread(<span class="hljs-number">2</span>)<br>    t1.start()<br>    t2.start()<br>    t1.join()<br>    t2.join()<br>    <br>############################################<br>---------------<span class="hljs-number">-0</span><br>---------------<span class="hljs-number">-2</span><br>---------------<span class="hljs-number">-0</span><br>---------------<span class="hljs-number">-2</span><br>---------------<span class="hljs-number">-0</span><br>---------------<span class="hljs-number">-1</span><br>---------------<span class="hljs-number">-0</span><br>---------------<span class="hljs-number">-1</span><br></code></pre></td></tr></table></figure>



<p>多线程中的锁</p>
<p><code>RLock</code>在一个线程中锁住了还能够再锁</p>
<p>不能重复锁，否则资源被死锁</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> threading<br><span class="hljs-keyword">import</span> time<br><br>num = <span class="hljs-number">0</span><br>lock = threading.Lock()<br><br>def test(n):<br>    global num<br>    num += n<br>    time.sleep(<span class="hljs-number">2</span>)<br>    num -= n<br>    time.sleep(<span class="hljs-number">1</span>)<br>    print(<span class="hljs-string">'----------------&#123;0&#125;'</span>.format(num))<br><br><span class="hljs-keyword">class</span> testThread(threading.Thread):<br>    def __init__(self, n, *args, **kwargs):<br>        super().__init__(*args, **kwargs)<br>        self.n = n<br><br>    def run(self) -&gt; None:<br>        for i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):<br>            lock.acquire()<br>            try:<br>                test(self.n)<br>            finally:<br>                lock.release()<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    t1 = testThread(<span class="hljs-number">1</span>)<br>    t2 = testThread(<span class="hljs-number">2</span>)<br>    t1.start()<br>    t2.start()<br>    t1.join()<br>    t2.join()<br>    <br>###########################################<br>---------------<span class="hljs-number">-0</span><br>---------------<span class="hljs-number">-0</span><br>---------------<span class="hljs-number">-0</span><br>---------------<span class="hljs-number">-0</span><br>---------------<span class="hljs-number">-0</span><br>---------------<span class="hljs-number">-0</span><br></code></pre></td></tr></table></figure>



<p>产生死锁</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">def run(self) -&gt; None:<br>    for i <span class="hljs-keyword">in</span> range(<span class="hljs-number">1000</span>):<br>        print(<span class="hljs-string">'start lock'</span>)<br>        lock.acquire()<br>        print(<span class="hljs-string">'lock again'</span>)<br>        lock.acquire()<br>        print(<span class="hljs-string">'lock end'</span>)<br>        try:<br>            test(self.n)<br>        finally:<br>            lock.release()<br>            <br>###########################################<br>start lock<br>lock again<br>start lock<br></code></pre></td></tr></table></figure>





<p>线程的调度与优化</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> threading, time<br><span class="hljs-keyword">from</span> multiprocessing.dummy <span class="hljs-keyword">import</span> Pool <span class="hljs-keyword">as</span> ThreadPool<br><br>def run(n):<br>    time.sleep(<span class="hljs-number">1</span>)<br>    print(threading.current_thread().name, n)<br><br>def test():<br>    t1 = time.time()<br>    for n <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        run(n)<br>    print(time.time() - t1)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    test()<br>    <br>########################################<br>MainThread <span class="hljs-number">0</span><br>MainThread <span class="hljs-number">1</span><br>MainThread <span class="hljs-number">2</span><br>MainThread <span class="hljs-number">3</span><br>MainThread <span class="hljs-number">4</span><br>MainThread <span class="hljs-number">5</span><br>MainThread <span class="hljs-number">6</span><br>MainThread <span class="hljs-number">7</span><br>MainThread <span class="hljs-number">8</span><br>MainThread <span class="hljs-number">9</span><br><span class="hljs-number">10.0053870677948</span><br></code></pre></td></tr></table></figure>



<p>快了很多</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> threading, time<br><span class="hljs-keyword">from</span> multiprocessing.dummy <span class="hljs-keyword">import</span> Pool <span class="hljs-keyword">as</span> ThreadPool<br><br>def run(n):<br>    time.sleep(<span class="hljs-number">1</span>)<br>    print(threading.current_thread().name, n)<br><br>def test_use_thread():<br>    t1 = time.time()<br>    ls = []<br>    for i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        t = threading.Thread(target=run, args=(i,))<br>        ls.append(t)<br>        t.start()<br><br>    for l <span class="hljs-keyword">in</span> ls:<br>        l.join()<br>    print(time.time() - t1)<br><br>def test():<br>    t1 = time.time()<br>    for n <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>):<br>        run(n)<br>    print(time.time() - t1)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    test_use_thread()<br>    <br>###############################################<br>Thread<span class="hljs-number">-2</span> <span class="hljs-number">1</span><br>Thread<span class="hljs-number">-3</span> <span class="hljs-number">2</span><br>Thread<span class="hljs-number">-1</span> <span class="hljs-number">0</span><br>Thread<span class="hljs-number">-5</span> <span class="hljs-number">4</span><br>Thread<span class="hljs-number">-4</span> <span class="hljs-number">3</span><br>Thread<span class="hljs-number">-6</span> <span class="hljs-number">5</span><br>Thread<span class="hljs-number">-10</span> <span class="hljs-number">9</span><br>Thread<span class="hljs-number">-8</span> <span class="hljs-number">7</span><br>Thread<span class="hljs-number">-9</span> <span class="hljs-number">8</span><br>Thread<span class="hljs-number">-7</span> <span class="hljs-number">6</span><br><span class="hljs-number">1.0038871765136719</span><br></code></pre></td></tr></table></figure>



<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">def test_use_pool():<br>    t1 = time.time()<br>    n_list = range(100)<br>   <span class="hljs-built_in"> pool </span>= Pool(10)<br>    pool.map(run, n_list)<br>    pool.close()<br>    pool.join()<br>    <span class="hljs-builtin-name">print</span>(time.time() - t1)<br></code></pre></td></tr></table></figure>



<p>达到了线程的复用</p>
<h3 id="Python进程"><a href="#Python进程" class="headerlink" title="Python进程"></a>Python进程</h3><p>进程的实现</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> multiprocessing <span class="hljs-keyword">import</span> Process<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span><span class="hljs-params">(name)</span>:</span><br>    <span class="hljs-string">"""<br>    name: 进程名称<br>    """</span><br>    print(<span class="hljs-string">"进程名称：&#123;&#125;"</span>.format(name))<br>    time.sleep(<span class="hljs-number">5</span>)<br>    print(<span class="hljs-string">"进程完成"</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    p = Process(target=run, args=(<span class="hljs-string">'my process'</span>,))<br>    p.start()<br>    p.join()<br>    <br><span class="hljs-comment">##############################################</span><br>进程名称：my process<br>进程完成<br></code></pre></td></tr></table></figure>

<p>使用过os模块下的<code>os.getpid()</code>可以得到当前进程的ID</p>
<p>进程间的通信</p>
<p>多进程中的锁：</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>pygame基础</title>
    <url>/page/pygame-basic-knowledge.html</url>
    <content><![CDATA[<p>官方文档：<a href="https://www.pygame.org/docs/" target="_blank" rel="noopener">https://www.pygame.org/docs/</a></p>
<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol>
<li>引入相关的包</li>
<li>初始化，pygame.init()</li>
<li>得到屏幕对象，<code>screen = pygame.display.set_mode((320, 240))</code></li>
<li>游戏主循环<ul>
<li>处理游戏事件</li>
<li>更新游戏状态</li>
<li>屏幕重新绘制</li>
</ul>
</li>
</ol>
<p>基本代码框架</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">import pygame<br><span class="hljs-comment"># 初始化</span><br>pygame.init()<br><span class="hljs-comment"># 获取屏幕对象</span><span class="hljs-built_in"><br>screen </span>= pygame.display.set_mode((width, height))<br><span class="hljs-comment"># 游戏主循环</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>	# 处理游戏事件<br>	<span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.<span class="hljs-builtin-name">get</span>():<br>		pass<br>	# 更新游戏状态（游戏逻辑）<br>	<br>	# 重新绘制屏幕<br></code></pre></td></tr></table></figure>



<h3 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h3><p>基本流程如下</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-comment"># 加载图片</span><br><span class="hljs-keyword">ball </span>= pygame.image.load(<span class="hljs-string">'assets/images/background.png'</span>)<br><br><span class="hljs-comment"># 图片绘制</span><br>    <span class="hljs-keyword">screen.blit(ball, </span><span class="hljs-keyword">ball.get_rect)<br></span>    pygame.<span class="hljs-keyword">display.flip()</span><br></code></pre></td></tr></table></figure>

<p>其中<code>get_rect</code>返回值为（left, top, width, height）。前者为图片显示的左上角坐标，后者为图片的长与宽。</p>
<p>绘制其他模块自带的图形</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">red = pygame.Color(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br># 画线<br>pygame.draw.line(screen, red, (<span class="hljs-number">10</span>,<span class="hljs-number">10</span>), (<span class="hljs-number">200</span>, <span class="hljs-number">200</span>),<span class="hljs-number">10</span>)<br># 画矩形<br>pygame.draw.rect(screen,red,(<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>),<span class="hljs-number">10</span>)<br># 画圆<br>pygame.draw.circle(screen, red, (<span class="hljs-number">100</span>, <span class="hljs-number">100</span>),<span class="hljs-number">50</span>,<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>



<h3 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h3><p>可以使用系统默认的字体进行加载，也可以在项目中使用ttf文件作为资源进行加载。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 加载字体（使用系统默认字体进行加载）</span><br><span class="hljs-string">red</span> <span class="hljs-string">=</span> <span class="hljs-string">pygame.Color(255,</span> <span class="hljs-number">0</span><span class="hljs-string">,</span> <span class="hljs-number">0</span><span class="hljs-string">)</span><br><span class="hljs-string">fonts</span> <span class="hljs-string">=</span> <span class="hljs-string">pygame.font.SysFont('宋体',</span> <span class="hljs-number">40</span><span class="hljs-string">)</span><br><span class="hljs-string">text</span> <span class="hljs-string">=</span> <span class="hljs-string">fonts.render('Scores:',</span> <span class="hljs-literal">True</span><span class="hljs-string">,</span> <span class="hljs-string">red)</span><br><br><span class="hljs-comment"># 写于游戏主循环</span><br><span class="hljs-string">screen.blit(text,</span> <span class="hljs-string">(20,</span> <span class="hljs-number">20</span><span class="hljs-string">))</span><br><span class="hljs-string">pygame.display.flip()</span><br></code></pre></td></tr></table></figure>

<p>加载项目中所带的ttf文件</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">fonts</span> = pygame.font.Font(<span class="hljs-string">'*.ttf'</span>, <span class="hljs-number">40</span>)<br></code></pre></td></tr></table></figure>



<h3 id="游戏音效"><a href="#游戏音效" class="headerlink" title="游戏音效"></a>游戏音效</h3><figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 加载音乐</span><br>bgm = pygame.mixer_music.load(<span class="hljs-string">'assets/sounds/game_bg_music.mp3'</span>)<br><span class="hljs-meta"># 循环播放</span><br>pygame.mixer_music.play(<span class="hljs-number">-1</span>)<br></code></pre></td></tr></table></figure>

<p>设置音量大小</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">pygame.mixer_music.set_volume(<span class="hljs-number">0.1</span>) 输入值为（<span class="hljs-number">0</span>，<span class="hljs-number">1</span>）<br></code></pre></td></tr></table></figure>



<h3 id="动画切换"><a href="#动画切换" class="headerlink" title="动画切换"></a>动画切换</h3><p>两张图片的切换（pygame貌似不支持使用gif之类的动图）</p>
<p>思路：通过设置帧率进行切换，<code>pygame.time.Clock</code></p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">import sys, pygame<br><span class="hljs-comment"># 初始化</span><br>pygame.init()<br><span class="hljs-comment"># 屏幕对象</span><span class="hljs-built_in"><br>screen </span>= pygame.display.set_mode((320, 800))<br><br>image1 = pygame.image.load(<span class="hljs-string">'assets/images/hero1.png'</span>)<br>image2 = pygame.image.load(<span class="hljs-string">'assets/images/hero2.png'</span>)<br>count = 0<span class="hljs-built_in"><br>clock </span>= pygame.time.Clock()<br><br><span class="hljs-comment"># 游戏主循环</span><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br><br>    count += 1<br>    <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> pygame.event.<span class="hljs-builtin-name">get</span>():<br>        <span class="hljs-keyword">if</span> event.type == pygame.QUIT:<br>            pygame.quit()<br>            sys.exit()<br>    screen.fill(pygame.Color(255, 255, 255))<br>    # 每秒60次<br>    clock.tick(60)<br>    <span class="hljs-keyword">if</span> count % 5 == 0:<br>        screen.blit(image1, (20, 20))<br>    <span class="hljs-keyword">else</span>:<br>        screen.blit(image2, (20, 20))<br><br>    pygame.display.update()<br></code></pre></td></tr></table></figure>



<h3 id="精灵及精灵组"><a href="#精灵及精灵组" class="headerlink" title="精灵及精灵组"></a>精灵及精灵组</h3><p><strong>精灵</strong>：可以理解为需要操纵的图片（飞机大战中的飞机），一种可以在屏幕上移动的图形对象，并且可以和其他图形对象交互。可以使用pygame绘制，也可以是资源图片。</p>
<p><strong>精灵组</strong>：是一个容器，用于管理组内精灵的绘制与更新，精灵加入精灵组，精灵组会自动调用每一个精灵的方法。</p>
<p>基本使用方法就是，对自己的精灵类继承自<code>pygame.sprite.Sprite</code>，然后填补update之类的方法即可。</p>
<p><strong>碰撞检测</strong>：检测两个精灵有没有重叠的部分</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># 输入两个精灵，输出为布尔值</span><br><span class="hljs-attr">res</span> = pygame.sprite.collide_rect(sprite1, sprite2)<br><span class="hljs-comment"># 指定碰撞精度</span><br><span class="hljs-attr">res</span> = pygame.sprite.collide_rect_ratio(<span class="hljs-number">0.5</span>)(sprite1, sprite2)<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>编程相关</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Pygame</tag>
      </tags>
  </entry>
  <entry>
    <title>Python异常处理</title>
    <url>/page/python6.html</url>
    <content><![CDATA[<h3 id="异常基本概述"><a href="#异常基本概述" class="headerlink" title="异常基本概述"></a>异常基本概述</h3><ol>
<li>每个异常都是某个类的实例</li>
<li>发生了异常如果不捕获，程序将终止执行</li>
<li>有一些内置的异常类（Exception等）</li>
</ol>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p> <code>try except</code>句式</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">def test(a, b):<br>    return a/b<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    try:<br>        print(test(<span class="hljs-number">2</span>, <span class="hljs-number">0</span>))<br>    except:<br>        print(<span class="hljs-string">"出错了"</span>)<br>        <br>#############################<br>出错了<br></code></pre></td></tr></table></figure>

<p>检测出错类型的方法</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">def test(a, b):<br>    return a/b<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    try:<br>        print(test(<span class="hljs-number">2</span>, <span class="hljs-string">'a'</span>))<br>    except ZeroDivisionError:<br>        print(<span class="hljs-string">"除数为0"</span>)<br>    except TypeError:<br>        print(<span class="hljs-string">"类型出错"</span>)<br>        <br>#######################################<br>类型出错<br></code></pre></td></tr></table></figure>



<p>获取出错信息</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">def test(a, b):<br>    return a/b<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    try:<br>        print(test(<span class="hljs-number">2</span>, <span class="hljs-string">'a'</span>))<br>    except (ZeroDivisionError, TypeError) <span class="hljs-keyword">as</span> e:<br>        print(e)<br>        <br>############################################<br>unsupported operand type(s) for /: <span class="hljs-string">'int'</span> and <span class="hljs-string">'str'</span><br></code></pre></td></tr></table></figure>



<p>处理必须处理的语句（finally中的语句不管有没有问题都会执行）</p>
<p><code>try except finally</code>语句</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">def test(a, b):<br>    return a/b<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    try:<br>        print(test(<span class="hljs-number">2</span>, <span class="hljs-string">'a'</span>))<br>    except (ZeroDivisionError, TypeError) <span class="hljs-keyword">as</span> e:<br>        print(e)<br>    finally:<br>        print(<span class="hljs-string">"我必须处理"</span>)<br>        <br>#################################################<br>unsupported operand type(s) for /: <span class="hljs-string">'int'</span> and <span class="hljs-string">'str'</span><br>我必须处理<br></code></pre></td></tr></table></figure>



<h3 id="自定义异常和抛出异常"><a href="#自定义异常和抛出异常" class="headerlink" title="自定义异常和抛出异常"></a>自定义异常和抛出异常</h3><p>通过继承<strong>Exception类</strong>来定义异常，通过使用<strong>raise</strong>关键字来抛出异常。</p>
<p>1、<strong>自定义异常</strong>。通过创建一个继承自Exception类的新的异常类来记录自己的异常</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">class</span> test(Exception):<br>    pass<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    <span class="hljs-keyword">if</span> <span class="hljs-literal">True</span>:<br>        raise test(<span class="hljs-string">'出现了自定义的测试错误'</span>)<br>        <br>######################################################<br>Traceback (most recent call last):<br>  File <span class="hljs-string">"C:/Users/lenovo/Desktop/python学习/decorate.py"</span>, line <span class="hljs-number">7</span>, <span class="hljs-keyword">in</span> &lt;<span class="hljs-keyword">module</span>&gt;<br>    raise test(<span class="hljs-string">'出现了自定义的测试错误'</span>)<br>__main__.test: 出现了自定义的测试错误<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python装饰器、迭代器、生成器</title>
    <url>/page/python5.html</url>
    <content><![CDATA[<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>用于拓展原来函数功能的一种函数，返回函数的函数，在不更改原函数代码的前提下给函数增加新的功能（易于代码重用）</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"># 装饰器的常用写法<br># 输入函数，在函数内部定义返回函数<br>def decoratre(func):<br>    def wrapper():<br>        print(<span class="hljs-string">'start'</span>)<br>        func()<br>        print((<span class="hljs-string">'end'</span>))<br>    return wrapper<br><br>@decoratre<br>def func():<br>    print(<span class="hljs-string">"原函数执行"</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    func()<br>    <br>##########################################<br>start<br>原函数执行<br>end<br></code></pre></td></tr></table></figure>



<h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><h4 id="装饰器参数的传入"><a href="#装饰器参数的传入" class="headerlink" title="装饰器参数的传入"></a>装饰器参数的传入</h4><figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">def gg(name):<br>    def decoratre(func):<br>        def wrapper():<br>            print(<span class="hljs-string">'&#123;&#125;:start'</span>.format(name))<br>            func()<br>            print(<span class="hljs-string">'&#123;&#125;:end'</span>.format(name))<br>        return wrapper<br>    return decoratre<br><br>@gg(<span class="hljs-string">'func'</span>)<br>def func():<br>    print(<span class="hljs-string">"原函数执行"</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    func()<br>    <br>#########################################<br>func:start<br>原函数执行<br>func:end<br></code></pre></td></tr></table></figure>



<h4 id="函数参数的传入"><a href="#函数参数的传入" class="headerlink" title="函数参数的传入"></a>函数参数的传入</h4><p>使用<code>*args, **kwargs</code></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">def gg(name):<br>    def decoratre(func):<br>        def wrapper(*args, **kwargs):<br>            print(<span class="hljs-string">'&#123;&#125;:start'</span>.format(name))<br>            res = func(*args, **kwargs)<br>            print(res)<br>            print(<span class="hljs-string">'&#123;&#125;:end'</span>.format(name))<br>            return res<br>        return wrapper<br>    return decoratre<br>    <br>@gg(<span class="hljs-string">'sum'</span>)<br>def sum(a, b):<br>    return a+b<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br>    <br>#############################################    <br>sum:start<br><span class="hljs-number">3</span><br>sum:end<br></code></pre></td></tr></table></figure>







<p>装饰器对函数进行封装时改变了原函数的名称与说明文档等信息，如下：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">def gg(name):<br>    def decoratre(func):<br>        def wrapper():<br>            print(<span class="hljs-string">'&#123;&#125;:start'</span>.format(name))<br>            func()<br>            print(<span class="hljs-string">'&#123;&#125;:end'</span>.format(name))<br>        return wrapper<br>    return decoratre<br><br>@gg(<span class="hljs-string">'func'</span>)<br>def func():<br>    print(<span class="hljs-string">"原函数执行"</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    print(func.__name__)<br>    <br>###################################################<br>wrapper<br></code></pre></td></tr></table></figure>



<p>为解决这个问题，可使用<code>@wraps(func)</code>方法，具体如下。</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">from</span> functools <span class="hljs-keyword">import</span> wraps<br><br>def gg(name):<br>    def decoratre(func):<br>        @wraps(func)<br>        def wrapper():<br>            print(<span class="hljs-string">'&#123;&#125;:start'</span>.format(name))<br>            func()<br>            print(<span class="hljs-string">'&#123;&#125;:end'</span>.format(name))<br>        return wrapper<br>    return decoratre<br><br>@gg(<span class="hljs-string">'func'</span>)<br>def func():<br>    print(<span class="hljs-string">"原函数执行"</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    print(func.__name__)<br>    <br>####################################################<br>func<br></code></pre></td></tr></table></figure>



<h3 id="类的装饰器"><a href="#类的装饰器" class="headerlink" title="类的装饰器"></a>类的装饰器</h3><p>对一些类都需要添加一些共有的方法，可以用类的装饰器实现</p>
<p>基本使用方法如下：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">def decorate(cls):<br>    cls.func = lambda self: print(<span class="hljs-string">"新方法"</span>)<br>    return cls<br><br>@decorate<br><span class="hljs-keyword">class</span> Pig():<br>    pass<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    pig = Pig()<br>    pig.func()<br>    <br>##########################################<br>新方法<br></code></pre></td></tr></table></figure>



<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一个可以<strong>记住遍历的位置的对象</strong>。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。字符串，列表或元组对象都可用于创建迭代器。同时，迭代器有两个基本的方法：<strong>iter()</strong> 和 <strong>next()</strong>。</p>
<p>把一个类作为一个迭代器使用需要在类中实现两个方法<code>__iter__</code>和<code>__next__</code>。<code>__iter__()</code>方法返回一个特殊的迭代器对象。<code>__next__()</code> 方法会返回下一个迭代器对象。</p>
<p>以下代码实现了一个计算平方的迭代器。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span>():</span><br>    value = <span class="hljs-number">0</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__iter__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__next__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:<br>        <span class="hljs-keyword">self</span>.value += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.value ** <span class="hljs-number">2</span><br><br><span class="hljs-keyword">if</span> __name_<span class="hljs-number">_</span> == <span class="hljs-string">'__main__'</span>:<br>    test = Square()<br>    print(test.__next_<span class="hljs-number">_</span>())<br>    print(test.__next_<span class="hljs-number">_</span>())<br>    print(<span class="hljs-keyword">next</span>(test))<br></code></pre></td></tr></table></figure>



<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>在 Python 中，使用了<code>yield</code> 的函数被称为生成器（generator）。在调用生成器运行的过程中，每次遇到<code>yield</code> 时函数会暂停并保存当前所有的运行信息，返回 <code>yield</code>的值, 并在下一次执行<code>next()</code>方法时从当前位置继续运行。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">square</span><span class="hljs-params">()</span></span>:<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">5</span>):<br>        <span class="hljs-keyword">yield</span> i ** <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python模块与文件读写</title>
    <url>/page/python4.html</url>
    <content><![CDATA[<h2 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h2><h3 id="导入模块时Python的操作"><a href="#导入模块时Python的操作" class="headerlink" title="导入模块时Python的操作"></a>导入模块时Python的操作</h3><p>当程序导入一个模块时，Python解析器对模块位置的搜索顺序为：</p>
<ol>
<li>当前目录</li>
<li>若当前目录搜索不到，Python则搜索在shell变量PYTHONPATH下的每个目录。</li>
<li>若都找不到，Python会察看默认路径。UNIX下，默认路径一为/usr/local/lib/python/。</li>
</ol>
<p>模块搜索路径存储在 system 模块的<strong>sys.path</strong> 变量中。变量里包含当前目录、PYTHONPATH和由安装过程决定的默认目录。</p>
<h3 id="模块常用函数"><a href="#模块常用函数" class="headerlink" title="模块常用函数"></a>模块常用函数</h3><p>1、<strong>dir()——列出对象的所有属性和方法</strong>。dir() 函数返回一个排好序的字符串列表，内容是一个模块里定义过的名字。返回的列表容纳了在一个模块里定义的所有<strong>模块</strong>，<strong>变量</strong>和<strong>函数</strong>。</p>
<p>2、<strong>help()——查看类、方法的帮助信息</strong></p>
<p>3、<strong>_<em>name_</em> ——模块的名称</strong></p>
<p>4、_<em>file_</em> ——文件全路径</p>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="open函数及其他基本操作"><a href="#open函数及其他基本操作" class="headerlink" title="open函数及其他基本操作"></a>open函数及其他基本操作</h3><p>Python使用<strong>open()</strong>打开文件，并返回文件的一个句柄。具体的参数为<strong>文件句柄 = open(‘文件路径’,打开模式, 编码方式)</strong>。其中编码方式encoding如果没有指定，将采用系统自带的编码方式。</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">f = open(<span class="hljs-string">'aa.txt'</span>)<br>print(f)<br>f.close()<br>####################################################<br>&lt;_io.TextIOWrapper name=<span class="hljs-string">'aa.txt'</span> mode=<span class="hljs-string">'r'</span> encoding=<span class="hljs-string">'cp936'</span>&gt;<br></code></pre></td></tr></table></figure>

<p>由以上输出可以看到，没指定打开模式时文件默认为只读模式（r），这时使用写入操作就会出错，常用的文件打开方式主要有以下几个。</p>
<p>1、<strong>r</strong>，只读的方式打开（文件必须存在，若文件不存在会抛出异常）。文件以什么编码写就以什么编码打开。</p>
<p>2、<strong>w</strong>，只写模式（文件不可读，若文件不存在，则创建一个新的文件，如果文件存在，则会清空里面的内容）</p>
<p>3、<strong>a</strong>，只追加写的模式 （文件不可读，不存在则创建新的文件，文件存在的话，可在后面追加内容）</p>
<p>4、<strong>b</strong>，对于非文本的文件，使用b的模式。’b’表示以字节的方式进行操作 如：rb,wb,ab 分别对应以上内容，如果以b的方式打开，读取到的内容是字节类型</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"># aa.txt文件中为一行字符串“hello world!”<br>f = open(<span class="hljs-string">'aa.txt'</span>, mode=<span class="hljs-string">'rb'</span>)<br>print(f.read())<br>f.close()<br>####################################<br>b<span class="hljs-string">'hello world!'</span><br></code></pre></td></tr></table></figure>

<p>5、<strong>’+‘模式</strong>，r+: 读写模式  w+:写读模式  a+：写读模式。在 <strong>r+</strong> 模式下，应该先读，后写，如果先写，后读，同样的道理，光标移动到了文件末尾，将读取不到内容。</p>
<p>同时使用<strong>open</strong>打开了一个文件操作完成后必须进行关闭，关闭文件使用<strong>close()</strong>。由于文件操作的这一性质，可以使用<strong>with</strong>关键字进行操作，如下：</p>
<p><strong>with 上下文管理器（到达语句末尾，将自动关闭文件）</strong></p>
<figure class="highlight fsharp"><table><tr><td class="code"><pre><code class="hljs fsharp"><span class="hljs-keyword">with</span> <span class="hljs-keyword">open</span>(<span class="hljs-string">"*.txt"</span>) <span class="hljs-keyword">as</span> f<br>	pass<br></code></pre></td></tr></table></figure>



<h3 id="与文件读写相关的一些功能函数"><a href="#与文件读写相关的一些功能函数" class="headerlink" title="与文件读写相关的一些功能函数"></a>与文件读写相关的一些功能函数</h3><p>1、读取文件的操作</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 读取文件，可以输入读取几个字符</span><br>read()<br><span class="hljs-meta"># 读取一行数据，也可以读取参数</span><br>readline()<br><span class="hljs-meta"># 读取所有行，并返回列表，之后可以通过对列表进行遍历得到数据</span><br>readlines()<br></code></pre></td></tr></table></figure>

<p>2、写入文件的操作</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 向文件中写入内容</span><br>write()<br><span class="hljs-meta"># 输入一个列表，将列表内容分别写入</span><br>wirtelines([])<br></code></pre></td></tr></table></figure>

<p>3、其他操作（文件定位操作）</p>
<p><strong>tell()</strong>方法告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。</p>
<p><strong>seek(offset [,from])</strong>方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python类的使用</title>
    <url>/page/python3.html</url>
    <content><![CDATA[<h3 id="一些基本内容"><a href="#一些基本内容" class="headerlink" title="一些基本内容"></a>一些基本内容</h3><p>_name：单前置下划线，私有化属性或方法，类对象和子类可以访问，from somemodule import *禁止导入</p>
<p>__name：双前置下划线，私有化属性或方法，无法在外部直接访问（名字重整所以访问不到）</p>
<p>__name__：系统定义的名字，自己不要创建</p>
<p>Python的析构函数<code>__del__(self)</code>。默认会直接进行操作。</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 判断是否为子类</span><br>issubclass(cat, animal)<br></code></pre></td></tr></table></figure>



<h3 id="调用父类方法"><a href="#调用父类方法" class="headerlink" title="调用父类方法"></a>调用父类方法</h3><p><code>super()</code>方法</p>
<p>若方法重名，先继承的优先调用</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">class</span> A():<br>    def test(self):<br>        print(<span class="hljs-string">"我是爸爸"</span>)<br><br><span class="hljs-keyword">class</span> B(A):<br>    def test(self):<br>        super().test()<br>        print(<span class="hljs-string">"我是儿子"</span>)<br>        <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    b = B()<br>    b.test()<br>    <br>#############################################<br>我是爸爸<br>我是儿子<br></code></pre></td></tr></table></figure>



<h3 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h3><p>@property：将类的方法当做属性来使用（可以简单理解为调用时可以将函数的括号去掉）</p>
<p>一般用来获取某些数据（如获取私有变量），不会向函数中传递参数</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">pig</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, name)</span></span>:<br>        <span class="hljs-keyword">self</span>.__name = name<br><br>    @property<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.__name<br>        <br>p = pig(<span class="hljs-string">"猪"</span>)<br>print(p.name) <span class="hljs-comment"># 等价于不加<span class="hljs-doctag">@property</span>时的，p.name()</span><br><br><span class="hljs-comment"># 猪</span><br></code></pre></td></tr></table></figure>



<p>@*.setter 表示可读可写，可以向该函数中传递参数，使用方法为<code>对象.函数名 = 参数值</code>。一般用来设置某些数据。</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pig</span>():</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, name)</span></span>:<br>        <span class="hljs-keyword">self</span>.__name = name<br><br>    @property<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-keyword">self</span>)</span></span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">self</span>.__name<br><br>    @name.setter<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span><span class="hljs-params">(<span class="hljs-keyword">self</span>, name)</span></span>:<br>        <span class="hljs-comment"># 在这即可对需要设置的值进行类型判断等操作</span><br>        <span class="hljs-keyword">self</span>.__name = name<br>        <br><span class="hljs-keyword">if</span> __name_<span class="hljs-number">_</span> == <span class="hljs-string">'__main__'</span>:<br>    p = Pig(<span class="hljs-string">'pig1'</span>)<br>    print(p.name)<br>    p.name = <span class="hljs-string">'pig2'</span> <span class="hljs-comment"># 可进行更改</span><br>    print(p.name)<br>  <br>​<br></code></pre></td></tr></table></figure>
<p>pig1<br>pig2<br>​```</p>
<figure class="highlight http"><table><tr><td class="code"><pre><code class="hljs http"><br><br><span class="clean"><br>### \__slots__&lt;限制类中的属性&gt;<br><br>为指定的类设置一个静态属性列表，为属性很少的类节约内存空间，同时提供更快的属性访问速度<br><br>使用`__slots__`后**不允许给类添加新的属性与方法**（对其子类也适用，子类新加的会拼接到后面）。示例如下：</span><br></code></pre></td></tr></table></figure>
<h1 id="不加slots"><a href="#不加slots" class="headerlink" title="不加slots"></a>不加<strong>slots</strong></h1><p>class B():<br>    pass</p>
<p>b = B()<br>b.gg = 1<br>print(b.gg)</p>
<p>###############################<br>1</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs plain"><br><br></code></pre></td></tr></table></figure>
<h1 id="加上slots"><a href="#加上slots" class="headerlink" title="加上slots"></a>加上<strong>slots</strong></h1><p>class A():<br>    <strong>slots</strong> = (‘name’)<br>    def <strong>init</strong>(self, name):<br>        self.name = name</p>
<p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    a = A(‘aa’)<br>    a.gg = 1<br>    print(a.gg)</p>
<p>###############################################<br>Traceback (most recent call last):<br>  File “C:/Users/lenovo/Desktop/python学习/decorate.py”, line 13, in <module><br>    a.gg = 1<br>AttributeError: ‘A’ object has no attribute ‘gg’</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"><br>可见，使用\__slots__指定了类的属性后就无法对实例添加属性了<br><br><br><br>### Python类中的方法<br><br>Python类中的方法主要可以分为以下三种：<br><br>* 实例方法：需要绑定要一个对象上，第一个参数默认使用self，会把对象作为第一个参数传递进来<br>* 静态方法：使用装饰器@staticmethod进行定义，类和对象都可以调用，不需要默认参数<br>* 类方法：使用装饰器@classmethod进行定义，类和对象都可以调用，第一个参数默认使用cls，会把类作为第一个参数传递进来<br><br><br><br>#### @staticmethod，静态方法<br><br>静态方法，可以直接通过类名对其进行调用（类的实例也可以调用 ）。相当于变为了<span class="hljs-string">"类的方法"</span>。&lt;类和对象都可以调用，不需要默认参数（如self等）&gt;<br></code></pre></td></tr></table></figure>
<p>class Pig():<br>    @staticmethod<br>    def func():<br>        print(“聪明的猪”)</p>
<p>Pig()</p>
<p>#############################################<br>聪明的猪</p>
<figure class="highlight http"><table><tr><td class="code"><pre><code class="hljs http"><br><br><span class="clean"><br>#### @classmethod，类方法<br><br>用于表示类的方法，可以**不实例化调用类的属性和方法**。有一个`cls`参数用于表示类本身。&lt;类和对象都可以调用，第一个参数默认使用cls，会把类作为第一个参数传递进来&gt;</span><br></code></pre></td></tr></table></figure>
<p>class A():<br>    def test(self):<br>        print(“test”)</p>
<pre><code>@classmethod
def gg(cls):
    cls().test()</code></pre><p>A.gg()</p>
<p>############################################<br>test</p>
<figure class="highlight http"><table><tr><td class="code"><pre><code class="hljs http"><br><br><span class="clean"><br>#### 动态添加实例方法</span><br></code></pre></td></tr></table></figure>
<p>class A():<br>    pass</p>
<p>def func(self):<br>    pass</p>
<p>a = A()<br>a.func = types.MethodType(func, a)    # 给实例添加方法</p>
<pre><code>
如上，可以使用types.MethodType的方式给类的实例添加其实例方法，但该对象的另一个实例则不具备该方法。
</code></pre>]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python函数相关内容</title>
    <url>/page/python2.html</url>
    <content><![CDATA[<h3 id="Python函数的基本特性"><a href="#Python函数的基本特性" class="headerlink" title="Python函数的基本特性"></a>Python函数的基本特性</h3><h4 id="Python函数为对象"><a href="#Python函数为对象" class="headerlink" title="Python函数为对象"></a>Python函数为对象</h4><p>Python中的函数都是对象，这也使得其具备了一些对象的通用特性。</p>
<ul>
<li><p>可作为<strong>值传递</strong>，赋值给另一个对象；</p>
</li>
<li><p>可以作为元素添加到集合对象中；</p>
</li>
<li><p>可以作为参数传递给其他函数；</p>
</li>
<li><p>可以作为函数的返回值。</p>
</li>
</ul>
<p>1、函数赋值给变量，通过变量可以调用。且传递方法为<strong>值传递</strong>，这也就意味着即使删除函数f1，temp仍然能够正常运行。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span><span class="hljs-params">(str)</span>:</span><br>  <span class="hljs-keyword">return</span> len(str)<br>temp=f1	<span class="hljs-comment"># 函数赋值给对象</span><br><span class="hljs-keyword">del</span> f1	<span class="hljs-comment"># 删除函数</span><br><span class="hljs-keyword">print</span> temp(<span class="hljs-string">'hello'</span>)	<span class="hljs-comment"># 仍然正常调用</span><br></code></pre></td></tr></table></figure>

<p>2、作为元素添加进入容器。</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown">def f2(str1,str2):<br>   return str1+str2<br>a=[]<br>a.append(f1)<br>a.append(f2)<br>print a[<span class="hljs-string">0</span>](<span class="hljs-link">'hello'</span>)<br>print a[<span class="hljs-string">1</span>](<span class="hljs-link">'hello','world'</span>)<br></code></pre></td></tr></table></figure>

<p>3、作为函数参数</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit">def <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f,str)</span>:</span><br>  <span class="hljs-keyword">return</span> f(str)<br>print <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f1,<span class="hljs-string">'hello'</span>)</span></span><br></code></pre></td></tr></table></figure>

<p>4、作为函数返回值</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><code class="hljs ruby"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mutiply</span><span class="hljs-params">(x,y)</span></span>:<br>  reutrn x*y<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sub</span><span class="hljs-params">(x,y)</span></span><span class="hljs-symbol">:return</span> x-y<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func2</span><span class="hljs-params">(i)</span></span><span class="hljs-symbol">:if</span> i==<span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-symbol">mutiplyelse:</span><span class="hljs-keyword">return</span> sub<br>temp=func2(<span class="hljs-number">2</span>)<br>print temp(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>)<br></code></pre></td></tr></table></figure>

<p><strong>Python函数是最高级别的对象，而不仅仅为一小段代码</strong>。一个函数是一个被其自己定义和执行的对象，参数是一种“成员数据”，所以它们的状态和其他对象一样，会随着每一次调用而改变。</p>
<h4 id="嵌套与闭包"><a href="#嵌套与闭包" class="headerlink" title="嵌套与闭包"></a>嵌套与闭包</h4><p>1、函数的嵌套</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">def fun1():<br>    def fun2():<br>        def fun3():<br>            print(<span class="hljs-string">"Hello world!"</span>)<br>        return fun3<br>    return fun2<br>fun1()()()<br>##########################################<br>Hello world!<br></code></pre></td></tr></table></figure>

<p>2、函数的闭包</p>
<p><strong>闭包函数就是函数可以读取到与自己不是一个作用域的局部变量</strong></p>
<ol>
<li>必须有一个内嵌函数</li>
<li>内嵌函数必须引用外部函数中的变量</li>
<li>外部函数的返回值必须是内嵌函数</li>
</ol>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">def fun1(x):<br>    def fun2(y):<br>        print(x+y)<br>    return fun2<br>fun1(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)<br>#############################<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p><strong>装饰器，匿名函数，map函数等都是函数的变体，都是通过这些基本特性来实现的</strong></p>
<p><strong>装饰器</strong>：使用函数的嵌套，外层函数传进来的参数为一个函数对象，里层函数对传进来的函数进行加工处理后再返回处理的函数</p>
<h3 id="函数的一些传参方法"><a href="#函数的一些传参方法" class="headerlink" title="函数的一些传参方法"></a>函数的一些传参方法</h3><h4 id="关键字传参"><a href="#关键字传参" class="headerlink" title="关键字传参"></a>关键字传参</h4><p>可以增强代码可读性，每次传参都需要指定形参名，以下就是关键字传参。</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit">def <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a,b)</span>:</span><br>	pass<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a=<span class="hljs-number">1</span>,b=<span class="hljs-number">2</span>)</span></span><br></code></pre></td></tr></table></figure>



<p><strong>Tip：</strong> * 代表之后所有参数传参时必须使用关键字传参（混合形式传参）</p>
<figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">def</span> func(<span class="hljs-built_in">p1</span>,*,<span class="hljs-built_in">p2</span>,<span class="hljs-built_in">p3</span>):<br>    print(<span class="hljs-built_in">p2</span>+<span class="hljs-built_in">p3</span>)<br><span class="hljs-symbol">func</span>(<span class="hljs-number">1</span>,<span class="hljs-built_in">p2</span><span class="hljs-number">=2</span>,<span class="hljs-built_in">p3</span><span class="hljs-number">=3</span>)<br><br># 输出<br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>以下代码中p2、p3不使用关键字传参即会报错。</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit">def <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p1,*,p2,p3)</span>:</span><br>    print(p2+p3)<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span><br><br><span class="hljs-meta"># 输出（报错）</span><br>TypeError                                 Traceback (most recent <span class="hljs-built_in">call</span> last)<br>&lt;ipython-input<span class="hljs-number">-17</span><span class="hljs-number">-83e9</span>b0e5315e&gt; <span class="hljs-keyword">in</span> &lt;module&gt;<br>      <span class="hljs-number">1</span> def <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p1,*,p2,p3)</span>:</span><br>      <span class="hljs-number">2</span>     print(p2+p3)<br>----&gt; <span class="hljs-number">3</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)</span></span><br><br>TypeError: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">takes</span> 1 <span class="hljs-title">positional</span> <span class="hljs-title">argument</span> <span class="hljs-title">but</span> 3 <span class="hljs-title">were</span> <span class="hljs-title">given</span></span><br></code></pre></td></tr></table></figure>

<h4 id="列表传参"><a href="#列表传参" class="headerlink" title="列表传参"></a>列表传参</h4><p>将列表传入函数，只要在列表名前面加上*即可传入</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit">def <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a, b)</span>:</span><br>    print(a+b)<br>l = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(*l)</span></span><br><br><span class="hljs-meta"># 输出</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<h4 id="字典传参"><a href="#字典传参" class="headerlink" title="字典传参"></a>字典传参</h4><p>将字典你传入函数，只需要在字典名前面加上**即可，这种方法可以先将参数写为json格式之后进行传入。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">def <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(a,b,<span class="hljs-built_in">c</span>)</span></span>:<br>    <span class="hljs-built_in">print</span>(a+b+<span class="hljs-built_in">c</span>)<br>param = &#123;<span class="hljs-string">"a"</span>:<span class="hljs-number">1</span>,<span class="hljs-string">"b"</span>:<span class="hljs-number">2</span>,<span class="hljs-string">"c"</span>:<span class="hljs-number">3</span>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(**param)</span></span><br><br># 输出<br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>很好理解，在定义函数时指定该参数的值即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 参数a默认为1</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span><span class="hljs-params">(a=<span class="hljs-number">1</span>)</span>:</span><br>	<span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure>

<h3 id="可变参数（重要特性）"><a href="#可变参数（重要特性）" class="headerlink" title="可变参数（重要特性）"></a>可变参数（重要特性）</h3><p>在定义函数时，不限定参数的个数，而使用<em>args和*</em>kwargs表示。<em>args为元组，*</em>kwargs为字典。</p>
<p>*args将参数打包为tuple给函数体使用，实例如下：</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">def func(a, *args):<br>    print(a)<br>    print(type(a))<br>    print(args)<br>    print(type(args))<br>func(<span class="hljs-string">'gg'</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'gg3'</span>)<br><br>######################################<br>gg<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'str'</span>&gt;<br>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">'gg3'</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'tuple'</span>&gt;<br></code></pre></td></tr></table></figure>

<p>**kwargs将参数打包为dict给函数使用，调用时实参为key=value的形式。</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">def func(a, **kwargs):<br>    print(a)<br>    print(type(a))<br>    print(kwargs)<br>    print(type(kwargs))<br>func(<span class="hljs-string">'gg'</span>, b=<span class="hljs-number">1</span>, c=<span class="hljs-number">1</span>)<br><br>############################################<br>gg<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'str'</span>&gt;<br>&#123;<span class="hljs-string">'b'</span>: <span class="hljs-number">1</span>, <span class="hljs-string">'c'</span>: <span class="hljs-number">1</span>&#125;<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">'dict'</span>&gt;<br></code></pre></td></tr></table></figure>

<h4 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h4><p>当多种参数组合使用时，参数定义顺序为必选参数、默认参数、可变参数。</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>可以简单理解为调用函数的函数。</p>
<h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a><code>lambda</code>表达式</h4><p>lambda是python中的一种表达式，创建内嵌的简单<strong>匿名函数</strong>。可以避免取函数名</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">f = lambda i:i**<span class="hljs-number">2</span><br>f(<span class="hljs-number">2</span>)<br># <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>



<h4 id="filter函数"><a href="#filter函数" class="headerlink" title="filter函数"></a>filter函数</h4><p>filter(func, seq)     返回seq中所有满足func结果为真的对象，可以简单理解为一个过滤器。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"># 找到所有奇数<br>l = range(<span class="hljs-number">10</span>)<br>a = filter(lambda n: n%<span class="hljs-number">2</span>!=<span class="hljs-number">0</span>, l)<br>print(list(a))<br># [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>]<br></code></pre></td></tr></table></figure>



<h4 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h4><p>map (func, seq) 返回对seq执行func后的值，可以简单理解为一个映射。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"># 找到数的所有平方<br>l = range(<span class="hljs-number">5</span>)<br>a = map(lambda n: n**<span class="hljs-number">2</span>, l)<br>print(list(a))<br># [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>]<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基本数据类型</title>
    <url>/page/python1.html</url>
    <content><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>1、 单双引号的应用，即字符串中包含单引号时可以使用双引号进行包含，包含双引号时使用单引号进行包含，如下：</p>
<figure class="highlight scilab"><table><tr><td class="code"><pre><code class="hljs scilab"><span class="hljs-string">"a'</span>s hhh<span class="hljs-string">"<br>'</span>a<span class="hljs-string">"s hhh'</span><br></code></pre></td></tr></table></figure>

<p>2、 字符串的一些基本操作（拼接、搜索、替换），其中<strong>替换操作必须要将str赋给一个新的变量</strong></p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">str</span> = str1 + str2	<span class="hljs-meta"># 拼接字符串（直接使用 + 进行操作）</span><br>len(<span class="hljs-keyword">str</span>) <span class="hljs-meta"># 获取长度</span><br><span class="hljs-keyword">str</span>.find(string) <span class="hljs-meta"># 返回搜索到的第一个index，没搜索到则返回-1</span><br><span class="hljs-keyword">str</span> = <span class="hljs-keyword">str</span>.replace(<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>) <span class="hljs-meta"># A替换B</span><br></code></pre></td></tr></table></figure>

<p>3、 格式化字符串（使用.format语句），使用{}占位符进行</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala"><span class="hljs-string">"&#123;&#125; &#123;&#125; gg"</span>.format(<span class="hljs-string">"huangkai"</span>,<span class="hljs-string">"is"</span>)<br><span class="hljs-meta"># huangkai is gg</span><br><br><span class="hljs-meta"># 带索引的格式化字符串</span><br><span class="hljs-string">"&#123;1&#125; &#123;0&#125; gg"</span>.format(<span class="hljs-string">"huangkai"</span>,<span class="hljs-string">"is"</span>)<br>is huangkai gg<br><br><span class="hljs-meta"># f形式的格式化字符串</span><br>str1 = <span class="hljs-string">'Curry'</span><br>str2 = <span class="hljs-string">'James'</span><br>combi = f<span class="hljs-string">'&#123;str1&#125; and &#123;str2&#125;, NBA stars'</span><br><br><span class="hljs-meta"># 使用别名</span><br>str3 = “gg &#123;s1&#125;， &#123;s2&#125;”。format(s1=str1, s2 str2)<br></code></pre></td></tr></table></figure>

<h3 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h3><p>列表在内存中按照顺序存储</p>
<p>1、 列表反转与排序</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">list</span>.<span class="hljs-built_in">reverse</span>()	<span class="hljs-comment"># 列表反转</span><br><span class="hljs-built_in">list</span>.sort() <span class="hljs-comment"># 升序排列</span><br><span class="hljs-built_in">list</span>.sort(<span class="hljs-built_in">reverse</span>=True) <span class="hljs-comment"># 降序排列</span><br></code></pre></td></tr></table></figure>

<p>2、 列表常用操作</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">list</span>.<span class="hljs-keyword">append</span>(new_element) # 在列表末尾添加元素<br><span class="hljs-keyword">list</span>.<span class="hljs-keyword">insert</span>(<span class="hljs-built_in">index</span>, new_element) # 在指定的<span class="hljs-built_in">index</span>处加入一个元素，其后元素全部后移<br><span class="hljs-keyword">list</span>.<span class="hljs-built_in">remove</span>(element) # 删除值为element的元素<br><span class="hljs-keyword">list</span>.<span class="hljs-keyword">pop</span>(<span class="hljs-built_in">index</span>) # 删除索引值为<span class="hljs-built_in">index</span>的元素，无<span class="hljs-built_in">index</span>则删除最后一个元素<br><span class="hljs-keyword">list</span>.clear() # 清空列表<br></code></pre></td></tr></table></figure>

<p>4、 列表其他操作（区别于append）</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">list</span>.<span class="hljs-built_in">extend</span>([e1, e2]) # 将列表追加进<span class="hljs-keyword">list</span>（区别于<span class="hljs-keyword">append</span>）<br></code></pre></td></tr></table></figure>

<p>5、 <strong>列表的复制</strong>，想将一个列表赋值给另一个列表必须要使用.copy方法，否则修改其中一个表另一个也会变，如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">l1 = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>l2 = l1<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(id(l1)</span></span>)<br><span class="hljs-function"><span class="hljs-title">print</span><span class="hljs-params">(id(l2)</span></span>)<br></code></pre></td></tr></table></figure>
<p>运行结果可以发现l1与l2指向了同一块内存，因此改变l1，l2也会相应改变。而copy()方法会重新创建一个空列表再将原列表的元素放进去。</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">l2 = <span class="hljs-built_in">list</span>.<span class="hljs-keyword">copy</span>()<br></code></pre></td></tr></table></figure>

<p>6、列表元素直接的对应操作，以相加为例，使用列表生成器如下。其中zip函数为将a、b两个列表中的元素一一组合。</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean">a = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>b = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>c = [i+j for i, j <span class="hljs-keyword">in</span> zip(a,b)]<br>########################################<br>[<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure>



<h3 id="字典（dict）"><a href="#字典（dict）" class="headerlink" title="字典（dict）"></a>字典（dict）</h3><p>键值对（key-value），可修改。Python中的散列值函数<code>hash(data)</code>，字典存储根据其哈希值存储。</p>
<p>1、 创建</p>
<figure class="highlight python"><table><tr><td class="code"><pre><code class="hljs python">dic = dict.fromkeys([<span class="hljs-string">'school number'</span>, <span class="hljs-string">'bala1'</span>, <span class="hljs-string">'bala2'</span>])<br>print(dic)<br><br><span class="hljs-comment"># 输出</span><br>&#123;<span class="hljs-string">'school number'</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">'bala1'</span>: <span class="hljs-literal">None</span>, <span class="hljs-string">'bala2'</span>: <span class="hljs-literal">None</span>&#125;<br></code></pre></td></tr></table></figure>

<p>2、 取值</p>
<figure class="highlight q"><table><tr><td class="code"><pre><code class="hljs q"># 直接使用<span class="hljs-built_in">key</span>获取<span class="hljs-built_in">value</span><br>dic[<span class="hljs-built_in">key</span>]<br># 使用<span class="hljs-built_in">get</span>方法（可以为不存在的<span class="hljs-built_in">key</span>赋默认值）<br>dic.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span>)<br></code></pre></td></tr></table></figure>

<p>3、 遍历字典</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 方案1</span><br><span class="hljs-attr">for</span> <span class="hljs-string">key in dic:</span><br>	<span class="hljs-attr">v</span> = <span class="hljs-string">dic[key]</span><br><span class="hljs-comment">	<br># 方案2（返回每一个键值对）</span><br><span class="hljs-attr">for</span> <span class="hljs-string">key,value in dic.items():</span><br></code></pre></td></tr></table></figure>

<p>4、 字典常用操作</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">dic.update(k1 </span>= new_value1, k2 = new_value2) <span class="hljs-comment"># 对多个键值进行更新或新增</span><br><span class="hljs-keyword">dic,pop(key) </span><span class="hljs-comment"># 删除键值为key</span><br><span class="hljs-keyword">dic.popitem() </span><span class="hljs-comment"># 删除最后一个键值对，并返回该键值对的tuple</span><br><span class="hljs-keyword">dic.clear() </span><span class="hljs-comment"># 清空字典</span><br><span class="hljs-keyword">dic.setdefault('key', </span><span class="hljs-string">'value'</span>) <span class="hljs-comment"># 设置默认值（如果没有该键值的话）</span><br><br><span class="hljs-comment"># 修改字典时下面三个值都会变</span><br><span class="hljs-keyword">dic.keys()	</span><span class="hljs-comment"># 返回所有键</span><br><span class="hljs-keyword">dic.values() </span><span class="hljs-comment"># 返回所有值</span><br><span class="hljs-keyword">dic.items() </span><span class="hljs-comment"># 返回所有键值对</span><br><br><span class="hljs-comment"># 格式化字符串，使用format_map</span><br><span class="hljs-keyword">dic </span>= &#123;<span class="hljs-string">'name'</span>:<span class="hljs-string">'Curry'</span>,<span class="hljs-string">'gg'</span>:<span class="hljs-string">'no'</span>&#125;<br>s = <span class="hljs-string">"姓名:&#123;name&#125;,瞎写:&#123;gg&#125;"</span>.format_map(<span class="hljs-keyword">dic)<br></span>print(s)<br><span class="hljs-comment"># 输出</span><br>姓名:Curry,瞎写:no<br></code></pre></td></tr></table></figure>

<h3 id="元组（tuple）"><a href="#元组（tuple）" class="headerlink" title="元组（tuple）"></a>元组（tuple）</h3><p>创建后不允许修改，当列表等可变对象为元组元素时，可以修改该元素的值。</p>
<h3 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h3><p>元素是无序的、可变的、元素不能重复，在内存中是分散保存的（存储方式与字典相似），缺点，浪费内存空间</p>
<p>1、 初始化</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># 空集合的创建</span><br><span class="hljs-meta"># 不能使用s = &#123;&#125;，这样默认创建的是字典</span><br>set1 = <span class="hljs-keyword">set</span>()<br></code></pre></td></tr></table></figure>
<p>2、 集合的常用运算</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">set1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br>set2 = &#123;<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>&#125;<br><br># 交集运算<br>set3 = set1.<span class="hljs-built_in">int</span>ersection(set2)	# 产生新集合<br># <span class="hljs-built_in">int</span>ersection_update为更新原有集合<br>print(set3)<br># 输出<br>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br><br># 并集运算<br>set3 = set1.union(set2)<br>print(set3)<br># 输出<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;<br><br># 差集运算<br>set3 = set1.difference(set2) # 得到set1中有，set2中没有的元素 <br>print(set3)<br># 输出<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><br># 双向差集<br>set3 = set1.symmetric_difference(set2)<br>print(set3)<br># 输出<br>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>&#125;<br></code></pre></td></tr></table></figure>

<p>3、 集合间的关系操作</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"># 判断两个集合的元素是否完全相同<br>s1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br>s2 = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>&#125;<br>print(s1 == s2)<br># 输出<br>True<br></code></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"># 子集判断<br># 父集判断，同理。 .issuperset()<br>s1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br>s2 = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;<br>print(s2.issubset(s1))<br># 输出<br>True<br></code></pre></td></tr></table></figure>

<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"># 判断两个集合是否存在重复元素<br># 返回False代表存在重复元素<br>s1 = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>&#125;<br>s2 = &#123;<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;<br>print(s1.isdisjoint(s2))<br># 输出<br>False<br></code></pre></td></tr></table></figure>

<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver"><span class="hljs-comment"># 新增数据</span><br><span class="hljs-built_in">set</span>.<span class="hljs-built_in">add</span>(<span class="hljs-keyword">element</span>) <span class="hljs-comment"># 一次添加一个元素</span><br><span class="hljs-built_in">set</span>.update(列表或元组) <span class="hljs-comment"># 一次添加多个元素</span><br><span class="hljs-comment"># 删除元素</span><br><span class="hljs-built_in">set</span>.remove(<span class="hljs-keyword">element</span>) <span class="hljs-comment"># 删除不存在的元素会报错</span><br><span class="hljs-built_in">set</span>.discard(<span class="hljs-keyword">element</span>) <span class="hljs-comment"># 删除不存在的元素会直接忽略</span><br></code></pre></td></tr></table></figure>

<h3 id="常用的转换函数"><a href="#常用的转换函数" class="headerlink" title="常用的转换函数"></a>常用的转换函数</h3><figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-built_in">list</span>() <span class="hljs-comment"># 转换为列表</span><br>tuple() <span class="hljs-comment"># 转换为元组</span><br>join(), str() <span class="hljs-comment"># 转换为字符串</span><br></code></pre></td></tr></table></figure>

<h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>1、 <strong>列表生成器</strong>，常用形式如下</p>
<p>[数据 循环语句 循环或判断语句]</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">l = [i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>)]<br># [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>, <span class="hljs-number">16</span>, <span class="hljs-number">25</span>, <span class="hljs-number">36</span>, <span class="hljs-number">49</span>, <span class="hljs-number">64</span>, <span class="hljs-number">81</span>]<br><br>l = [i**<span class="hljs-number">2</span> <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> range(<span class="hljs-number">10</span>) <span class="hljs-keyword">if</span> i%<span class="hljs-number">2</span> ==<span class="hljs-number">0</span>]<br># [<span class="hljs-number">0</span>, <span class="hljs-number">4</span>, <span class="hljs-number">16</span>, <span class="hljs-number">36</span>, <span class="hljs-number">64</span>]<br></code></pre></td></tr></table></figure>

<p>2、 字典生成器</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">list1</span> = [<span class="hljs-string">'A'</span>, <span class="hljs-string">'B'</span>, <span class="hljs-string">'C'</span>]<br><span class="hljs-attr">dic</span> = &#123;i:list1[i] for i in range(len(list1))&#125;<br><span class="hljs-comment"># &#123;0: 'A', 1: 'B', 2: 'C'&#125;</span><br></code></pre></td></tr></table></figure>

<p>3、 集合生成器（跟列表生成式类似）</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">set1</span> = &#123;i for i in range(<span class="hljs-number">10</span>)&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Python</category>
        <category>Python基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Anaconda+PyCharm配置PyQt5全过程</title>
    <url>/page/pyqt5-env-ide-build.html</url>
    <content><![CDATA[<p>前段时间写了一个手写电话号码识别的小程序，GUI用的是Python自带的Tkinter，但这种GUI太简陋可视化效果不佳，因此打算使用别的更加强大的GUI重构一下，目光就瞄准了pyqt，因为用C++时接触过，知道这是个好用的GUI吧。</p>
<h2 id="Anaconda下安装"><a href="#Anaconda下安装" class="headerlink" title="Anaconda下安装"></a>Anaconda下安装</h2><p>在Anaconda在GitHub上的issue下知道由于兼容Python2的原因没法用conda安装最新版PyQt5包，所以得使用pip命令进行安装。</p>
<p>在Anaconda自带的prompt下输入以下命令即可完成安装。</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake">pip3 <span class="hljs-keyword">install</span> PyQt5<br></code></pre></td></tr></table></figure>

<p>但速度通常很慢，因此建议改为清华的镜像进行安装。</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><code class="hljs groovy">pip install -i <span class="hljs-string">https:</span><span class="hljs-comment">//pypi.tuna.tsinghua.edu.cn/simple PyQt5</span><br></code></pre></td></tr></table></figure>

<p>之后在命令行窗口输入<code>import PyQt5</code>，不报错，说明安装成功。</p>
<h2 id="Pycharm下配置相关环境"><a href="#Pycharm下配置相关环境" class="headerlink" title="Pycharm下配置相关环境"></a>Pycharm下配置相关环境</h2><p>用过Qt的应该都知道Qt有QtDesigner这种优秀的可视化设计工具，可以简化编码，所以如果使用PyCharm作为IDE编写Python的话需要将QtDesigner作为拓展程序进行配置（这样可以在IDE中直接进行调用了，会很方便）。除此之外，还需要配置将QtDesigner生成的.ui文件转化为.py文件。</p>
<h3 id="配置QtDesigner"><a href="#配置QtDesigner" class="headerlink" title="配置QtDesigner"></a>配置QtDesigner</h3><p>在PyCharm中的<code>File-&gt;Settings</code>下，进行如下操作，即可配置完成QDesigner。</p>
<p><img src="http://cdn.ziyedy.top/image/Python/GUI/Anaconda%2BPyCharm%E9%85%8D%E7%BD%AEPyQt5%E5%85%A8%E8%BF%87%E7%A8%8B/1.png" alt=""></p>
<h3 id="配置PyUIC"><a href="#配置PyUIC" class="headerlink" title="配置PyUIC"></a>配置PyUIC</h3><p>使用QDesigner生成的文件格式为.ui的格式，要将其转化为.py格式安装的pyqt包中也已经写好的相应的程序。在上图中的相同界面中输入以下信息。</p>
<p><img src="http://cdn.ziyedy.top/image/Python/GUI/Anaconda%2BPyCharm%E9%85%8D%E7%BD%AEPyQt5%E5%85%A8%E8%BF%87%E7%A8%8B/2.png" alt=""></p>
<p>program中输入pyuic5.exe的路径。</p>
<p>在参数栏中输入如下命令：(该命令就是将.ui转化为.py文件)</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$FileName</span><span class="hljs-variable">$ </span>-o <span class="hljs-variable">$FileNameWithoutExtension</span><span class="hljs-variable">$.</span>py<br></code></pre></td></tr></table></figure>

<p>该步骤中也有直接输入pyuic.py文件的，但我试验了以下没有成功，所以使用.exe文件还是最靠谱的（Windows下）。</p>
<h2 id="使用实验"><a href="#使用实验" class="headerlink" title="使用实验"></a>使用实验</h2><p>在菜单栏“工具”中找到拓展工具，选择QDesigner即可。</p>
<p><img src="http://cdn.ziyedy.top/image/Python/GUI/Anaconda%2BPyCharm%E9%85%8D%E7%BD%AEPyQt5%E5%85%A8%E8%BF%87%E7%A8%8B/3.png" alt=""></p>
<p>打开设计工具之后，即可创建相应的ui界面如下：</p>
<p><img src="http://cdn.ziyedy.top/image/Python/GUI/Anaconda%2BPyCharm%E9%85%8D%E7%BD%AEPyQt5%E5%85%A8%E8%BF%87%E7%A8%8B/4.png" alt=""></p>
<p>这时候可以看到PyCharm界面中多了一个.ui文件，在该文件上右击，选择拓展工具中的PyUIC即可完成.ui到.py的转换。</p>
<p><img src="http://cdn.ziyedy.top/image/Python/GUI/Anaconda%2BPyCharm%E9%85%8D%E7%BD%AEPyQt5%E5%85%A8%E8%BF%87%E7%A8%8B/5.png" alt=""></p>
<p>此时可以发现多了一个同名的.py文件，打开文件里面包含的就是之前设计好的界面的python代码了，加入以下主函数运行：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">import sys<br>from PyQt5.QtWidgets import QApplication, QMainWindow<br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">'__main__'</span>:<br>    app = QApplication(sys.argv)<br>    MainWindow = QMainWindow()<br>    ui = Ui_MainWindow()<br>    ui.setupUi(MainWindow)<br>    MainWindow.show()<br>    sys.<span class="hljs-keyword">exit</span>(app.exec_())<br></code></pre></td></tr></table></figure>

<p>即可得到如下结果：</p>
<p><img src="http://cdn.ziyedy.top/image/Python/GUI/Anaconda%2BPyCharm%E9%85%8D%E7%BD%AEPyQt5%E5%85%A8%E8%BF%87%E7%A8%8B/6.png" alt=""></p>
<p>OK，那使用PyQt5构建python的GUI程序的流程总算整通了。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.jianshu.com/p/094928ac0b73" target="_blank" rel="noopener">https://www.jianshu.com/p/094928ac0b73</a></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>PyQt5</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo实现多台机器同时编写博客</title>
    <url>/page/hexo3.html</url>
    <content><![CDATA[<p>正常情况下，只在一台电脑上使用hexo编写部署博客非常方便，但多台电脑进行部署就需要云盘等媒介进行md文件的传输了。我的电脑是双系统，因此如果要部署的话还得重启，比较麻烦，因此干脆实现一个博客多设备管理，方便快捷。</p>
<p>实现多设备的博客管理关键就是要实现本地hexo源文件的多台设备传输与修改，首先想到的当然是使用git了。本地的<code>_config.yml</code>文件中默认使用<code>hexo d</code>进行部署是部署在GitHub相应项目（也就是以用户名命名的博客项目）的<code>master</code>分支上的，因此，只需要在同一项目上新建一个存储源文件的分支即可解决问题。</p>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>在已经作为博客本地文件的地方打开终端输入以下命令</p>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts">git branch <span class="hljs-params">&lt;hexo&gt;</span>	<span class="hljs-comment">//hexo处为你想建立的分支的名字</span><br></code></pre></td></tr></table></figure>

<p>之后在github中博客仓库的<code>-&gt;Settings-&gt;Branches-&gt;Default branch</code>下将默认分支改为新建的分支，并保存更新。</p>
<h3 id="分支连接本地文件"><a href="#分支连接本地文件" class="headerlink" title="分支连接本地文件"></a>分支连接本地文件</h3><ol>
<li><p>最简单且有效的方法就是将新建的<code>hexo</code>分支<code>git clone</code>到本地文件夹内，输入<code>git branch</code>即可看到当前分支为<code>hexo</code>。</p>
</li>
<li><p>再将之前新建的博客文件复制到以上文件夹中，注意将<code>themes</code>文件中隐藏的<code>.git</code>文件等与git有关的文件删除，否则主题文件会默认为是整个项目的一个子模块而不被上传到你的GitHub。</p>
</li>
<li><p>将之前部署生成的<code>.deploy_git</code>文件删除，否则由于之前删去了部分原来的git信息部署时有可能会发生错误。</p>
</li>
<li><p>输入如下命令你的博客的源码分支hexo就建立好了。</p>
</li>
</ol>
<figure class="highlight armasm"><table><tr><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">git</span> <span class="hljs-keyword">add </span>.<br><span class="hljs-symbol">git</span> commit -m <span class="hljs-string">"first push"</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push </span>origin hexo<br></code></pre></td></tr></table></figure>

<ol start="5">
<li>想在另一台电脑上写博客时。只要确保该电脑安装了hexo所需要的各种环境（再在GitHub上加入ssh密匙），只需要在本地建立一个文件夹将博客源文件<code>clone</code>下来即可。而每次更新上传后，在另一台计算机上只需每次使用<code>git pull</code>更新一下源文件即可十分方便。</li>
</ol>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>多机同时管理博客其实就是在一个github仓库的<code>master</code>分支存储网页静态文件，在<code>hexo</code>分支存储博客源文件。由于hexo进行部署时默认是在<code>master</code>分支上部署（<code>_config.yml</code>文件中可见），因此部署博客时还是输入以下代码即可</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">g</span><br><span class="hljs-attr">hexo</span> <span class="hljs-string">d</span><br></code></pre></td></tr></table></figure>

<p>同时应该注意的是，这样做会使得源文件开源，不想开源的话可以在github仓库中设置该仓库为private。这样该仓库就不可见但gitpage的功能也使用不了了，所以要怎样做仁者见仁智者见智吧。</p>
]]></content>
      <categories>
        <category>问题解决</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客部署到腾讯云服务器全流程</title>
    <url>/page/hexo2.html</url>
    <content><![CDATA[<p>Hexo署到Githubpage上在国内访问速度很慢，正好前段时间买了一个腾讯云服务器，就干脆把hexo生成的博客文件直接放到云上跑算了，本文记录将hexo同时部署到GitHub与腾讯云服务器的过程。参考博客<a href="https://blog.csdn.net/StaunchKai/article/details/82878928" target="_blank" rel="noopener">https://blog.csdn.net/StaunchKai/article/details/82878928</a></p>
<h2 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h2><ul>
<li>本地环境<ul>
<li>Ubuntu 18.04（64bit）</li>
<li>所需环境：git，Node.js，hexo</li>
</ul>
</li>
<li>服务器环境<ul>
<li>腾讯云（CentOS 7.6 64bit）</li>
<li>所需环境：git，Nginx</li>
</ul>
</li>
</ul>
<h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>安装依赖包：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> curl-devel expat-devel gettext-devel openssl-devel zlib-devel<br>yum <span class="hljs-keyword">install</span>  gcc perl-ExtUtils-MakeMaker<br></code></pre></td></tr></table></figure>

<p>卸载旧版本git（如果服务器自带git太旧的话）</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> <span class="hljs-string">/usr/local/src</span>   <span class="hljs-string">//</span> 选择文件保存位置<br>wget https:<span class="hljs-string">//mirrors.edge.kernel.org/pub/software/scm/git/git-2.19.0.tar.gz</span>   <span class="hljs-string">//</span> 下载链接<br>tar -zxvf git-2.19.0.tar.gz   <span class="hljs-string">//</span> 解压<br></code></pre></td></tr></table></figure>

<p>具体的版本选择可在<a href="https://mirrors.edge.kernel.org/pub/software/scm/git/" target="_blank" rel="noopener">https://mirrors.edge.kernel.org/pub/software/scm/git/</a> 查看。</p>
<p>编译安装</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss">cd git<span class="hljs-number">-2.19</span><span class="hljs-number">.0</span>   <span class="hljs-comment">// 进入文件夹</span><br><span class="hljs-built_in">make</span> prefix=/usr/<span class="hljs-keyword">local</span>/git all  <span class="hljs-comment">// 编译源码</span><br><span class="hljs-built_in">make</span> prefix=/usr/<span class="hljs-keyword">local</span>/git install  <span class="hljs-comment">// 安装至 /usr/local/git 路径</span><br></code></pre></td></tr></table></figure>

<p>之后正常的话<code>git --version</code>就可以看到git的版本了，如果在终端输入git没反应，则应该将git的安装位置加入环境变量中。</p>
<h3 id="创建git用户"><a href="#创建git用户" class="headerlink" title="创建git用户"></a>创建git用户</h3><figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">adduser</span> <span class="hljs-string">git</span><br><span class="hljs-attr">passwd</span> <span class="hljs-string">git</span><br><span class="hljs-attr">chmod</span> <span class="hljs-string">740 /etc/sudoers</span><br><span class="hljs-attr">vim</span> <span class="hljs-string">/etc/sudoers</span><br></code></pre></td></tr></table></figure>

<p>找到以下内容</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">## Allow root <span class="hljs-keyword">to</span> run <span class="hljs-keyword">any</span> commands anywhere<br>root    <span class="hljs-keyword">ALL</span>=(<span class="hljs-keyword">ALL</span>)       <span class="hljs-keyword">ALL</span><br></code></pre></td></tr></table></figure>

<p>在root的下面添加一行</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">git <span class="hljs-keyword">ALL</span>=(<span class="hljs-keyword">ALL</span>) <span class="hljs-keyword">ALL</span><br></code></pre></td></tr></table></figure>

<p>保存退出后将权限改回来</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">chmod <span class="hljs-number">400</span> /etc/sudoers<br></code></pre></td></tr></table></figure>

<h3 id="密匙配置"><a href="#密匙配置" class="headerlink" title="密匙配置"></a>密匙配置</h3><p>与将本地博客文件连接至GitHub一样，将本地的<code>id_rsa.pub</code>复制好，在服务器创建.ssh下的文件，粘贴进去。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">su</span> <span class="hljs-string">git</span><br><span class="hljs-attr">mkdir</span> <span class="hljs-string">~/.ssh</span><br><span class="hljs-attr">vim</span> <span class="hljs-string">~/.ssh/authorized_keys</span><br></code></pre></td></tr></table></figure>

<p>修改权限</p>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-keyword">cd</span> ~<br>chmod 600 <span class="hljs-string">.ssh/authorzied_keys</span><br>chmod 700 <span class="hljs-string">.ssh</span><br></code></pre></td></tr></table></figure>

<h3 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h3><p>在本地终端输入</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -v git<span class="hljs-variable">@SERVER</span><br></code></pre></td></tr></table></figure>

<p>SERVER为你的服务器的公网地址，在控制台可以找到，如果成功连接说明服务器git配置成功。</p>
<h3 id="创建网站根目录"><a href="#创建网站根目录" class="headerlink" title="创建网站根目录"></a>创建网站根目录</h3><p>网站根目录就是之后存放博客静态文件与资源的位置，你可以自己挑选位置创建你的根目录，之后再赋予权限。</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">su root<br><span class="hljs-built_in">mkdir</span> /<span class="hljs-built_in">home</span>/myblog    # 此目录为网站的根目录<br>chown git:git -R /<span class="hljs-built_in">home</span>/myblog<br></code></pre></td></tr></table></figure>

<h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><figure class="highlight gml"><table><tr><td class="code"><pre><code class="hljs gml">yum install -<span class="hljs-symbol">y</span> nginx    <span class="hljs-comment">// 安装</span><br>systemctl start nginx.service     <span class="hljs-comment">// 启动服务</span><br></code></pre></td></tr></table></figure>

<p>此时访问<strong>公网ip/80</strong>应该就能看到nginx的初始界面。</p>
<h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h3><p>使用<code>nginx -t</code>查看配置文件位置，一般为<code>/etc/nginx/nginx.conf</code></p>
<p>打开nginx.conf文件，修改配置文件如下</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span> default_server;<br>    <span class="hljs-attribute">listen</span>       [::]:<span class="hljs-number">80</span> default_server;<br>    <span class="hljs-attribute">server_name</span>  www.ziyedy.top;    <span class="hljs-comment"># 修改为自己的域名</span><br>    <span class="hljs-attribute">root</span>         /home/myblog;    <span class="hljs-comment"># 修改为网站的根目录</span><br><br>    <span class="hljs-comment"># Load configuration files for the default server block.</span><br>    <span class="hljs-attribute">include</span> /etc/nginx/default.d/<span class="hljs-regexp">*.conf</span>;<br><br>    <span class="hljs-attribute">location</span> / &#123;<br>    	<span class="hljs-attribute">index</span> index.html	<span class="hljs-comment"># 设置自己的index网页</span><br>    &#125;<br><br>    error_page <span class="hljs-number">404</span> /<span class="hljs-number">404</span>.html;<br>        <span class="hljs-attribute">location</span> = /40x.html &#123;<br>    &#125;<br><br>    <span class="hljs-attribute">error_page</span> <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span> /50x.html;<br>        <span class="hljs-attribute">location</span> = /50x.html &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>之后可以使用<code>nginx -t</code>检查配置文件中是否有语法错误，之后重启服务即可。</p>
<h2 id="hexo自动部署"><a href="#hexo自动部署" class="headerlink" title="hexo自动部署"></a>hexo自动部署</h2><h3 id="建立git裸库"><a href="#建立git裸库" class="headerlink" title="建立git裸库"></a>建立git裸库</h3><p>在与文件同一根目录下建立裸库</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">su</span> <span class="hljs-string">root</span><br><span class="hljs-attr">git</span> <span class="hljs-string">init --bare blog.git</span><br></code></pre></td></tr></table></figure>

<p>这时，<code>git</code> 用户的 <code>~</code> 目录下就存在一个 <code>blog.git</code> 文件夹，可使用 <code>ls</code> 命令查看。再修改 <code>blog.git</code> 的权限。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">chown</span> <span class="hljs-selector-tag">git</span><span class="hljs-selector-pseudo">:git</span> <span class="hljs-selector-tag">-R</span> <span class="hljs-selector-tag">blog</span><span class="hljs-selector-class">.git</span><br></code></pre></td></tr></table></figure>

<h3 id="使用git-hooks同步网站根目录"><a href="#使用git-hooks同步网站根目录" class="headerlink" title="使用git-hooks同步网站根目录"></a>使用git-hooks同步网站根目录</h3><p>在这使用的是 <code>post-receive</code> 这个钩子，当 <code>git</code> 有收发的时候就会调用这个钩子。 在 <code>blog.git</code> 裸库的 hooks 文件夹中，新建 <code>post-receive</code> 文件。</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">vim blog.git<span class="hljs-regexp">/hooks/</span>post-receive<br></code></pre></td></tr></table></figure>

<p>填入以下内容，注意myblog应该填入自己的根目录文件名</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/sh</span><br>git --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f<br></code></pre></td></tr></table></figure>

<p>保存后，赋予该文件可执行权限</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">chmod +x <span class="hljs-regexp">/home/gi</span>t<span class="hljs-regexp">/blog.git/</span>hooks<span class="hljs-regexp">/post-receive</span><br></code></pre></td></tr></table></figure>

<h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><p>与部署到GitHub相同，在本地博客文件根目录下的<code>_config.yml</code> 文件中修改<code>deploy</code>设置如下。SERVER为服务器的公网ip，如果不想部署到GitHub了将<code>github</code>一行删去即可。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-attribute">deploy</span>:<br>  <span class="hljs-attribute">type</span>: git<br>  <span class="hljs-attribute">repo</span>:<br>    <span class="hljs-attribute">github</span>: git<span class="hljs-variable">@github</span>.<span class="hljs-attribute">com</span>:xxxx/xxxx.github.io.git<br>    <span class="hljs-attribute">git1</span>: git<span class="hljs-variable">@SERVER</span>:/home/git/blog.git <br>  <span class="hljs-attribute">branch</span>: master<br></code></pre></td></tr></table></figure>

<p>之后正常配置</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">hexo</span> <span class="hljs-string">clean</span><br><span class="hljs-attr">hexo</span> <span class="hljs-string">g</span><br><span class="hljs-attr">hexo</span> <span class="hljs-string">d</span><br></code></pre></td></tr></table></figure>

<p>这是输入你的公网ip即可进入你的博客，要实现域名访问，在你的域名内解析你的公网ip即可。</p>
]]></content>
      <categories>
        <category>问题解决</category>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>务虚时代下的国贼——李鸿章</title>
    <url>/page/Li_Hongzhang.html</url>
    <content><![CDATA[<center>一</center>

<p>近日看老剧《走向共和》，其前半段多以李鸿章之视角演绎，李鸿章何许人也，若非要集这百年悠悠之口套出几个词来，想必就是汉奸卖国贼之类的了，至少用于普及基本历史常识的历史课本中，作为百年国耻代表的《马关条约》与《辛丑条约》之上，就铸着该君的名字，所以这样说也没错。</p>
<p>所谓汉奸，所谓卖国贼，这两个词至少在中华文化体系下是一种性质非常恶劣的词了吧，这与百年辛酸史，或者说在国家危亡之际国人对所谓“忠臣名将”的向往是分不开的，无论何人，无论何时，只要在身份认同上认为自己是中国人的，对待这些人都可以堂而皇之的啐一口唾沫，道一声“呸”。因为在我们中国人眼中，对历史的“通俗看法”（所谓通俗看法，是指不专门研究某一段历史的普通人，对身处该时段历史人物的主观看法，或说评价）是有底线和顶线的，底线想必就是卖国攘民等龌龊行径了，而顶线就是所谓为国请命的英雄们了，或者说以死明志的气节。当然除此之外，在看待历史人物时，顶线与底线往往还联络着主角道德的好与坏。</p>
<center>二</center>

<p>底线之下，无论之前干过什么，无论这个人作为一个人来讲怎么样，都不值得原谅，参考秦桧与汪精卫（前者还跪着呢）；而顶线之上，有所作为当然更好，但似乎事情做没做成也没有太大所谓，死谏，不趋附权贵，最好再带点文采写些个正气凛然的东西或者稀里糊涂的处在一段展现美好品行的故事中心，都值得树碑立传，万世景仰（至少在大部分国人心目中此类人物的形象是好的），参考孔融。</p>
<p>底线之下，无甚好说，做了过分引人注目的坏事情，难道还会有很多人愿意去考虑你干这坏事之前的心路？大部分人会憎恶你，少部分脑袋勤快点的人会在憎恶中加上一些同情，还有极小部分人会把你当成一个工具，表达他们“看清事实”与“与众不同”的工具，这一类人不谈也罢，他们不懂得当瑕疵多到一种程度时，瑕不掩瑜这个词是不适用的。</p>
<p>但顶线之上就会有一些问题了，在史书中活成这一类的人心念一动就能想出很多，他们大部分都可以作为鲁迅先生笔下我中华的脊梁，但我偏偏把孔融放在这里，为何呢？是因为我想说明这条适用于大众的对历史人物看法的惯性思维多半有些不客观。“孔四岁，能让梨”，这是大部分人都清楚的故事，别的不说，我在痴迷三国的那个年龄，总还是把孔融当成个人物的。但稍稍读点书，以今日之眼光，想瞧得上孔融这个人实在是难，可他却在未来的两千年里享尽英德之名，被无数父母当作启蒙孩子的一个典范，与古往今来无数仁人志士枭雄豪杰并排而立，我以为实在是忝列其中啊。</p>
<center>三</center>

<p>让一个梨便得以流芳千古，这个梨也实在是贵的很啊，让梨这个操作也算是东汉末年一个最成功的炒作了吧。但我实在是不明白大一点的梨子是孔融吃掉还是他哥哥吃掉到底对他们一家或者说对他们兄弟二人能有多大干系呢。非要说的话，难道梨子在东汉越大越香？而大到一定程度会产生口感上的质变？还是一个天生不太喜欢吃梨子的小孩在东汉不太常见？</p>
<p>我以为是后者，毕竟在一个百姓连饭都吃不饱的时代，产生一个类似孔融这种不喜欢梨的小孩实在是困难，这也是保证这件事合理性的唯一解释了，不然孔融一家想必都有癔症。</p>
<p>但遗憾的是，事实来看他们一家就是有癔症，也许是遗传的吧。毕竟硬要说的话，他们的老祖宗孔丘也有癔症，但孔夫子的癔症到底是在我这个两千多年后的后生眼里才能得见的，在孔夫子那个时代就算是癔症也多少有些可爱。但一种病毒也许两千年前无伤大雅甚至可以说是可爱，到一千年前病毒几经变异变成了值得称颂的一个身体特征，而到了一百多年前当一个群体把感染了这个病毒当成荣耀并认为人人便该如此的时候，来了另一群没得病且更强壮的人使得感染这个病毒变成了自然选择的一个逆选项时，有一些病人开始尝试治病但囿于同胞掣肘与病毒几经进化下的狡诈以及自身体内病毒的顽固，失败了，对于这种人，在考虑失败后果之前，我以为首先得感慨一下其知其不可而为之的勇气，至少这是我尊敬孔子的一个重要原因，也是我认为对卖国贼李鸿章，有必要进行另一番议论的原因。</p>
<center>四</center>

<p>以上所述的“癔症”，我想与今年的新冠肺炎多少有些类似，症状复杂容易变异，只是这癔症并不作用在生理上而是作用在精神上。其症状很多，五花八门，但我今天想谈谈的只有务虚。</p>
<p>就像孔融让梨得到赞扬一样，赞扬的不是让梨这个动作而是其谦让的品德。我从不否认谦让是个美德，但让一个历史上实实在在活生生的人，因为这样一个简单的动作就成为了根植一个名族内心千年的道德符号，我认为实在是荒谬了些，哲学上喜欢将一件事情推到极端而后再观察其是否仍然符合某一标准，而长大后的孔融倒着实使这个荒谬的意味更深了些。</p>
<p>几乎没有付出任何代价与个人的努力，一件名门世家随意记录的小小的事情，让一个人毫不费力收获了也许是古往今来来自孩子和家长们最多的赞誉，这不是偶然，而是自先秦到清末国人一直存在的务虚观念，几个小小的汉字，所谓仁义礼智信孝廉，都是好的优秀的修身品德，也从来都是封建时代的国人精英们竞相模仿参照的对象，可仔细想想，这几个字有所谓放之四海而皆准的具体的标准与定义吗？是所谓的标准管用还是历代大儒帝王的一声惊叹或者流传坊间的一段传奇更加管用呢？普通人是实实在在的做事更能得到赞扬还是卧冰求鲤式的“作秀”更能得到赞扬呢？</p>
<p>这些品德确立之初的好坏我无从得知，但由于上述文字解释权等原因，这几个字或者说我中华中世纪所追求的那些抽象的概念，渐渐变为了权力与利益的代言人，成为了统治者所谓推行“王治”的工具（与其说是王治，不如说是愚民）。而随着皇权的愈加集中，传播这些务虚概念的工具，即我们引以为傲的科举，使得无数中世纪乃至近代的国人精英沦为了务虚的奴隶，深陷囹圄而自以为自由（李鸿章有改变很多事物的资本，但他囿于所谓忠君之类的概念敷衍其事含糊其词，想必也是务虚已入骨髓矣）。在没有西方文化冲击的情况下，整个民族和国家都浸沐在这务虚的汤药中，难以自拔。</p>
<p>我本身是一个很懒惰的人，所谓磨洋工的一把好手，所以倘若我在百年千年前的话，肯定会变着花样以把自己弄死为标准去对应这些百姓追求统治者喜欢的概念，也许周围正好来了个大儒书圣，听说了我的故事的话还能把我的事迹记录一些，这样“流芳百世”的难度的确是大，但想必也比实干勤学的概率要大的多，还省去了不论是脑力还是体力带来的困难与麻烦，整不好运气更好点倒是能成为孔融一样的道德符号，实在是妙啊，妙不可言。</p>
<p>既然务虚便能带来一切能够自我宽慰还得社会认可的东西，那作为贵族官员干嘛要务实呢？留着指甲，以商贾为耻，以农桑为耻，以一切实干为耻（当然社会是需要人做实事的，但做实事在我们的文化里受待见吗？所谓君子远庖厨，历朝历代各个英雄豪杰当然也有很多实干的，但实干的基础仍然是这个务虚的社会，这本身就给这个实干抹上了一层务虚的阴影），专注虚妄的经学便能高人一等，有文才胸富万经的为官一处自是高高在上，没有这个本事的寒窗苦读一番也能落个“读书人的偷能叫偷吗”的阿Q式精神胜利，在精神上又是高高在上，都是高高在上，在1793年英国使团来华时是高高在上，在19世纪被英国揍、被日本揍之后还是高高在上。永远都是高高在上，这一词也许便能概括李鸿章一生大部分清廷官员的心理了吧，即使对洋人卑躬屈膝，对着百姓照样还是高高在上，照样是所谓“牧民于野”的当代俊杰。</p>
<p>欺民，罔民，愚民，却将这种行为解释为王化，“王化”过后便使牧民如放牧牛羊那般简单（如此看来儒家的王治倒是能够作为畜牧业一个很好的理论），古语中的这个“牧”字用的很是精髓啊。这也概括了务虚之道能够得以盛行，国人能够自欺欺人的原因，在这样一个务虚时代之末，则有国贼李鸿章。</p>
<center>五</center>

<p>梁任公先生在1901年为李鸿章做的传记里，有这样一段话：</p>
<blockquote>
<p><em>夫李鸿章果足称为中国第一人与否吾不敢知，而要之现今五十岁以上之人，三四品以上之官，无一可以望李之肩背者，则吾所能断言也。李之死，于中国全局有关系与否吾不敢知，而要之现在政府失一李鸿章，如虎之丧其伥，前途岌岌，愈益多事，此又吾所敢断言也</em></p>
</blockquote>
<p>加之记述一下李鸿章光绪元年所上之奏疏：</p>
<blockquote>
<p><em>近时拘谨之儒，多以交涉洋务为涴人之具；取巧之士，又以引避洋务为自便之图。若非朝廷力开风气，破拘挛之故习，求制胜之实际，天下危局，终不可支，日后乏才，且有甚于今日者。以中国之大，而无自立之时，非惟可忧，抑亦可耻</em></p>
</blockquote>
<p>摘录至此，不由扼腕感慨百多年前洋务之艰难，掣肘之猖獗。</p>
<p>引避洋务以自便，多轻松的自便之法啊，从前务虚以留其名，尚且还得付出诸多代价，而洋人来了后为一个高风亮节之名，却只需对奇技淫巧表达不屑，对操办洋务以自强求富之人以鄙夷眼光视之。多轻便啊，居庙堂之高则上书参劾，处江湖之远则煽民怨怼，永远站在务虚下道德的制高点，倒颇像今天的键盘侠，下笔滔滔如有千言，若问韬略胸无一策。可惜的是今天的键盘侠倒是稍讲道理的人就会心生厌恶，而那个时代做一个真正杀人的键盘侠倒成了政治正确。</p>
<p>而“求制胜之实际”这句话倒着实让我奇怪，我实在不知道制胜的实际为什么要求。在一个逝者如斯夫的三维世界，什么东西都是一锤子买卖，制胜难道还有实际与不实际的分别？一个管理着四亿五千万人口的朝廷，于国事竟要以“实际”与否为争论点，实在荒唐（也许以往务虚之实际对洋人不管用吧，毕竟洋人大部分人都不给你“牧”，明明这才是现在看来正常的表现到了晚清士大夫眼中成了蛮夷无廉耻的表现，估计他们也很苦恼吧），也难怪任公先生有以上断言了。</p>
<p>这就是那个时代我国的头号国贼了，倒不知他卖的国是虚妄概念上的国还是实际意义上的国了，不知道满清朝廷在马关之后的朝堂上有没有这一议论。</p>
<center>六</center>

<p>说李是国贼的论据，我以为归纳起来大约有四个大点。其一为边防塞防之争；其二为甲午战争之败；其三为辛丑条约之耻；其四为死后余产之巨。针对这几点，我也想简单谈谈我的看法。</p>
<p>关于边防塞防之争，以今日结果的眼光来看李鸿章所谓的“放弃新疆”自然是妥妥卖国行为，引述其作此决策的理由大致如下：</p>
<blockquote>
<p><em>历代备边，多在西北，其强弱之势，主客之形，皆适相埒，且犹有中外界限。今则东南海疆万余里，各国通商传教，往来自如，麇集京师，及各省腹地，阳托和好之名，阴怀吞噬之计，一国生事，诸国构煽，实为数千年来未有之变局。轮船、电报之速，瞬息千里，军器、机事之精，工力百倍，又为数千年来未有之强敌。外患之乘，变幻如此，而我犹以成法制之，譬如医者疗疾，不问何症，概投之以古方，诚未见其效也</em></p>
</blockquote>
<p>彼时背景正为日本寻衅侵略台湾，海防压力巨大，若忽略新疆一事，我以为兴建海防实在算是清末洋务少有的高瞻远瞩之举了，而对于新疆问题，李鸿章倒似乎想以外交途径解决（这也是他的惯用伎俩了，甲午之败这也是因素之一）。唉，彼时之人哪里懂得弱国无外交的道理呢，如此看来若无左宗棠收复新疆，也许新疆在那时候就成为了永远收不回的东三省了吧（九一八事变后民国政府也企图通过外交途径解决东北问题）。</p>
<p>也正应如此，世人往往厚左而薄李，但以我之见，左宗棠与李鸿章并无大分别，李并非一意放弃塞防而是以为边防更为紧迫，而左亦非务虚守旧之人，只是认为新疆之失已迫在眉睫而海上之难尚可以时日斡旋。边防塞防之争，与其说是善恶之争，倒不如说是厉害得失之争。可叹啊，百年后的课本中，左宗棠成了英雄，而李鸿章却成了国贼，实在只是命长与命短的分别啊。</p>
<p>而对甲午战争之败，我没有什么好说的，整个战争我仿佛看到的不是战争，而是一帮小孩在拿人命、鲜血与一个民族的尊严为筹码玩过家家，仿佛这个国，不是实际意义上的国。世人皆知甲午海战北洋水师全军覆没，是以为耻，却不知陆军在朝鲜更是一败涂地。对此战的总结梁任公先生在为李所作传记中已经分析的很透彻了，我不再赘言，遂摘录如下。</p>
<blockquote>
<p><em>当中日战事之际，李鸿章以一身为万矢之的，几于身无完肤，人皆欲杀。平心而论，李鸿章诚有不能辞其咎者，其始误劝朝鲜与外国立约，昧于公法，咎一；既许立约，默认其自主，而复以兵干涉其内乱，授人口实，咎二；日本既调兵，势固有进无退，而不察先机，辄欲倚赖他国调停，致误时日，咎三；聂士成请乘日军未集之时，以兵直捣韩城以制敌而不能用，咎四；高升事未起之前，丁汝昌请以北洋海军先鏖敌舰，而不能用，遂令反客为主，敌坐大而我愈危，综其原因，皆由不欲衅自我开，以为外交之道应尔，而不知当甲午五六月间，中日早成敌国，而非友邦矣，误以交邻之道施诸兵机，咎五；鸿章将自解曰：量我兵力不足以敌日本，故惮于发难也。虽然，身任北洋整军经武二十年，何以不能一战？咎六；彼又将自解曰：政府掣肘，经费不足也。虽然，此不过不能扩充已耳，何以其所现有者，如叶志超、卫汝贵诸军，素以久练著名，亦脆弱乃尔，且克减口粮盗掠民妇之事，时有所闻，乃并纪律而无之也，咎七；枪或苦窳，弹或赝物，弹不对枪，药不随械，谓从前管军械局之人皆廉明，谁能信之，咎八；平壤之役，军无统帅，此兵家所忌，李乃蹈之，咎九；始终坐待敌攻，致于人而不能致人，畏敌如虎，咎十；海军不知用快船快炮，咎十一；旅顺天险，西人谓以数百兵守之，粮食苟足，三年不能破，乃委之于所亲昵阘冗恇怯之人，闻风先遁，咎十二。此皆可以为李鸿章罪者。若夫甲午九十月以后，则群盲狂吠，筑室道谋，号令不出自一人，则责备自不得归于一点。若尽以为李鸿章咎，李固不任受也。又岂惟不任受而已，吾见彼责李罪李者，其可责可罪，更倍蓰于李而未有已也。是役将帅无一人不辱国，不待言矣。然比较于百步五十步之间，则海军优于陆军，李鸿章部下之陆军，又较优于他军也。</em></p>
</blockquote>
<p>战争之后，尚有广东水师向日本索要被俘舰只，理由竟是此次战役与广东无涉。荒唐至此，毫无国家民族观念，以五十步笑百步之典，李倒着实是那五十步之人，但一个国家只有五十步与百步的分别，岂不谬哉！</p>
<p>至于辛丑条约，我以为无甚好说，前两者对李都有切实可责可恨之处，凡是认为李无一点错误责任，无一点卖国嫌疑者都是巧言令色之人。惟此辛丑条约，说李是代国背锅言辞尚可牵强而去。只是可惜可恨啊，面对务实之世界，务虚者仍活在往日虚幻的天朝大国的旧梦里，可惜是针对那时被虚妄的概念奴役却自以为自由的愚民，可恨是针对朝堂上自私自利毫无理性的那几家几姓。</p>
<p>最后也就是死后遗产之巨了，关于这个我没有观点，也没做什么考证，四千万家产的言论没有什么根据，但清正廉洁的说法也就是自娱自乐了，而对于因为李鸿章财产甚多而输了甲午战争的言论，我也无话可说，见解如此，与键盘侠无异。以下摘录任公所作传记中的一段话，仁者见仁，智者见智吧。</p>
<blockquote>
<p><em>世人竞传李鸿章富甲天下，此其事殆不足信，大约数百万金之产业，意中事也。招商局、电报局、开平煤矿、中国通商银行，其股份皆不少，或言南京、上海各地之当铺银号，多属其管业云</em></p>
</blockquote>
<p>以上四点，第一、第三、第四点我认为以此为依据对李进行口诛笔伐只是视李为国贼带来的惯性思维所致，即在摆出论据之前心中已有答案，而后用这些论据中的点去套已有的结论。这样做虽然看起来不够客观，但我认为实在是人心所向。而第二点则是“国贼论”的核心，也是李鸿章以及所谓大清帝国的转折点吧，在这一点上李鸿章有直接责任。从前被英法等一流列强欺负，但装饰门面倒还对的起“帝国”这两个字的隐形含义，今而兴洋务练出的新军在日本人面前不堪一击，以使敌人在朝鲜都不相信战胜的就是所谓清廷按照西法练成的精锐部队。</p>
<p>由此看来，这些活在近代的中古士大夫在务虚本领之上倒还是实在的啊，能够做到让外人不辨雌雄。</p>
<center>七</center>

<p>对李鸿章，梁任公先生总结其为“时势所造之英雄，非造时势之英雄”，又对其一生事迹评价为“不学无术，不敢破格，是其所短也；不避劳苦，不畏谤言，是其所长也”。</p>
<p>是英雄造时势还是时势造英雄，这一直可以视为是一个悖论问题，这一问题有诸多解法的原因其实也只是因为对英雄与时势有诸多不同的定义与见解而已。</p>
<p>英雄是什么，一怒之下伏尸百万流血千里的应该能算，这是就其权威而论的；率性任侠义气为先的想必也能算，这是就其个性担当而言的；富国强兵振兴朝政的一定能算，这是就其能力而论的；而为国请命鞠躬尽瘁死而后已的也一定能算，这是就其一片赤子之心而论的。这四点似乎都没错，但偏偏国贼李鸿章似乎与后三点都沾些边，对部下讲情义，为国事不避艰难，临死之前尚在为国事操心，按这个道理，他该是英雄啊，在通俗历史评价上他该是顶线以上的人啊，怎么会落得底线以下的看法与待遇呢？还是引用任公先生的话。</p>
<blockquote>
<p><em>十九世纪列国皆有英雄，而我国独无一英雄，则吾辈安得不指鹿为马，聊自解嘲，翘李鸿章以示于世界曰，此我国之英雄也。呜呼！亦适我国之英雄而已矣，亦适成为我国十九世纪以前之英雄而已矣</em></p>
</blockquote>
<p>是啊，自始皇帝嬴政开创中央集权政体之日起，五经四书浸染之下的千年务虚时代，又哪有什么英雄造时势的事情呢？始皇殁后有项羽，一个勇武过人的英雄在乎的是如何让锦衣不夜行，在意这种虚妄的概念使他重新推行分封。后有刘邦，有曹操，有李世民，有赵匡胤，有朱洪武，再有所谓康乾盛世，有所谓同治中兴，那么多个皇帝之下有那么多个能人猛士堪称英雄，可有谁真正造就过时势吗？似乎有，如周瑜赤壁的那一把火，似乎又没有，因为我只看到了一个个朝代的更替与牧民锁链的加重。也许以百年局部的眼光来看，总有公瑾一般的豪杰改造时势，但以千年民族国家的眼光来看，十九世纪前所谓的英雄，不过是在同一片天空之下翻手为云覆手为雨罢了，他们从没有改天换日的见识与气魄。</p>
<p>话虽这样说，但英雄在他们的时代仍然是英雄，非要以今日之眼光视昨日之旧人未免落入历史虚无主义的窠臼。而对李鸿章以国贼的态度进行苛责，与此同理，无非是以今日之评价观点视旧时之英雄罢了。在对李一系列失误的讨论之外，我认为不应该让一个旧时代的先行者为他所处的整个时代背锅。</p>
<p>但话又说回来，这样一个不避劳苦的旧时代先行者，究其一生却为何在历史上仍落个身败名裂的下场呢？</p>
<p>千年务虚时代，治经论典自然是务虚，可人毕竟是活在现实世界的啊，“务实”必不可少，闻鸡起舞者有之，改政变法者有之，“格物致知”者亦有之，为何集数千年这亿万之人，却无一个堪当变务虚时势为务实的英雄呢？自是千年务虚痼疾已深，不彻底打碎更变实在是无从谈起啊。否定了这一点，就是对20世纪我们中国人长达一个世纪的更革奋斗视而不见。</p>
<p>而以李鸿章为汉奸国贼者，必为甲午之败辛丑之耻痛惜扼腕，仿佛杀李则能改变战局避免国耻，而清廷则仍是堂堂正正的大清帝国，这实在是癔梦啊。想当造时势之英雄，则必须要能真正的打破务虚学而有术，这在当时几乎是与整个千年文化积习为敌，事实证明李鸿章这种务虚时代的实干家不行，翁同龢这种务虚时代的所谓君子、康有为这种务虚时代所谓的改革家都不行，那些务虚时代的小人就更不必说了。</p>
<p>以李鸿章之务实敢干不辞辛劳生于务虚时代都难以学而有术，洋务半生尚“不识国民之原理，不通世界之大势，不知政治之本原”，一生兢兢业业如履薄冰都难以在后世摆脱一个“国贼”的骂名，可见务虚痼疾程度之深了。以务虚时代之英雄而成务实时代之国贼，英雄和国贼果然有所谓巨大的间隙吗？还是李鸿章生平前后的主流文化之间有这般巨大的间隙呢？这百年来，那么多只如鲁迅先生般的如椽巨笔，才堪堪扭转千年痼疾在人心中的荼毒之深，将这种荼毒所表现出的后果让李一人一力承担，我觉得实在是肤浅过分的言论。</p>
<p>唉，以旧英雄之身份而成新时代之国贼，以今日之眼光，到底该视为李鸿章的过错还是千年务虚文化的过错呢？</p>
<center>八</center>

<p>作为一个中国人，对历史总会心存一些假如（毕竟有强汉盛唐，现在的口号也还是复兴）。总有人会说满清误国，认为遇上19世纪那千年未有之变局的假如不是满清朝廷而是汉人王朝情况会完全不同；也有人会想若遭遇此事的中国统治者不是咸丰，不是光绪，不是慈禧，而是秦皇汉武唐宗宋祖，结局也会不一样；还有人说明朝的资本主义萌芽是被满清给消灭的，否则中国也会自然而然的成为近代西方那样发达的资本主义国家。</p>
<p>诸如此类的想法很多，但历史没有偶然，即使有偶然，在一个模拟器中能够重现历史，让那些明君圣君放弃一家一姓特权，让那些世家门阀放弃所有地方权益的概率能有多少呢？即使有人真的愿意，他能够扳的过整个旧文化的手腕吗？（过继当上皇帝的想尊自己的生父历朝历代士大夫都会罗里吧嗦的，没有点手腕的皇帝连这种事都搞不定，即使手腕通天难道能搞定整个文化变革的事情吗？因此在中国这种务虚文化的千年体系下，自上而下的改革是不可能行的通的，想变革只有改变一个民族的思想，这又哪里是一个人能够办得到的呢），孟子说过“人之所以异于禽兽者几希，庶民去之，君子存之”，孟子当然是惯于骂人禽兽，而放弃他这种庶民君子的成见，还智于百姓，让“君子”与“禽兽”平起平坐，历代有君王与权臣能够做到吗？（也许中国能够依赖如明治天皇那样的明君通过变革依靠广阔的土地在19世纪成为列强，但这种强国方式与英美等国还是有根本区别，日本明治维新后是变强了，但仍然有华族这种旧时代产物，我以为仍然带着野蛮不理性的气息，以中国之大，如此，更甚矣，仍然只会成为如沙皇俄国那样的纸老虎）王莽的改制引来了千古骂名只是因为其制过激而使掣肘过厉，而“科举”的产生也只是得益于旧门阀势力的削弱，而这种削弱，无不是血与铁的结果，而后再看19世纪末李鸿章所遭之非议，守旧势力在19世纪到20世纪的关口还指望着把洋人赶走继续上古时期的统治方法。这是他们幼稚吗？不是，实在是千年务虚积疾过深，使得四万万国人人人为鸵鸟而不自知，大才如严复尚且崇尚科举，务实如李鸿章尚且惋惜自己一生没做成军机大臣。</p>
<p>在这种千年务虚观念深入骨髓的情况下，小修小补有用吗？剜肉补疮有用吗？我看把血全换了都未必有用。在这种情况下，将千年务虚积累下导致的癔病产生的痛苦全部归咎给李鸿章这种只会小医小补的郎中，合理吗？骂李是国贼，那必须带上当时满朝文武，带上当时被欺罔了数千年的四万万百姓，带上数千年政治文化风俗的方方面面。雪崩之时，没有一片雪花是无辜的，但作为压死骆驼的最后一根稻草，难道李鸿章留给历史的意义只是让后人怒斥痛骂吗？</p>
<p>十九世纪以前的英雄，配上了务虚思想引导下的务实，却成了日后人们眼中的国贼，应该感到悲哀吗？不应该感到悲哀吗？对着那个由务虚向务实转化的时代，是继续痛斥那务虚时代下的国贼或者说英雄，还是应该对我们19世纪以前的文化多做一些反思呢？</p>
<p>后者，我以为才是李鸿章这个历史车轮扭动间隙下产生的矛盾人物该给我们带来的意义。</p>
<center>后记</center>

<p>本文基本可以视为是《走向共和》电视剧前半段以及梁任公先生的传记《李鸿章》的观后感吧，写之前没想过要什么纲领也没有确定什么中心论点，写到现在洋洋洒洒有八千多字，也渐渐形成了一个很不清晰的脉络吧。</p>
<p>全文的中心其实也就是以李鸿章个人在通俗历史评价上的矛盾为引，引出对19世纪前中华传统文化的反思吧。一个代表着那段历史的人物，以两种文化的眼光看待，会得出英雄和国贼两个迥异的看法，这种激烈的矛盾也着实可以说明旧文化的一些荒谬之处了。</p>
<p>当然全文只是借用了务实与务虚这一对矛盾在19世纪末那个节点上所爆发出来的强弱态势，并没有对中西文化或者说中国传统文化与现代文化进行所谓优劣对比及形成原因说明。因为非要进行详细的对比说明的话，我认为恐怕得从先秦思想和古希腊哲学的迥异说起，那话题就大了，所以全文对这种矛盾在我国中世纪的表现仅仅以叙代议，所表达的仅仅只是矛盾本身而不是对矛盾产生原因的分析论证。</p>
<p>全文以李鸿章为引，但对李鸿章一生的事迹仅仅摘捡了其作为国贼原因的几个大点论述，如果对李鸿章或那个时代感兴趣，着实推荐任公先生的传记《李鸿章》（即《同光以来大事记》），其文作于1901年李鸿章死后不久，集合了那个时代的视角与梁公极其客观的评价，我认为堪称是了解李鸿章的第一手资料，也是了解那个时代的一个不错的POV。</p>
<p>再来谈谈文章的另一个引子孔融，也许以知人论世而言他该算是在文学上卓有成就（建安七子之首），气节上也不错（堪称魏晋风骨，虽然我以为孔融这种气节不要也罢）。我在文章中如此苛责他说实话与大众苛责李鸿章也许没有什么本质的区别吧，要说区别，其实也是因为孔融所代表的这种务虚做派着实让我disgusting吧（细细想来，古人会写字的不多，所以键盘侠才会如此弥足珍贵吧），之前读过一些孔融的史料，有机会会写写我为啥那么不喜欢孔融，在此不再说明了。</p>
<p>最后，谈谈为何我写着写着就以务虚作为一个主线了吧，这个原因说来惭愧，实在是自己的务虚行为所致，如今三月，还有三个月本科就该画上句号，但纵观自己这四年，基本没干成什么实在的事情（书读的好当然是实在的，游戏打出了名堂也是实在的啊，唯独什么都没做的像样倒是值得思考的一个点），遂作此文以自勉。</p>
<p>子夜，记于2020.3.4 九江。希望疫情退散武汉加油。</p>
]]></content>
      <categories>
        <category>杂谈杂想</category>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>QGis专题地图编制</title>
    <url>/page/qgis-thematic-map-drawing.html</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>本次任务是制作蕲春县株林镇的土地覆盖专题图，因此重点主要是通过一些空间分析方法对相关数据进行处理，从而得到相关专题数据，同时，对专题图底图也应在实习一的基础上进行简化修改，总结而言，本次任务具体环节如下：</p>
<p>1、对之前的TDFG数据添加村代码和村名。使用按位置连接等工具连接相关的村名、村代码。</p>
<p>2、土地利用数据的权属数据和行政区数据整理。xzq数据与地类图斑数据边界不一致，需要处理成为一致的。同时增加一个新的村，有自己的学号，以及自己命名一个村名。以改好权属的dltb为基础，采用融合方法，按权属代码融合得到新的xzq层，并转一个新界线层。</p>
<p>3、准备专题图数据。使用相应方法统计与计算各村各大类的各种面积属性项，如耕地面积、人均耕地面积、人口等等。</p>
<p>4、制作专题地图底图。图纸采用A4大小，版式自己进行设计横版或竖版；注意主图比例尺设计合适，使主图、整饰要素、统计图表、图文等要素布局均衡、松紧适宜。底图要素保留行政界线、主要河流、水库、居民点；道路根据各自设计处理。增加必要的地图注记，如选取居民点、主要河流、水库等名称，可采用标注方法。</p>
<p>5、制作专题地图主图。以输入专题数据的xzq为基础，用渐变填色方法制作人均耕地分级色图；由XZQ生成质点，加载质点数据，用结构图方法制作各类用地结构图表；根据全市或分村统计各坡度级耕地面积，制作图外统计图表。</p>
<p>6、制作专题图整饰。添加色带、图名、指北针、数字比例尺、位置图、图例等。</p>
<h2 id="土地利用数据的权属数据整理"><a href="#土地利用数据的权属数据整理" class="headerlink" title="土地利用数据的权属数据整理"></a>土地利用数据的权属数据整理</h2><h3 id="添加村代码和村名"><a href="#添加村代码和村名" class="headerlink" title="添加村代码和村名"></a>添加村代码和村名</h3><p>此处总体步骤为使用实习一中的TDFG数据，对各地类多边形进行求质心操作，进而通过对质心位置的判断，链接上村名和村代码。本人的具体操作如下。</p>
<p>1、首先对实习1中的TDFG数据，选择“矢量”下的“拓扑结构检查器”（需要在插件中加载该功能）进行拓扑检查（检查无效多边形），避免生成质心时QGIS报错。如下图1即为本次实习中有拓扑错误的多边形。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%871.png" style="zoom:67%;" />

<p>2、根据拓扑错误对多边形进行修改，主要应避免如下图的拓扑错误，方法为在该处取消吸附功能。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%872.png" style="zoom:33%;" />

<p>3、对修改后的TDFG图层进行求质心操作，可右击菜单栏打开“处理工具箱”工具，之后的一系列相关操作功能都可在该工具栏中进行搜索获得。如下一图即为“质心”工具运行结果，如下二图为求质心之后的效果。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%873.png" style="zoom: 80%;" />

<p>4、使用“按位置连接”工具，选择“内含于”等选项，运行结果如下。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%874.png" style="zoom:67%;" />

<p>5、选择“按字段值连接属性”，各选项如下。完成村名和村代码的添加。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%875.png" style="zoom: 50%;" />

<h3 id="按各村界线进行图形分割"><a href="#按各村界线进行图形分割" class="headerlink" title="按各村界线进行图形分割"></a>按各村界线进行图形分割</h3><p>本步骤主要就是按照实习一中的XZQ图层对各个跨越XZQ的图版进行分割（主要就是实习一中补充的那部分），方法是启动编辑后使用“编辑”中的“分割要素”工具对图形进行切割，如图所示。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%876.png" style="zoom: 50%;" />

<h3 id="新增村庄"><a href="#新增村庄" class="headerlink" title="新增村庄"></a>新增村庄</h3><p>按照要求，随便选一块区域，将属性表中的村名、村代码进行更改，形成一个新的村子，如图所示。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%877.png" style="zoom: 50%;" />

<h3 id="融合"><a href="#融合" class="headerlink" title="融合"></a>融合</h3><p>融合的目的即为使属性表中为一个村的地区真正“融”为一个村，从而形成的边界图层替代实习一中的XZQ图层，为之后的专题图制作提供基础底图。本次实习先使用了QGIS中的融合工具，但效果不佳，有如下图所示的裂纹，无法使用。</p>
<p><img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%878.png" alt=""></p>
<p>鉴于此，本次实习在该功能上使用了ArcGIS中的“融合”功能，其相关参数如下（由于数据源的问题，村名中出现了一些代码，因此本处使用村代码作为融合依据，之后根据村名和村代码的对应关系将村名链接了上去）。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%879.png" style="zoom:50%;" />

<p>由于之前在QGIS中对部分图形进行了切割的缘故，在ArcGIS生成的融合图形中仍有部分毛边，本次实习在ArcGIS中启用编辑，使用“删除点”工具对这些毛边进行了处理，同时使用“添加点”功能对部分细小缝隙进行了修补，以避免之后生成质心时出现拓扑错误，完成操作后使用QGIS打开相关shp文件，效果如下。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8710.png" style="zoom: 33%;" />

<h2 id="专题图数据处理与统计"><a href="#专题图数据处理与统计" class="headerlink" title="专题图数据处理与统计"></a>专题图数据处理与统计</h2><h3 id="相关数据的分村统计"><a href="#相关数据的分村统计" class="headerlink" title="相关数据的分村统计"></a>相关数据的分村统计</h3><p>所需的数据主要包括各村的面积、人口、各大类地面积、人均耕地面积等数据，除去人口数据是需要自己进行输入，其余都需通过各分析方法得到。</p>
<p>1、对2.1节中得到的“新界线”图层TDFG_RH添加新字段，主要内容为以上所述的各内容，类型选择为“小数”。 </p>
<p>2、在“处理工具箱”中搜索找到“添加几何属性”功能，输入要素如下图，得到一个有相关面积等数据的图层，将该临时图层中相关字段中的面积数据连接到TDFG_RH中的相关字段，得到各村面积数据。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8711.png" style="zoom:50%;" />

<p>3、在“处理工具箱”中搜索找到“按类别统计工具”，输入要素如下图1所示，字段选择为地类字段和村名字段。之后程序输出为一个表格，“打开属性表”打开之后，可见其信息如下图2，各村的各类面积都已补充完整，将相关数据填入TDFG_RH中的相关字段即可。</p>
<p><img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8712.png" alt=""></p>
<p>4、将TDFG_RH图层中的RK（人口）字段按照相关资料（主要是网上相关的资料）进行填入，大致区间在300-1300人之间，之后打开编辑后，使用“字段计算器”，填入相应内容后，将RJGDMJ（人均耕地面积）进行计算与填入。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8713.png" style="zoom:50%;" />

<h3 id="坡度的分村统计"><a href="#坡度的分村统计" class="headerlink" title="坡度的分村统计"></a>坡度的分村统计</h3><p>坡度的统计需要借用ArcGIS中的相关功能以及已有的DGX、GCD等数据，主要步骤如下。 </p>
<p>1、在ArcGIS中借用“3D Analyst工具”-&gt;“数据管理”-&gt;“TIN”-&gt;“创建TIN”，输入如下图1参数，得到TIN数据如下图2。TIN数据与DEM数据最大的区别是一个是矢量数据一个是栅格数据，因此要实现转化须将其进行矢栅转化。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8714.png" style="zoom: 50%;" />

<p>2、“3D Analyst工具”-&gt;“转换”-&gt;“由TIN转出”-&gt;“TIN转栅格”，实现TIN数据与DEM数据的转化，具体输入见下图1，DEM数据效果见下图2。</p>
<p><img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8715.png" alt=""></p>
<p>3、使用ArcGIS中的“坡度”工具，将DEM数据输入，得到相应的坡度图，效果如下两图。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8716.png" style="zoom: 67%;" />

<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8717.png" style="zoom:50%;" />

<p>4、使用ArcGIS中的转换工具（可以直接转也可以使用ArcToolBoxzhon给的相关工具）将坡度图导出为tif格式，并将其导入QGIS，如图所示。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8718.png" style="zoom:50%;" />

<p>5、使用“分区统计”工具对各村坡度进行计算，该程序运行完之后会发现输入的TDFG_RH图层中多了三个计算图层，如下。</p>
<p><img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8719.png" alt=""></p>
<p>6、取上表的相关数据导入excel中进行数据统计，便于之后绘制图表。</p>
<h2 id="制作专题地图底图"><a href="#制作专题地图底图" class="headerlink" title="制作专题地图底图"></a>制作专题地图底图</h2><p>在《QGis地表覆盖图编制》基础上进行要素选取，最后结果如下</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8720.png" style="zoom:50%;" />

<h2 id="制作专题地图主图"><a href="#制作专题地图主图" class="headerlink" title="制作专题地图主图"></a>制作专题地图主图</h2><h3 id="分级设色"><a href="#分级设色" class="headerlink" title="分级设色"></a>分级设色</h3><p>1、在相关图层的属性下的“符号”中，进行如下选择，可得到分级设色的效果。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8721.png" style="zoom:50%;" />

<p>2、调整相关颜色（颜色1与颜色2）如下，使其符合基本的色彩视觉要求要求。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8722.png" style="zoom:50%;" />

<p>3、完成分级设色，效果如下。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8723.png" style="zoom:50%;" />

<h3 id="饼状图绘制"><a href="#饼状图绘制" class="headerlink" title="饼状图绘制"></a>饼状图绘制</h3><p>1、利用质心工具对新界线进行求质心操作，得到质心图如下，同时该质心图层已经包含了TDFG_RH中在2.2.2中进行统计后的字段。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8724.png" style="zoom:50%;" />

<p>2、利用已经统计了的数据实现饼状图的绘制，在属性中“图表”中进行如下选择，可实现饼状图绘制，更改颜色后，完成饼状图绘制。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8725.png" style="zoom:67%;" />

<p>3、由于饼状图的图例绘制在QGIS中效果不好，因此本次实习选择在AI中对其进行绘制，绘制完成后如下，可导出为PNG格式。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8726.png" style="zoom: 80%;" />

<p>4、整体效果如下。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8727.png" style="zoom: 50%;" />

<h3 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h3><p>同样根据统计数据使用AI进行绘制，不再赘述</p>
<h2 id="地图整饰"><a href="#地图整饰" class="headerlink" title="地图整饰"></a>地图整饰</h2><p>地图整饰包括制作色带、图名、指北针、数字比例尺、位置图、图例等内容，本节也以此为基础进行相关叙述。其中其余参考《QGis地表覆盖图编制》即可</p>
<h3 id="位置图"><a href="#位置图" class="headerlink" title="位置图"></a>位置图</h3><p>1、将位置图图片导入项目，并使用配准工具对其进行处理，如下图所示。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8728.png" style="zoom:50%;" />

<p>2、使用QGIS中的“栅格矢量化”工具对该位图进行矢量化，具体见面如下，可得到位置图的矢量图（本次实习使用该功能效果不太好）</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8729.png" style="zoom:67%;" />

<p>3、对其进行分类处理，并新增一个MC（名称）字段，调整颜色，设置标志（注记），即完成位置图的制作，效果如下。</p>
<p><img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8730.png" alt=""></p>
<h3 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h3><p>1、在菜单栏左侧使用相应工具添加图例，并设置其条目属性，并将图例置于右下角，效果如下。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8731.png" style="zoom:50%;" />

<p>2、将4.2小节中绘制好的饼状图图例以导入图片的形式导入，并将其置于右下角。</p>
<h2 id="整体效果"><a href="#整体效果" class="headerlink" title="整体效果"></a>整体效果</h2><p><img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8732.png" alt=""></p>
]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>QGis</tag>
      </tags>
  </entry>
  <entry>
    <title>QGis地表覆盖图编制</title>
    <url>/page/qgis-Surface-coverage-mapping.html</url>
    <content><![CDATA[<h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><h3 id="图像配准与提取"><a href="#图像配准与提取" class="headerlink" title="图像配准与提取"></a>图像配准与提取</h3><p>没有精确的图像配准，后续对数据的判读及精确的矢量化便无从谈起，将影像投影设置为与DLTB图层一致之后，便可按如下步骤在QGIS中完成相应的工作。 </p>
<p>1、右键菜单栏加载出对应的菜单，并且在插件菜单栏中调出默认安装了的GDAL配准插件， 并且将相应的影像数据等加入建立好的工程。 </p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%871.png" style="zoom:67%;" />

<p>2、打开配准工具，将要进行操作的影像图导入，之后根据地图地名等信息使得DLTB图层上相应点与影像上的点一一对应，选择四个点及以上时完成配准，本次实验选点及配置如下图。 </p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%872.png" style="zoom: 67%;" />

<p>3、结束点对对应后，点击配准菜单栏上的“开始配准”并完成配准，得到一个配准完成后的影像图层。效果如下所示。 </p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%873.png" style="zoom:67%;" />

<p>4、配准完成后在菜单栏“栅格”中选择“提取”下的“按掩膜图层裁剪栅格”，并将无数据区透明度设置为0，此举使得影像数据与DLTB数据基本重合，便于后续操作 </p>
<h3 id="空缺数据补充"><a href="#空缺数据补充" class="headerlink" title="空缺数据补充"></a>空缺数据补充</h3><p>在使用原始的DLTB数据时，根据“核对修改范围”数据的提示，可以很清楚的看到其中间部分有一空缺处，而根据3.1.1处理好的结果，对DLTB数据在“符号化”中进行分类， 如下图。并在分类的基础上根据影像图进行地图矢量化，并按照影像图对其相关字段进行命名，从而完成空缺数据的补充（其中各矢量化工具的使用基本与ArcGIS中的相应工具类似，因此不再赘述）。 </p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%874.png" style="zoom:50%;" />

<h3 id="其他数据的补充"><a href="#其他数据的补充" class="headerlink" title="其他数据的补充"></a>其他数据的补充</h3><p>除去DLTB空缺的数据，还应对居民地，相应公路等数据进行补充，与以上相比，矢量化工具由多边形变为了点和线，因此不再赘述，大致结果图如下</p>
<p><img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%875.png" style="zoom: 67%;" /><img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%876.png" alt=""></p>
<h2 id="数据检查"><a href="#数据检查" class="headerlink" title="数据检查"></a>数据检查</h2><p>一些基本的数据检查方法此处略，只对应QGis的相关操作。由于原始数据中编码相对较老，因此需要进行更新编码的操作，此处可以使用表连接方法</p>
<h3 id="更改数据对应编码"><a href="#更改数据对应编码" class="headerlink" title="更改数据对应编码"></a>更改数据对应编码</h3><p>在QGIS当中，本次具体的对应操作为建立一个相应的Excel表，在表中设置三列数据， 分别对应两类名称与对应的新编码，如下图所示。 </p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%876.png" style="zoom:70%;" />



<p>之后在属性中选择“连接”并选择相应Excel表的相应字段，具体见下图，连接完成后可见DLTB图层的属性表中多出了两条字段，分别对应新名称与新编号。 </p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%877.png" style="zoom:50%;" />

<p>最后将其导出为TDFG图层，按照新字段进行分类后（见下图），之后便以此为基础在TDFG图层上进行之后的符号化。 </p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%878.png" style="zoom: 50%;" />

<h2 id="地图的编绘"><a href="#地图的编绘" class="headerlink" title="地图的编绘"></a>地图的编绘</h2><p>完成了之前包括影像配准，数据对应整理与处理，空缺数据矢量化与补充，数据相应转化后，便可进入地图绘制的阶段，此阶段主要可概括为符号的使用与制作， 地图的整饰与制作两个阶段。 </p>
<h3 id="符号的使用与制作"><a href="#符号的使用与制作" class="headerlink" title="符号的使用与制作"></a>符号的使用与制作</h3><p>本次操作较为简单，在TDFG图层的分类下右击鼠标选中“编辑符号”，进入符号后更改填充颜色、线宽、点状符号、线状符号即可，如下图。由于相应符号老师都已给出，因此总体而言较为方便，唯一不便的地方就是得将CMYK转化为RGB再输入， 此过程本人使用AI得到。 </p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%879.png" style="zoom:67%;" />

<h3 id="地图的整饰设计"><a href="#地图的整饰设计" class="headerlink" title="地图的整饰设计"></a>地图的整饰设计</h3><p>本次实习所进行的地图整饰设计主要包括色带、图廓、方里网、图名、图例、比例尺等内容。进行整饰在QGIS中可在“项目”菜单中选择“新建打印布局”，之后在其中完成一系列相关操作即可。 </p>
<h4 id="色带"><a href="#色带" class="headerlink" title="色带"></a>色带</h4><p>即图地图外部上的条带。本次实习色带是使用QGIS自带的轮廓功能制作的。具体步骤为在“矢量”菜单栏地学数据处理工具中选择“轮廓”，并选择相关数值， 对TDFG图层进行两次使用后，即可得到两个色带。 </p>
<h4 id="图廓"><a href="#图廓" class="headerlink" title="图廓"></a>图廓</h4><p>图廓相关在4.2总述中已经涉及了，页面即为外图廓，而内图廓即拖动地图使之与外图廓契合并能够很好显示地图即可。可使用左侧菜单栏中“选择/移动条目”与“移动条目内容”对其进行设置。</p>
<h4 id="方里网"><a href="#方里网" class="headerlink" title="方里网"></a>方里网</h4><p>方里网在地图的条目属性中添加网格，并更改并应用网格属性，设置如下图所示。 </p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8710.png" style="zoom:67%;" />

<h4 id="图名"><a href="#图名" class="headerlink" title="图名"></a>图名</h4><p>在菜单栏左侧使用相应工具添加图名，并更改其条目属性如下，再将其置于相应位置，本次为图面左上角。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8711.png" style="zoom:67%;" />

<h4 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h4><p>在菜单栏左侧使用相应工具添加图例，并设置其条目属性如下，并将图例置于右下角。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8712.png" style="zoom:67%;" />

<h4 id="比例尺"><a href="#比例尺" class="headerlink" title="比例尺"></a>比例尺</h4><p>在菜单栏左侧使用相应工具添加比例尺，并设置其条目属性如下，并将其置于图面右下角。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8713.png" style="zoom: 67%;" />

<h2 id="成果图"><a href="#成果图" class="headerlink" title="成果图"></a>成果图</h2><p><img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8714.png" alt=""></p>
]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>QGis</tag>
      </tags>
  </entry>
  <entry>
    <title>改变</title>
    <url>/page/the_change.html</url>
    <content><![CDATA[<p>时光本身没有魔力，它的奇妙来自于人们很容易愣神。</p>
<p>当你发呆的时候，当你全身心地在做一件事的时候，当你摊在沙发上消磨时光的时候，它总会轻而易举地从你的指尖溜走。“溜”，这是个形容时光已经用烂了的动词，但大可不必对这种形容做一些所谓老生常谈的说教，因为这在汉语中确实用的很妙。</p>
<p>小学生用文字形容时光是一把好手，因为似乎我们的教育自小到大一个很大的主题就是劝人切莫虚度时光。所谓“少壮不努力，老大徒伤悲”也可以视为是对时光的隐喻，这种隐喻隐藏在许许多多与时光本身看似并不相关的事物上，但作为两种状态之间的对比却往往体现出时光的作用来。从这个角度来看，也许本身就没有什么隐喻不隐喻的吧，毕竟活在时光长河里的生物，怎么可能规避的了时光二字呢。如此看来“时光”这两个汉字也着实幸运，明明是人造出的东西，表达的却是一种任何人也捉摸不透却又身在其中的感觉。</p>
<p>现在已经五月份了，其实我也很纳闷怎么就五月份了。我不记得上一次愣神是在什么时候，大概是今年二月？或者是去年的什么时间，或许是十年前？总之现在已经快要接近我生命中的第21个年头了。我在愣神当中曾经说过我才18，也曾经说过我才20，但我现在快满21了。这是一种相当奇妙的感觉，你不知道起点在哪，也无法推算终点何在，你一次又一次的愣神，又一次又一次地回过神来开始思考，可每次回忆起自己上一次的思考，又会发现那不过是无数次愣神递归过程之中的某个终止条件。人的一生永远是在愣神中度过，而时光却又如此狡猾，永远会在你愣神的时候从你的指尖溜走。</p>
<p>仿佛避开守卫出逃的囚犯，仿佛透过缝隙射入的阳光。</p>
<p>今年的五一假期，武汉的阳光十分强烈，但温度并不高，是让人很舒服的那种天气，但又给人以预示，夏天显然快要来了。</p>
<p>我很喜欢夏天，现在回想起来也许是因为夏天是成长过程中唯一可以自由自在的季节吧。庐山上的夏天并不热，反而充满着慵懒的感觉。其他地方的夏天虽然普遍地能够被称为酷暑，但酷热之中却又蕴含了随意与激情，透露着狄俄倪索斯的气息，我很喜欢去品尝这种缺乏理性的味道，它会让愣神与发呆变得顺理成章。</p>
<p>这不是我今年第一次感到夏天要来了。我依稀可以记得，度过清明节假期之后的那天，很热。在回汉的路上，高铁里那种通过机器进行流通的空气的味道。呆板，麻木，但每每闻到它我总能想起旅行的过程，想起我四处寻找不同城市中别样的迪厄尼多斯的故事。这种感觉将过去的我和现在的我融为一体，时刻提醒从前的我与现在的我还是同一个人。这种非人的物质不断地通过嗅觉神经冲击你的大脑，一遍又一遍地通过一种缺乏科学与理性的方法强迫你去相信一个没有理性能够论证的哲学命题，强行告诉你你已经惫藾了多久以及你是否将永远以这种状态惫藾下去。</p>
<p>我还能够记得，从学校南二门回寝室的路上，四月的空气显得过于闷热了，给了我一种很不舒服的感觉。仿佛我还在去年的6月，大病初愈在六月的烈阳下回寝室收拾东西回家，我无法形容那是一种什么感觉，大病过后精神似乎由于充裕的休息变得很好，但总给人以一种缺憾的感觉。就像六月的阳光除去酷热以外似乎于我而言少了一层意义，但少的是什么呢？我苦苦思索也得不到答案。也许今年的夏天我能够找到它，也许永远也找不到了，也许它将被我遗忘，这也是大概率的事情了，也许这种缺憾感只是因为我对阳光多了一层理解而产生的错觉，也许缺憾的感觉与获得的感觉纠缠一起令我无法区分。但不论产生这种感觉的机理是什么，我只知道那时的我与现在的我多少有些不同了，也许是去年躺在病床上痛苦地享受闲暇时光以及六月的天气造成的，也许是命中注定在这个年龄会产生的改变，也许只是一个发展趋势附着于生病这件事情上带给我的错觉。我能写下很多种也许，但也许它们没有一个是答案。</p>
<p>从前有一段时间我热衷于探讨“Riddles of Existence”这个永远也不会有答案的形而上学问题，里面有一种支持宿命论的观点。如果加上空间三维与时间一维的话，在我们的生活中每一个结点的坐标都是固定的，一切事情都是一定会发生的。具体的证明方法我已经记不清了，但的的确确，我们的每一秒，每一个抉择，每一个时间节点上发生的事，都在我们愣神之后被一笔带过，被时光这个东西窃取而空。而下一个时间节点当我们思虑从前那些改变的时候，这种思虑又成为了下下个节点思考的素材。我们就如俄罗斯套娃一般死死地在时光的长河之中套下过去的自己，再被将来的自己套下，无穷无尽。而在我们执着于套娃本身的方法时，时光流逝，间断性地带给我们套下过去自己的满足感，告诉我们有些东西从未改变，就如木制娃娃用颜料画上的微笑的脸庞。</p>
<p>五月出头，这几天天气很好，阳光明媚却不毒辣，路边的梧桐树重新长出了夏天最亮眼的绿，我于道中抬头，看见阳光透过树叶缝隙泛起的柔和的光。</p>
<p>我感觉并不舒服，就像感受到了从前的自己。傍晚看到了属于夏天独有的那种灿烂的夕阳，我于美感之中蹉跎，我想起了海，想起了很多年前在海边的自己，想起了自己惫藾的时光，亦美亦不美，两个时空的我产生了龃龉，这是很难用理性判断的事情。</p>
<p>改变是必然的，“往者不可谏，来者犹可追”这句话永远是苍白无力的，但也没有多少人会纠结于改变本身而放弃对这句话的追求。</p>
<p>毕竟，人们在愣神之时总会开始学会欣赏从前的自己，总会以最柔和的方法面对改变所带来的龃龉。</p>
<p>就像俄罗斯套娃，大的娃娃总会接纳小的，尽管它们是那么不同。</p>
<blockquote>
<p>记于19.5.5  武汉</p>
</blockquote>
]]></content>
      <categories>
        <category>杂谈杂想</category>
        <category>杂想</category>
      </categories>
      <tags>
        <tag>杂想</tag>
      </tags>
  </entry>
  <entry>
    <title>ArcGIS二次开发基础配置说明</title>
    <url>/page/ArcGIS_dev.html</url>
    <content><![CDATA[<p>很早就听说过ArcGIS二次开发各种麻烦所以也一直不打算去做这一块（电脑里装的是VS2017，但ArcEngine老一些的版本不支持这个版本，新的版本又找不到，实在是不想再装一个新的VS），但这学期由于一个小实习的需要，不得不稍微学一下，也算完成任务吧。仔细想想稍微了解下ArcGIS二次开发也不坏，毕竟我还是个学GIS的。。。</p>
<h2 id="开发环境安装"><a href="#开发环境安装" class="headerlink" title="开发环境安装"></a>开发环境安装</h2><p>首先想明确的是，一个电脑里装两个版本的VS2017正常情况下是不会有问题的，之前网上总有些人说这样安装会失败，也许是他们自己的问题吧，反正经过尝试本人是没发现任何问题。同时AE10.2推荐的VS版本是2010或2012，更高的版本会报错，所以感觉极端stupid。</p>
<ol>
<li>安装AE之前必须保证先安装VS，而VS的安装包很好找，推荐一个公众号“软件安装管家”，里面应有尽有。</li>
<li>之后安装ArcGIS Desktop，ArcGIS反正我是感觉是一个水很深的软件，同样推荐上面那个公众号，跟着步骤安装。</li>
<li>最后开始安装AE，<a href="https://pan.baidu.com/s/1k5cg94K70yXwLO2ZX0coBg" target="_blank" rel="noopener">下载点我,p2f1</a>，注意选择对应VS版本的AE安装。<ol>
<li>对安装包进行解压，解压Part1然后在解压过程中会弹出对话框加上Part2即可</li>
<li>解压后点开解压文件，打开ESRI.exe文件安装相应文件即可</li>
<li>打开相应VS版本，查看有没有ArcGIS开发组件即可。</li>
</ol>
</li>
</ol>
<h2 id="基本事项"><a href="#基本事项" class="headerlink" title="基本事项"></a>基本事项</h2><p>本人也没有具体去系统学过所谓ArcGIS二次开发，因为大部分时候的确用不上这些，现在只是所谓面向作业编程。这次作业实现了delaunay三角网以及相应图形的合并，由于老师有样例代码所以很简单。不过还是得吐槽一句，给代码不把框架说清楚，给的接口参考文件说明只有一个名词，比如某接口中，方法Area边上写了个面积，难道我不知道这个单词是面积的意思？关键是这方法怎么调用吧。百度，OK，ArcGIS二次开发基本没人做，然后就只能去查帮助文档了，这本身无可厚非，但说白了，这么个搞清楚架构、理解老师要干啥花三个小时，编程一刻钟的作业，真的蠢。</p>
<h3 id="帮助文档"><a href="#帮助文档" class="headerlink" title="帮助文档"></a>帮助文档</h3><p>ArcGIS二次开发做的人不多，网上基本上找不到有参考意义的教程（当然某些论坛还是不错的），而这玩意又以接口众多出名（几乎是面向接口编程），所以帮助文档就很重要了。<br>一切安装妥当后，在<strong>开始-&gt;ArcGIS-&gt;ArcObjects help</strong>中打开就能找到，之后在其中选择相应接口之类的查看即可。各种参数和不同语言的不同用法写的还是很清楚的。</p>
<h3 id="文件迁移设置变更"><a href="#文件迁移设置变更" class="headerlink" title="文件迁移设置变更"></a>文件迁移设置变更</h3><p>由于是ArcGIS二次开发，所以需要调用外部的ArcMap程序。在代码迁移的时候，由于不同终端上ArcMap存储的文件位置不一致，所以要手动进行更改。<br>主要步骤是<br>右击项目名称，选择最下面的“属性”，并且选择属性菜单栏中的“调试”，在启动操作中选择“启动外部程序”并在其中将文件路径更改为现在运行终端中的相应文件路径即可。具体如下所示：<br><img src="img/BlogImg/arcgis1/1.jpg" alt=""></p>
<h3 id="常见错误处理"><a href="#常见错误处理" class="headerlink" title="常见错误处理"></a>常见错误处理</h3><p>编译调试运行时如果出现了诸如“无法注册程序集 .dll- 拒绝访问。请确保您正在以管理员身份运行应用程序。对注册表项“…”的访问被拒绝”的错误，可以进行如下操作处理。<br>WIN+R，运行对话框中输入gpedit.msc，开启组策略，然后一步步地在“计算机配置”-“Windows 设置”-“安全设置”-“本地策略”-“安全选项”，找到右侧的“用户账户控制：以管理员批准模式运行所有管理员”这个项，你会看到这个项默认是启用的，把它设成禁用。如下图<br><img src="img/BlogImg/arcgis1/2.png" alt=""><br>之后重启电脑即可。</p>
]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>ArcGIS</tag>
      </tags>
  </entry>
  <entry>
    <title>雨与晴</title>
    <url>/page/the_rain_and_the_shine.html</url>
    <content><![CDATA[<p>今天早上8点半左右，我像往常一样上三楼接水，在楼梯间的窗户向外瞥，围墙外的篮球场的塑胶地上湿了一片。围墙略显斑驳，是本来就不那么年经了的建筑被大水冲洗过后的一种自然姿态，带着一些年迈的美丽。</p>
<p>没事的时候我很喜欢透过这里向外望，但这次不是，因为我的眼光里多少带了些形色匆匆的味道。被水洗过的塑胶绿和围墙这边的绿色的植物，与其说是我看到了她们，不如说是她们的颜色主宰了那一秒内我的视神经。现在窗外夜色朦胧，是置身城市里很少见到的那种纯粹的墨蓝，纯粹的证明也并非是我自情自愿，是因为我抬头能看到星星。</p>
<p>不对，在东边的天空，还有一轮月亮，也许足够用皓月来形容。</p>
<p>我并不像一些下午一样，站在那个楼梯间的窗户面前带着什么思考或者纯粹性的发呆向外望。清晨的我手里拿着洗面奶和脸盆毛巾经过了那里，我现在也只能以上帝的姿态回顾那个瞬间我究竟是迈开了左腿还是右腿，脑子中想的究竟是窗外的绿还是一些什么别的乱七八糟的东西。这到底是模拟，有一万种不同的可能，这花了我很长的时间，沉淀了许多情感。我并不喜欢喝白酒，事实上也的确没怎么喝过，但我觉得所谓后劲，就是如此吧。在张开嘴的瞬间，咽下的酒精会让觥筹交错之后的你花上几个小时醉在自己的梦里，所需要的契机也只是热闹向平淡的自然转变。</p>
<p>雨是早就要下的了，昨晚睡前就已经开始了，但我并没有太在意，只记得它很大，像是夏天的雷雨，全然不同于上个月那阴雨绵绵的枯燥，倒是热烈洒脱，干脆利落。昨晚12点左右的时候，我躺在床上，感觉很累很累。我不知道“累”这种感觉的产生是基于什么，也许是某种激素，那我觉得自己想必是有些内分泌失调了。我并没有什么能过得去的让我感觉到疲惫的理由，但我就是很累。这一个月来我思考了很多，这个多也只是相对于我某种程度上放弃思考开始自欺欺人的那大段时间而已，只是一个正常水平，就像冬末的阴雨只要地球还在正常的轨道上，只要太阳不出什么问题，就一定会消散一样。阴天和晴天，只不过是地球表面的两种正常状态，但其微小的不同，的确会对地表的生物造成一些困扰，这我想是肯定的。</p>
<p>半夜的时候我被雨声惊醒了，这很少见，除去呼噜声与钟表的滴答，我是很难被别的声音惊醒的。半夜醒来的人对时间是没法计数的，一切理性和情感都处于朦胧的状态，也许这道朦胧会在大脑留下沙滩上城堡般的记忆，也许不会。但我却记得，那算是雨后的阴沉的味道吧。翠绿的世界总是会给人一种虽然充满生气但却脆弱稚嫩的感觉，在这脆弱稚嫩之下不知纯粹为何物，但被大雨蹂躏过后的植物的墨绿虽然给人阴沉郁结之感，却又十足纯粹。淅沥小雨下的天空阴沉混沌，赶时间的人会痛恨这种“欲擒故纵”般的感觉，世界并不是在接受清洗，而是在把污浊借雨水之名平摊到各地，也许是为了遮瑕，但却使原来作为“瑜”的部分都消失殆尽，纯粹一词无处藏身。而大雨磅礴的天空也许更是阴沉可怖，但却给人以十足的命令感，再赶时间你也不会为“走”或“不走”而面露难色，只有在屋檐下耐心等待。等待的过程也许是生活中难得的纯粹的仪式，因为静坐听雨的意境在当代实在是少的可怜，就连裤腿被大雨淋湿的触感都变得弥足珍贵。</p>
<p>雨后，空气中会有清爽的纯粹，世界接受清洗之后，无论是借着日光还是霓虹，路面倒映出的射影，是世界的另一种面貌，印着纯粹二字。</p>
<p>但我并不知道纯粹为何物，它是最狡诈多变的一个词。在我有不同的情感时，思考不同的问题时，面临不同的选择时，它是我最后的仪仗，是我追求的东西，尽管为此我注定没有方向。</p>
<p>我不知道小时候庐山上的蓝天白云与我的无忧无虑算不算纯粹，也许无忧无虑只是假象，是人丢掉一段时间内的大部分记忆的一种自然而然的感受。我马上21了，在我以1开头的年岁里，我的确很少看到记忆中的那种蓝天了。在熬过二月的阴雨之后，最近武汉的天气晴空万里，就连今天早上阴沉潮湿的墨绿在我中午再一次以相同的视角观望时都已经消失殆尽了，但蓝天上仍然有一层阴霾，蓝的并不纯粹，而我已经习惯了这种蓝，并且也开始用湛蓝形容它。没事的时候我也会在教五门口的广场上休息，或者在万林艺术馆的天台上坐着以一个不至于让太阳抢去风头的角度欣赏蓝天，我为这种天气而欣喜，但内心中又似乎对一场夏天的雷雨更为期待。我不知道是因为暴雨真的能够洗刷世界，还是因为我仅仅期待那雨声给我带来的视觉、听觉再到触觉的全方位的模拟，能够带我回到小时候，或者说情感更加纯粹的年岁。</p>
<p>现在外面天很黑，皓月当空，高悬东方，在宿舍门口我看到有人在用微单拍摄。我很遗憾单反不在身边，同时又很庆幸单反不在身边。我尝试用手机对这个美丽的夜色进行记录，但最后发现它只属于我的眼睛，属于在我记忆中注定渐渐消散的那一块区域。我很快会把昨晚的雨、清晨的绿以及东方的月这些印记着今天的一切特征给淡忘，因为未来还会有无数个相同的日子，武大的樱花会一直开下去，我的路，我的追求，我的思考也不会停下，至死方休。时不时想想上一个今天自己对纯粹的定义，也许会发现愚蠢，也许会发现美丽，但更重要的是找到不同日子纯粹变化的轨迹。文字的意义总会是虚无缥缈的，但追求的东西如果套用一个词来表达的话我认为总不至于两个时间的方向会是南北迥异的吧。</p>
<p>说句实话，我想家了。</p>
<p>人只有在意识到自己脆弱的时候才会顿生羁旅之情。</p>
<p>但也从来没有用羁旅表达自己状态的人会停下脚步。</p>
<blockquote>
<p>记于 19.3.20 武汉</p>
</blockquote>
]]></content>
      <categories>
        <category>杂谈杂想</category>
        <category>杂想</category>
      </categories>
      <tags>
        <tag>杂想</tag>
      </tags>
  </entry>
  <entry>
    <title>git的基本命令</title>
    <url>/page/git.html</url>
    <content><![CDATA[<h2 id="Git-小记"><a href="#Git-小记" class="headerlink" title="Git 小记"></a>Git 小记</h2><p>Git是使用最广泛的版本控制系统，加上GitHub如此闻名（假笑），所以学习Git的一些基本命令还是很重要的，本人是学习了廖雪峰老师的Git相关教程，并将其中Git的一些相关命令记录下来，方便查找，也算一个笔记（本人原来从不记笔记，现在改过自新了）。嘻嘻。<br>廖雪峰老师的Git学习<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">传送门</a><br>首先应该明确的我认为有这么两个东西，即<em>工作区（Working Directory）</em>与<em>版本库（Repository）</em>。工作区可以简单理解成存放你工作内容的文件夹（本地），版本库则可以简单理解为记录你修改等操作内容的git生成的一个文件。版本库中又主要包含<em>暂存区</em>以及<em>分支结构master（默认）</em>。通过git提交项目修改之类的过程，可以简单理解为在本地进行修改后通过<strong>git add</strong>与<strong>git commit</strong>两个命令步骤，由本地到暂存区再到分支结构，这个命令的具体使用，后续会说明，这儿只对原理做一些粗略阐述。<br>同时分支结构有啥用呢？我觉得不必细谈，反正就理解为n个人可以一起工作还不会乱的一种机制吧，有Git需求的人想必能够理解，在此不做赘述（三言两语我也讲不清楚嘻嘻）</p>
<h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><p>选中文件夹不用一个个cd输入路径，选中相应文件夹鼠标右键选择<em>Git Bash Here</em>就行。<br><strong>PS：以下说明中&lt;&gt;括号内表示是你要输入的信息</strong></p>
<h3 id="初始化git仓库"><a href="#初始化git仓库" class="headerlink" title="初始化git仓库"></a>初始化git仓库</h3><p>即将你选中的目录变为git管理的仓库</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git init<br></code></pre></td></tr></table></figure>

<h3 id="提交你的修改"><a href="#提交你的修改" class="headerlink" title="提交你的修改"></a>提交你的修改</h3><p>提交单个文件，记得加后缀。同时file后用空格分割可以一次add很多文件</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile">$ git <span class="hljs-keyword">add</span><span class="bash"> &lt;file&gt;</span><br></code></pre></td></tr></table></figure>
<p>提交一个文件夹</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><code class="hljs dockerfile">$ git <span class="hljs-keyword">add</span><span class="bash"> &lt;foldname&gt;/</span><br></code></pre></td></tr></table></figure>
<p>把暂存区的内容提交到当前分支（Git小记中的第二过程哦），<message>表示的是你对这此提交做的说明，类似于备忘录，方便你以后查看，同时每次使用<em>commit</em>命令后系统会生成一个id来记录这次提交，亦能方便查找</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">$ git commit -m <span class="hljs-tag">&lt;<span class="hljs-name">yourmessage</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="查看仓库中文件修改的信息"><a href="#查看仓库中文件修改的信息" class="headerlink" title="查看仓库中文件修改的信息"></a>查看仓库中文件修改的信息</h3><p>查看仓库当前的状态（文件增删，文件内容改变等）</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git status<br></code></pre></td></tr></table></figure>
<p>查看相应文件修改的具体内容</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git diff &lt;<span class="hljs-keyword">file</span>&gt;<br></code></pre></td></tr></table></figure>
<p>显示从最近到最远的提交日志（包括上一节中你输入的说明，时间等内容），较为详细。在其之后加上相应备注后（行二），可以简略输出（id号码等等）</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">$ git <span class="hljs-built_in">log</span><br>$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--pretty=oneline</span><br></code></pre></td></tr></table></figure>
<p>显示你的每一次命令（可以用来查看之前的每一步操作）</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">$ git <span class="hljs-built_in">ref</span>log<br></code></pre></td></tr></table></figure>

<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>Git中有一个HEAD指针指向当前版本，而HEAD^表示上个版本，HEAD^^表示上上个版本，HEAD~n表示第n个版本。<br>回退到之前的版本于回退到相应版本的命令如下，其中<commit id>相信你已经明白了，这个就是上一节信息当中的版本号。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">$ git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^</span><br>$ git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard &lt;commit id&gt;</span><br></code></pre></td></tr></table></figure>
<p>撤销工作区的修改，请注意这里的关键词<em>工作区</em>，也就是说这个操作只能将你还没有执行<strong>add</strong>命令的文件修改去除。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git checkout -- &lt;<span class="hljs-keyword">file</span>&gt;<br></code></pre></td></tr></table></figure>
<p>要去除已经使用add进入暂存区的修改，请使用以下命令命令。第一行是将暂存区的修改撤销掉（unstage），第二行就接着使用上面的命令就好，不重复写了。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">$ git <span class="hljs-keyword">reset</span> <span class="hljs-keyword">HEAD</span> &lt;<span class="hljs-keyword">file</span>&gt;<br></code></pre></td></tr></table></figure>
<p>以上便是应对“工作区修改”、“暂存区修改”、“已提交”这三种情况的版本回退命令，足够应付大部分时间了。</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>第一行命令：删除本地文件。<br>第二行命令：从版本库中删除文件(删除后记得再使用commit命令提交一次)<br>至于删错了恢复，请见上一节。</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> rm &lt;<span class="hljs-keyword">file</span>&gt;<br><span class="hljs-symbol">$</span> git &lt;<span class="hljs-keyword">file</span>&gt;<br></code></pre></td></tr></table></figure>

<h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><p>分支在第一大节也有提到，这里列出一些常用操作<br>第一行为创建名称为<name>的分支，并将当前分支切换为<name>。第二行为切换当前分支为<name>。（同时，master为默认主分支）</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">$ git checkout -b &lt;<span class="hljs-built_in">name</span>&gt;<br>$ git checkout &lt;<span class="hljs-built_in">name</span>&gt;<br></code></pre></td></tr></table></figure>
<p>查看所有分支</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git branch<br></code></pre></td></tr></table></figure>
<p>第一行为把分支<name>合并到当前分支中。第二行为删除<name>分支。第三行为强行删除未进行合并操作的<name>分支。</p>
<figure class="highlight fortran"><table><tr><td class="code"><pre><code class="hljs fortran">$ git <span class="hljs-built_in">merge</span> &lt;<span class="hljs-keyword">name</span>&gt;<br>$ git branch -d &lt;<span class="hljs-keyword">name</span>&gt;<br>$ git branch -D &lt;<span class="hljs-keyword">name</span>&gt;<br></code></pre></td></tr></table></figure>
<p>查看分区合并历史以及合并图</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--graph --pretty=oneline --abbrev-commit</span><br></code></pre></td></tr></table></figure>
<p><strong>PS：</strong>同时应注意，当你在master分支与新建的分支上都进行了修改并执行了commit命令时，直接合并可能会把报错，然后你得去相关文件中手动修改一下再commit。git会在相应文件中给你进行两次修改的醒目标注，很方便</p>
<h3 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h3><p>大家都知道软件会有版本，比如adobe公司的一堆CS和CC，tag在Git中就起到给一个commit设定一个除去id外更容易记住的别名的作用，方便查找。默认设置tag是设置在最近一次commit上。<br>以下第一行为设置一个标签；第二行为在id为commit_id的commit上设置标签；第三行在第二行的基础上给tag一点说明；第四行为查看现有所有标签；第五行查看相应标签详细信息；第六行删除一个本地标签。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">&lt;tagname</span>&gt;<br>$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">&lt;tagname</span>&gt; <span class="hljs-tag">&lt;commit_id&gt;</span><br>$ git <span class="hljs-keyword">tag</span> <span class="hljs-title">-a</span> <span class="hljs-tag">&lt;tagname&gt;</span> -m <span class="hljs-tag">&lt;message&gt;</span> <span class="hljs-tag">&lt;commit_id&gt;</span><br>$ git <span class="hljs-keyword">tag</span><br><span class="hljs-title">$</span> git show <span class="hljs-tag">&lt;tagname&gt;</span><br>git <span class="hljs-keyword">tag</span> <span class="hljs-title">-d</span> <span class="hljs-tag">&lt;tagname&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><p>前面提到了GitHub，自然学git远程操作（或者理解成跟GitHub玩游戏也成）是必不可少的，本地下载了git咋和GitHub扯上关系就略过不谈了，以下记录一些相关常用操作。<br>刚下好git打开就会有以下这些玩意，你也可以随时使用相应命令查看相应配置，使用<strong>git config -1</strong>可以查看很多信息，试试就知道。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">$ git<span class="hljs-built_in"> config </span>--global user.email <span class="hljs-string">"your_email@qq.com"</span><br>$ git<span class="hljs-built_in"> config </span>__global user.name <span class="hljs-string">"your_github_name"</span><br></code></pre></td></tr></table></figure>
<p>将本地库与远程库相关联（origin是远程库的默认名称）</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">$ git remote <span class="hljs-keyword">add</span> origin git@&lt;<span class="hljs-keyword">server</span>-<span class="hljs-type">name</span>:<span class="hljs-type">path</span>/repo-<span class="hljs-type">name</span>.git&gt;<br></code></pre></td></tr></table></figure>
<p>使用<em>push</em>命令，将本地库的内容推送到远程库上(第一次)，之后每次本地修改后若要推送可用第二行命令</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">$ git push -u origin <span class="hljs-keyword">master</span><br><span class="hljs-title">$</span> git push origin <span class="hljs-literal">master</span><br></code></pre></td></tr></table></figure>
<p>将GitHub上的内容克隆到本地（注意你要是想对其有修改并推送，应先fork到自己的库里，再克隆）。输入git clone后将你所要克隆的网址复制后加上就好。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh">$ git <span class="hljs-keyword">clone</span> <span class="hljs-title">&lt;http</span>:~&gt;<br></code></pre></td></tr></table></figure>
<p>查看远程库详细相关信息</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git remote -v<br></code></pre></td></tr></table></figure>
<p>建立远程库dev分支与本地dev的链接</p>
<figure class="highlight q"><table><tr><td class="code"><pre><code class="hljs q">$ git branch --<span class="hljs-built_in">set</span>-upstream-to=origin/<span class="hljs-built_in">dev</span> <span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure>
<p>把最新的提交抓取下来</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>git pull<br></code></pre></td></tr></table></figure>

<h3 id="有关参考"><a href="#有关参考" class="headerlink" title="有关参考"></a>有关参考</h3><p>其实很多命令压根不用记，但要去看每个操作下来git给的提示，很多后续如何操作已经写好了，你所需的往往只是做一做英语阅读。</p>
]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>对一个文件夹下的图像进行整体操作</title>
    <url>/page/batch_RS.html</url>
    <content><![CDATA[<p>前些日子（其实好几个月前了吧），复现一个遥感图像“填缝”的算法，想想matlab好久没用，便打算记录一点点，当作消遣。下面这个算是一个基底数据获取的小过程吧，可以当成matlab图像批处理的一个模板代码段。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">clear;<br>clc;<br><span class="hljs-attribute">srcDir</span>=uigetdir();<br>cd(srcDir);<br><span class="hljs-attribute">allnames</span>=struct2cell(dir('*.tif')); %只处理8位的.tif文件<br>[k,len]=size(allnames); %获得tif文件的个数<br><br>J = imread(allnames&#123;1,1&#125;);<br>[m,n] = size(J);<br>T = zeros(m,n);<br><br><span class="hljs-keyword">for</span> <span class="hljs-attribute">ii</span>=1:len<br>%逐次取出文件<br>    <span class="hljs-attribute">name</span>=allnames&#123;1,ii&#125;;<br>    <span class="hljs-attribute">I</span>=imread(name);<br>    I(isnan(I))=0; %图像nan处设置为0<br>    <span class="hljs-keyword">for</span> <span class="hljs-attribute">jj</span>=1:m<br>        <span class="hljs-keyword">for</span> kk = 1:n<br>            T(jj,kk) =  T(jj,kk)+I(jj,kk);<br>        end<br>    end<br>end<br><span class="hljs-attribute">T</span>=T/len;<br>imshow(T);<br>imwrite(T,<span class="hljs-string">'test_8.tif'</span>);<br></code></pre></td></tr></table></figure>
<p>下面记几个用到的函数，方便以后忘了用来查查。<br>uigetdir：ui get dir</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode"><span class="hljs-meta">%</span>打开一个模态对话框，返回path为用户所选择的路径，若用户点击关闭path=<span class="hljs-number">0</span><br>fpath = uigetdir<br><span class="hljs-meta">%</span>打开路径path下的对话框<br>fpath = uigetdir<span class="hljs-comment">(path)</span><br>uigetdir<span class="hljs-comment">('C:\')</span> <span class="hljs-meta">%</span>打开C盘<br>uigetdir<span class="hljs-comment">(matlabroot)</span> <span class="hljs-meta">%</span>打开matlab默认文件夹<br></code></pre></td></tr></table></figure>
<p>其余几个：</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><code class="hljs matlab">cd(path) <span class="hljs-comment">%这个就不必多说了吧，设置当前文件夹</span><br>c = struct2cell(s) <span class="hljs-comment">%结构体s转化为元胞数组c</span><br>dir(name) <span class="hljs-comment">%列出与name匹配的所有文件</span><br><span class="hljs-built_in">isnan</span>(<span class="hljs-built_in">i</span>) <span class="hljs-comment">%判断矩阵中为nan的地方并返回1，其余返回0</span><br></code></pre></td></tr></table></figure>
<p>其实都蛮好记的了，说起来写完这个我在怀疑我会不会把这些东西忘掉哈哈哈</p>
]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>matlab</tag>
        <tag>RS</tag>
      </tags>
  </entry>
  <entry>
    <title>latex基本用法</title>
    <url>/page/latex1.html</url>
    <content><![CDATA[<p>谈到码字与排版大家首先想到的一定是word等办公软件，即一些“所见即所得”的排版与“码字”软件，这些软件功能强大足够应付日常的一切工作。<br>但当大家有英文论文的写作与排版需求时，尤其是面对美赛这种“英文写作比赛”时，输出的PDF文件的美观性就尤其重要了（本人也是因为美赛才接触了latex这个让人又爱又恨的软件）。出于实用与给自己进行用法记录的目的，我也就不拿软件的历史之类的凑字数了，直接上可以产生效果的东西。<br><strong>PS：</strong>我个人认为latex 与HTML之类的标签语言十分相似，学习成本低，易用难精（也没必要精），因此本文只针对相应排版的具体问题，不涉及任何latex的理论与底层问题，想精学的朋友建议移步刘海洋的《LaTeX入门》（可以联系本人电子版），同时有其他问题建议百度搜索或混混相应论坛，这儿给一个tackle problems的<a href="http://www.latexstudio.net/" target="_blank" rel="noopener">传送门</a>,下载TEXLive请移步<a href="http://tug.org/texlive/" target="_blank" rel="noopener">传送</a>,选择相应版本后耐心等待。<br><strong>以下未经说明使用TeXworks编辑器，编译方式选择XELaTeX</strong></p>
<h2 id="目录及其相关设置"><a href="#目录及其相关设置" class="headerlink" title="目录及其相关设置"></a>目录及其相关设置</h2><figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-tag">\<span class="hljs-name">tableofcontents</span></span>            <span class="hljs-comment">%插入目录，由于latex的“交叉引用”，注意应编译两次</span><br><span class="hljs-tag">\<span class="hljs-name">thispagestyle</span><span class="hljs-string">&#123;empty&#125;</span></span>       <span class="hljs-comment">%设置目录页不计入页码，用于文章其他部位亦可</span><br><span class="hljs-tag">\<span class="hljs-name">clearpage</span></span>                  <span class="hljs-comment">%该语句使得文章后面内容另起一页显示，此处使得目录单独写在一页</span><br><span class="hljs-tag">\<span class="hljs-name">setcounter</span><span class="hljs-string">&#123;page&#125;</span><span class="hljs-string">&#123;1&#125;</span></span>        <span class="hljs-comment">%设置目录后正文第一页目录计数为1</span><br></code></pre></td></tr></table></figure>

<h2 id="正文文章结构的设置"><a href="#正文文章结构的设置" class="headerlink" title="正文文章结构的设置"></a>正文文章结构的设置</h2><figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-tag">\<span class="hljs-name">section</span><span class="hljs-string">&#123;一级标题内容&#125;</span></span><br>正文<br><span class="hljs-tag">\<span class="hljs-name">subsection</span><span class="hljs-string">&#123;二级标题内容&#125;</span></span><br>正文<br><span class="hljs-tag">\<span class="hljs-name">subsubsection</span><span class="hljs-string">&#123;三级标题内容&#125;</span></span><br>正文<br></code></pre></td></tr></table></figure>
<p>以上模式相信用过word的朋友都很容易理解了，同时通过上一条所述的目录内容会根据正文中的\section{}等标签自动生成文章目录，十分方便。</p>
<h2 id="字体字号的常用设置"><a href="#字体字号的常用设置" class="headerlink" title="字体字号的常用设置"></a>字体字号的常用设置</h2><p>latex中包含了很多种字体，但如果没有特殊需求，我认为以下内容完全能够满足需要了</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-tag">\<span class="hljs-name">textbf</span><span class="hljs-string">&#123;内容&#125;</span></span>       <span class="hljs-comment">%将大括号内字体加粗</span><br><span class="hljs-tag">\<span class="hljs-name">textit</span><span class="hljs-string">&#123;内容&#125;</span></span>       <span class="hljs-comment">%将大括号内字体变为斜体</span><br><span class="hljs-tag">\<span class="hljs-name">emph</span><span class="hljs-string">&#123;内容&#125;</span></span>         <span class="hljs-comment">%强调括号内字体内容</span><br></code></pre></td></tr></table></figure>

<h2 id="列表环境"><a href="#列表环境" class="headerlink" title="列表环境"></a>列表环境</h2><h3 id="有计数的列表"><a href="#有计数的列表" class="headerlink" title="有计数的列表"></a>有计数的列表</h3><figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">&#123;enumerate&#125;</span></span><br>    <span class="hljs-tag">\<span class="hljs-name">item</span></span> 内容1<br>    <span class="hljs-tag">\<span class="hljs-name">item</span></span> 内容2<br><span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">&#123;enumerate&#125;</span></span><br></code></pre></td></tr></table></figure>
<h3 id="无计数的列表（bulleted-list）"><a href="#无计数的列表（bulleted-list）" class="headerlink" title="无计数的列表（bulleted list）"></a>无计数的列表（bulleted list）</h3><figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">&#123;itemize&#125;</span></span><br>    <span class="hljs-tag">\<span class="hljs-name">item</span></span> 内容1<br>    <span class="hljs-tag">\<span class="hljs-name">item</span></span> 内容2<br><span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">&#123;itemize&#125;</span></span><br></code></pre></td></tr></table></figure>
<h3 id="复杂列表"><a href="#复杂列表" class="headerlink" title="复杂列表"></a>复杂列表</h3><p>同时上述各个列表可以相互嵌套，如下即为在一个bulleted list下又嵌套了一个计数列表。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">&#123;itemize&#125;</span></span><br>    <span class="hljs-tag">\<span class="hljs-name">item</span></span> 内容1<br>    <span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">&#123;enumerate&#125;</span></span><br>        <span class="hljs-tag">\<span class="hljs-name">item</span></span> 内容1.1<br>        <span class="hljs-tag">\<span class="hljs-name">item</span></span> 内容1.2<br>    <span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">&#123;enumerate&#125;</span></span><br><span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">&#123;itemize&#125;</span></span><br></code></pre></td></tr></table></figure>

<h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>在正文中插入图片很简单，如果你没有特殊的需求copy下面这段代码并且更改里面一些参数完全够用了，图片的资源文件和其他开发都是一样的，建议在根目录下建立一个img文件夹专门存放，同时记得将文件的命名与格式搞清楚。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-comment">%下行代码中[]内为可选项意义分别为</span><br><span class="hljs-comment">%h 代表here,将表格排在当前文字位置</span><br><span class="hljs-comment">%t 表示将表格放在下一页的 top (页首)</span><br><span class="hljs-comment">%b 表示将表格放在当前页的 bottom (底部)</span><br><span class="hljs-comment">%! 表示忽略美观因素，尽可能按照参数指定的方式来处理表格浮动位置</span><br><span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">&#123;figure&#125;</span><span class="hljs-string">[h]</span></span><br>    <span class="hljs-tag">\<span class="hljs-name">centering</span></span>      <span class="hljs-comment">%使图片居中</span><br>    <span class="hljs-comment">%下面这行可以简单理解为载入图片的函数，width=0.6\textwidth是将图片等比例设为宽度为0.6个间页长（排版的名词不大记得可以简单这么理解），你也可以使用px之类的将其设置为定宽。后面大括号内一定得是如image1.jpg这种格式，后缀不能漏</span><br>    <span class="hljs-tag">\<span class="hljs-name">includegraphics</span><span class="hljs-string">[width=0.6\textwidth]</span><span class="hljs-string">&#123;加后缀的图片名&#125;</span></span><br>    <span class="hljs-tag">\<span class="hljs-name">caption</span><span class="hljs-string">&#123;图片的名称&#125;</span></span>    <span class="hljs-comment">%大括号内为页面显示的图片的名称</span><br>    <span class="hljs-tag">\<span class="hljs-name">label</span><span class="hljs-string">&#123;fig:1&#125;</span></span>          <span class="hljs-comment">%设置图片的标签方便交叉引用</span><br><span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">&#123;figure&#125;</span></span><br></code></pre></td></tr></table></figure>

<h2 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h2><p>表格是一切论文或其他议论文体中非常常见的数据表达形式，由于数据的不同各种类型多种多样，不想上节所述的图片那么一段代码打天下，所以表格内容较多，我尽量将我认为的常用的表格形式的通用代码附上，同时也列举一下表格的基本形式，方便读者进行变换。</p>
<h3 id="普通表格"><a href="#普通表格" class="headerlink" title="普通表格"></a>普通表格</h3><p>普通表格是指一个没有任何改动的最基本的表格（参考word你便知道样式），我也可以借由此说明一下表格中的一些常用参数<br>同时，如\centering；\caption{};\label{}等操作，与上一节所述关于图片相同</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">&#123;table&#125;</span><span class="hljs-string">[!htb]</span></span> <span class="hljs-comment">%[]内与上一节所述图片相同</span><br>    <span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">&#123;tabular&#125;</span><span class="hljs-string">&#123;|c|r|l|&#125;</span></span>    <span class="hljs-comment">%后一个括号内c代表居中，r代表靠右，l代表靠左，|为表格竖线，可以舍去</span><br>        <span class="hljs-tag">\<span class="hljs-name">hline</span></span>  <span class="hljs-comment">%为表格横线，可以舍去</span><br>        内容1 &amp; 内容2 &amp; 内容3 <span class="hljs-tag">\<span class="hljs-name">\</span></span>    <span class="hljs-comment">%每个单元格间由&amp;分开，\\表示换行</span><br>        <span class="hljs-tag">\<span class="hljs-name">hline</span></span><br>        内容4 &amp; 内容5 &amp; 内容6 <span class="hljs-tag">\<span class="hljs-name">\</span></span><br>        <span class="hljs-tag">\<span class="hljs-name">hline</span></span><br>    <span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">&#123;tabular&#125;</span></span><br><span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">&#123;table&#125;</span></span><br></code></pre></td></tr></table></figure>
<h3 id="表格其他的常用设置"><a href="#表格其他的常用设置" class="headerlink" title="表格其他的常用设置"></a>表格其他的常用设置</h3><p>重新定义表格线的宽度代码如下，可随意更改使用相应代号的名称。使用时找到代码相应位置进行相应更改即可。<br>注意：<strong>以下内容要放在导言区</strong></p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript">%定义表格横线<span class="hljs-string">\ttline的线宽为1.4pt，使用时用\ttline代替上一节中的\hline即可</span><br><span class="hljs-string">\newcommand&#123;\ttline&#125;&#123;</span><br>    <span class="hljs-string">\noalign</span> &#123;<span class="hljs-string">\ifnum</span> <span class="hljs-number">0</span>=`&#125;<span class="hljs-string">\fi</span> <span class="hljs-string">\hrule</span> height <span class="hljs-number">1.4pt</span><br>    <span class="hljs-string">\futurelet</span> <span class="hljs-string">\reserved@a</span> <span class="hljs-string">\@xhline</span><br>&#125;<br>%重定义表格竖线！的线宽为<span class="hljs-number">2pt</span>，使用时用！代替上一节中的|即可<br><span class="hljs-string">\newcolumntype&#123;!&#125;&#123;@&#123;\hskip\tabcolsep\vrule</span> width <span class="hljs-number">2pt</span><span class="hljs-string">\hskip\tabcolsep&#125;&#125;</span><br><span class="hljs-string">\makeatother</span><br></code></pre></td></tr></table></figure>
<p>剩下的一些小功能如下：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-comment">%设置表格标题置于表格上面（默认置于下面）</span><br><span class="hljs-tag">\<span class="hljs-name">setlength</span><span class="hljs-string">&#123;\belowcaptionskip&#125;</span><span class="hljs-string">&#123;6pt&#125;</span></span>  <span class="hljs-comment">%置于表格上面6pt</span><br><br><span class="hljs-comment">%如果想单独使一个单元格居中，可以这么写</span><br><span class="hljs-tag">\<span class="hljs-name">multicolumn</span><span class="hljs-string">&#123;1&#125;</span><span class="hljs-string">&#123;c&#125;</span><span class="hljs-string">&#123;content&#125;</span></span><br><br><span class="hljs-comment">%想调整表格上下间距，可以在\begin&#123;table&#125;前加（同样适用于更改正文行距）</span><br><span class="hljs-tag">\<span class="hljs-name">linespread</span><span class="hljs-string">&#123;倍数&#125;</span></span> <span class="hljs-comment">%更改后值为 倍数*默认间距</span><br><br><span class="hljs-comment">%合并单元格，合并行列可以使用以下公式进行嵌套</span><br><span class="hljs-tag">\<span class="hljs-name">multicolumn</span><span class="hljs-string">&#123;项数&#125;</span><span class="hljs-string">&#123;新列格式&#125;</span><span class="hljs-string">&#123;单元格内容&#125;</span></span> <span class="hljs-comment">%合并列</span><br><span class="hljs-tag">\<span class="hljs-name">multirow</span><span class="hljs-string">&#123;项数&#125;</span><span class="hljs-string">&#123;新列格式&#125;</span><span class="hljs-string">&#123;单元格内容&#125;</span></span> <span class="hljs-comment">%合并行</span><br><br><span class="hljs-tag">\<span class="hljs-name">cline</span><span class="hljs-string">&#123;2-3&#125;</span></span> <span class="hljs-comment">%表示画出一条位于第2列到第3列的横线段，其他列将不会有横线段</span><br></code></pre></td></tr></table></figure>
<h3 id="几种特殊表格代码"><a href="#几种特殊表格代码" class="headerlink" title="几种特殊表格代码"></a>几种特殊表格代码</h3><p>下面是几种相对特殊的表格的代码，根据这些代码结合前两小节的内容更改相应部分即可完成自己的制定。</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-tag">\<span class="hljs-name">linespread</span><span class="hljs-string">&#123;1.1&#125;</span></span><br><span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">&#123;table&#125;</span><span class="hljs-string">[h]</span></span><br><span class="hljs-tag">\<span class="hljs-name">setlength</span><span class="hljs-string">&#123;\belowcaptionskip&#125;</span><span class="hljs-string">&#123;6pt&#125;</span></span><span class="hljs-tag">\<span class="hljs-name">centering</span></span><span class="hljs-tag">\<span class="hljs-name">caption</span><span class="hljs-string">&#123;dia test&#125;</span></span><span class="hljs-tag">\<span class="hljs-name">label</span><span class="hljs-string">&#123;tab:dia&#125;</span></span><br><span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">&#123;tabular&#125;</span><span class="hljs-string">&#123;ccc&#125;</span></span><span class="hljs-tag">\<span class="hljs-name">ttline</span></span><br><span class="hljs-tag">\<span class="hljs-name">diagbox</span><span class="hljs-string">&#123;test1&#125;</span><span class="hljs-string">&#123;test2&#125;</span></span> &amp; altitude &amp; vavlue <span class="hljs-tag">\<span class="hljs-name">\</span></span> <span class="hljs-tag">\<span class="hljs-name">tline</span></span><br>testa &amp; <span class="hljs-formula">$22.2$</span> &amp; <span class="hljs-formula">$22.1$</span> <span class="hljs-tag">\<span class="hljs-name">\</span></span> <br>testb &amp; <span class="hljs-formula">$1.22$</span> &amp; <span class="hljs-formula">$2.22$</span> <span class="hljs-tag">\<span class="hljs-name">\</span></span><br><span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">&#123;tabular&#125;</span></span><br><span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">&#123;table&#125;</span></span><br></code></pre></td></tr></table></figure>
<p>此种表格应记住在导言区加上 <strong>\usepackage{diagbox}</strong><br><img src="/assets/BlogPic/2.1/t1.png" alt="示例1"><br>三线表是各种论文中较为常用的部分，代码与示例见下</p>
<h2 id="插入公式及其他数学式"><a href="#插入公式及其他数学式" class="headerlink" title="插入公式及其他数学式"></a>插入公式及其他数学式</h2><p>公式环境与图片和表格类似，也可以自动编号以及使用交叉引用，只需设置好\label{}内容即可，具体如下：</p>
<h3 id="公式环境"><a href="#公式环境" class="headerlink" title="公式环境"></a>公式环境</h3><p>一般公式编辑：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">&#123;equation&#125;</span></span><br>    公式内容<br>    <span class="hljs-tag">\<span class="hljs-name">label</span><span class="hljs-string">&#123;eq:1&#125;</span></span><br><span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">&#123;equation&#125;</span></span><br></code></pre></td></tr></table></figure>
<p>分段函数模板：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><code class="hljs tex"><span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">&#123;equation&#125;</span></span><br>p_&#123;j&#125;=<span class="hljs-tag">\<span class="hljs-name">begin</span><span class="hljs-string">&#123;cases&#125;</span></span> <br>    0,j=2<span class="hljs-tag">\<span class="hljs-name">\</span></span><br>    1,j=1<br><span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">&#123;cases&#125;</span></span><br><span class="hljs-tag">\<span class="hljs-name">label</span><span class="hljs-string">&#123;&#125;</span></span><br><span class="hljs-tag">\<span class="hljs-name">end</span><span class="hljs-string">&#123;equation&#125;</span></span><br></code></pre></td></tr></table></figure>
<h3 id="常见数学公式的编辑"><a href="#常见数学公式的编辑" class="headerlink" title="常见数学公式的编辑"></a>常见数学公式的编辑</h3>]]></content>
      <categories>
        <category>工具使用</category>
      </categories>
      <tags>
        <tag>latex</tag>
      </tags>
  </entry>
</search>

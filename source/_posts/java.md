---
title: java
date: 2020-06-27 17:25:12
tags:
categories:
fileName:
---





1

构造函数需要一个有参构造和一个无参构造



getter/setter





包：一个JAVA源文件中只能有一个package语句

命名方法：域名倒序+模块+功能



static：静态成员、类成员

无论类实例化多少，值都相同 



静态方法不能直接访问非静态成员

 

使用{}形成代码块，每个代码块是一个独立的作用空间

{}——在方法中，普通代码块。在类中，构造代码块

static{}——静态代码块





在方法中通过对象作为参数，传递的是他的引用



方法重载：

1、同一个类中

2、方法名相同，参数列表不同，方法返回值相同

3、访问修饰符。



方法重写：

1、有继承关系的子类中

2、方法名相同，参数列表相同（参数顺序、个数相同）



Java只能是单继承

子类可以访问父类非私有成员



 

共有：public：任意位置

私有：private：本类中访问

保护：protected：当前类、同包子类/非子类、跨包子类（跨包子类不允许）

默认：当前类、同包子类（跨包子类不允许调用）



super：父类对象的引用

super.print() 访问父类成员方法

super.name 访问父类属性

super() 访问父类构造方法，必须位于子类构造方法的第一行



子类的构造过程必须调用其父类的构造方法，若子类构造方法中没有显式标注，则系统默认调用父类无参构造方法（若子类构造方法无显式标值且父类中没有无参构造方法，则编译出错）



Object类是所有类的父类





final

1、在类前添加，标识该类不允许有子类（如System和String都有final关键字）

2、在方法前添加，表明该方法不能被子类重写（子类能够调用）。不能修饰构造方法



设计模式：软件开发人员在软件开发过程中面临的一般问题的解决方案。基于场景的解决方案

单例模式：1、某个类有且只有一个实例；2、必须自行创建实例；3、自行向整个系统提供这个实例



多态：不同类的对象对同一消息做出不同响应

编译时多态：（方法重载）

运行时多态：程序运行时动态决定调用哪个方法



多态必要条件

1、满足继承关系

2、父类引用指向子类对象



向上转型，父类引用指向子类实例。可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法

Animal two = new Cat()



向下转型，子类引用指向父类实例，此处要求必须进行强转

instanceof 运算符，返回 true false

```
if(obj instanceof Cat) {
	Cat temp = (Cat)obj
}
```



```
if() {
	return new Dog();
} else {
	return new Cat();
}
```





abstract关键字

抽象类，无法进行实例化的类（可以通过向上转型指向子类实例 ）

抽象方法：子类必须进行实现（或者子类也设置为抽象类），在父类定义时不能有方法体



包含抽象方法的类是抽象类

抽象类中可以没有抽象方法

static/final/private不能与abstract共存



接口：命名通常以“I”打头

接口定义了某一批类所需要遵守的规范

接口不关心这些类的内部数据，也不关心类中方法的实现细节，只规定这些类中必须提供某些方法





接口访问修饰符：public 默认

接口中抽象方法可以不写abstract关键字

作为接口的实现类必须实现接口中定义的所有方法，否则需要将该类设置为抽象类

接口中可以包含常量，默认public static final

```
public interface INet {
	public void func();
}
```



```
public class A implements INet {
	
}
```



```
INet net = new A();

```






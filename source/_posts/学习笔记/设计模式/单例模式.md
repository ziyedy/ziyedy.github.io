---
title: 单例模式
date: 2021-02-22 22:00:22
tags:
	- 设计模式
categories:
	- 学习笔记
	- 设计模式
fileName: singleton-pattern
---

## 单例

> 保证一个类仅有一个实例，并提供一个全局访问点（创建型）

在内存中只有一个实例，减少内存开销，避免资源多重占用

没有接口，拓展比较困难，私有构造器，线程安全，延迟加载

序列化反序列化

反射





数据库的连接池不会反复创建



### 懒汉模式（线程不安全）

* 默认的构造函数中添加了私有属性`private`
* 多个访问者同时获取对象实例会造成多个同样的实例并存

```java
public class Singleton {
    private static Singleton instance;
    
    private Singleton_01() { }
    
    public static Singleton getInstance() {
        if (null != instance) return instance;
        instance = new Singleton();
        return instance;
    }
}
```



### 懒汉模式（线程安全）

相对上一种实现方法在获取实例方法前使用了`synchronized`关键字，但这种模式由于上锁会导致资源浪费，不建议使用

```java
public class Singleton {
    private static Singleton instance;
    private Singleton() { }
    public static synchronized Singleton getInstance(){
        if (null != instance) return instance;
        instance = new Singleton();
        return instance;
    }
}
```



### 饿汉模式（线程安全）

在程序启动的时候直接运⾏行行加载，后续有外部需要使⽤用的时候获取即可，但不是懒加载，会造成性能上的损失

```java
public class Singleton {
    private static Singleton instance = new Singleton();
    private Singleton() { }
    public static Singleton getInstance() {
    	return instance;
    }
}
```



### 使用类的内部类（线程安全）

是一种比较好的方式

既保证了线程安全又保证了懒加载，同时不会因为加锁的方式耗费性能（因为JVM保证了一个类的构造方法在多线程环境下能够被正确的加载）

```java
public class Singleton {
    private static class SingletonHolder {
    	private static Singleton instance = new Singleton();
    }
    private Singleton() { }
    public static Singleton getInstance() {
    	return SingletonHolder.instance;
    }
}
```






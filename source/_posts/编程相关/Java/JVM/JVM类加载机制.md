---
title: Java类加载机制
date: 2021-02-04 13:38:33
tags:
	- JVM
categories:
	- 编程相关
	- Java
	- JVM
fileName: jvm-classloader
---

# 类生命周期

## 类的生命周期



## 加载

### 加载的过程

1. 通过类的全限定名获取该类的二进制字节流。
2. 将二进制字节流所代表的静态结构转化为方法区的运行时数据结构。
3. 在内存中创建一个代表该类的 `java.lang.Class` 对象，作为方法区这个类的各种数据的访问入口。

### “非数组类”与“数组类”加载比较

* 非数组类加载阶段可以使用系统提供的引导类加载器，也可以由用户自定义的类加载器完成（如重写一个类加载器的 `loadClass()` 方法）
* **数组类本身不通过类加载器创建**，它是由 Java 虚拟机直接创建的，再由类加载器创建数组中的元素类





## 连接

就是将已经读入内存的类的二进制数据合并到JVM运行时环境中

### 验证

确保被加载类的正确性

* **类文件结构检查**∶按照JVM规范规定的类文件结构进行

* **元数据验证**：对字节码描述的信息进行语义分析，保证其符合Java语言规范要求

* **字节码验证**∶通过对数据流和控制流进行分析，确保程序语义是合法和符合逻辑的。这里主要对**方法体**进行校验

* 符号引用验证：对类自身以外的信息，也就是常量池中的各种符号引用，进行匹配校验，**确保解析正常执行**

### 准备

为类的静态变量分配内存，并设置初始值

### 解析

将常量池中的符号引用替换为直接引用

* 符号引用：以一组无歧义的符号来描述所引用的目标，与虚拟机无关

* 直接引用：直接指向目标的指针、相对偏移量、或是能间接定位到目标的句柄，是和虚拟机实现相关的

主要针对：类、接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符

## 初始化

为类的静态变量赋初始值

类的初始化就是为类的静态变量赋初始值，或者说是执行类构造器<clinit>方法的过程

1）如果类还没有加载和连接，就先加载和连接
2）如果类存在父类，且父类没有初始化，就先初始化父类

3）如果类中存在初始化语句，就依次执行这些初始化语句

4）如果是接口

​	a初始化一个类的时候，并不会先初始化它实现的接口

​	b初始化一个接口时，并不会初始化它的父接口

c、只有当程序首次使用接口里面的变量或者是调用接口方法的时候，才会导致接口初始化

5)调用Classloader类的loadClass方法来装载一个类，并不会初始化这个类，不是对类的主动使用



类加载完成的功能

1、通过类的全限定名来获取该类的二进制字节流
2、把二进制字节流转化为方法区的运行时数据结构
3、在堆上创建一个java.lang.Class对象，用来封装类在方法区内的数据结构，并向外提供了访问方法区内数据结构的接口



# 类加载器

## 类加载器种类

Java虚拟机自带的加载器包括如下3种∶

* 启动类加载器（BootstrapClassLoader）

   负责将存放在 `<JAVA_HOME>\lib` 目录中的，并且能被虚拟机识别的（仅**按照文件名**识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中

* 拓展类加载器（Extension ClassLoader，JDK8）  

   JDK9之后为平台类加载器（PlatformClassLoader）。负责加载 `<JAVA_HOME>\lib\ext` 目录中的所有类库，开发者可以直接使用扩展类加载器

* 应用程序类加载器（AppClassLoader）

  它负责加载用户类路径（classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中**默认的类加载器**。

* 用户自定义的加载器

  是`java.lang.ClassLoader`的子类，用户可以定制类的加载方式;只不过自定义类加载器其加载的顺序是在所有系统类加载器的最后







## 类加载器实验

Java程序不能直接引用启动类加载器，直接设置classLoader为null，默认就使用启动类加载器
类加载器并不需要等到某个类“首次主动使用”的时候才加载它，Jvm规范允许类加载器在预料到某个类将要被使用的时候就预先加载它

如果在加载的时候.class文件缺失，会在该类首次主动使用时报告LinkageError错误，如果一直没有被使用，就不会报错



## 自定义类加载器





## 双亲委派模型

JVM中的ClassLoader通常采用双亲委派模型，要求除了启动类加载器外，其余的类加载器都应该有自己的父级加载器（这里的父子关系一般不会以继承的关系实现，而是**以组合关系来复用父加载器的代码**）

### 工作过程
1、首先判断当前类是否被加载过，已经被加载的类会直接返回，否则才会尝试加载；

2、加载的时候，首先会把该请求委派该父类加载器的 `loadClass()` 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 `BootstrapClassLoader` 中；

3、当父类加载器无法完成这个加载请求（找不到所需的类）时，子加载器才会尝试自己去加载。

### 为何使用双亲委派模型

1、双亲委派模型保证了Java程序的稳定运作，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），*保证没有同包同名的类*

2、保证了Java的核心API不被篡改，*保证系统类不会被覆盖*





2、实现双亲委派的代码在java.lang.ClassLoader的loadClass()方法中，如果自定义类加载器的话，推荐覆盖实现findClass()方法







参考：

> 






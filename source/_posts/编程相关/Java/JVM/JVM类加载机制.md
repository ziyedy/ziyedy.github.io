---
title: Java类加载机制
date: 2021-02-04 13:38:33
tags:
	- JVM
categories:
	- 编程相关
	- Java
	- JVM
fileName: jvm-classloader
---

# 类生命周期

加载：查找并加载类文件的二进制数据

连接：就是将已经读入内存的类的二进制数据合并到JVM运行时环境中

​	验证：确保被加载类的正确性

类文件结构检查∶按照JVM规范规定的类文件结构进行

元数据验证:对字节码描述的信息进行语义分析，保证其符合Java语言规范要求
字节码验证∶通过对数据流和控制流进行分析，确保程序语义是合法和符合逻辑的。这里主要对方法体进行校验

符号引用验证:对类自身以外的信息，也就是常量池中的各种符号引用，进行匹配校验

​	准备：为类的静态变量分配内存，并初始化他们

​	解析：将常量池中的符号引用转化为直接引用

​	符号引用：以一组无歧义的符号来描述所引用的目标，与虚拟机无关

​	直接引用:直接指向目标的指针、相对偏移量、或是能间接定位到目标的句柄，是和虚拟机实现相关的

​	主要针对:类、接口、字段、类方法、接口方法、方法类型、方法句柄、调用点限定符

初始化：为类的静态变量赋初始值

类的初始化就是为类的静态变量赋初始值，或者说是执行类构造器<clinit>方法的过程

1）如果类还没有加载和连接，就先加载和连接
2）如果类存在父类，且父类没有初始化，就先初始化父类

3）如果类中存在初始化语句，就依次执行这些初始化语句

4）如果是接口

​	a初始化一个类的时候，并不会先初始化它实现的接口

​	b初始化一个接口时，并不会初始化它的父接口

c、只有当程序首次使用接口里面的变量或者是调用接口方法的时候，才会导致接口初始化

5)调用Classloader类的loadClass方法来装载一个类，并不会初始化这个类，不是对类的主动使用



类加载完成的功能

1、通过类的全限定名来获取该类的二进制字节流
2、把二进制字节流转化为方法区的运行时数据结构
3、在堆上创建一个java.lang.Class对象，用来封装类在方法区内的数据结构，并向外提供了访问方法区内数据结构的接口



# 类加载器

## 类加载器种类

Java虚拟机自带的加载器包括如下几种∶

启动类加载器(BootstrapClassLoader )

jdk8 拓展类加载器（Extension ClassLoader）  平台类加载器(PlatformClassLoader ) JDK9之后

应用程序类加载器(AppClassLoader )



用户自定义的加载器，是java.lang.ClassLoader的子类，用户可以定制类的加载方式;只不过自定义类加载器其加载的顺序是在所有系统类加载器的最后





启动类加载器︰用于加载启动的基础模块类，比如:java.base、java.management、java.xml等等
平台类加载器︰用于加载一些平台相关的模块，比如∶java.scripting . java.compiler*、 java.corba*等等应用程序类加载器∶用于加载应用级别的模块，比如∶jdk.compiler、jdk.jartool、jdk.jshell 等等;还加载classpath路径中的所有类库





JDK8:启动类加载器︰负责将<JAVA_HOME>/lib，或者-Xbootclasspath参数指定的路径中的，且是虚拟机识别的类库加载到内存中（按照名字识别，比如rt.jar，对于不能识别的文件不予装载)
JDK8:扩展类加载器∶负责加载<JRE_HOME>/lib/ext ,或者java.ext.dirs系统变量所指定路径中的所有类库
JDK8:应用程序类加载器∶负责加载classpath路径中的所有类库





Java程序不能直接引用启动类加载器，直接设置classLoader为null，默认就使用启动类加载器
类加载器并不需要等到某个类“首次主动使用”的时候才加载它，Jvm规范允许类加载器在预料到某个类将要被使用的时候就预先加载它

如果在加载的时候.class文件缺失，会在该类首次主动使用时报告LinkageError错误，如果一直没有被使用，就不会报错



## 自定义类加载器



## 双亲委派模型

JVM中的ClassLoader通常采用双亲委派模型，要求除了启动类加载器外，其余的类加载器都应该有自己的父级加载器。这里的父子关系是组合而不是继承，工作过程如下∶
1 )一个类加载器接收到类加载请求后，首先搜索它的内建加载器定义的所有“具名模块”
2）如果找到了合适的模块定义，将会使用该加载器来加载

3）如果class没有在这些加载器定义的具名模块中找到，那么将会委托给父级加载器，直到启动类加载器

4）如果父级加载器反馈它不能完成加载请求，比如在它的搜索路径下找不到这个类，那子的类加载器才自己来加载
5）在类路径下找到的类将成为这些加载器的无名模块



1、双亲委派模型对于保证Java程序的稳定运作很重要
2、实现双亲委派的代码在java.lang.ClassLoader的loadClass()方法中，如果自定义类加载器的话，推荐覆盖实现findClass()方法



3、如果有一个类加载器能加载某个类，称为定义类加载器，所有能成功返回该类的Class的类加载器都被称为初始类加载器

4、如果没有父加载器，默认就是启动加载器

5、每个类加载器都有自己的命名空间，命名空间由该加载器及其所有父加载器所加载的类构成，不同的命名空间，可以出现类的全路径名相同的情况
6、运行时包由同一个类加载器的类构成，决定两个类是否属于同一个运行时包，不仅要看全路径名是否一样，还要看定义类加载器是否相同。只有属于同一个运行时包的类才能实现相互包内可见



保证系统类不会被覆盖

保证没有同包同名的类






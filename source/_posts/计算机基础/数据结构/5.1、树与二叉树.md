---
title: 5.1、树与二叉树
date: 2020-07-20 16:11:47
tags:
	- 数据结构
categories:
	- 计算机基础
	- 数据结构
fileName:ds-tree-binarytree
---

## 树





### 二叉树

### 基本性质

#### 基本特点

1、每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。

2、左子树和右子树是有顺序的，次序不能任意颠倒。

3、即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。

#### 数学性质



### 基础实现

二叉树的节点，与之前提到的链表的节点很相似，只不过有两个引用，在Java中可以作为一个类中类。

```
class Node {
	E e;
	Node left;
	Node right;
}
```

二叉树所需要的基础方法如下，该基础实现与之后要讲的二叉搜索树是一致的，因此此处类名直接采用BST。

```
public class BST<E extends Comparable<E>> {
    private class Node {
        public E e;
        public Node left, right;

        public Node(E e) {
            this.e = e;
            left = null;
            right = null;
        }
    }

    private Node root;
    private int size;

    public BST() {
        root = null;
        size = 0;
    }

    public int getSize() {
        return size;
    }

    public boolean isEmpty() {
        return size==0;
    }
}
```



### 遍历操作

遍历操作就是把所有节点都访问一遍，由于树的定义天生就带有递归特性，因此使用递归进行遍历是最简单的，但也可以使用普通的迭代方法。

#### 二叉树中的几种遍历

PreOrder Traversal （前序遍历）
InOrder Traversal	（中序遍历）
PostOrder Traversal	（后序遍历）
LevelOrder Traversal	（层序遍历）

**规律：**显然，中序遍历可以与其余三种遍历方法的任何一种完成对二叉树的重建（唯一），而其余三种遍历方法任何一种两两结合都无法构建唯一的二叉树。
这很好理解，其余三种遍历方法告知了我们根节点的位置，而根据这一点我们可以由中序遍历确定左右子树，然后根据二叉树的递归定义完成重建



前三种遍历方法可以依靠递归轻松实现，其不同之处仅在于递归语句中用于遍历当前节点的语句所处的位置，如下。

```
// 前序遍历处理当前节点位置
递归（左子树）;
// 中序遍历处理当前节点位置
递归（右子树）;
// 后续遍历处理当前节点位置
```

其中具体代码可见**迭代实现**中所示。



前三种遍历都可以依靠递归进行简单的实现，可以简单理解为**深度优先**，而最后一种层序遍历则为**广度优先**，依靠队列即可进行实现，其实现方法如下：

```
public void levelOrder() {
    Queue<Node> q = new LinkedList<>();
    q.add(root);
    while (!q.isEmpty()) {
        Node cur = q.remove();
        System.out.println(cur.e);
        if(cur.left != null) q.add(cur.left);
        if(cur.right != null) q.add(cur.right);
    }
}
```



#### 递归实现

1、前序遍历

```
private void preOrder(Node node) {
    if(node == null) return;
    System.out.println(node.e);
    preOrder(node.left);
    preOrder(node.right);
}
```





#### 迭代实现

前序遍历

```
public void preOrderNR() {
    Stack<Node> stack = new Stack<>();
    stack.push(root);
    while(!stack.isEmpty()) {
        Node cur = stack.pop();
        System.out.println(cur.e);
        if(cur.right != null) stack.push(cur.right);
        if(cur.left != null) stack.push(cur.left);
    }
}
```


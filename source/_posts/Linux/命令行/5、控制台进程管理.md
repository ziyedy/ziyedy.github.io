---
title: 控制台进程管理
date: 2020-08-06 10:00:19
tags:
	- Linux
categories:
	- Linux
	- 命令行
fileName: terminal-process-manage
---

## 进程工作

当系统启动的时候，内核先把一些它自己的活动初始化为进程，然后运行一个叫做 init 的程序。init，依次地，再运行一系列的称为 init 脚本的 shell 脚本（位于/etc），它们可以启动所有的系统服务。其中许多系统服务以守护（daemon）程序的形式实现，守护程序仅在后台运行，没有任何用户界面。这样，即使我们没有登录系统，至少系统也在忙于执行一些例行事务。

内核维护每个进程的信息，以此来保持事情有序。例如，系统分配给每个进程一个数字，这个数字叫做进程 ID 或 PID。PID 号按升序分配，init 进程的 PID 总是1。内核也对分配给每个进程的内存和就绪状态进行跟踪以便继续执行这个进程。



## 常用命令

### ps – 报告当前进程快照

#### 不带任何参数

默认情况下，ps 不会显示很多进程信息，只是列出与当前终端会话相关的进程

```
$ ps
  PID TTY          TIME CMD
 3471 pts/1    00:00:00 bash
12266 pts/1    00:00:00 ps
```

#### 加上 x ，展示所有进程

```
ps x
```

输出中"TTY"中的？表示没有控制终端。而新增的STAT表示进程的状态，状态如下。出去这些基本的状态，进程之后还会跟随其他字符，表示各种外来进程的特性

<table class="multi">
<caption class="cap">进程状态</caption>
<thead>
<tr>
<th class="title">状态</th>
<th class="title">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" width="15%">R</td>
<td valign="top">运行中。这意味着，进程正在运行或准备运行。
</td>
</tr>
<tr>
<td valign="top">S</td>
<td valign="top">正在睡眠。进程没有运行，而是，正在等待一个事件，
比如说，一个按键或者网络分组。
</td>
</tr>
<tr>
<td valign="top">D</td>
<td valign="top">不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。</td>
</tr>
<tr>
<td valign="top">T</td>
<td valign="top">已停止. 已经指示进程停止运行。稍后介绍更多。</td>
</tr>
<tr>
<td valign="top">Z</td>
<td
valign="top">一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。
（父进程没有把子进程从进程表中删除）</td>
</tr>
<tr>
<td valign="top"><</td>
<td
valign="top">一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。
进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice），
因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。
</td>
</tr>
<tr>
<td valign="top">N</td>
<td valign="top">低优先级进程。
一个低优先级进程（一个“好”进程）只有当其它高优先级进程被服务了之后，才会得到处理器时间。
</td>
</tr>
</tbody>
</table>



### top – 显示任务

ps只显示ps执行那一个瞬间的信息，而top 程序以进程活动顺序显示连续更新的系统进程列表（默认情况下，每三秒钟更新一次）



### jobs – 列出活跃的任务

如在当前窗口后台运行的进程，**可用来查看PID等信息**

### bg – 把一个任务放到后台执行

### fg – 把一个任务放到前台执行

### kill – 给一个进程发送信号

#### 默认中止程序

```
kill PID
```

#### 发送信号

查看所有信号

```
kill -l
```

如下，是对PID为13546的进程发送了1号信号（HUP，挂起）。注意，信号既可以用号码，也可以用名字来指定，包括在前面加上字母 “SIG” 的名字

```
kill -1 13546
```

#### 常见信号

<table class="multi">
<caption class="cap">常用信号</caption>
<tr>
<th class="title">编号</th>
<th class="title">名字</th>
<th class="title">含义</th>
</tr>
<tr>
<td valign="top" width="10%">1</td>
<td valign="top" width="10%">HUP</td>
<td valign="top">挂起。这是美好往昔的残留部分，那时候终端机通过电话线和调制解调器连接到
远端的计算机。这个信号被用来告诉程序，控制的终端机已经“挂起”。
通过关闭一个终端会话，可以展示这个信号的作用。在当前终端运行的前台程序将会收到这个信号并终止。
<p>许多守护进程也使用这个信号，来重新初始化。这意味着，当一个守护进程收到这个信号后，
这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。</p>
</td>
</tr>
<tr>
<td valign="top">2</td>
<td valign="top">INT</td>
<td valign="top">中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会终止一个程序。
</td>
</tr>
<tr>
<td valign="top">9</td>
<td valign="top">KILL</td>
<td
valign="top">杀死。这个信号很特别。尽管程序可能会选择不同的方式来处理发送给它的
信号，其中也包含忽略信号，但是 KILL 信号从不被发送到目标程序。而是内核立即终止
这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存工作。
因为这个原因，把 KILL 信号看作最后一招，当其它终止信号失败后，再使用它。
</td>
</tr>
<tr>
<td valign="top">15</td>
<td valign="top">TERM</td>
<td valign="top">终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么
这个它会终止。 </td>
</tr>
<tr>
<td valign="top">18</td>
<td valign="top">CONT</td>
<td valign="top">继续。在一个停止信号后，这个信号会恢复进程的运行。</td>
</tr>
<tr>
<td valign="top">19</td>
<td valign="top">STOP</td>
<td
valign="top">停止。这个信号导致进程停止运行，而不是终止。像 KILL 信号，它不被
发送到目标进程，因此它不能被忽略。
</td>
</tr>
</table>

### killall – 杀死指定名字的进程、给多个进程发送信号

### shutdown – 关机或重启系统



## 控制进程的基本使用

### 中断一个进程

按下 Ctrl-c

### 将一个进程放置到后台

为了启动一个程序并让它立即在后台运行，我们在程序命令之后，加上"&"字符。如下

```
xlogo &
[1] 12453
```

执行命令之后，这个 xlogo 窗口出现，并且 shell 提示符返回，同时打印一些有趣的数字。这条信息是 shell 特性的一部分，叫做任务控制。通过这条信息，shell 告诉我们，已经启动了任务号为1（“［1］”），PID 为12453的程序

此时使用**jobs**命令即可看到后台运行的进程的信息

### 将一个进程返回到前台

如下，将任务序号为1的进程返回前台。之后Ctrl-c即可中断进程

```
fg %1
```

### 停止一个进程

使用Ctrl-z停止一个进程，目的是允许前台进程被移动到后台（处理忘记加"&"的情况）。

将任务序号为1的进程放置在后台

```
bg %1
```

### 信号

综上所述的各种操作进程的命令，本质上是给程序发送信号。信号是操作系统与程序之间进行通信时所采用的几种方式中的一种



## 命令行启动程序

1. 想要启动的程序，可能没有在窗口管理器的菜单中列出来（xlogo、typora等等）
2. 从命令行启动一个程序，能够看到一些错误信息
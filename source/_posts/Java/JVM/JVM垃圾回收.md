---
title: JVM垃圾回收
date: 2021-03-06 21:13:28
tags:
	- JVM
categories:
	- Java
	- JVM
fileName: jvm-garbage-collection
---

# 对象死亡

## 判断对象是否存活

垃圾：内存中已经不再被使用到的内存空间就是垃圾

### 引用计数器

给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的

* 优点：实现简单、效率高

* 缺点：不能解决对象之间循环引用的问题（因此该方法不可行）

循环引用就是：A引用B，B也引用A，但没别的对象引用这两个对象，这时其引用计数器不为0，所以引用计数器无法通知GC回收它们

### 可达性分析法

通过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的

![](http://cdn.ziyedy.top/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90.png)

## 引用

### 强引用

如果一个对象具有强引用，Java 虚拟机宁愿抛出 `OutOfMemoryError` 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

### 软引用

如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存

### 弱引用

弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。

### 虚引用

如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。



# 垃圾收集算法

## 标记-清除算法

首先**标记出**所有不需要回收的对象

在标记完成后**统一回收**掉所有没有被标记的对象

<img src="http://cdn.ziyedy.top/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95.jpeg" style="zoom:50%;" />

## 复制算法

将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象**复制**到另一块去，然后再把使用的空间一次清理掉

JVM实际实现中，是将内存分为一块较大的Eden区和两块较小的Survivor空间，每次使用Eden和一块Survivor，**回收时，把存活的对象复制到另一块Survivor**。HotSpot默认的Eden和Survivor比是8:1，每次能够使用90%新生代空间

<img src="http://cdn.ziyedy.top/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95.png" style="zoom:50%;" />

* 优点：实现简单，运行高效，不用考虑碎片
* 缺点：内存有些浪费

## 标记-整理算法

标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象**向一端移动**，然后直接**清理掉端边界以外的内存**

<img src="http://cdn.ziyedy.top/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95.png" style="zoom: 80%;" />

## 分代收集算法

核心思想：根据对象存活周期的不同将内存分为几块，从而可以根据各个年代的特点选择合适的垃圾收集算法

**如新生代通常采用复制算法，而老年代则采用标记-整理算法**

# 垃圾收集器

垃圾收集器具体实现垃圾收集算法。HotSpot常见的收集算法及其作用邻域如下：

<img src="http://cdn.ziyedy.top/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/HotSpot%E6%94%B6%E9%9B%86%E5%99%A8.png" style="zoom:67%;" />

## Serial收集器

是一个单线程收集器，在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ **"Stop The World"** ），直到它收集结束

**新生代采用标记-复制算法，老年代采用标记-整理算法**

![](http://cdn.ziyedy.top/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/Serial%E6%94%B6%E9%9B%86%E5%99%A8.png)

## ParNew收集器

 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）**和 Serial 收集器完全一样**

**新生代采用标记-复制算法，老年代采用标记-整理算法。**

除了 Serial 收集器外，只有它能与 CMS 收集器配合工作

![](http://cdn.ziyedy.top/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/ParNew%E6%94%B6%E9%9B%86%E5%99%A8.png)

## CMS

> CMS（Concurrent Mark Sweep）收集器是一种以**获取最短回收停顿时间**为目标的收集器。它非常符合在注重用户体验的应用上使用。
>
> 收集器是 HotSpot 虚拟机第一款真正意义上的**并发收集器**，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作

![](http://cdn.ziyedy.top/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/CMS.png)

### 运行过程

使用的是**标记-清除算法**，其运行分为四个步骤：

* 初始阶段：暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快
* 并发阶段：同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。跟踪记录**发生引用更新的地方**
* 重新标记：修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录
* 并发清除：开启用户线程，同时 GC 线程开始对未标记的区域做清扫

### 优缺点

* 优点：并发收集、低停顿
* 缺点：对CPU资源敏感；无法处理浮动垃圾；由于使用标记-清除算法导致收集结束后会有大量空间碎片产生

## G1

G1 (Garbage-First) 是一款面向服务器的垃圾收集器，主要针对配备多处理器及大容量内存的机器.。以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征.

*被视为 JDK1.7 中 HotSpot 虚拟机的一个重要进化特征*

### 特点

* **并行与并发**
* **分代收集**：虽然 G1 可以**不需要其他收集器**配合就能独立管理整个 GC 堆，但是还是保留了分代的概念
* **空间整合**：G1 从整体来看是基于“标记-整理”算法实现的收集器；从局部上来看是基于“标记-复制”算法实现的
* **可预测的停顿**：G1 除了追求低停顿外，还能建立可预测的停顿时间模型







参考：

> https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6




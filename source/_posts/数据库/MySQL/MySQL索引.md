---
title: MySQL索引相关问题
date: 2021-04-11 21:37:11
tags:
    - MySQL
categories:
	- 数据库
    - MySQL
fileName: mysql-index
---

## 索引目的

> 索引是存储引擎用于快速找到记录的一种数据结构

优点：

- 减少扫描的数据量，加速查询
- 减少或完全消除数据库的排序操作（ORDER BY），因为索引是有序的
- 将服务器的**随机 IO 变为顺序 IO**，例如，想要查询 salary 处于 1500 ~ 2100 的员工，就可以按照索引顺序查询

缺点：

- 索引会占据额外的存储空间（毕竟它是数据结构），包括磁盘和内存
- 由于对数据需要排序，自然会影响到数据更新（插入、更新、删除）的速度

### 2000万条数据使用主键索引要查多少次

首先，**B+树一个节点的大小设为一页或页的倍数最为合适**。（如果一个节点大小小于1页，读取该节点读取的仍然是一页，因此会造成资源浪费）。在MySQL中B+树一个节点大小为1页（16k）

* 非叶子节点存的为key+指针，叶子节点存的为数据行
* 对于叶子节点，需要看一行数据的大小，如果一行数据大小为1k，那么一页存16数据
* 对于非叶子节点，key使用的为bigint，则为8字节，指针在MySQL中为6字节，一共为14字节。因此16k能存 `16 * 1024 / 14 = 1170`个索引指针。因此对于高度为3的的B+树就能存2000多万条数据。也即主键索引通过3次IO操作就能查到对应数据

参考：https://blog.csdn.net/dl674756321/article/details/102987984



## 索引数据结构

### InnoDB索引实现

不同的存储引擎自然也就会有各自不同的实现

对于 InnoDB 而言，它的内部实现使用的是 B+ 树

使用B+树的原因：

- 中间节点不保存真实数据，就可以去存储更多的索引数据，以降低整体树的层级，减少磁盘 IO 的次数，提高查询性能
- 所有的数据都保存在叶子节点，查询的次数也就是相同的，查询稳定性很高
- 叶子节点之间顺序链接在一起，范围查询的效率极高

### 为什么在Innodb用B+树而不用B树？

1、B+树只有叶节点存放数据，其余节点用来索引，而B树是每个索引节点都会有Data域。所以使用B+树能够**减少索引对内存的占用**

2、B+树除了叶子节点比较小，所以相对于B树，**磁盘的IO次数小**

3、B+树在叶子节点通常使用指针将所有叶子节点连接起来，因此**能够有效支持数据库常用的区间访问（范围访问）**，而B树不行

4、同时B+树每次查询的时间效率比较平均（都是经过相同次查找），因此用在数据库中效率更加稳定

### 为什么数据库不采用红黑树等平衡树呢

**AVL 数和红黑树基本都是存储在内存中才会使用的数据结构**。在大规模数据存储的时候，红黑树往往出现由于**树的深度过大**而造成磁盘IO读写过于频繁，进而导致效率低下的情况

### 为什么不采用哈希索引

哈希索引能较好的适应等值查找，但无法应对范围查找，也无法利用索引完成排序

哈希索引不支持多列联合索引的最左匹配规则（数据量大会频繁发生哈希碰撞）

### 磁盘IO与预读

**数据库系统的设计者巧妙利用了磁盘预读原理**，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证**一个节点物理上也存储在一个页里**，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。



## 索引类型

### 按存储类型

根据索引叶子节点*是否指向真实数据*分为聚簇索引与非聚簇索引

* 聚簇索引：索引与数据是一起存放的，叶子节点存储的是数据行。
* 非聚簇索引：索引与数据是分开存放的，叶子节点存储的是指向数据的指针。

InnoDB的主键索引是聚簇索引，非主键索引（辅助索引）则是非聚簇索引。当需要查询Name="Ellison"的记录时，查询过程是先在Name字段上的辅助索引树找到Name="Ellison"的记录，得到主键ID=14，再到主键索引树上查找ID=14对应的记录。

InnoDB 规定一个表只能有一个聚簇索引，且会使用主键来创建（因此InnoDB推荐使用自增主键，因为**自增主键会使插入效率大大提高**）

### 回表

数据库根据索引（非主键）找到了指定的记录所在行后，还需要回到主键索引树进行搜索，从数据块里获取数据，该过程称为回表

### 覆盖索引

如下SQL只需要查id的值，而id的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经“覆盖了”我们的查询需求，我们称为覆盖索引（即将需要的字段放在索引中去。查询的时候就能避免回表）

```sql
select id frome table where k in (1, 2, 3);
```

**覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段**

### 联合索引

在一个字段上建立索引，就是普通索引。在多个字段上建立索引，就被称为联合索引（由于B+树结构的特性，具有最左前缀匹配原则）

### 普通索引与唯一索引

主键与`unique`关键字约束的字段会自动添加索引



## 索引优化

### 最左前缀匹配

最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符

### 索引下推

MySQL 5.6 之后引入了索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，**减少回表次数**。

### 前缀索引

如下语句为string创建索引时，对于每个记录只取前6个字节

```sql
alter table Table add index(string(6));
```

针对建索引字符串的特点（区分度），合理的定义好长度，就可以既节省空间，又不需要增加额外的查询成本

但是需要注意：**使用前缀索引就无法使用覆盖索引了**，因为索引中并未包含所有信息

### 索引失效的情况

1、模糊匹配当中以通配符“%”开头了

```sql
select * from emp where ename like '%T';
```

2、如果使用or，那么要求or两边的条件字段都要有索引，才会走索引

3、使用复合索引的时候，没有使用左侧的列查找（违反最左匹配原则）

4、在where当中索引列参加了运算（或使用了函数）等操作，索引失效

```sql
select * from emp where sal+1 = 800;
```

5、使用不等于（<>）或范围条件（**范围条件会导致右边索引失效**）

6、字符串不加单引号会导致索引失效

7、order by 或 group by 使用了非索引字段

### EXPLAIN语句

Explain 命令是查看**查询优化器**如何决定执行查询的主要方法

通常的操作是我们会开启慢查询，让慢查询日志去记录一些执行时间比较长的SQL语句，找出这些SQL语句后，就需要用explain这个命令来查看一个这些SQL语句的执行计划，查看该SQL语句有没有使用上了索引，有没有全表扫描、表如何连接及连接顺序等。

所以我们通过对查询语句的分析，可以了解查询语句的执行情况，找出查询语向执行的瓶颈，从而优化查询语句。





### 索引选择的异常处理

有时候MySQL会选错索引：比如同时有index(b)和index(b, a)的情况下两者使用效率并不相同

这时可以使用`force index()`手动指定使用哪个索引（不建议，因为会涉及很多修改）

也可以在写sql语句时**“引导”优化器去选择索引**，如`select from table order by b, a;`



## 数据库设计三大范式

1、任何一张表必须有主键，每一个字段原子性不可再分

2、所有非主键字段完全依赖主键，不要产生部分依赖。

3、所有非主键字段直接依赖主键，不要产生传递依赖

### 为什么建议InnoDB表必须建主键，并且推荐使用整型的自增主键

UUID唯一识别码，不一定有序
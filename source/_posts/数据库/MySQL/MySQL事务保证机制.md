---
title: MySQL事务保证机制
date: 2021-05-10 20:28:30
tags:
categories:
fileName:
---

## 事务

事务指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)，既可由一条简单SQL语句组成，也可由一组复杂SQL语句组成。在事务中的操作，**要么全部完成，要么全部不完成**

事务有ACID四大特性：即原子性、持久性、隔离性、一致性

### 原子性（Atomicity）

> 事务是一个不可分割的单元，要么都执行要么都不执行

想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行回滚，而在 MySQL 中，恢复机制是通过回滚日志（undo log）实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后在对数据库中的对应行进行写入

回滚日志除了能够在发生错误或者用户执行 ROLLBACK 时提供回滚相关的信息，它还能够在整个系统发生崩溃、数据库进程直接被杀死后，当用户再次启动数据库进程时，还能够立刻通过查询回滚日志将之前未完成的事务进行回滚，这也就需要回滚日志必须先于数据持久化到磁盘上，是我们需要先写日志后写数据库的主要原因。

### 持久性（Durability）

> 事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失

WAL（Write Ahead Log）：先写日志，再写数据库

### 隔离性（Isolation）

> 数据库允许多个并发事务同时对数据进行读写和修改，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致

当多个事务并发执行时，虽然单个事务的执行可能没有任何问题，但总体而言就有可能造成数据库的一致性出现问题，如更新丢失、**脏读、不可重复读、幻读**等等。

使用串行化能够避免该问题，但是会影响执行性能，因此SQL标准中有**4种隔离级别**对其进行控制

为了实现这种隔离级别，MySQL使用了各类锁以及MVCC（多版本并发控制），这也是其保证隔离性的核心。

### 一致性（Consistency）

> 在事务开始之前和事务结束以后，数据库的完整性没有被破坏。或者说是从一个一致性状态变到另一个一致性状态

事务的一致性可以理解为两个方面。其一就是数据库层面数据完整性的约束（如主键约束等检查）；其二是业务逻辑上的一致性，这是应用层面上一致性的要求。



## 锁

### 全局锁

执行全局锁后整个数据库就处于只读状态了



自增锁（Auto-inc Locks）

是特殊的表级别锁，专门针对事务插入AUTO_INCREMENT类型的列

原理：每张表自增长值并不保存在磁盘上进行持久化，而是每次InnoDB存储引擎启动时，执行以下操作

```sql
SELECT MAX(auto_inc_col) FROM T FOR UPDATE;
```

保证了每张表只有同一时刻只能有一个自增锁



共享/排他锁（shared and exclusive locks）

标准行级锁。共享锁之间兼容，排他锁与其他任何锁都不兼容

* 共享锁（S）：事务拿到某一行记录共享S锁，才能读取。可以提高读读并发

  ```sql
  SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE
  ```

* 排他锁（X）：事务拿到某一行记录排他X锁，才能修改或者删除。用来保证数据强一致

  ```sql
  SELECT * FROM table_name WHERE ... FOR UPDATE
  ```



意向锁（Intention Locks）

意向锁是指未来某个时刻，事务要加共享/排他锁了，提前声明个意向

- 意向共享锁(IS)：事务有意向对表中某几行加S锁
- 意向排他锁(IX)：事务有意向对表中某几行加X锁

意向锁协议：

- 事务要获得某些行的S锁，必须先获得表的IS锁
- 事务要获得某些行的X锁，必须先获得表的IX锁







### InnoDB锁算法

1、记录锁（Record Locks）

单个行记录上的锁，用来封锁**索引记录**，也叫行锁

2、间隙锁（Gap Locks）

间隙锁封锁索引记录中的间隙（针对隔离级别为可重复读及以上级别的）

3、临键锁（Next-key Locks）

记录锁与间隙锁的组合，即封锁记录又封锁区间



## MVCC（多版本并发控制）

> **MVCC**，全称Multi-Version Concurrency Control，即多版本并发控制。

MVCC在MySQL InnoDB中的实现主要是为了提高数据库并发性能，用更好的方式去处理读-写冲突，做到即使有读写冲突时，也能做到不加锁，非阻塞并发读

MVCC 只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作

* 当前读：读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。如下操作都是当前读

  select lock in share mode

  select for update

  update

  insert

  delete

* 快照读：读取基于多版本，实现基于MVCC，避免了加锁操作。快照读读到的不一定是数据的最新版本，有可能是之前的历史版本。不加锁的select操作就是快照读

### 版本链与undo log

一个表只能有一个主键，所以只能有一个聚簇索引，如果表没有定义主键，则选择第一个非NULL唯一索引作为聚簇索引，如果还没有则生成一个隐藏id列作为聚簇索引UUID。

两个个隐式字段：

* DB_TRX_ID：事务ID，记录创建这条记录/最后一次修改该记录的事务ID（由于事务id是递增的，因此该字段能够表示事务开始的先后顺序）
* DB_ROLL_PTR：回滚指针，指向这条记录的上一个版本

当进行删除修改操作时，会生成对应的undo log，并将当前数据记录中的DB_ROLL_PTR指向新的undo log。而undo log可以还原到之前的版本

### Read View

当事务执行快照读时，会生成数据库系统当前的一个快照（读视图：Read VIew），记录并维护系统当前活跃事务的id。通常用于进行**事务版本的可见性判断**

已提交读和可重复读的区别就在于它们生成ReadView的策略不同

* **up_limit_id**：当前已经提交的事务号 + 1，事务号 < up_limit_id，对于当前Read View都是可见的。

  创建当前Read View前已经提交的事务对于当前事务肯定是可见的

* **low_limit_id**：当前最大的事务号 + 1，事务号 >= low_limit_id，对于当前Read View都是不可见的

  创建当前Read View之后创建的事务对于当前事务肯定是不可见的

* **trx_ids**：活跃事务列表，即当前Read View初始化时尚未提交的事务列表。

  当进行RR读的时候，其中的事务是不可见的



## 并发事务处理

### 并发事务处理带来的问题

* 脏读：一个数据对一条记录进行了修改，但未完成提交。而另一个事务读取同一条数据，如果不进行控制，第二个事务读到了未提交的数据（称为脏数据），这种现象就叫做脏读
* 不可重复读：一个事务在读取某些数据后的某个时间，再次读取之前读过的数据，发现该数据进行了改变，这种现象就叫不可重复读（重点是修改）
* 幻读：一个事务按照相同的逻辑重新读取之前检索的数据，却发现其他事务插入了满足要求的新数据，这种现象称为幻读（重点是删除或新增）

### 事务隔离级别

查看当前数据库的隔离级别

```
SELECT @@global.tx_isolation;
```

* 读未提交（Read UnCommitted）：最低的隔离级别。一个事务可以读取另一个事务并未提交的更新结果。
* 读提交（Read Committed）：大部分数据库采用的默认隔离级别。一个事务的更新操作结果只有在该事务提交之后，另一个事务才可以的读取到同一笔数据更新后的结果。
* 可重复读（Repeatable Read）：**mysql的默认级别**。整个事务过程中，对同一笔数据的读取结果是相同的，不管其他事务是否在对共享数据进行更新，也不管更新提交与否。
* 串行化（Serializable）：最高隔离级别。所有事务操作依次顺序执行。注意这会导致并发度下降，性能最差。通常会用其他并发级别加上相应的并发锁机制来取代它。

|          | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| 读未提交 | 是   | 是         | 是   |
| 读提交   | 否   | 是         | 是   |
| 可重复读 | 否   | 否         | 是   |
| 串行化   | 否   | 否         | 否   |

### 隔离级别的实现





## 参考

MVCC：https://zhuanlan.zhihu.com/p/66791480

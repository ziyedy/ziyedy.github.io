{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/3-hexo/source/css/mobile.styl","path":"css/mobile.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/avatar.jpg","path":"img/avatar.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/school-book.png","path":"img/school-book.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/brown-papersq.png","path":"img/brown-papersq.png","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/alipay.jpg","path":"img/alipay.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","path":"img/article-list-background.jpeg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/iconfont.js","path":"js/iconfont.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","path":"js/jquery.autocomplete.min.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","path":"js/jquery.pjax.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/search.js","path":"js/search.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","path":"css/fonts/icomoon.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","path":"css/fonts/icomoon.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","path":"css/fonts/icomoon.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","path":"css/fonts/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","path":"css/fonts/icomoon.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","path":"css/fonts/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","path":"css/fonts/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","path":"css/fonts/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","path":"css/hl_theme/atom-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/fonts/selection.json","path":"css/fonts/selection.json","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","path":"css/hl_theme/atom-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","path":"css/hl_theme/brown-paper.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","path":"css/hl_theme/darcula.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","path":"css/hl_theme/github-gist.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","path":"css/hl_theme/github.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","path":"css/hl_theme/gruvbox-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","path":"css/hl_theme/kimbie-dark.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","path":"css/hl_theme/gruvbox-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","path":"css/hl_theme/railscasts.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","path":"css/hl_theme/kimbie-light.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","path":"css/hl_theme/rainbow.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","path":"css/hl_theme/school-book.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","path":"css/hl_theme/sublime.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/img/weixin.jpg","path":"img/weixin.jpg","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","path":"css/hl_theme/sunburst.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","path":"css/hl_theme/zenbum.styl","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitment.js","path":"js/gitment.js","modified":0,"renderable":1},{"_id":"themes/3-hexo/source/js/gitalk.js","path":"js/gitalk.js","modified":0,"renderable":1}],"Cache":[{"_id":"themes/3-hexo/_config.yml","hash":"653e845f88dcb628e4ef7143804f5882c1de47a5","modified":1586202835610},{"_id":"source/_posts/Anaconda+PyCharm配置PyQt5全过程.md","hash":"301437511a4f924b6e836732df896793d30d05f1","modified":1592143785430},{"_id":"source/_posts/GOT_S8E3.md","hash":"069d870181a38494686e4c7b9dd83302bf088749","modified":1584038464869},{"_id":"source/_posts/Ubuntu环境下anaconda出现的问题及解决方法.md","hash":"da3ddbe4c70b8eb703970ed5f92af238dbfd72e5","modified":1592145287360},{"_id":"source/_posts/Python1.md","hash":"b45266491fdd739823aecde11ff15f2c984bd46f","modified":1589382616568},{"_id":"source/_posts/Hexo博客搭建.md","hash":"34386cbfb5063ef1194969613d02ee9990788d39","modified":1584068031026},{"_id":"source/_posts/Hexo博客部署到腾讯云服务器全流程.md","hash":"ff7504ffbee47b71e24cd352178a75a9da32e451","modified":1584068335458},{"_id":"source/_posts/Hexo实现多台机器同时编写博客.md","hash":"606e79e30d83418726ccf4bbaabbd575a7ed7620","modified":1584082500675},{"_id":"source/_posts/python2.md","hash":"14af947164dff12894ef7b7b98d944b52c43e508","modified":1589382605871},{"_id":"source/_posts/python3.md","hash":"3c2c544392bfd7bd247418bccf0434b89c3f1a8d","modified":1589382590799},{"_id":"source/_posts/python4.md","hash":"d9ef6b63e8f1fd7273c63d52a6a5c7ccf70ef65b","modified":1589382581554},{"_id":"source/_posts/python5.md","hash":"f42b87a2889a1817b28c024c67ed80b09412c9ff","modified":1589526884791},{"_id":"source/_posts/git.md","hash":"12dcd362533b24f4211cc24a42b12182ba1bd0b4","modified":1584038464871},{"_id":"source/_posts/latex.md","hash":"12463db1abc6f2e40fae6b5ee5f6a42448cae248","modified":1584038464871},{"_id":"source/_posts/binary_tree.md","hash":"4093678dc5c0fab640b00780b3ceb318276383b6","modified":1584038464870},{"_id":"source/_posts/全卷积神经网络（FCN）.md","hash":"aab20eac6dec0ce95a84c1e02e4cd19d3c07b239","modified":1592145312006},{"_id":"themes/3-hexo/layout/index.ejs","hash":"99aecf628b29c3345ddf819fe3d26e88788600ea","modified":1584038464884},{"_id":"themes/3-hexo/layout/indexs.md","hash":"be3d8a19030c5c77181baa73435d70d33a97c642","modified":1584451432228},{"_id":"themes/3-hexo/layout/post.ejs","hash":"aeda285031ba8d4e94225e82b364bcf5f79fce1d","modified":1584038464885},{"_id":"source/_posts/务虚时代下的国贼——李鸿章.md","hash":"f625ff598c2f1c6e322754a5ba10714d78cb0541","modified":1584038464872},{"_id":"source/_posts/改变.md","hash":"0791a408e9dea2c503333bb93d33cc9738636244","modified":1584038464872},{"_id":"source/_posts/雨与晴.md","hash":"c913b54e2d544bcb9dfe36afc872b0e08dc47aaa","modified":1584038464873},{"_id":"themes/3-hexo/source/.DS_Store","hash":"fdcc907c46e093a14b153c5dc8c038461997ed3c","modified":1584038464886},{"_id":"source/_img/Anaconda+PyCharm配置PyQt5全过程/2.png","hash":"0a94cea08690fb13fd65a9238d8aff7f13820b1b","modified":1586529731782},{"_id":"source/_img/Anaconda+PyCharm配置PyQt5全过程/3.png","hash":"5166d3ccd52deb50829d029dba95e6b4b8bfd9a6","modified":1586531476526},{"_id":"source/_img/Anaconda+PyCharm配置PyQt5全过程/5.png","hash":"bccf83148c7a43cca22331ee9d02af7bce61f98f","modified":1586532006737},{"_id":"themes/3-hexo/layout/_partial/article.ejs","hash":"0ccec30a2a6799451afe9a213fa5310d1ad06c0d","modified":1584038464874},{"_id":"themes/3-hexo/layout/_partial/article_copyright.ejs","hash":"e46b7a68a5cd417330cca6fb5a5e65855fbed77b","modified":1584038464875},{"_id":"themes/3-hexo/layout/_partial/comment.ejs","hash":"d18f94e04ef0cf7abb432a8e707ccb3abc7fe435","modified":1584038464875},{"_id":"themes/3-hexo/layout/_partial/copyright.ejs","hash":"e42230f8406969d8aba5f02caa7cb090d48cbcee","modified":1586202839209},{"_id":"themes/3-hexo/layout/_partial/dashang.ejs","hash":"c41a62155c416ca7d4bd90a7e2cd0ec06f174ab6","modified":1584038464879},{"_id":"themes/3-hexo/layout/_partial/footer.ejs","hash":"38a0008a4644354752fd21289a4d12e2275b647e","modified":1584083242963},{"_id":"themes/3-hexo/layout/_partial/friends.ejs","hash":"558a3d4bad578819fb07729fe1b50d9b81da8b93","modified":1584038464880},{"_id":"themes/3-hexo/layout/_partial/full-toc.ejs","hash":"38285b8d5272a14bfa4769163c8d569abff4c95f","modified":1584038464880},{"_id":"themes/3-hexo/layout/_partial/header.ejs","hash":"915d5f10dd8f3dcd19cb75010e23689e8f385caf","modified":1584038464880},{"_id":"themes/3-hexo/layout/_partial/mathjax.ejs","hash":"e2be0e37f3d48e63e65a47d819bfb800b9aa3784","modified":1584038464881},{"_id":"themes/3-hexo/layout/_partial/meta.ejs","hash":"ef387e80043b62e1925a068267f2377cac64adc7","modified":1584038464881},{"_id":"themes/3-hexo/layout/_partial/nav-left.ejs","hash":"5ac624e06b325227c6317de7fcaa685e77572233","modified":1584038464882},{"_id":"themes/3-hexo/layout/_partial/tag.ejs","hash":"d4b69b53e15abe71d2abeaff8eefa7695c12f0f6","modified":1584038464883},{"_id":"themes/3-hexo/layout/_partial/nav-right.ejs","hash":"46ad0f737b04a015ff7068933fe3342127cbe8ab","modified":1584038464882},{"_id":"themes/3-hexo/layout/_partial/toc-ref.ejs","hash":"33f7a4bfca1bb9835ec8f0d1e73188d1f56cc8b9","modified":1584038464884},{"_id":"themes/3-hexo/source/css/mobile.styl","hash":"d10bdd736aa343f38fe15cba4c81d45d3d259de4","modified":1584038464906},{"_id":"themes/3-hexo/source/css/style.styl","hash":"322abe325d5fe9ff37347bdd19e772315a8ebfed","modified":1584038464906},{"_id":"themes/3-hexo/source/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1584038464909},{"_id":"themes/3-hexo/source/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1584038464910},{"_id":"themes/3-hexo/source/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1584038464910},{"_id":"themes/3-hexo/source/img/alipay.jpg","hash":"e457d1d3dfefbbd824d154cf756a2c6d10b812a2","modified":1584038464908},{"_id":"themes/3-hexo/source/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1584038464908},{"_id":"themes/3-hexo/source/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1584038464916},{"_id":"themes/3-hexo/source/js/jquery.autocomplete.min.js","hash":"2462169ad7f4a8ae9f9f4063995cbe7fed45cd77","modified":1584038464916},{"_id":"themes/3-hexo/source/js/jquery.pjax.js","hash":"8c2a4f10a4da3d9615a3a81542494c6d21479b3d","modified":1584038464917},{"_id":"themes/3-hexo/source/js/script.js","hash":"14772b08b9c3d5c99a4b54748be9666deaae2778","modified":1584038464918},{"_id":"themes/3-hexo/source/css/gitalk.css","hash":"3dc58e9a3fd63a3144d5fe850eb55e3dc885c9fb","modified":1584038464897},{"_id":"source/_img/Anaconda+PyCharm配置PyQt5全过程/1.png","hash":"4f56e51278d0827b6d4a18654a9710df1847c9b6","modified":1586502734770},{"_id":"source/_img/Anaconda+PyCharm配置PyQt5全过程/6.png","hash":"66cfa20ff8732175ac6af01f6cee02c195b20f8a","modified":1586532523034},{"_id":"themes/3-hexo/layout/_partial/comments/click2show.ejs","hash":"05b09c45b379ffeb4f48c1604044d88829f90799","modified":1584038464876},{"_id":"themes/3-hexo/layout/_partial/comments/disqus.ejs","hash":"32ce7b48d366b9c888ff2ceb911a3cd82f864537","modified":1584038464876},{"_id":"themes/3-hexo/layout/_partial/comments/gentie.ejs","hash":"908d9046502612d24780ca354bd9392a009b4d7b","modified":1584038464877},{"_id":"themes/3-hexo/layout/_partial/comments/gitalk.ejs","hash":"01567e010cf4f2dd141fe2019490d3f0d5aa2529","modified":1584038464877},{"_id":"themes/3-hexo/layout/_partial/comments/gitment.ejs","hash":"eaf2b6f297282606b630ad55fb9e38af7e2829dc","modified":1584038464878},{"_id":"themes/3-hexo/source/css/_partial/autocomplete.styl","hash":"1ffe51e3b77afefcd94d386a718506d5b055ad94","modified":1584038464886},{"_id":"themes/3-hexo/source/css/_partial/comment.styl","hash":"fe00fb1269b4fe1f3d5ab917891926222ce47275","modified":1584038464887},{"_id":"themes/3-hexo/source/css/_partial/dashang.styl","hash":"f0eac1dc1f5dbed1769d032bb5fd5f002faaee26","modified":1584038464887},{"_id":"themes/3-hexo/source/css/_partial/fade.styl","hash":"02c7510a26f306e240f23ddbf772a69be2c890dd","modified":1584038464888},{"_id":"themes/3-hexo/source/css/_partial/font.styl","hash":"c200f3fabcfe83f3e45746e186b4bb111e73ad47","modified":1584038464888},{"_id":"themes/3-hexo/source/css/_partial/full-toc.styl","hash":"4102753dad0cc1ee9ed673f7253ba097a960c3b7","modified":1584038464889},{"_id":"themes/3-hexo/source/css/_partial/nav-left.styl","hash":"bf29eab9ea75fa191d678b6eefec440505ddf6e3","modified":1584038464889},{"_id":"themes/3-hexo/source/css/_partial/nav-right.styl","hash":"1d01247f974b059d9ef6a2178a724b4f72acd659","modified":1584038464890},{"_id":"themes/3-hexo/source/css/_partial/nprogress.styl","hash":"2620a02169a6aeb75137fd368eac2c36423d8498","modified":1584038464890},{"_id":"themes/3-hexo/source/css/_partial/num-load.styl","hash":"f7ef35459ece22e1da950b86126be1c2bfe97fcf","modified":1584038464891},{"_id":"themes/3-hexo/source/css/_partial/post.styl","hash":"1f83fe0bcf229cb64f6ae55f9bcda835dfc4f062","modified":1584038464891},{"_id":"themes/3-hexo/source/js/search.js","hash":"788c610149a5f9361295f9f0207c8523f37ddb8b","modified":1584038464918},{"_id":"themes/3-hexo/source/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1584038464892},{"_id":"themes/3-hexo/source/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1584038464893},{"_id":"themes/3-hexo/source/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1584038464892},{"_id":"themes/3-hexo/source/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1584038464894},{"_id":"themes/3-hexo/source/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1584038464893},{"_id":"themes/3-hexo/source/css/fonts/iconfont.svg","hash":"7e54ae44c02faa319c4fe128e1e6bda38eae5c9d","modified":1584038464895},{"_id":"themes/3-hexo/source/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1584038464895},{"_id":"themes/3-hexo/source/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1584038464896},{"_id":"themes/3-hexo/source/css/hl_theme/atom-dark.styl","hash":"f3eb4e5feda9cbd6242ccf44ca064e2979b5d719","modified":1584038464897},{"_id":"themes/3-hexo/source/css/fonts/selection.json","hash":"b6456a4eabcffd95e822d1d7adce96da524d481a","modified":1584038464896},{"_id":"themes/3-hexo/source/css/hl_theme/atom-light.styl","hash":"69d184a682bcaeba2b180b437dc4431bc3be38aa","modified":1584038464898},{"_id":"themes/3-hexo/source/css/hl_theme/brown-paper.styl","hash":"03af387edcc1cf8c18d12e9c440fd51b6cf425b6","modified":1584038464898},{"_id":"themes/3-hexo/source/css/hl_theme/darcula.styl","hash":"2bfc14f27ccca108b4b3755782de8366e8bd001e","modified":1584038464898},{"_id":"themes/3-hexo/source/css/hl_theme/github-gist.styl","hash":"5e05b19832c1099bd9d284bc3ed00dc8a3d7ee23","modified":1584038464900},{"_id":"themes/3-hexo/source/css/hl_theme/github.styl","hash":"53276ff1f224f691dfe811e82c0af7f4476abf5d","modified":1584038464900},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-dark.styl","hash":"315ad610d303caba9eac80a7d51002193a15478a","modified":1584038464900},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-dark.styl","hash":"e9c190f9ffc37a13cac430512e4e0c760205be4a","modified":1584038464902},{"_id":"themes/3-hexo/source/css/hl_theme/gruvbox-light.styl","hash":"1bece084b1dbbbd4af064f05feffd8c332b96a48","modified":1584038464901},{"_id":"themes/3-hexo/source/css/hl_theme/railscasts.styl","hash":"a6e8cfd2202afd7893f5268f3437421e35066e7b","modified":1584038464902},{"_id":"themes/3-hexo/source/css/hl_theme/kimbie-light.styl","hash":"0c3ccd0d64e7504c7061d246dc32737f502f64e4","modified":1584038464902},{"_id":"themes/3-hexo/source/css/hl_theme/rainbow.styl","hash":"e5c37646a9d9c1094f9aab7a7c65a4b242e8db00","modified":1584038464903},{"_id":"themes/3-hexo/source/css/hl_theme/school-book.styl","hash":"51659351b391a2be5c68728bb51b7ad467c5e0db","modified":1584038464903},{"_id":"themes/3-hexo/source/css/hl_theme/sublime.styl","hash":"501d75ef0f4385bea24d9b9b4cc434ba68d4be27","modified":1584038464904},{"_id":"themes/3-hexo/source/img/weixin.jpg","hash":"8dafb22561698d0758fba9ea2a45abf6ad3512a2","modified":1584038464912},{"_id":"themes/3-hexo/source/css/hl_theme/sunburst.styl","hash":"2aa9817e68fb2ed216781ea04b733039ebe18214","modified":1584038464904},{"_id":"themes/3-hexo/source/css/hl_theme/zenbum.styl","hash":"92941a6ae73b74f44ad7c559c5548c44073c644a","modified":1584038464905},{"_id":"source/_img/Anaconda+PyCharm配置PyQt5全过程/4.png","hash":"ce6bccfa0152967296296e644d655976a5d6abbd","modified":1586531825743},{"_id":"themes/3-hexo/source/js/gitment.js","hash":"67984b83cd46ff4300d4fd959bf6c17dd66b4136","modified":1584038464915},{"_id":"themes/3-hexo/source/js/gitalk.js","hash":"a31e03951c67aa3d5d8814b22a5c927305e80e85","modified":1584038464913},{"_id":"public/page/python5.html","hash":"1310269400635c72f21bf65297bd646670ca7a81","modified":1594915808715},{"_id":"public/page/python4.html","hash":"88e414f8309b16eded19f63e3a5dd9354918f50f","modified":1594915808715},{"_id":"public/page/python3.html","hash":"1bc5db748ccfb14df12014492dda445b55e21c9b","modified":1594915808715},{"_id":"public/page/python2.html","hash":"c0881259c6e7ce8849451913e0b9cdb78b286cef","modified":1594915808715},{"_id":"public/page/python1.html","hash":"ab456fa4215a99ddde3616bc0ca8856dab73ac61","modified":1594915808715},{"_id":"public/page/pyqt1.html","hash":"2142da561f940bb2762e8f411b45b2d84cae8a7e","modified":1594915808715},{"_id":"public/page/FCN.html","hash":"2007fa9b295ce0d8cbb9403caaf5dd9216e493d6","modified":1594915808715},{"_id":"public/page/hexo3.html","hash":"d697ede7079fdc671a69388d4c16e9d2a2edaf2d","modified":1594915808715},{"_id":"public/page/hexo2.html","hash":"dd70ce1dcfea5f7e87cd050a55641cf507032e7d","modified":1594915808715},{"_id":"public/page/hexo1.html","hash":"852747341fbd2796b4abe3b1f3767c586600c726","modified":1594915808715},{"_id":"public/page/Li_Hongzhang.html","hash":"f916d8571bb86075eb8ae1cadfe398b5494aa608","modified":1594915808715},{"_id":"public/page/the_change.html","hash":"981fd7273e209a38021a32b4dc21fa2a094de66d","modified":1594915808715},{"_id":"public/page/GOT_S8E3.html","hash":"beac43c16f87a56482d73466693d8d8a71bd9347","modified":1594915808715},{"_id":"public/page/undefined.html","hash":"453c5050b3f9ddcd5b58c1c9083893370264c0a7","modified":1594915808715},{"_id":"public/page/the_rain_and_the_shine.html","hash":"72f92fd4d76cb644dc13b974fc2f14fd548c572e","modified":1594915808715},{"_id":"public/tags/python/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/GUI/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/剧评/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/hexo/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/云服务器/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/git/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/latex/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/论文/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/二叉树/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/CNN/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/语义分割/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/散文/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/杂文/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/日志/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/page/2/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/page/2/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/2019/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/2019/02/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/2019/03/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/2019/04/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/2019/05/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/2020/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/2020/page/2/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/2020/03/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/2020/05/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/2020/04/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/Python/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/随笔/index.html","hash":"baee4afb49832b7bc31d2d4938973314d2298491","modified":1594891824173},{"_id":"public/categories/记录/index.html","hash":"baee4afb49832b7bc31d2d4938973314d2298491","modified":1594891824173},{"_id":"public/categories/Python/PyQt5/index.html","hash":"baee4afb49832b7bc31d2d4938973314d2298491","modified":1594891824173},{"_id":"public/categories/Python/基础知识/index.html","hash":"baee4afb49832b7bc31d2d4938973314d2298491","modified":1594891824173},{"_id":"public/categories/随笔/剧评/index.html","hash":"baee4afb49832b7bc31d2d4938973314d2298491","modified":1594891824173},{"_id":"public/categories/命令/index.html","hash":"387b4026ba5e25d11298072c0ca7b51a189466cb","modified":1592140177289},{"_id":"public/categories/记录/hexo/index.html","hash":"baee4afb49832b7bc31d2d4938973314d2298491","modified":1594891824173},{"_id":"public/categories/笔记/index.html","hash":"baee4afb49832b7bc31d2d4938973314d2298491","modified":1594891824173},{"_id":"public/categories/论文笔记/index.html","hash":"baee4afb49832b7bc31d2d4938973314d2298491","modified":1594891824173},{"_id":"public/categories/命令/git/index.html","hash":"387b4026ba5e25d11298072c0ca7b51a189466cb","modified":1592140177289},{"_id":"public/categories/命令/其它/index.html","hash":"387b4026ba5e25d11298072c0ca7b51a189466cb","modified":1592140177289},{"_id":"public/categories/随笔/散文/index.html","hash":"baee4afb49832b7bc31d2d4938973314d2298491","modified":1594891824173},{"_id":"public/categories/随笔/杂文/index.html","hash":"baee4afb49832b7bc31d2d4938973314d2298491","modified":1594891824173},{"_id":"public/img/avatar.jpg","hash":"a42360089bfa892d803cf5747eab359d90f337f1","modified":1589382724042},{"_id":"public/img/school-book.png","hash":"711ec983c874e093bb89eb77afcbdf6741fa61ee","modified":1589382724042},{"_id":"public/img/brown-papersq.png","hash":"3a1332ede3a75a3d24f60b6ed69035b72da5e182","modified":1589382724042},{"_id":"public/img/article-list-background.jpeg","hash":"4fdf8b3e53dd02d6ee6360aebfadb0cba1fb5633","modified":1589382724042},{"_id":"public/img/alipay.jpg","hash":"e457d1d3dfefbbd824d154cf756a2c6d10b812a2","modified":1589382724042},{"_id":"public/css/fonts/icomoon.eot","hash":"b6195bedc1cb2f9cfcb26cc27021f2e94be2ab0a","modified":1589382724042},{"_id":"public/css/fonts/icomoon.ttf","hash":"eb976d8b8559fcddfc2658a03a4350cb566fc06b","modified":1589382724042},{"_id":"public/css/fonts/icomoon.svg","hash":"b5e7562c8494b0ddb3a70ecc5545ef7340d8e971","modified":1589382724042},{"_id":"public/css/fonts/iconfont.eot","hash":"3dfe8e557d9dfaf39bca088a02b76deb82dbaa3d","modified":1589382724042},{"_id":"public/css/fonts/icomoon.woff","hash":"3985d29416bb9b19f50a2f20f2bbbce47f10af8d","modified":1589382724042},{"_id":"public/css/fonts/iconfont.ttf","hash":"aa087561480fb9c2cfd541e33d1e99d5ac1a56bb","modified":1589382724042},{"_id":"public/css/fonts/iconfont.svg","hash":"7e54ae44c02faa319c4fe128e1e6bda38eae5c9d","modified":1589382724042},{"_id":"public/css/fonts/iconfont.woff","hash":"f8ed131ccf13f4bdd3ec11fc3e997339dd7b66ba","modified":1589382724042},{"_id":"public/css/mobile.css","hash":"79ab291be160e0ca753512a96c5198f7477f13be","modified":1589382724042},{"_id":"public/js/jquery.autocomplete.min.js","hash":"7b8ac4d06c9e763963832529f44a56ad42a81e5f","modified":1589382724042},{"_id":"public/js/search.js","hash":"c80c9a231ee040c7adc07a477793873fb85ce8bc","modified":1589382724042},{"_id":"public/css/hl_theme/atom-dark.css","hash":"88d11052a24e8100af6248eb4dbe1ce7b0e96408","modified":1589382724042},{"_id":"public/css/hl_theme/atom-light.css","hash":"a3c8f3ee9a655594eff7ac545cb2e6914c1abcc2","modified":1589382724042},{"_id":"public/css/hl_theme/brown-paper.css","hash":"500c8e750373f6656ff49a7857c871ceedcf8777","modified":1589382724042},{"_id":"public/css/hl_theme/darcula.css","hash":"4341074bae4bc9f0b86e32b623e27babc0159b6e","modified":1589382724042},{"_id":"public/css/hl_theme/github-gist.css","hash":"7a41c1c479d09df875f99f1f6d94aac42e9e2ad0","modified":1589382724042},{"_id":"public/css/hl_theme/kimbie-dark.css","hash":"728527fcc308da454722c119b89e6da3025bd1e3","modified":1589382724042},{"_id":"public/css/hl_theme/github.css","hash":"e05a0806a508a26b9f3f3794b6b588ec6504ad3f","modified":1589382724042},{"_id":"public/css/hl_theme/railscasts.css","hash":"511f2fd2a84d426e5da5cb17880cc08f73beb002","modified":1589382724042},{"_id":"public/css/hl_theme/gruvbox-dark.css","hash":"8c440d9b4ee19ac03eaee3c6af78ba52e5ba5535","modified":1589382724042},{"_id":"public/css/hl_theme/rainbow.css","hash":"7ff4251938076ddb7e4e49413db82653e5b61321","modified":1589382724042},{"_id":"public/css/hl_theme/gruvbox-light.css","hash":"30514aaa242a34647aa666cfca4fc74c595ea8f2","modified":1589382724042},{"_id":"public/css/hl_theme/kimbie-light.css","hash":"0c61926c989163faefb031d27bce3e287d6e10f2","modified":1589382724042},{"_id":"public/css/hl_theme/school-book.css","hash":"ffbbcd13a74ac2404262c50b7a43053dfd0096ff","modified":1589382724042},{"_id":"public/css/hl_theme/sunburst.css","hash":"8a135abac1512cf430d1d1ad2304b79afa1a4d6e","modified":1589382724042},{"_id":"public/css/hl_theme/sublime.css","hash":"f65c5b116d9213afb9c324384a2f3bc86cb71121","modified":1589382724042},{"_id":"public/css/hl_theme/zenbum.css","hash":"0a78f74a93568e20b32ca7427c719e9bae9a0b55","modified":1589382724042},{"_id":"public/css/style.css","hash":"fc4b532e837d1177f0cb6957985bdf07c708c9d7","modified":1589382724042},{"_id":"public/js/iconfont.js","hash":"3a0869ca1b09af07d82987e343a3bc4cb9558ecb","modified":1589382724042},{"_id":"public/js/jquery.pjax.js","hash":"191c49fdb40dff115a49cfd2b30dffb888d86550","modified":1589382724042},{"_id":"public/css/gitalk.css","hash":"58177ce227c50ee359fbf99a4fdd26058887afc5","modified":1589382724042},{"_id":"public/js/script.js","hash":"7502191e29366a11323dc72ae365b1aed254e6f2","modified":1589382724042},{"_id":"public/css/fonts/selection.json","hash":"047b615ea32dc48dae5b964061427d41feaaafdf","modified":1589382724042},{"_id":"public/js/gitment.js","hash":"59a1e03f2b0ce61dd9bd405d3c52d3e07cc10dec","modified":1589382724042},{"_id":"public/js/gitalk.js","hash":"00419a6156f5d4f9b8aba00d446cd64ba73e0d12","modified":1589382724042},{"_id":"public/img/weixin.jpg","hash":"8dafb22561698d0758fba9ea2a45abf6ad3512a2","modified":1589382724042},{"_id":"source/_posts/pygame基础.md","hash":"c9b6009409d623ef285597530931fba48887bd63","modified":1592144672681},{"_id":"source/_posts/python6.md","hash":"0df56ee5abbe35967dfea4890bdd591b6d1342db","modified":1589538245596},{"_id":"source/_posts/post-1.md","hash":"043e062e7a5df80fc0481793305e5f63a56c7e78","modified":1592231706827},{"_id":"public/page/null.html","hash":"ee6588eb3539b66b5a10ce0058bd41d66ccb53dc","modified":1592140177289},{"_id":"public/page/pygame1.html","hash":"fd04cd91518ded292bf8359f4dae82078939b997","modified":1594915808715},{"_id":"public/page/python6.html","hash":"d7c85d9084d829f2be2216254a3e7dcfe2bc69be","modified":1594915808715},{"_id":"public/categories/Python/pygame/index.html","hash":"baee4afb49832b7bc31d2d4938973314d2298491","modified":1594891824173},{"_id":"public/tags/pygame/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"source/_posts/1、Python基本数据类型.md","hash":"af08e2679f0525a3304cc75b07242d6f95e7f156","modified":1592670882094},{"_id":"source/_posts/2、Python函数相关内容.md","hash":"a6dfef3bf6708baddec4be20592bbb948bf538c5","modified":1592379810026},{"_id":"source/_posts/1、JS内置对象.md","hash":"482d45331dc5fc89e4289ab10ca72316cb0a6cba","modified":1592143839189},{"_id":"source/_posts/3、Python类的使用.md","hash":"72a3aa53999a375096dae03af7ea54a254ff7dd5","modified":1592322012141},{"_id":"source/_posts/5、Python装饰器、迭代器、生成器.md","hash":"41b2fac9cee3b04b8f491aa40894f892a36bd712","modified":1592741978589},{"_id":"source/_posts/4、Python文件读写.md","hash":"fc9d2eb023276eed0fd0fee42f2b368ebb6f242d","modified":1592122371740},{"_id":"source/_posts/7、Python的线程与进程.md","hash":"10272de686f741d14dc008cff3155769f773857b","modified":1592550494822},{"_id":"source/_posts/6、Python异常处理.md","hash":"4ac8e9ea0a16bc52c5f48cda4f94ad165897bdc7","modified":1592742377393},{"_id":"source/_posts/SQL的一些机制.md","hash":"a0db553da9f9e2a64508857e988f908e6490d932","modified":1592321294867},{"_id":"source/_posts/SQL查询语句.md","hash":"2358dad929c5eb8a5a87a5e9e7ddee76ae697937","modified":1592841474496},{"_id":"source/_posts/post-4.md","hash":"0533571b3ec5912f56995565d38a5f196dc1a279","modified":1592107471747},{"_id":"source/_posts/SQL的增删改等语句.md","hash":"ba3cb3ead76c89c800dbd15e992685937fd584c1","modified":1592145256917},{"_id":"source/_posts/Anaconda+PyCharm配置PyQt5全过程/2.png","hash":"0a94cea08690fb13fd65a9238d8aff7f13820b1b","modified":1586529731782},{"_id":"source/_posts/Anaconda+PyCharm配置PyQt5全过程/5.png","hash":"bccf83148c7a43cca22331ee9d02af7bce61f98f","modified":1586532006737},{"_id":"source/_posts/Anaconda+PyCharm配置PyQt5全过程/1.png","hash":"4f56e51278d0827b6d4a18654a9710df1847c9b6","modified":1586502734770},{"_id":"source/_posts/Anaconda+PyCharm配置PyQt5全过程/3.png","hash":"5166d3ccd52deb50829d029dba95e6b4b8bfd9a6","modified":1586531476526},{"_id":"source/_posts/Anaconda+PyCharm配置PyQt5全过程/6.png","hash":"66cfa20ff8732175ac6af01f6cee02c195b20f8a","modified":1586532523034},{"_id":"source/_posts/Anaconda+PyCharm配置PyQt5全过程/4.png","hash":"ce6bccfa0152967296296e644d655976a5d6abbd","modified":1586531825743},{"_id":"public/page/mysql1.html","hash":"333fc7d1be6c414275efb9c1f5467283325321ad","modified":1594915808715},{"_id":"public/page/javascript1.html","hash":"747d30dfd1f5d70aa7861c93ba35a59f4b3a100d","modified":1594915808715},{"_id":"public/page/python7.html","hash":"a93187d4babedcee1c13f83b94f070d0be13b9e6","modified":1594915808715},{"_id":"public/archives/page/3/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/2020/06/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/数据库/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/数据库/MySQL/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/page/3/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"source/_posts/OSM数据基本操作.md","hash":"12f04991a934aac773793b29cdd191c446a545fd","modified":1592144985605},{"_id":"source/_posts/The Long Night（权力的游戏 S8E3）.md","hash":"c06c1304b719b7c9b10d30a82c974dd944d5b3a3","modified":1592144561466},{"_id":"source/_posts/git的基本命令.md","hash":"4d310a201799c37821e46b83dac4970194d85ce2","modified":1592144946518},{"_id":"source/_posts/latex基本用法.md","hash":"7dda6567e3e04b333fd563da60b1fb88607d016c","modified":1592144968048},{"_id":"source/_posts/对一个文件夹下的图像进行整体操作.md","hash":"89e86b99fb12dc951b288b34315a54a9f5ec2acf","modified":1592144604272},{"_id":"source/_posts/ArcGIS二次开发基础配置说明.md","hash":"1d50d46518f0be5de5fba8ebeeccbe1aa9d877f7","modified":1592145383581},{"_id":"source/_posts/OSM数据基本操作/arcgis1.png","hash":"e3808258688cbeffd7482d120bf0b98a8172f316","modified":1551453053000},{"_id":"source/_posts/OSM数据基本操作/arcgis.png","hash":"21dd6171bbd029c84f33160cbcd6941013648b8b","modified":1551450752000},{"_id":"source/_posts/OSM数据基本操作/exports.png","hash":"a7bd175ee130c82a90cd07c4dbda7a4abaa524e7","modified":1551429262000},{"_id":"source/_posts/OSM数据基本操作/query.png","hash":"31aeea6ca656b8d2a5331152d1275b72b45e3b2a","modified":1551542454000},{"_id":"source/_posts/OSM数据基本操作/code.png","hash":"a08dec8ce934b8398519907bf00c7356f90c1108","modified":1551429161000},{"_id":"source/_posts/OSM数据基本操作/map1.png","hash":"6bb2310d4978db7a07c63c14aad36d1c1a459f35","modified":1551429128000},{"_id":"source/_posts/OSM数据基本操作/total.jpg","hash":"9e39109b0fee71afc4669db0d5bea3e4590ac69a","modified":1551430760000},{"_id":"public/tags/Python/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/page/mysql2.html","hash":"1887c4f442f7c066dae3be7b42f77afc9a7eb4fc","modified":1594915808715},{"_id":"public/page/mysql3.html","hash":"749f0a7f12d073902fc990fa47e20173e4a3c97f","modified":1594915808715},{"_id":"public/page/ubuntu_anaconda_problem.html","hash":"20a3f1a61bea1b1735788c995f5d93adc39d949c","modified":1594915808715},{"_id":"public/page/ArcGIS_dev.html","hash":"20c76e25ae642c69cf2ab447c358dd1513618a7e","modified":1594915808715},{"_id":"public/page/git1.html","hash":"2e6daa6ed27b8520769908df206922299f68cd52","modified":1594915808715},{"_id":"public/page/osm_data_process.html","hash":"39503a7126c3e909def2807b5eba96e1f183954c","modified":1594915808715},{"_id":"public/page/batch_RS.html","hash":"d35739d29c6a9df8eadff9b9c6e0cd9ee6209187","modified":1594915808715},{"_id":"public/page/latex1.html","hash":"ac0a8063c749f9d13190af73e50648ca0aca353c","modified":1594915808715},{"_id":"public/tags/matlab/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/图像/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/前端/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/ArcGIS/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/GIS/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/数据库/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/问题解决/index.html","hash":"baee4afb49832b7bc31d2d4938973314d2298491","modified":1594891824173},{"_id":"public/categories/前端/JS/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/前端/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/GIS/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/常用命令/index.html","hash":"baee4afb49832b7bc31d2d4938973314d2298491","modified":1594891824173},{"_id":"public/categories/常用命令/latex/index.html","hash":"baee4afb49832b7bc31d2d4938973314d2298491","modified":1594891824173},{"_id":"public/categories/常用命令/git/index.html","hash":"baee4afb49832b7bc31d2d4938973314d2298491","modified":1594891824173},{"_id":"public/page/pyqt1/2.png","hash":"0a94cea08690fb13fd65a9238d8aff7f13820b1b","modified":1592145533127},{"_id":"public/page/pyqt1/3.png","hash":"5166d3ccd52deb50829d029dba95e6b4b8bfd9a6","modified":1592145533127},{"_id":"public/page/pyqt1/5.png","hash":"bccf83148c7a43cca22331ee9d02af7bce61f98f","modified":1592145533127},{"_id":"public/page/osm_data_process/arcgis.png","hash":"21dd6171bbd029c84f33160cbcd6941013648b8b","modified":1592145533127},{"_id":"public/page/osm_data_process/code.png","hash":"a08dec8ce934b8398519907bf00c7356f90c1108","modified":1592145533127},{"_id":"public/page/osm_data_process/arcgis1.png","hash":"e3808258688cbeffd7482d120bf0b98a8172f316","modified":1592145533127},{"_id":"public/page/osm_data_process/exports.png","hash":"a7bd175ee130c82a90cd07c4dbda7a4abaa524e7","modified":1592145533127},{"_id":"public/page/osm_data_process/query.png","hash":"31aeea6ca656b8d2a5331152d1275b72b45e3b2a","modified":1592145533127},{"_id":"public/page/pyqt1/1.png","hash":"4f56e51278d0827b6d4a18654a9710df1847c9b6","modified":1592145533127},{"_id":"public/page/pyqt1/6.png","hash":"66cfa20ff8732175ac6af01f6cee02c195b20f8a","modified":1592145533127},{"_id":"public/page/pyqt1/4.png","hash":"ce6bccfa0152967296296e644d655976a5d6abbd","modified":1592145533127},{"_id":"public/page/osm_data_process/map1.png","hash":"6bb2310d4978db7a07c63c14aad36d1c1a459f35","modified":1592145533127},{"_id":"public/page/osm_data_process/total.jpg","hash":"9e39109b0fee71afc4669db0d5bea3e4590ac69a","modified":1592145533127},{"_id":"source/_posts/post-2.md","hash":"483ba4b0ae730fab047ace916bcabec05337bb7c","modified":1592235525690},{"_id":"source/_posts/post.md","hash":"c323ab696d4fb757d2daaa6cdd61560d2ac5a301","modified":1592733902195},{"_id":"source/_posts/8、Python的一些语言特性与机制.md","hash":"f75b6b4dfc114ab29ce373529ca5f34c856fdccb","modified":1592550352828},{"_id":"source/_posts/4、Python模块与文件读写.md","hash":"2a1f81e52dadd834b295fead7aee2423234d468e","modified":1592741331676},{"_id":"source/_posts/Git出现的报错合集.md","hash":"a04f0373269dfc705213c54a306abbff7549b879","modified":1592550466651},{"_id":"source/_posts/1、JS内置对象与基本语法.md","hash":"9e72b24fcb3fae34fcb3803b56221a9408939d16","modified":1592724768100},{"_id":"source/_posts/post-3.md","hash":"6e4416b48b18e967c5fbb9a2fddef49da65c28c9","modified":1592557740482},{"_id":"source/_posts/Python中os模块的常用操作.md","hash":"fe16b8c1878972f895f7bfe4f19f4e4bdb76b1b4","modified":1592711827892},{"_id":"source/_posts/Python操作MySQL数据库.md","hash":"90ca4309f2c8f6d32a3ac5051eb318f86f21666e","modified":1592550394510},{"_id":"source/_posts/post/1.png","hash":"081c5150174c0bce7f3abfb1e072b08a9eb28193","modified":1592723057538},{"_id":"source/_posts/SQL查询语句/sql连接.png","hash":"06d5f913bbcbd15859036903c9593214dc8d1eec","modified":1592839741850},{"_id":"public/page/javascript2.html","hash":"1ecbd0751269792068b637205d0bbacdfe6ae23b","modified":1594915808715},{"_id":"public/page/Python_os1.html","hash":"295952ff1e3c2193481c785563806d5f66695984","modified":1594915808715},{"_id":"public/page/python_mysql.html","hash":"354f69bf7a4f61fb833dfcaf4cedc411b3e0dcda","modified":1594915808715},{"_id":"public/page/django1.html","hash":"401634b5effabc7126644f765984acb9d0166413","modified":1594915808715},{"_id":"public/page/python8.html","hash":"0a95d6786748a96a8d2f6c33ddb879090a7095c6","modified":1594915808715},{"_id":"public/page/git_error.html","hash":"06062575e3bdb6ec7fa653d7955dfafe95d5e125","modified":1594915808715},{"_id":"public/archives/page/4/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/2020/page/3/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/Python/page/2/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/问题处理/index.html","hash":"baee4afb49832b7bc31d2d4938973314d2298491","modified":1594891824173},{"_id":"public/categories/Python/Django/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/page/4/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/page/javascript2/1.png","hash":"081c5150174c0bce7f3abfb1e072b08a9eb28193","modified":1592893030442},{"_id":"public/page/mysql2/sql连接.png","hash":"06d5f913bbcbd15859036903c9593214dc8d1eec","modified":1592893030442},{"_id":"source/_posts/1、Django基础内容.md","hash":"dadaa7038ceb4d557877fd0eda7ea51fde50bb3c","modified":1593616974994},{"_id":"source/_posts/2、DOM节点操作.md","hash":"1f712b4e89648e8e385426b47cef62fad5c7aecf","modified":1594891196097},{"_id":"source/_posts/1、Java语言基础.md","hash":"019c76fe5bbbd91cfd92a9b7190155f9a2ad4a57","modified":1594891144429},{"_id":"source/_posts/1、数组.md","hash":"18b73ba196708c90ffdb05fddebc53ed4675a78e","modified":1594891181682},{"_id":"source/_posts/2、Java中的类与接口.md","hash":"743f8582d93c6ff74170766790470c51e1857a8c","modified":1594891209715},{"_id":"source/_posts/2、栈和队列.md","hash":"9bd8d208568d749999e4f76f8cc61e91d0531e9c","modified":1594891242511},{"_id":"source/_posts/4、Java多线程.md","hash":"8bbd9de4d297b6c842c0e7841a9a26417ee0668f","modified":1594891272160},{"_id":"source/_posts/3、Java中的常用容器与方法.md","hash":"a261b0a370fa988a8febc4b7f961ba8b27ef9845","modified":1594891251979},{"_id":"source/_posts/Java父类引用指向子类对象.md","hash":"4d235588c8018e77b9b598503e5fdf85868e59ed","modified":1594891297867},{"_id":"source/_posts/SQL语句——查.md","hash":"1eb35f7814c34fdaf2b2283e060737184198eb18","modified":1593414629612},{"_id":"source/_posts/队列.md","hash":"f161164b991710eec7c43105cf55932d4a685e4e","modified":1594891342110},{"_id":"source/_posts/Python/1、Python基本数据类型.md","hash":"af08e2679f0525a3304cc75b07242d6f95e7f156","modified":1592670882094},{"_id":"source/_posts/Python/3、Python类的使用.md","hash":"72a3aa53999a375096dae03af7ea54a254ff7dd5","modified":1592322012141},{"_id":"source/_posts/Python/4、Python模块与文件读写.md","hash":"2a1f81e52dadd834b295fead7aee2423234d468e","modified":1592741331676},{"_id":"source/_posts/Python/2、Python函数相关内容.md","hash":"a6dfef3bf6708baddec4be20592bbb948bf538c5","modified":1592379810026},{"_id":"source/_posts/Python/8、Python的一些语言特性与机制.md","hash":"f75b6b4dfc114ab29ce373529ca5f34c856fdccb","modified":1592550352828},{"_id":"source/_posts/Python/5、Python装饰器、迭代器、生成器.md","hash":"41b2fac9cee3b04b8f491aa40894f892a36bd712","modified":1592741978589},{"_id":"source/_posts/Python/6、Python异常处理.md","hash":"4ac8e9ea0a16bc52c5f48cda4f94ad165897bdc7","modified":1592742377393},{"_id":"source/_posts/Python/7、Python的线程与进程.md","hash":"10272de686f741d14dc008cff3155769f773857b","modified":1592550494822},{"_id":"source/_posts/Python/pythonic的编码方式.md","hash":"72c2add84e5782331bb1c76789dcf2f3a1a4fa1c","modified":1594569698092},{"_id":"source/_posts/Python/Python中os模块的常用操作.md","hash":"fe16b8c1878972f895f7bfe4f19f4e4bdb76b1b4","modified":1592711827892},{"_id":"source/_posts/Python/pygame基础.md","hash":"c9b6009409d623ef285597530931fba48887bd63","modified":1592144672681},{"_id":"source/_posts/Python/Python操作MySQL数据库.md","hash":"90ca4309f2c8f6d32a3ac5051eb318f86f21666e","modified":1592550394510},{"_id":"source/_posts/Python/python常见问题.md","hash":"91f654af716b5c7cd79e8db8931e232e320cad53","modified":1593165138187},{"_id":"source/_posts/SQL语句——查/sql连接.png","hash":"06d5f913bbcbd15859036903c9593214dc8d1eec","modified":1592839741850},{"_id":"source/_posts/Python/1、Django基础内容.md","hash":"844c3b72a9e5a096dd7888044c5bb8a9c2e43023","modified":1594891816026},{"_id":"source/_posts/Python/Anaconda+PyCharm配置PyQt5全过程.md","hash":"301437511a4f924b6e836732df896793d30d05f1","modified":1592143785430},{"_id":"source/_posts/Python/Anaconda+PyCharm配置PyQt5全过程/2.png","hash":"0a94cea08690fb13fd65a9238d8aff7f13820b1b","modified":1586529731782},{"_id":"source/_posts/Python/Anaconda+PyCharm配置PyQt5全过程/3.png","hash":"5166d3ccd52deb50829d029dba95e6b4b8bfd9a6","modified":1586531476526},{"_id":"source/_posts/Python/Anaconda+PyCharm配置PyQt5全过程/5.png","hash":"bccf83148c7a43cca22331ee9d02af7bce61f98f","modified":1586532006737},{"_id":"source/_posts/Python/Anaconda+PyCharm配置PyQt5全过程/1.png","hash":"4f56e51278d0827b6d4a18654a9710df1847c9b6","modified":1586502734770},{"_id":"source/_posts/Python/Anaconda+PyCharm配置PyQt5全过程/6.png","hash":"66cfa20ff8732175ac6af01f6cee02c195b20f8a","modified":1586532523034},{"_id":"source/_posts/Python/Anaconda+PyCharm配置PyQt5全过程/4.png","hash":"ce6bccfa0152967296296e644d655976a5d6abbd","modified":1586531825743},{"_id":"public/page/dssss.html","hash":"aea756bfac36a0d33eb2d9933cfe56f3813ceb89","modified":1594915808715},{"_id":"public/page/java4.html","hash":"de0ba4c9fdda7be060551fdb960de271afe6a312","modified":1594915808715},{"_id":"public/page/java3.html","hash":"e2d1f6edef28e2312715c3efc0a36cc3f2457fce","modified":1594915808715},{"_id":"public/page/java_polymorphic.html","hash":"cbd595366ee525e23c2af030d7b415337f6821b2","modified":1594915808715},{"_id":"public/page/ds-array.html","hash":"e6b0164c6e2a35f9c431d0316984f07311c8c529","modified":1594915808715},{"_id":"public/page/ds.html","hash":"4ffd8cd4b47e70fa35d48db67307d366516a0d24","modified":1594915808715},{"_id":"public/page/java2.html","hash":"cf3cf7f90eb7fc749d3b383ec2d5b9d53d383353","modified":1594915808715},{"_id":"public/page/pythonic.html","hash":"6ae89866c61c7cc19d16b9fffdbfd14cb13bd4a0","modified":1594915808715},{"_id":"public/page/python_method.html","hash":"7abba0cbc1711924ef61d308d6781b91862a51d7","modified":1594915808715},{"_id":"public/page/java1.html","hash":"ed2dc4c3cc605cb1783d101cea9b5ee89ef39bdc","modified":1594915808715},{"_id":"public/page/5/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/Java/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/tags/数据结构/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/page/5/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/2020/page/4/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/2020/06/page/2/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/2020/07/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/Java/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/Java/基础知识/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/数据结构/index.html","hash":"baee4afb49832b7bc31d2d4938973314d2298491","modified":1594891824173},{"_id":"source/_posts/数据库/SQL语句——查/sql连接.png","hash":"06d5f913bbcbd15859036903c9593214dc8d1eec","modified":1592839741850},{"_id":"source/_posts/GIS/OSM数据基本操作/arcgis.png","hash":"21dd6171bbd029c84f33160cbcd6941013648b8b","modified":1551450752000},{"_id":"source/_posts/GIS/OSM数据基本操作/code.png","hash":"a08dec8ce934b8398519907bf00c7356f90c1108","modified":1551429161000},{"_id":"source/_posts/GIS/OSM数据基本操作/exports.png","hash":"a7bd175ee130c82a90cd07c4dbda7a4abaa524e7","modified":1551429262000},{"_id":"source/_posts/GIS/OSM数据基本操作/query.png","hash":"31aeea6ca656b8d2a5331152d1275b72b45e3b2a","modified":1551542454000},{"_id":"source/_posts/GIS/OSM数据基本操作/arcgis1.png","hash":"e3808258688cbeffd7482d120bf0b98a8172f316","modified":1551453053000},{"_id":"source/_posts/GIS/OSM数据基本操作/map1.png","hash":"6bb2310d4978db7a07c63c14aad36d1c1a459f35","modified":1551429128000},{"_id":"source/_posts/GIS/OSM数据基本操作/total.jpg","hash":"9e39109b0fee71afc4669db0d5bea3e4590ac69a","modified":1551430760000},{"_id":"source/_posts/计算机基础/数据结构/1、数组.md","hash":"18b73ba196708c90ffdb05fddebc53ed4675a78e","modified":1594891181682},{"_id":"source/_posts/计算机基础/数据结构/2、栈和队列.md","hash":"9bd8d208568d749999e4f76f8cc61e91d0531e9c","modified":1594891242511},{"_id":"source/_posts/计算机基础/数据结构/队列.md","hash":"f161164b991710eec7c43105cf55932d4a685e4e","modified":1594891342110},{"_id":"source/_posts/其他/Git出现的报错合集.md","hash":"a04f0373269dfc705213c54a306abbff7549b879","modified":1592550466651},{"_id":"source/_posts/其他/Ubuntu环境下anaconda出现的问题及解决方法.md","hash":"da3ddbe4c70b8eb703970ed5f92af238dbfd72e5","modified":1592145287360},{"_id":"source/_posts/其他/git的基本命令.md","hash":"4d310a201799c37821e46b83dac4970194d85ce2","modified":1592144946518},{"_id":"source/_posts/其他/latex基本用法.md","hash":"7dda6567e3e04b333fd563da60b1fb88607d016c","modified":1592144968048},{"_id":"source/_posts/笔记/论文/全卷积神经网络（FCN）.md","hash":"2c101515ccb43d90b7369cb11a8f6ddb51507de3","modified":1594915127901},{"_id":"source/_posts/GIS/OSM数据基本操作.md","hash":"12f04991a934aac773793b29cdd191c446a545fd","modified":1592144985605},{"_id":"source/_posts/GIS/ArcGIS二次开发基础配置说明.md","hash":"1d50d46518f0be5de5fba8ebeeccbe1aa9d877f7","modified":1592145383581},{"_id":"source/_posts/GIS/对一个文件夹下的图像进行整体操作.md","hash":"6badbcf23fb9504b6fc4880b2918b37f141e9414","modified":1594915658333},{"_id":"source/_posts/刷题/binary_tree.md","hash":"8579b05c2a11363a510b2e932cd3ba25c0e1a143","modified":1594914828080},{"_id":"source/_posts/Java/语言基础/1、Java语言基础.md","hash":"6bf69e3097bd18dc6f99c1cbac4854d664f4d34c","modified":1594915579597},{"_id":"source/_posts/Java/语言基础/2、Java中的类与接口.md","hash":"995d3ebd2e9c7635190bf05dd46a0ace2a898615","modified":1594915588483},{"_id":"source/_posts/Java/语言基础/3、Java中的常用容器与方法.md","hash":"f9d8358fce04f62bd95ea46019c6b9d73c189451","modified":1594915595916},{"_id":"source/_posts/Java/语言基础/4、Java多线程.md","hash":"1338a64cde6df4054d1cef3af20de1c1726f65a7","modified":1594915609158},{"_id":"source/_posts/Java/语言基础/Java父类引用指向子类对象.md","hash":"e5b0111d5f3a4113b80a15ee09f376624cecf010","modified":1594915618026},{"_id":"source/_posts/Python/Django/1、Django基础内容.md","hash":"844c3b72a9e5a096dd7888044c5bb8a9c2e43023","modified":1594891816026},{"_id":"source/_posts/Python/GUI/Anaconda+PyCharm配置PyQt5全过程.md","hash":"3b0c5ac929c0e0280caba35c6a02a0a56994d46c","modified":1594915339585},{"_id":"source/_posts/Python/其他/python常见问题.md","hash":"91f654af716b5c7cd79e8db8931e232e320cad53","modified":1593165138187},{"_id":"source/_posts/Python/数据库/Python操作MySQL数据库.md","hash":"eaf32c1ce12b00e14811f1d8e50a4b526faec118","modified":1594915358453},{"_id":"source/_posts/Python/游戏/pygame基础.md","hash":"d487dc4cf446c40487f64571b48c1451fba57f85","modified":1594915394499},{"_id":"source/_posts/Python/语言基础/1、Python基本数据类型.md","hash":"c3baaac1690c018e8cb3372acbccaa65fa5513eb","modified":1594915427803},{"_id":"source/_posts/Python/语言基础/2、Python函数相关内容.md","hash":"749acee997ce9d8b3e2ea4540cf96376e4ab1e06","modified":1594915437441},{"_id":"source/_posts/Python/语言基础/3、Python类的使用.md","hash":"515f61d49d742d6f7e8ec8cb959d5960404dc5c1","modified":1594915443669},{"_id":"source/_posts/Python/语言基础/4、Python模块与文件读写.md","hash":"316cbeca4dfc0e0cc0cc467b9061b378d3df79b3","modified":1594915449790},{"_id":"source/_posts/Python/语言基础/5、Python装饰器、迭代器、生成器.md","hash":"50bbfa14f892a19065aa5e9a5cf981d8e6b36eb5","modified":1594915458441},{"_id":"source/_posts/Python/语言基础/6、Python异常处理.md","hash":"d1c8b7f923b92795b3a636f7aa02651cbe70cad7","modified":1594915465054},{"_id":"source/_posts/Python/语言基础/7、Python的线程与进程.md","hash":"1f95fb7161307287fcc83b5670cd0e75e99af0cd","modified":1594915505555},{"_id":"source/_posts/Python/语言基础/8、Python的一些语言特性与机制.md","hash":"790016970859dd9566a02c2126d5855b9bb816cc","modified":1594915516616},{"_id":"source/_posts/Python/语言基础/Python中os模块的常用操作.md","hash":"b6a1c90494fe4ba4288d86b017431419d89d5206","modified":1594915545601},{"_id":"source/_posts/Python/语言基础/pythonic的编码方式.md","hash":"a05fa44a2afd6ecae475b2122b418e6746ab2518","modified":1594915534593},{"_id":"source/_posts/其他/debug/Git出现的报错合集.md","hash":"2b30449e51366bfb444c364341e91d053bfc1ae3","modified":1594914963972},{"_id":"source/_posts/其他/debug/Ubuntu环境下anaconda出现的问题及解决方法.md","hash":"1dbb9c35022e1d2db52a32bb12cad2f81e882e97","modified":1594915029121},{"_id":"source/_posts/其他/工作效率/git的基本命令.md","hash":"f8c13e4cb2b8e76d44d1c73fdce5d7d2590c6129","modified":1594915063212},{"_id":"source/_posts/其他/工作效率/latex基本用法.md","hash":"23193d76d4bcd3935a1a0aba7568413ef2b42540","modified":1594915072892},{"_id":"source/_posts/前端/Hexo/Hexo博客搭建.md","hash":"8cc4d156cc7fdcce9a7276b778b045086fd09898","modified":1594914916558},{"_id":"source/_posts/前端/Hexo/Hexo博客部署到腾讯云服务器全流程.md","hash":"4097288a757b8cff576c9232dab2dfc1dd509a6d","modified":1594914904633},{"_id":"source/_posts/前端/Hexo/Hexo实现多台机器同时编写博客.md","hash":"5517afbd2bb76993dc4f827f07189f6b318e7d68","modified":1594914923175},{"_id":"source/_posts/前端/JS/1、JS内置对象与基本语法.md","hash":"9e72b24fcb3fae34fcb3803b56221a9408939d16","modified":1592724768100},{"_id":"source/_posts/前端/JS/2、DOM节点操作.md","hash":"597cd1e4148b9759e7ac2d10d4ca945ea99f6a75","modified":1594914942631},{"_id":"source/_posts/学习笔记/论文/全卷积神经网络（FCN）.md","hash":"2c101515ccb43d90b7369cb11a8f6ddb51507de3","modified":1594915127901},{"_id":"source/_posts/数据库/MySQL/SQL的一些机制.md","hash":"a0db553da9f9e2a64508857e988f908e6490d932","modified":1592321294867},{"_id":"source/_posts/数据库/MySQL/SQL的增删改等语句.md","hash":"ba3cb3ead76c89c800dbd15e992685937fd584c1","modified":1592145256917},{"_id":"source/_posts/数据库/MySQL/SQL语句——查.md","hash":"1eb35f7814c34fdaf2b2283e060737184198eb18","modified":1593414629612},{"_id":"source/_posts/瞎侃/剧评/The Long Night（权力的游戏 S8E3）.md","hash":"062ab17c69e004f44c8ffa5a205a249dc6cb4ac0","modified":1594914854582},{"_id":"source/_posts/瞎侃/散文/改变.md","hash":"958bbf458ebff2925eddfd6f6de369011c595dc2","modified":1594914871771},{"_id":"source/_posts/瞎侃/散文/雨与晴.md","hash":"4740b037e93883233154284553f5263bc94ad032","modified":1594911573182},{"_id":"source/_posts/瞎侃/杂文/务虚时代下的国贼——李鸿章.md","hash":"ab6be32df2db913adc662b5a6ce516575d54579e","modified":1594911536208},{"_id":"source/_posts/计算机基础/数据结构/1、动态数组.md","hash":"c69d8f30b0aebc799e5e8f1d24b321c409d8be0d","modified":1594915088756},{"_id":"source/_posts/计算机基础/数据结构/2、栈.md","hash":"e8f79e989ad63de25a3de3f5f40796038c9cd526","modified":1594915098074},{"_id":"source/_posts/计算机基础/数据结构/3、队列.md","hash":"3579ac94708d9f201819c900153bde9908617fdb","modified":1594915757586},{"_id":"source/_posts/Python/GUI/Anaconda+PyCharm配置PyQt5全过程/2.png","hash":"0a94cea08690fb13fd65a9238d8aff7f13820b1b","modified":1586529731782},{"_id":"source/_posts/Python/GUI/Anaconda+PyCharm配置PyQt5全过程/3.png","hash":"5166d3ccd52deb50829d029dba95e6b4b8bfd9a6","modified":1586531476526},{"_id":"source/_posts/Python/GUI/Anaconda+PyCharm配置PyQt5全过程/5.png","hash":"bccf83148c7a43cca22331ee9d02af7bce61f98f","modified":1586532006737},{"_id":"source/_posts/Python/GUI/Anaconda+PyCharm配置PyQt5全过程/1.png","hash":"4f56e51278d0827b6d4a18654a9710df1847c9b6","modified":1586502734770},{"_id":"source/_posts/Python/GUI/Anaconda+PyCharm配置PyQt5全过程/6.png","hash":"66cfa20ff8732175ac6af01f6cee02c195b20f8a","modified":1586532523034},{"_id":"source/_posts/Python/GUI/Anaconda+PyCharm配置PyQt5全过程/4.png","hash":"ce6bccfa0152967296296e644d655976a5d6abbd","modified":1586531825743},{"_id":"source/_posts/数据库/MySQL/SQL语句——查/sql连接.png","hash":"06d5f913bbcbd15859036903c9593214dc8d1eec","modified":1592839741850},{"_id":"public/categories/瞎侃/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/瞎侃/杂文/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/瞎侃/散文/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/刷题/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/瞎侃/剧评/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/其他/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/前端/hexo/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/其他/工作效率/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/其他/debug/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/计算机基础/数据结构/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/学习笔记/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/学习笔记/论文/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/计算机基础/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/Python/GUI/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/Python/游戏/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/Python/数据库/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/Python/语言基础/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/categories/Java/语言基础/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/page/6/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/2020/page/5/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/archives/2020/07/page/2/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715},{"_id":"public/page/6/index.html","hash":"95ab4da77ff32bf3b9a52a7b543516c80dcb8454","modified":1594915808715}],"Category":[{"name":"Python","_id":"cka5hfrqp0002skjscs0jc8w0"},{"name":"随笔","_id":"cka5hfrrs000bskjs1trxeshd"},{"name":"记录","_id":"cka5hfrrz000hskjs25xpfzu7"},{"name":"PyQt5","parent":"cka5hfrqp0002skjscs0jc8w0","_id":"cka5hfrs5000nskjs74b72j1d"},{"name":"基础知识","parent":"cka5hfrqp0002skjscs0jc8w0","_id":"cka5hfrsj0010skjs8no61d4i"},{"name":"剧评","parent":"cka5hfrrs000bskjs1trxeshd","_id":"cka5hfrst001bskjs4euv7swm"},{"name":"命令","_id":"cka5hfrt4001lskjse5gufami"},{"name":"hexo","parent":"cka5hfrrz000hskjs25xpfzu7","_id":"cka5hfrt7001rskjs7s4u5wfa"},{"name":"笔记","_id":"cka5hfrte0022skjs9tgufixb"},{"name":"论文笔记","_id":"cka5hfrth0026skjs88x9ek3r"},{"name":"git","parent":"cka5hfrt4001lskjse5gufami","_id":"cka5hfrtm002bskjs270s7woo"},{"name":"其它","parent":"cka5hfrt4001lskjse5gufami","_id":"cka5hfrtn002fskjsgsrd0ez3"},{"name":"散文","parent":"cka5hfrrs000bskjs1trxeshd","_id":"cka5hfru4002pskjseqnldkq7"},{"name":"杂文","parent":"cka5hfrrs000bskjs1trxeshd","_id":"cka5hfru6002rskjs7g512wzb"},{"name":"pygame","parent":"cka5hfrqp0002skjscs0jc8w0","_id":"ckav33tky0002fgjsafh8a28n"},{"name":"数据库","_id":"ckbf331r4000pzwjs2csf4hnd"},{"name":"MySQL","parent":"ckbf331r4000pzwjs2csf4hnd","_id":"ckbf331rj000tzwjsaap1g5gd"},{"name":"问题解决","_id":"ckbf3trug00014sjsh97s7a4m"},{"name":"前端","_id":"ckbf5c0rl00074sjsb3yp5yc0"},{"name":"JS","parent":"ckbf5c0rl00074sjsb3yp5yc0","_id":"ckbf5c0rn000a4sjs0ruq6t3j"},{"name":"GIS","_id":"ckbf6822t0001sgjs7y2g59bc"},{"name":"常用命令","_id":"ckbf682330006sgjs7guo294u"},{"name":"latex","parent":"ckbf682330006sgjs7guo294u","_id":"ckbf6825s000dsgjs7iowhml6"},{"name":"git","parent":"ckbf682330006sgjs7guo294u","_id":"ckbf6825u000esgjs3x1386w8"},{"name":"问题处理","_id":"ckbrje4bv0008ckjsbbgp0i1h"},{"name":"Django","parent":"cka5hfrqp0002skjscs0jc8w0","_id":"ckbrje4c5000eckjsetth8q64"},{"name":"Java","_id":"ckcokw9qw0006tkjsdk105r9v"},{"name":"基础知识","parent":"ckcokw9qw0006tkjsdk105r9v","_id":"ckcokw9rb000btkjs4w6e91qt"},{"name":"数据结构","_id":"ckcol4yli0004xwjsd2bq2lft"},{"name":"瞎侃","_id":"ckcox5dgp001v68jsbf393inc"},{"name":"杂文","parent":"ckcox5dgp001v68jsbf393inc","_id":"ckcox5dgr001w68js1czbfdzy"},{"name":"散文","parent":"ckcox5dgp001v68jsbf393inc","_id":"ckcox65zg002368js10c323kq"},{"name":"刷题","_id":"ckcoz3xh5004u68jsdg4x7aj0"},{"name":"剧评","parent":"ckcox5dgp001v68jsbf393inc","_id":"ckcoz4hxe005068js5j750qgz"},{"name":"hexo","parent":"ckbf5c0rl00074sjsb3yp5yc0","_id":"ckcoz5kjp005568jsbr35a9kk"},{"name":"其他","_id":"ckcoz6nr9005d68js16ltd91g"},{"name":"debug","parent":"ckcoz6nr9005d68js16ltd91g","_id":"ckcoz6ubx005f68js0pb98sh0"},{"name":"常用命令","parent":"ckcoz6nr9005d68js16ltd91g","_id":"ckcoz75yi005h68js1xxog7gh"},{"name":"工作效率","parent":"ckcoz6nr9005d68js16ltd91g","_id":"ckcoz8ywj006468js4xzyfym7"},{"name":"计算机基础","_id":"ckcoz9im3006768jsfolxe0kq"},{"name":"数据结构","parent":"ckcoz9im3006768jsfolxe0kq","_id":"ckcoz9im4006868js34i1gmue"},{"name":"论文","parent":"cka5hfrte0022skjs9tgufixb","_id":"ckcoza7jh006f68js94o71vng"},{"name":"学习笔记","_id":"ckcozactj006i68jsag34e9bv"},{"name":"论文","parent":"ckcozactj006i68jsag34e9bv","_id":"ckcozactj006j68jse1nobiru"},{"name":"语言基础","parent":"ckcokw9qw0006tkjsdk105r9v","_id":"ckcozp8ry0005l4jseeoo301d"},{"name":"GUI","parent":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8sx000ml4js903o0osb"},{"name":"游戏","parent":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8t4000tl4jsb8occcko"},{"name":"语言基础","parent":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8ta0011l4js45vyagdd"},{"name":"数据库","parent":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8ty001kl4jsdyl1d8eg"}],"Data":[],"Page":[],"Post":[{"title":"1、Java语言基础","date":"2020-06-27T09:25:12.000Z","fileName":"java1","_content":"\n参考：https://github.com/Snailclimb/JavaGuide\n\n### 基本概念\n\n1、**JVM**：Java虚拟机，用于运行Java字节码，其针对不同的操作系统有着特定的实现，使得相同的字节码运行会给出相同的结果。\n\n在Java中，JVM能够理解的代码就叫做**字节码**（.class文件）。其不面向任何特定的处理器，只面向虚拟机。\n\n2、**JDK**，即Java Development Kit，是功能齐全的Java软件开发包，拥有JRE所拥有的一切，有编译器（javac）和一些其他工具，能够创建和编译程序。\n\n3、**JRE**，即Java运行时环境。其为运行已编译Java程序所需要的所有内容的集合，包括Java虚拟机、Java类库、Java命令和其他一些基础的构建。但是，其不能用于创建新程序。\n\n\n\n**编译与解释并存**：Java程序要经过先编译、后解释两个步骤。（先经过编译生成字节码文件*.class，再经过解释进行执行）\n\n\n\n\n\n### 基本数据类型\n\nJava有8中基本数据类型，数字类型（byte<1>、short<2>、int<4>、long<8>、float<4>、double<8>）；字符类型（char<2>）；布尔型（boolean<依赖于JVM的具体实现>），其中<>内为其所对应的字节数，每个基本数据类型又有对应的默认值。\n\n#### 装箱与拆箱\n\n参考：https://www.cnblogs.com/dolphin0520/p/3780005.html\n\nJava为每种基本数据类型都提供了对应的包装器类型，将基本数据类型转换成包装类称为**装箱**，反之则称为**拆箱**。\n\n1、装箱：其中第一种方法不会触发自动装箱的机制，在执行效率和资源占用上，第二种方法通常要优于第一种情况。\n\n```\nInteger i = new Integer(10);\t// 手动装箱\nInteger i = 10;\t// 自动装箱\n```\n\n拆箱（直接进行赋值语句即可）：\n\n```\nint i2 = i;\n```\n\n**装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。**\n\n***\n\n**注意：**\n\n如下代码的输出不同，原因在于valueOf的实现方法，*可以简单总结为若数值在[-128,127]之间，便返回IntegerCache.cache中已存在的对象的引用，否则创建一个新的Integer对象*\n\n```\nInteger i1 = 100;\nInteger i2 = 100;\n\nInteger i3 = 200;\nInteger i4 = 200;\n\nSystem.out.println(i1==i2);\nSystem.out.println(i3==i4);\n\n####################################\ntrue\nfalse\n```\n\n同时，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的（**这些方法实现了常量池技术**），而Double、Float的valueOf方法的实现是类似的（**这些方法没有使用常量池技术**）。因此，上述代码若换成Double，会输出“false false”，换成Boolean会输出“true true”。\n\n除此之外，还应该注意的是，如果这些包装类使用了算数运算符，那么“==”比较的将会是数值（即触发了自动拆箱），如下：\n\n```\nInteger a = 1;\nInteger b = 2;\nInteger c = 3;\nSystem.out.println(c==(a+b));\n\n#########################################\ntrue\n```\n\n***\n\n对于包装器类型，equals方法并不会进行类型转换，如下：\n\n```\nInteger a = 1;\nInteger b = 2;\n\nLong c = 3L;\nLong d = 2L;\n\nSystem.out.println(c==a+b);\nSystem.out.println(c.equals(a+b));\nSystem.out.println(c.equals(a+d));\n\n###########################################\ntrue\nfalse\ntrue\n```\n\n\n\n\n\n### 方法（函数）\n\n#### 参数\n\n1、一个方法不能修改一个基本数据类型的参数。\n\n2、一个方法可以改变一个对象参数的状态。\n\n3、一个方法不能让对象参数引用一个新的对象。\n\n#### 方法的重载与重写\n\n**方法重载**：同样的方法根据输入数据的不同，做出不同处理（同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理）。满足如下要求：\n\na、同一个类中\n\nb、方法名相同，参数列表不同，方法返回值相同\n\nc、访问修饰符。\n\n\n\n**方法重写**：重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写（重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变）。满足以下条件：\n\na、发生有继承关系的子类中，且父类方法的访问修饰符为private/final/static则表示该方法不能重写，但是使用static修饰的方法能够被再次声明。同时构造方法不能被重写。\n\nb、方法名相同，参数列表相同（参数顺序、个数相同），返回值类型相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。\n\n\n\n\n\n\n\n\n\n构造函数需要一个有参构造和一个无参构造\n\n\n\ngetter/setter\n\n\n\n\n\n包：一个JAVA源文件中只能有一个package语句\n\n命名方法：域名倒序+模块+功能\n\n\n\nstatic：静态成员、类成员\n\n无论类实例化多少，值都相同 \n\n\n\n静态方法不能直接访问非静态成员\n\n \n\n使用{}形成代码块，每个代码块是一个独立的作用空间\n\n{}——在方法中，普通代码块。在类中，构造代码块\n\nstatic{}——静态代码块\n\n\n\n\n\n在方法中通过对象作为参数，传递的是他的引用\n\n\n\n\n\n\n\nJava只能是单继承\n\n子类可以访问父类非私有成员\n\n\n\n \n\n共有：public：任意位置\n\n私有：private：本类中访问\n\n保护：protected：当前类、同包子类/非子类、跨包子类（跨包子类不允许）\n\n默认：当前类、同包子类（跨包子类不允许调用）\n\n\n\nsuper：父类对象的引用\n\nsuper.print() 访问父类成员方法\n\nsuper.name 访问父类属性\n\nsuper() 访问父类构造方法，必须位于子类构造方法的第一行\n\n\n\n子类的构造过程必须调用其父类的构造方法，若子类构造方法中没有显式标注，则系统默认调用父类无参构造方法（若子类构造方法无显式标值且父类中没有无参构造方法，则编译出错）\n\n\n\nObject类是所有类的父类\n\n\n\n\n\nfinal\n\n1、在类前添加，标识该类不允许有子类（如System和String都有final关键字）\n\n2、在方法前添加，表明该方法不能被子类重写（子类能够调用）。不能修饰构造方法\n\n\n\n设计模式：软件开发人员在软件开发过程中面临的一般问题的解决方案。基于场景的解决方案\n\n单例模式：1、某个类有且只有一个实例；2、必须自行创建实例；3、自行向整个系统提供这个实例\n\n\n\n多态：不同类的对象对同一消息做出不同响应\n\n编译时多态：（方法重载）\n\n运行时多态：程序运行时动态决定调用哪个方法\n\n\n\n多态必要条件\n\n1、满足继承关系\n\n2、父类引用指向子类对象\n\n\n\n向上转型，父类引用指向子类实例。可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法\n\nAnimal two = new Cat()\n\n\n\n向下转型，子类引用指向父类实例，此处要求必须进行强转\n\ninstanceof 运算符，返回 true false\n\n```\nif(obj instanceof Cat) {\n\tCat temp = (Cat)obj\n}\n```\n\n\n\n```\nif() {\n\treturn new Dog();\n} else {\n\treturn new Cat();\n}\n```\n\n\n\n\n\nabstract关键字\n\n抽象类，无法进行实例化的类（可以通过向上转型指向子类实例 ）\n\n抽象方法：子类必须进行实现（或者子类也设置为抽象类），在父类定义时不能有方法体\n\n\n\n包含抽象方法的类是抽象类\n\n抽象类中可以没有抽象方法\n\nstatic/final/private不能与abstract共存\n\n\n\n接口：命名通常以“I”打头\n\n接口定义了某一批类所需要遵守的规范\n\n接口不关心这些类的内部数据，也不关心类中方法的实现细节，只规定这些类中必须提供某些方法\n\n\n\n\n\n接口访问修饰符：public 默认\n\n接口中抽象方法可以不写abstract关键字\n\n作为接口的实现类必须实现接口中定义的所有方法，否则需要将该类设置为抽象类\n\n接口中可以包含常量，默认public static final\n\n```\npublic interface ITest {\n    public void func();\n}\n```\n\n\n\n```\npublic class A implements ITest {\n\n    @java.lang.Override\n    public void func() {\n\n    }\n}\n```\n\n\n\n```\nINet net = new A();\n\n```\n\n\n\ndefault 关键字\n\n```\npublic interface ITest {\n\t// 默认方法\n\tdefault void func1() {\n\t\t\n\t}\n\t// 静态方法\n\tstatic void func2() {\n\t\n\t}\n}\n\n// 调用接口中的默认方法\nITest.super.func1();\n```\n\n接口的继承，可以一对多\n\n\n\n在Java中，可以将一个类定义在另一个类中或者一个方法中，这样的类称为内部类\n\n\n\n1、成员内部类\n\n获取内部类\n\n```\nA.a1 me = new A().new a1();\n```\n\n\n\n2、静态内部类\n\n3、方法内部类\n\n4、匿名内部类\n\n\n\n\n\n","source":"_posts/Java/1、Java语言基础.md","raw":"---\ntitle: 1、Java语言基础\ndate: 2020-06-27 17:25:12\ntags:\n\t- Java\ncategories:\n\t- Java\n\t- 基础知识\nfileName: java1\n---\n\n参考：https://github.com/Snailclimb/JavaGuide\n\n### 基本概念\n\n1、**JVM**：Java虚拟机，用于运行Java字节码，其针对不同的操作系统有着特定的实现，使得相同的字节码运行会给出相同的结果。\n\n在Java中，JVM能够理解的代码就叫做**字节码**（.class文件）。其不面向任何特定的处理器，只面向虚拟机。\n\n2、**JDK**，即Java Development Kit，是功能齐全的Java软件开发包，拥有JRE所拥有的一切，有编译器（javac）和一些其他工具，能够创建和编译程序。\n\n3、**JRE**，即Java运行时环境。其为运行已编译Java程序所需要的所有内容的集合，包括Java虚拟机、Java类库、Java命令和其他一些基础的构建。但是，其不能用于创建新程序。\n\n\n\n**编译与解释并存**：Java程序要经过先编译、后解释两个步骤。（先经过编译生成字节码文件*.class，再经过解释进行执行）\n\n\n\n\n\n### 基本数据类型\n\nJava有8中基本数据类型，数字类型（byte<1>、short<2>、int<4>、long<8>、float<4>、double<8>）；字符类型（char<2>）；布尔型（boolean<依赖于JVM的具体实现>），其中<>内为其所对应的字节数，每个基本数据类型又有对应的默认值。\n\n#### 装箱与拆箱\n\n参考：https://www.cnblogs.com/dolphin0520/p/3780005.html\n\nJava为每种基本数据类型都提供了对应的包装器类型，将基本数据类型转换成包装类称为**装箱**，反之则称为**拆箱**。\n\n1、装箱：其中第一种方法不会触发自动装箱的机制，在执行效率和资源占用上，第二种方法通常要优于第一种情况。\n\n```\nInteger i = new Integer(10);\t// 手动装箱\nInteger i = 10;\t// 自动装箱\n```\n\n拆箱（直接进行赋值语句即可）：\n\n```\nint i2 = i;\n```\n\n**装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。**\n\n***\n\n**注意：**\n\n如下代码的输出不同，原因在于valueOf的实现方法，*可以简单总结为若数值在[-128,127]之间，便返回IntegerCache.cache中已存在的对象的引用，否则创建一个新的Integer对象*\n\n```\nInteger i1 = 100;\nInteger i2 = 100;\n\nInteger i3 = 200;\nInteger i4 = 200;\n\nSystem.out.println(i1==i2);\nSystem.out.println(i3==i4);\n\n####################################\ntrue\nfalse\n```\n\n同时，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的（**这些方法实现了常量池技术**），而Double、Float的valueOf方法的实现是类似的（**这些方法没有使用常量池技术**）。因此，上述代码若换成Double，会输出“false false”，换成Boolean会输出“true true”。\n\n除此之外，还应该注意的是，如果这些包装类使用了算数运算符，那么“==”比较的将会是数值（即触发了自动拆箱），如下：\n\n```\nInteger a = 1;\nInteger b = 2;\nInteger c = 3;\nSystem.out.println(c==(a+b));\n\n#########################################\ntrue\n```\n\n***\n\n对于包装器类型，equals方法并不会进行类型转换，如下：\n\n```\nInteger a = 1;\nInteger b = 2;\n\nLong c = 3L;\nLong d = 2L;\n\nSystem.out.println(c==a+b);\nSystem.out.println(c.equals(a+b));\nSystem.out.println(c.equals(a+d));\n\n###########################################\ntrue\nfalse\ntrue\n```\n\n\n\n\n\n### 方法（函数）\n\n#### 参数\n\n1、一个方法不能修改一个基本数据类型的参数。\n\n2、一个方法可以改变一个对象参数的状态。\n\n3、一个方法不能让对象参数引用一个新的对象。\n\n#### 方法的重载与重写\n\n**方法重载**：同样的方法根据输入数据的不同，做出不同处理（同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理）。满足如下要求：\n\na、同一个类中\n\nb、方法名相同，参数列表不同，方法返回值相同\n\nc、访问修饰符。\n\n\n\n**方法重写**：重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写（重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变）。满足以下条件：\n\na、发生有继承关系的子类中，且父类方法的访问修饰符为private/final/static则表示该方法不能重写，但是使用static修饰的方法能够被再次声明。同时构造方法不能被重写。\n\nb、方法名相同，参数列表相同（参数顺序、个数相同），返回值类型相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。\n\n\n\n\n\n\n\n\n\n构造函数需要一个有参构造和一个无参构造\n\n\n\ngetter/setter\n\n\n\n\n\n包：一个JAVA源文件中只能有一个package语句\n\n命名方法：域名倒序+模块+功能\n\n\n\nstatic：静态成员、类成员\n\n无论类实例化多少，值都相同 \n\n\n\n静态方法不能直接访问非静态成员\n\n \n\n使用{}形成代码块，每个代码块是一个独立的作用空间\n\n{}——在方法中，普通代码块。在类中，构造代码块\n\nstatic{}——静态代码块\n\n\n\n\n\n在方法中通过对象作为参数，传递的是他的引用\n\n\n\n\n\n\n\nJava只能是单继承\n\n子类可以访问父类非私有成员\n\n\n\n \n\n共有：public：任意位置\n\n私有：private：本类中访问\n\n保护：protected：当前类、同包子类/非子类、跨包子类（跨包子类不允许）\n\n默认：当前类、同包子类（跨包子类不允许调用）\n\n\n\nsuper：父类对象的引用\n\nsuper.print() 访问父类成员方法\n\nsuper.name 访问父类属性\n\nsuper() 访问父类构造方法，必须位于子类构造方法的第一行\n\n\n\n子类的构造过程必须调用其父类的构造方法，若子类构造方法中没有显式标注，则系统默认调用父类无参构造方法（若子类构造方法无显式标值且父类中没有无参构造方法，则编译出错）\n\n\n\nObject类是所有类的父类\n\n\n\n\n\nfinal\n\n1、在类前添加，标识该类不允许有子类（如System和String都有final关键字）\n\n2、在方法前添加，表明该方法不能被子类重写（子类能够调用）。不能修饰构造方法\n\n\n\n设计模式：软件开发人员在软件开发过程中面临的一般问题的解决方案。基于场景的解决方案\n\n单例模式：1、某个类有且只有一个实例；2、必须自行创建实例；3、自行向整个系统提供这个实例\n\n\n\n多态：不同类的对象对同一消息做出不同响应\n\n编译时多态：（方法重载）\n\n运行时多态：程序运行时动态决定调用哪个方法\n\n\n\n多态必要条件\n\n1、满足继承关系\n\n2、父类引用指向子类对象\n\n\n\n向上转型，父类引用指向子类实例。可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法\n\nAnimal two = new Cat()\n\n\n\n向下转型，子类引用指向父类实例，此处要求必须进行强转\n\ninstanceof 运算符，返回 true false\n\n```\nif(obj instanceof Cat) {\n\tCat temp = (Cat)obj\n}\n```\n\n\n\n```\nif() {\n\treturn new Dog();\n} else {\n\treturn new Cat();\n}\n```\n\n\n\n\n\nabstract关键字\n\n抽象类，无法进行实例化的类（可以通过向上转型指向子类实例 ）\n\n抽象方法：子类必须进行实现（或者子类也设置为抽象类），在父类定义时不能有方法体\n\n\n\n包含抽象方法的类是抽象类\n\n抽象类中可以没有抽象方法\n\nstatic/final/private不能与abstract共存\n\n\n\n接口：命名通常以“I”打头\n\n接口定义了某一批类所需要遵守的规范\n\n接口不关心这些类的内部数据，也不关心类中方法的实现细节，只规定这些类中必须提供某些方法\n\n\n\n\n\n接口访问修饰符：public 默认\n\n接口中抽象方法可以不写abstract关键字\n\n作为接口的实现类必须实现接口中定义的所有方法，否则需要将该类设置为抽象类\n\n接口中可以包含常量，默认public static final\n\n```\npublic interface ITest {\n    public void func();\n}\n```\n\n\n\n```\npublic class A implements ITest {\n\n    @java.lang.Override\n    public void func() {\n\n    }\n}\n```\n\n\n\n```\nINet net = new A();\n\n```\n\n\n\ndefault 关键字\n\n```\npublic interface ITest {\n\t// 默认方法\n\tdefault void func1() {\n\t\t\n\t}\n\t// 静态方法\n\tstatic void func2() {\n\t\n\t}\n}\n\n// 调用接口中的默认方法\nITest.super.func1();\n```\n\n接口的继承，可以一对多\n\n\n\n在Java中，可以将一个类定义在另一个类中或者一个方法中，这样的类称为内部类\n\n\n\n1、成员内部类\n\n获取内部类\n\n```\nA.a1 me = new A().new a1();\n```\n\n\n\n2、静态内部类\n\n3、方法内部类\n\n4、匿名内部类\n\n\n\n\n\n","slug":"Java/1、Java语言基础","published":1,"updated":"2020-07-16T09:19:04.429Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcox1368000068jsac1w10tm","content":"<p>参考：<a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\" rel=\"noopener\">https://github.com/Snailclimb/JavaGuide</a></p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>1、<strong>JVM</strong>：Java虚拟机，用于运行Java字节码，其针对不同的操作系统有着特定的实现，使得相同的字节码运行会给出相同的结果。</p>\n<p>在Java中，JVM能够理解的代码就叫做<strong>字节码</strong>（.class文件）。其不面向任何特定的处理器，只面向虚拟机。</p>\n<p>2、<strong>JDK</strong>，即Java Development Kit，是功能齐全的Java软件开发包，拥有JRE所拥有的一切，有编译器（javac）和一些其他工具，能够创建和编译程序。</p>\n<p>3、<strong>JRE</strong>，即Java运行时环境。其为运行已编译Java程序所需要的所有内容的集合，包括Java虚拟机、Java类库、Java命令和其他一些基础的构建。但是，其不能用于创建新程序。</p>\n<p><strong>编译与解释并存</strong>：Java程序要经过先编译、后解释两个步骤。（先经过编译生成字节码文件*.class，再经过解释进行执行）</p>\n<h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><p>Java有8中基本数据类型，数字类型（byte&lt;1&gt;、short&lt;2&gt;、int&lt;4&gt;、long&lt;8&gt;、float&lt;4&gt;、double&lt;8&gt;）；字符类型（char&lt;2&gt;）；布尔型（boolean&lt;依赖于JVM的具体实现&gt;），其中&lt;&gt;内为其所对应的字节数，每个基本数据类型又有对应的默认值。</p>\n<h4 id=\"装箱与拆箱\"><a href=\"#装箱与拆箱\" class=\"headerlink\" title=\"装箱与拆箱\"></a>装箱与拆箱</h4><p>参考：<a href=\"https://www.cnblogs.com/dolphin0520/p/3780005.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dolphin0520/p/3780005.html</a></p>\n<p>Java为每种基本数据类型都提供了对应的包装器类型，将基本数据类型转换成包装类称为<strong>装箱</strong>，反之则称为<strong>拆箱</strong>。</p>\n<p>1、装箱：其中第一种方法不会触发自动装箱的机制，在执行效率和资源占用上，第二种方法通常要优于第一种情况。</p>\n<pre><code>Integer i = new Integer(10);    // 手动装箱\nInteger i = 10;    // 自动装箱</code></pre><p>拆箱（直接进行赋值语句即可）：</p>\n<pre><code>int i2 = i;</code></pre><p><strong>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。</strong></p>\n<hr>\n<p><strong>注意：</strong></p>\n<p>如下代码的输出不同，原因在于valueOf的实现方法，<em>可以简单总结为若数值在[-128,127]之间，便返回IntegerCache.cache中已存在的对象的引用，否则创建一个新的Integer对象</em></p>\n<pre><code>Integer i1 = 100;\nInteger i2 = 100;\n\nInteger i3 = 200;\nInteger i4 = 200;\n\nSystem.out.println(i1==i2);\nSystem.out.println(i3==i4);\n\n####################################\ntrue\nfalse</code></pre><p>同时，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的（<strong>这些方法实现了常量池技术</strong>），而Double、Float的valueOf方法的实现是类似的（<strong>这些方法没有使用常量池技术</strong>）。因此，上述代码若换成Double，会输出“false false”，换成Boolean会输出“true true”。</p>\n<p>除此之外，还应该注意的是，如果这些包装类使用了算数运算符，那么“==”比较的将会是数值（即触发了自动拆箱），如下：</p>\n<pre><code>Integer a = 1;\nInteger b = 2;\nInteger c = 3;\nSystem.out.println(c==(a+b));\n\n#########################################\ntrue</code></pre><hr>\n<p>对于包装器类型，equals方法并不会进行类型转换，如下：</p>\n<pre><code>Integer a = 1;\nInteger b = 2;\n\nLong c = 3L;\nLong d = 2L;\n\nSystem.out.println(c==a+b);\nSystem.out.println(c.equals(a+b));\nSystem.out.println(c.equals(a+d));\n\n###########################################\ntrue\nfalse\ntrue</code></pre><h3 id=\"方法（函数）\"><a href=\"#方法（函数）\" class=\"headerlink\" title=\"方法（函数）\"></a>方法（函数）</h3><h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>1、一个方法不能修改一个基本数据类型的参数。</p>\n<p>2、一个方法可以改变一个对象参数的状态。</p>\n<p>3、一个方法不能让对象参数引用一个新的对象。</p>\n<h4 id=\"方法的重载与重写\"><a href=\"#方法的重载与重写\" class=\"headerlink\" title=\"方法的重载与重写\"></a>方法的重载与重写</h4><p><strong>方法重载</strong>：同样的方法根据输入数据的不同，做出不同处理（同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理）。满足如下要求：</p>\n<p>a、同一个类中</p>\n<p>b、方法名相同，参数列表不同，方法返回值相同</p>\n<p>c、访问修饰符。</p>\n<p><strong>方法重写</strong>：重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写（重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变）。满足以下条件：</p>\n<p>a、发生有继承关系的子类中，且父类方法的访问修饰符为private/final/static则表示该方法不能重写，但是使用static修饰的方法能够被再次声明。同时构造方法不能被重写。</p>\n<p>b、方法名相同，参数列表相同（参数顺序、个数相同），返回值类型相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</p>\n<p>构造函数需要一个有参构造和一个无参构造</p>\n<p>getter/setter</p>\n<p>包：一个JAVA源文件中只能有一个package语句</p>\n<p>命名方法：域名倒序+模块+功能</p>\n<p>static：静态成员、类成员</p>\n<p>无论类实例化多少，值都相同 </p>\n<p>静态方法不能直接访问非静态成员</p>\n<p>使用{}形成代码块，每个代码块是一个独立的作用空间</p>\n<p>{}——在方法中，普通代码块。在类中，构造代码块</p>\n<p>static{}——静态代码块</p>\n<p>在方法中通过对象作为参数，传递的是他的引用</p>\n<p>Java只能是单继承</p>\n<p>子类可以访问父类非私有成员</p>\n<p>共有：public：任意位置</p>\n<p>私有：private：本类中访问</p>\n<p>保护：protected：当前类、同包子类/非子类、跨包子类（跨包子类不允许）</p>\n<p>默认：当前类、同包子类（跨包子类不允许调用）</p>\n<p>super：父类对象的引用</p>\n<p>super.print() 访问父类成员方法</p>\n<p>super.name 访问父类属性</p>\n<p>super() 访问父类构造方法，必须位于子类构造方法的第一行</p>\n<p>子类的构造过程必须调用其父类的构造方法，若子类构造方法中没有显式标注，则系统默认调用父类无参构造方法（若子类构造方法无显式标值且父类中没有无参构造方法，则编译出错）</p>\n<p>Object类是所有类的父类</p>\n<p>final</p>\n<p>1、在类前添加，标识该类不允许有子类（如System和String都有final关键字）</p>\n<p>2、在方法前添加，表明该方法不能被子类重写（子类能够调用）。不能修饰构造方法</p>\n<p>设计模式：软件开发人员在软件开发过程中面临的一般问题的解决方案。基于场景的解决方案</p>\n<p>单例模式：1、某个类有且只有一个实例；2、必须自行创建实例；3、自行向整个系统提供这个实例</p>\n<p>多态：不同类的对象对同一消息做出不同响应</p>\n<p>编译时多态：（方法重载）</p>\n<p>运行时多态：程序运行时动态决定调用哪个方法</p>\n<p>多态必要条件</p>\n<p>1、满足继承关系</p>\n<p>2、父类引用指向子类对象</p>\n<p>向上转型，父类引用指向子类实例。可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法</p>\n<p>Animal two = new Cat()</p>\n<p>向下转型，子类引用指向父类实例，此处要求必须进行强转</p>\n<p>instanceof 运算符，返回 true false</p>\n<pre><code>if(obj instanceof Cat) {\n    Cat temp = (Cat)obj\n}</code></pre><pre><code>if() {\n    return new Dog();\n} else {\n    return new Cat();\n}</code></pre><p>abstract关键字</p>\n<p>抽象类，无法进行实例化的类（可以通过向上转型指向子类实例 ）</p>\n<p>抽象方法：子类必须进行实现（或者子类也设置为抽象类），在父类定义时不能有方法体</p>\n<p>包含抽象方法的类是抽象类</p>\n<p>抽象类中可以没有抽象方法</p>\n<p>static/final/private不能与abstract共存</p>\n<p>接口：命名通常以“I”打头</p>\n<p>接口定义了某一批类所需要遵守的规范</p>\n<p>接口不关心这些类的内部数据，也不关心类中方法的实现细节，只规定这些类中必须提供某些方法</p>\n<p>接口访问修饰符：public 默认</p>\n<p>接口中抽象方法可以不写abstract关键字</p>\n<p>作为接口的实现类必须实现接口中定义的所有方法，否则需要将该类设置为抽象类</p>\n<p>接口中可以包含常量，默认public static final</p>\n<pre><code>public interface ITest {\n    public void func();\n}</code></pre><pre><code>public class A implements ITest {\n\n    @java.lang.Override\n    public void func() {\n\n    }\n}</code></pre><pre><code>INet net = new A();\n</code></pre><p>default 关键字</p>\n<pre><code>public interface ITest {\n    // 默认方法\n    default void func1() {\n\n    }\n    // 静态方法\n    static void func2() {\n\n    }\n}\n\n// 调用接口中的默认方法\nITest.super.func1();</code></pre><p>接口的继承，可以一对多</p>\n<p>在Java中，可以将一个类定义在另一个类中或者一个方法中，这样的类称为内部类</p>\n<p>1、成员内部类</p>\n<p>获取内部类</p>\n<pre><code>A.a1 me = new A().new a1();</code></pre><p>2、静态内部类</p>\n<p>3、方法内部类</p>\n<p>4、匿名内部类</p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考：<a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\" rel=\"noopener\">https://github.com/Snailclimb/JavaGuide</a></p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>1、<strong>JVM</strong>：Java虚拟机，用于运行Java字节码，其针对不同的操作系统有着特定的实现，使得相同的字节码运行会给出相同的结果。</p>\n<p>在Java中，JVM能够理解的代码就叫做<strong>字节码</strong>（.class文件）。其不面向任何特定的处理器，只面向虚拟机。</p>\n<p>2、<strong>JDK</strong>，即Java Development Kit，是功能齐全的Java软件开发包，拥有JRE所拥有的一切，有编译器（javac）和一些其他工具，能够创建和编译程序。</p>\n<p>3、<strong>JRE</strong>，即Java运行时环境。其为运行已编译Java程序所需要的所有内容的集合，包括Java虚拟机、Java类库、Java命令和其他一些基础的构建。但是，其不能用于创建新程序。</p>\n<p><strong>编译与解释并存</strong>：Java程序要经过先编译、后解释两个步骤。（先经过编译生成字节码文件*.class，再经过解释进行执行）</p>\n<h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><p>Java有8中基本数据类型，数字类型（byte&lt;1&gt;、short&lt;2&gt;、int&lt;4&gt;、long&lt;8&gt;、float&lt;4&gt;、double&lt;8&gt;）；字符类型（char&lt;2&gt;）；布尔型（boolean&lt;依赖于JVM的具体实现&gt;），其中&lt;&gt;内为其所对应的字节数，每个基本数据类型又有对应的默认值。</p>\n<h4 id=\"装箱与拆箱\"><a href=\"#装箱与拆箱\" class=\"headerlink\" title=\"装箱与拆箱\"></a>装箱与拆箱</h4><p>参考：<a href=\"https://www.cnblogs.com/dolphin0520/p/3780005.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dolphin0520/p/3780005.html</a></p>\n<p>Java为每种基本数据类型都提供了对应的包装器类型，将基本数据类型转换成包装类称为<strong>装箱</strong>，反之则称为<strong>拆箱</strong>。</p>\n<p>1、装箱：其中第一种方法不会触发自动装箱的机制，在执行效率和资源占用上，第二种方法通常要优于第一种情况。</p>\n<pre><code>Integer i = new Integer(10);    // 手动装箱\nInteger i = 10;    // 自动装箱</code></pre><p>拆箱（直接进行赋值语句即可）：</p>\n<pre><code>int i2 = i;</code></pre><p><strong>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。</strong></p>\n<hr>\n<p><strong>注意：</strong></p>\n<p>如下代码的输出不同，原因在于valueOf的实现方法，<em>可以简单总结为若数值在[-128,127]之间，便返回IntegerCache.cache中已存在的对象的引用，否则创建一个新的Integer对象</em></p>\n<pre><code>Integer i1 = 100;\nInteger i2 = 100;\n\nInteger i3 = 200;\nInteger i4 = 200;\n\nSystem.out.println(i1==i2);\nSystem.out.println(i3==i4);\n\n####################################\ntrue\nfalse</code></pre><p>同时，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的（<strong>这些方法实现了常量池技术</strong>），而Double、Float的valueOf方法的实现是类似的（<strong>这些方法没有使用常量池技术</strong>）。因此，上述代码若换成Double，会输出“false false”，换成Boolean会输出“true true”。</p>\n<p>除此之外，还应该注意的是，如果这些包装类使用了算数运算符，那么“==”比较的将会是数值（即触发了自动拆箱），如下：</p>\n<pre><code>Integer a = 1;\nInteger b = 2;\nInteger c = 3;\nSystem.out.println(c==(a+b));\n\n#########################################\ntrue</code></pre><hr>\n<p>对于包装器类型，equals方法并不会进行类型转换，如下：</p>\n<pre><code>Integer a = 1;\nInteger b = 2;\n\nLong c = 3L;\nLong d = 2L;\n\nSystem.out.println(c==a+b);\nSystem.out.println(c.equals(a+b));\nSystem.out.println(c.equals(a+d));\n\n###########################################\ntrue\nfalse\ntrue</code></pre><h3 id=\"方法（函数）\"><a href=\"#方法（函数）\" class=\"headerlink\" title=\"方法（函数）\"></a>方法（函数）</h3><h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>1、一个方法不能修改一个基本数据类型的参数。</p>\n<p>2、一个方法可以改变一个对象参数的状态。</p>\n<p>3、一个方法不能让对象参数引用一个新的对象。</p>\n<h4 id=\"方法的重载与重写\"><a href=\"#方法的重载与重写\" class=\"headerlink\" title=\"方法的重载与重写\"></a>方法的重载与重写</h4><p><strong>方法重载</strong>：同样的方法根据输入数据的不同，做出不同处理（同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理）。满足如下要求：</p>\n<p>a、同一个类中</p>\n<p>b、方法名相同，参数列表不同，方法返回值相同</p>\n<p>c、访问修饰符。</p>\n<p><strong>方法重写</strong>：重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写（重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变）。满足以下条件：</p>\n<p>a、发生有继承关系的子类中，且父类方法的访问修饰符为private/final/static则表示该方法不能重写，但是使用static修饰的方法能够被再次声明。同时构造方法不能被重写。</p>\n<p>b、方法名相同，参数列表相同（参数顺序、个数相同），返回值类型相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</p>\n<p>构造函数需要一个有参构造和一个无参构造</p>\n<p>getter/setter</p>\n<p>包：一个JAVA源文件中只能有一个package语句</p>\n<p>命名方法：域名倒序+模块+功能</p>\n<p>static：静态成员、类成员</p>\n<p>无论类实例化多少，值都相同 </p>\n<p>静态方法不能直接访问非静态成员</p>\n<p>使用{}形成代码块，每个代码块是一个独立的作用空间</p>\n<p>{}——在方法中，普通代码块。在类中，构造代码块</p>\n<p>static{}——静态代码块</p>\n<p>在方法中通过对象作为参数，传递的是他的引用</p>\n<p>Java只能是单继承</p>\n<p>子类可以访问父类非私有成员</p>\n<p>共有：public：任意位置</p>\n<p>私有：private：本类中访问</p>\n<p>保护：protected：当前类、同包子类/非子类、跨包子类（跨包子类不允许）</p>\n<p>默认：当前类、同包子类（跨包子类不允许调用）</p>\n<p>super：父类对象的引用</p>\n<p>super.print() 访问父类成员方法</p>\n<p>super.name 访问父类属性</p>\n<p>super() 访问父类构造方法，必须位于子类构造方法的第一行</p>\n<p>子类的构造过程必须调用其父类的构造方法，若子类构造方法中没有显式标注，则系统默认调用父类无参构造方法（若子类构造方法无显式标值且父类中没有无参构造方法，则编译出错）</p>\n<p>Object类是所有类的父类</p>\n<p>final</p>\n<p>1、在类前添加，标识该类不允许有子类（如System和String都有final关键字）</p>\n<p>2、在方法前添加，表明该方法不能被子类重写（子类能够调用）。不能修饰构造方法</p>\n<p>设计模式：软件开发人员在软件开发过程中面临的一般问题的解决方案。基于场景的解决方案</p>\n<p>单例模式：1、某个类有且只有一个实例；2、必须自行创建实例；3、自行向整个系统提供这个实例</p>\n<p>多态：不同类的对象对同一消息做出不同响应</p>\n<p>编译时多态：（方法重载）</p>\n<p>运行时多态：程序运行时动态决定调用哪个方法</p>\n<p>多态必要条件</p>\n<p>1、满足继承关系</p>\n<p>2、父类引用指向子类对象</p>\n<p>向上转型，父类引用指向子类实例。可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法</p>\n<p>Animal two = new Cat()</p>\n<p>向下转型，子类引用指向父类实例，此处要求必须进行强转</p>\n<p>instanceof 运算符，返回 true false</p>\n<pre><code>if(obj instanceof Cat) {\n    Cat temp = (Cat)obj\n}</code></pre><pre><code>if() {\n    return new Dog();\n} else {\n    return new Cat();\n}</code></pre><p>abstract关键字</p>\n<p>抽象类，无法进行实例化的类（可以通过向上转型指向子类实例 ）</p>\n<p>抽象方法：子类必须进行实现（或者子类也设置为抽象类），在父类定义时不能有方法体</p>\n<p>包含抽象方法的类是抽象类</p>\n<p>抽象类中可以没有抽象方法</p>\n<p>static/final/private不能与abstract共存</p>\n<p>接口：命名通常以“I”打头</p>\n<p>接口定义了某一批类所需要遵守的规范</p>\n<p>接口不关心这些类的内部数据，也不关心类中方法的实现细节，只规定这些类中必须提供某些方法</p>\n<p>接口访问修饰符：public 默认</p>\n<p>接口中抽象方法可以不写abstract关键字</p>\n<p>作为接口的实现类必须实现接口中定义的所有方法，否则需要将该类设置为抽象类</p>\n<p>接口中可以包含常量，默认public static final</p>\n<pre><code>public interface ITest {\n    public void func();\n}</code></pre><pre><code>public class A implements ITest {\n\n    @java.lang.Override\n    public void func() {\n\n    }\n}</code></pre><pre><code>INet net = new A();\n</code></pre><p>default 关键字</p>\n<pre><code>public interface ITest {\n    // 默认方法\n    default void func1() {\n\n    }\n    // 静态方法\n    static void func2() {\n\n    }\n}\n\n// 调用接口中的默认方法\nITest.super.func1();</code></pre><p>接口的继承，可以一对多</p>\n<p>在Java中，可以将一个类定义在另一个类中或者一个方法中，这样的类称为内部类</p>\n<p>1、成员内部类</p>\n<p>获取内部类</p>\n<pre><code>A.a1 me = new A().new a1();</code></pre><p>2、静态内部类</p>\n<p>3、方法内部类</p>\n<p>4、匿名内部类</p>\n"},{"title":"ArcGIS二次开发基础配置说明","date":"2019-04-28T14:48:42.000Z","fileName":"ArcGIS_dev","_content":"很早就听说过ArcGIS二次开发各种麻烦所以也一直不打算去做这一块（电脑里装的是VS2017，但ArcEngine老一些的版本不支持这个版本，新的版本又找不到，实在是不想再装一个新的VS），但这学期由于一个小实习的需要，不得不稍微学一下，也算完成任务吧。仔细想想稍微了解下ArcGIS二次开发也不坏，毕竟我还是个学GIS的。。。\n## 开发环境安装\n首先想明确的是，一个电脑里装两个版本的VS2017正常情况下是不会有问题的，之前网上总有些人说这样安装会失败，也许是他们自己的问题吧，反正经过尝试本人是没发现任何问题。同时AE10.2推荐的VS版本是2010或2012，更高的版本会报错，所以感觉极端stupid。\n1. 安装AE之前必须保证先安装VS，而VS的安装包很好找，推荐一个公众号“软件安装管家”，里面应有尽有。\n2. 之后安装ArcGIS Desktop，ArcGIS反正我是感觉是一个水很深的软件，同样推荐上面那个公众号，跟着步骤安装。\n3. 最后开始安装AE，[下载点我,p2f1](https://pan.baidu.com/s/1k5cg94K70yXwLO2ZX0coBg)，注意选择对应VS版本的AE安装。\n    1. 对安装包进行解压，解压Part1然后在解压过程中会弹出对话框加上Part2即可\n    2. 解压后点开解压文件，打开ESRI.exe文件安装相应文件即可\n    3. 打开相应VS版本，查看有没有ArcGIS开发组件即可。\n\n## 基本事项\n本人也没有具体去系统学过所谓ArcGIS二次开发，因为大部分时候的确用不上这些，现在只是所谓面向作业编程。这次作业实现了delaunay三角网以及相应图形的合并，由于老师有样例代码所以很简单。不过还是得吐槽一句，给代码不把框架说清楚，给的接口参考文件说明只有一个名词，比如某接口中，方法Area边上写了个面积，难道我不知道这个单词是面积的意思？关键是这方法怎么调用吧。百度，OK，ArcGIS二次开发基本没人做，然后就只能去查帮助文档了，这本身无可厚非，但说白了，这么个搞清楚架构、理解老师要干啥花三个小时，编程一刻钟的作业，真的蠢。\n\n### 帮助文档\nArcGIS二次开发做的人不多，网上基本上找不到有参考意义的教程（当然某些论坛还是不错的），而这玩意又以接口众多出名（几乎是面向接口编程），所以帮助文档就很重要了。\n一切安装妥当后，在**开始->ArcGIS->ArcObjects help**中打开就能找到，之后在其中选择相应接口之类的查看即可。各种参数和不同语言的不同用法写的还是很清楚的。\n\n### 文件迁移设置变更\n由于是ArcGIS二次开发，所以需要调用外部的ArcMap程序。在代码迁移的时候，由于不同终端上ArcMap存储的文件位置不一致，所以要手动进行更改。\n主要步骤是\n右击项目名称，选择最下面的“属性”，并且选择属性菜单栏中的“调试”，在启动操作中选择“启动外部程序”并在其中将文件路径更改为现在运行终端中的相应文件路径即可。具体如下所示：\n![](img/BlogImg/arcgis1/1.jpg)\n\n### 常见错误处理\n编译调试运行时如果出现了诸如“无法注册程序集 .dll- 拒绝访问。请确保您正在以管理员身份运行应用程序。对注册表项“...”的访问被拒绝”的错误，可以进行如下操作处理。\nWIN+R，运行对话框中输入gpedit.msc，开启组策略，然后一步步地在“计算机配置”-“Windows 设置”-“安全设置”-“本地策略”-“安全选项”，找到右侧的“用户账户控制：以管理员批准模式运行所有管理员”这个项，你会看到这个项默认是启用的，把它设成禁用。如下图\n![](img/BlogImg/arcgis1/2.png)\n之后重启电脑即可。","source":"_posts/GIS/ArcGIS二次开发基础配置说明.md","raw":"---\ntitle: ArcGIS二次开发基础配置说明\ndate: 2019-04-28 22:48:42\ntags:\n    - ArcGIS\ncategories:\n    - GIS\nfileName: ArcGIS_dev\n---\n很早就听说过ArcGIS二次开发各种麻烦所以也一直不打算去做这一块（电脑里装的是VS2017，但ArcEngine老一些的版本不支持这个版本，新的版本又找不到，实在是不想再装一个新的VS），但这学期由于一个小实习的需要，不得不稍微学一下，也算完成任务吧。仔细想想稍微了解下ArcGIS二次开发也不坏，毕竟我还是个学GIS的。。。\n## 开发环境安装\n首先想明确的是，一个电脑里装两个版本的VS2017正常情况下是不会有问题的，之前网上总有些人说这样安装会失败，也许是他们自己的问题吧，反正经过尝试本人是没发现任何问题。同时AE10.2推荐的VS版本是2010或2012，更高的版本会报错，所以感觉极端stupid。\n1. 安装AE之前必须保证先安装VS，而VS的安装包很好找，推荐一个公众号“软件安装管家”，里面应有尽有。\n2. 之后安装ArcGIS Desktop，ArcGIS反正我是感觉是一个水很深的软件，同样推荐上面那个公众号，跟着步骤安装。\n3. 最后开始安装AE，[下载点我,p2f1](https://pan.baidu.com/s/1k5cg94K70yXwLO2ZX0coBg)，注意选择对应VS版本的AE安装。\n    1. 对安装包进行解压，解压Part1然后在解压过程中会弹出对话框加上Part2即可\n    2. 解压后点开解压文件，打开ESRI.exe文件安装相应文件即可\n    3. 打开相应VS版本，查看有没有ArcGIS开发组件即可。\n\n## 基本事项\n本人也没有具体去系统学过所谓ArcGIS二次开发，因为大部分时候的确用不上这些，现在只是所谓面向作业编程。这次作业实现了delaunay三角网以及相应图形的合并，由于老师有样例代码所以很简单。不过还是得吐槽一句，给代码不把框架说清楚，给的接口参考文件说明只有一个名词，比如某接口中，方法Area边上写了个面积，难道我不知道这个单词是面积的意思？关键是这方法怎么调用吧。百度，OK，ArcGIS二次开发基本没人做，然后就只能去查帮助文档了，这本身无可厚非，但说白了，这么个搞清楚架构、理解老师要干啥花三个小时，编程一刻钟的作业，真的蠢。\n\n### 帮助文档\nArcGIS二次开发做的人不多，网上基本上找不到有参考意义的教程（当然某些论坛还是不错的），而这玩意又以接口众多出名（几乎是面向接口编程），所以帮助文档就很重要了。\n一切安装妥当后，在**开始->ArcGIS->ArcObjects help**中打开就能找到，之后在其中选择相应接口之类的查看即可。各种参数和不同语言的不同用法写的还是很清楚的。\n\n### 文件迁移设置变更\n由于是ArcGIS二次开发，所以需要调用外部的ArcMap程序。在代码迁移的时候，由于不同终端上ArcMap存储的文件位置不一致，所以要手动进行更改。\n主要步骤是\n右击项目名称，选择最下面的“属性”，并且选择属性菜单栏中的“调试”，在启动操作中选择“启动外部程序”并在其中将文件路径更改为现在运行终端中的相应文件路径即可。具体如下所示：\n![](img/BlogImg/arcgis1/1.jpg)\n\n### 常见错误处理\n编译调试运行时如果出现了诸如“无法注册程序集 .dll- 拒绝访问。请确保您正在以管理员身份运行应用程序。对注册表项“...”的访问被拒绝”的错误，可以进行如下操作处理。\nWIN+R，运行对话框中输入gpedit.msc，开启组策略，然后一步步地在“计算机配置”-“Windows 设置”-“安全设置”-“本地策略”-“安全选项”，找到右侧的“用户账户控制：以管理员批准模式运行所有管理员”这个项，你会看到这个项默认是启用的，把它设成禁用。如下图\n![](img/BlogImg/arcgis1/2.png)\n之后重启电脑即可。","slug":"GIS/ArcGIS二次开发基础配置说明","published":1,"updated":"2020-06-14T14:36:23.581Z","_id":"ckcox1f6m000868js9bf46cp2","comments":1,"layout":"post","photos":[],"link":"","content":"<p>很早就听说过ArcGIS二次开发各种麻烦所以也一直不打算去做这一块（电脑里装的是VS2017，但ArcEngine老一些的版本不支持这个版本，新的版本又找不到，实在是不想再装一个新的VS），但这学期由于一个小实习的需要，不得不稍微学一下，也算完成任务吧。仔细想想稍微了解下ArcGIS二次开发也不坏，毕竟我还是个学GIS的。。。</p>\n<h2 id=\"开发环境安装\"><a href=\"#开发环境安装\" class=\"headerlink\" title=\"开发环境安装\"></a>开发环境安装</h2><p>首先想明确的是，一个电脑里装两个版本的VS2017正常情况下是不会有问题的，之前网上总有些人说这样安装会失败，也许是他们自己的问题吧，反正经过尝试本人是没发现任何问题。同时AE10.2推荐的VS版本是2010或2012，更高的版本会报错，所以感觉极端stupid。</p>\n<ol>\n<li>安装AE之前必须保证先安装VS，而VS的安装包很好找，推荐一个公众号“软件安装管家”，里面应有尽有。</li>\n<li>之后安装ArcGIS Desktop，ArcGIS反正我是感觉是一个水很深的软件，同样推荐上面那个公众号，跟着步骤安装。</li>\n<li>最后开始安装AE，<a href=\"https://pan.baidu.com/s/1k5cg94K70yXwLO2ZX0coBg\" target=\"_blank\" rel=\"noopener\">下载点我,p2f1</a>，注意选择对应VS版本的AE安装。<ol>\n<li>对安装包进行解压，解压Part1然后在解压过程中会弹出对话框加上Part2即可</li>\n<li>解压后点开解压文件，打开ESRI.exe文件安装相应文件即可</li>\n<li>打开相应VS版本，查看有没有ArcGIS开发组件即可。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"基本事项\"><a href=\"#基本事项\" class=\"headerlink\" title=\"基本事项\"></a>基本事项</h2><p>本人也没有具体去系统学过所谓ArcGIS二次开发，因为大部分时候的确用不上这些，现在只是所谓面向作业编程。这次作业实现了delaunay三角网以及相应图形的合并，由于老师有样例代码所以很简单。不过还是得吐槽一句，给代码不把框架说清楚，给的接口参考文件说明只有一个名词，比如某接口中，方法Area边上写了个面积，难道我不知道这个单词是面积的意思？关键是这方法怎么调用吧。百度，OK，ArcGIS二次开发基本没人做，然后就只能去查帮助文档了，这本身无可厚非，但说白了，这么个搞清楚架构、理解老师要干啥花三个小时，编程一刻钟的作业，真的蠢。</p>\n<h3 id=\"帮助文档\"><a href=\"#帮助文档\" class=\"headerlink\" title=\"帮助文档\"></a>帮助文档</h3><p>ArcGIS二次开发做的人不多，网上基本上找不到有参考意义的教程（当然某些论坛还是不错的），而这玩意又以接口众多出名（几乎是面向接口编程），所以帮助文档就很重要了。<br>一切安装妥当后，在<strong>开始-&gt;ArcGIS-&gt;ArcObjects help</strong>中打开就能找到，之后在其中选择相应接口之类的查看即可。各种参数和不同语言的不同用法写的还是很清楚的。</p>\n<h3 id=\"文件迁移设置变更\"><a href=\"#文件迁移设置变更\" class=\"headerlink\" title=\"文件迁移设置变更\"></a>文件迁移设置变更</h3><p>由于是ArcGIS二次开发，所以需要调用外部的ArcMap程序。在代码迁移的时候，由于不同终端上ArcMap存储的文件位置不一致，所以要手动进行更改。<br>主要步骤是<br>右击项目名称，选择最下面的“属性”，并且选择属性菜单栏中的“调试”，在启动操作中选择“启动外部程序”并在其中将文件路径更改为现在运行终端中的相应文件路径即可。具体如下所示：<br><img src=\"/page/ArcGIS_dev/BlogImg/arcgis1/1.jpg\" alt></p>\n<h3 id=\"常见错误处理\"><a href=\"#常见错误处理\" class=\"headerlink\" title=\"常见错误处理\"></a>常见错误处理</h3><p>编译调试运行时如果出现了诸如“无法注册程序集 .dll- 拒绝访问。请确保您正在以管理员身份运行应用程序。对注册表项“…”的访问被拒绝”的错误，可以进行如下操作处理。<br>WIN+R，运行对话框中输入gpedit.msc，开启组策略，然后一步步地在“计算机配置”-“Windows 设置”-“安全设置”-“本地策略”-“安全选项”，找到右侧的“用户账户控制：以管理员批准模式运行所有管理员”这个项，你会看到这个项默认是启用的，把它设成禁用。如下图<br><img src=\"/page/ArcGIS_dev/BlogImg/arcgis1/2.png\" alt><br>之后重启电脑即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>很早就听说过ArcGIS二次开发各种麻烦所以也一直不打算去做这一块（电脑里装的是VS2017，但ArcEngine老一些的版本不支持这个版本，新的版本又找不到，实在是不想再装一个新的VS），但这学期由于一个小实习的需要，不得不稍微学一下，也算完成任务吧。仔细想想稍微了解下ArcGIS二次开发也不坏，毕竟我还是个学GIS的。。。</p>\n<h2 id=\"开发环境安装\"><a href=\"#开发环境安装\" class=\"headerlink\" title=\"开发环境安装\"></a>开发环境安装</h2><p>首先想明确的是，一个电脑里装两个版本的VS2017正常情况下是不会有问题的，之前网上总有些人说这样安装会失败，也许是他们自己的问题吧，反正经过尝试本人是没发现任何问题。同时AE10.2推荐的VS版本是2010或2012，更高的版本会报错，所以感觉极端stupid。</p>\n<ol>\n<li>安装AE之前必须保证先安装VS，而VS的安装包很好找，推荐一个公众号“软件安装管家”，里面应有尽有。</li>\n<li>之后安装ArcGIS Desktop，ArcGIS反正我是感觉是一个水很深的软件，同样推荐上面那个公众号，跟着步骤安装。</li>\n<li>最后开始安装AE，<a href=\"https://pan.baidu.com/s/1k5cg94K70yXwLO2ZX0coBg\" target=\"_blank\" rel=\"noopener\">下载点我,p2f1</a>，注意选择对应VS版本的AE安装。<ol>\n<li>对安装包进行解压，解压Part1然后在解压过程中会弹出对话框加上Part2即可</li>\n<li>解压后点开解压文件，打开ESRI.exe文件安装相应文件即可</li>\n<li>打开相应VS版本，查看有没有ArcGIS开发组件即可。</li>\n</ol>\n</li>\n</ol>\n<h2 id=\"基本事项\"><a href=\"#基本事项\" class=\"headerlink\" title=\"基本事项\"></a>基本事项</h2><p>本人也没有具体去系统学过所谓ArcGIS二次开发，因为大部分时候的确用不上这些，现在只是所谓面向作业编程。这次作业实现了delaunay三角网以及相应图形的合并，由于老师有样例代码所以很简单。不过还是得吐槽一句，给代码不把框架说清楚，给的接口参考文件说明只有一个名词，比如某接口中，方法Area边上写了个面积，难道我不知道这个单词是面积的意思？关键是这方法怎么调用吧。百度，OK，ArcGIS二次开发基本没人做，然后就只能去查帮助文档了，这本身无可厚非，但说白了，这么个搞清楚架构、理解老师要干啥花三个小时，编程一刻钟的作业，真的蠢。</p>\n<h3 id=\"帮助文档\"><a href=\"#帮助文档\" class=\"headerlink\" title=\"帮助文档\"></a>帮助文档</h3><p>ArcGIS二次开发做的人不多，网上基本上找不到有参考意义的教程（当然某些论坛还是不错的），而这玩意又以接口众多出名（几乎是面向接口编程），所以帮助文档就很重要了。<br>一切安装妥当后，在<strong>开始-&gt;ArcGIS-&gt;ArcObjects help</strong>中打开就能找到，之后在其中选择相应接口之类的查看即可。各种参数和不同语言的不同用法写的还是很清楚的。</p>\n<h3 id=\"文件迁移设置变更\"><a href=\"#文件迁移设置变更\" class=\"headerlink\" title=\"文件迁移设置变更\"></a>文件迁移设置变更</h3><p>由于是ArcGIS二次开发，所以需要调用外部的ArcMap程序。在代码迁移的时候，由于不同终端上ArcMap存储的文件位置不一致，所以要手动进行更改。<br>主要步骤是<br>右击项目名称，选择最下面的“属性”，并且选择属性菜单栏中的“调试”，在启动操作中选择“启动外部程序”并在其中将文件路径更改为现在运行终端中的相应文件路径即可。具体如下所示：<br><img src=\"/page/ArcGIS_dev/BlogImg/arcgis1/1.jpg\" alt></p>\n<h3 id=\"常见错误处理\"><a href=\"#常见错误处理\" class=\"headerlink\" title=\"常见错误处理\"></a>常见错误处理</h3><p>编译调试运行时如果出现了诸如“无法注册程序集 .dll- 拒绝访问。请确保您正在以管理员身份运行应用程序。对注册表项“…”的访问被拒绝”的错误，可以进行如下操作处理。<br>WIN+R，运行对话框中输入gpedit.msc，开启组策略，然后一步步地在“计算机配置”-“Windows 设置”-“安全设置”-“本地策略”-“安全选项”，找到右侧的“用户账户控制：以管理员批准模式运行所有管理员”这个项，你会看到这个项默认是启用的，把它设成禁用。如下图<br><img src=\"/page/ArcGIS_dev/BlogImg/arcgis1/2.png\" alt><br>之后重启电脑即可。</p>\n"},{"title":"Hexo博客部署到腾讯云服务器全流程","date":"2020-03-12T18:48:15.000Z","fileName":"hexo2","_content":"\n部署到Githubpage上在国内访问速度很慢，正好前段时间买了一个腾讯云服务器，就干脆把hexo生成的博客文件直接放到云上跑算了，本文记录将hexo同时部署到GitHub与腾讯云服务器的过程。参考博客https://blog.csdn.net/StaunchKai/article/details/82878928\n\n部署到Githubpage上在国内访问速度很慢，正好前段时间买了一个腾讯云服务器，就干脆把hexo生成的博客文件直接放到云上跑算了，本文记录将hexo同时部署到GitHub与腾讯云服务器的过程。参考博客https://blog.csdn.net/StaunchKai/article/details/82878928\n\n\n\nHexo署到Githubpage上在国内访问速度很慢，正好前段时间买了一个腾讯云服务器，就干脆把hexo生成的博客文件直接放到云上跑算了，本文记录将hexo同时部署到GitHub与腾讯云服务器的过程。参考博客https://blog.csdn.net/StaunchKai/article/details/82878928\n\n## 部署环境\n\n* 本地环境\n  * Ubuntu 18.04（64bit）\n  * 所需环境：git，Node.js，hexo\n* 服务器环境\n  * 腾讯云（CentOS 7.6 64bit）\n  * 所需环境：git，Nginx\n\n## 服务器配置\n\n### 安装git\n\n安装依赖包：\n\n```\nyum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel\nyum install  gcc perl-ExtUtils-MakeMaker\n```\n\n卸载旧版本git（如果服务器自带git太旧的话）\n\n```\ncd /usr/local/src   // 选择文件保存位置\nwget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.19.0.tar.gz   // 下载链接\ntar -zxvf git-2.19.0.tar.gz   // 解压\n```\n\n具体的版本选择可在https://mirrors.edge.kernel.org/pub/software/scm/git/ 查看。\n\n编译安装\n\n```\ncd git-2.19.0   // 进入文件夹\nmake prefix=/usr/local/git all  // 编译源码\nmake prefix=/usr/local/git install  // 安装至 /usr/local/git 路径\n```\n\n之后正常的话`git --version`就可以看到git的版本了，如果在终端输入git没反应，则应该将git的安装位置加入环境变量中。\n\n### 创建git用户\n\n```\nadduser git\npasswd git\nchmod 740 /etc/sudoers\nvim /etc/sudoers\n```\n\n找到以下内容\n\n```\n## Allow root to run any commands anywhere\nroot    ALL=(ALL)       ALL\n```\n\n在root的下面添加一行\n\n```\ngit ALL=(ALL) ALL\n```\n\n保存退出后将权限改回来\n\n```\nchmod 400 /etc/sudoers\n```\n\n### 密匙配置\n\n与将本地博客文件连接至GitHub一样，将本地的`id_rsa.pub`复制好，在服务器创建.ssh下的文件，粘贴进去。\n\n```\nsu git\nmkdir ~/.ssh\nvim ~/.ssh/authorized_keys\n```\n\n修改权限\n\n```\ncd ~\nchmod 600 .ssh/authorzied_keys\nchmod 700 .ssh\n```\n\n### 测试连接\n\n在本地终端输入\n\n```\nssh -v git@SERVER\n```\n\nSERVER为你的服务器的公网地址，在控制台可以找到，如果成功连接说明服务器git配置成功。\n\n### 创建网站根目录\n\n网站根目录就是之后存放博客静态文件与资源的位置，你可以自己挑选位置创建你的根目录，之后再赋予权限。\n\n```\nsu root\nmkdir /home/myblog    # 此目录为网站的根目录\nchown git:git -R /home/myblog\n```\n\n### 安装Nginx\n\n```\nyum install -y nginx    // 安装\nsystemctl start nginx.service     // 启动服务\n```\n\n此时访问**公网ip/80**应该就能看到nginx的初始界面。\n\n### 配置Nginx\n\n使用`nginx -t`查看配置文件位置，一般为`/etc/nginx/nginx.conf`\n\n打开nginx.conf文件，修改配置文件如下\n\n```\nserver {\n    listen       80 default_server;\n    listen       [::]:80 default_server;\n    server_name  www.ziyedy.top;    # 修改为自己的域名\n    root         /home/myblog;    # 修改为网站的根目录\n\n    # Load configuration files for the default server block.\n    include /etc/nginx/default.d/*.conf;\n\n    location / {\n    \tindex index.html\t# 设置自己的index网页\n    }\n\n    error_page 404 /404.html;\n        location = /40x.html {\n    }\n\n    error_page 500 502 503 504 /50x.html;\n        location = /50x.html {\n    }\n}\n\n```\n\n之后可以使用`nginx -t`检查配置文件中是否有语法错误，之后重启服务即可。\n\n## hexo自动部署\n\n### 建立git裸库\n\n在与文件同一根目录下建立裸库\n\n```\nsu root\ngit init --bare blog.git\n```\n\n这时，`git` 用户的 `~` 目录下就存在一个 `blog.git` 文件夹，可使用 `ls` 命令查看。再修改 `blog.git` 的权限。\n\n```\nchown git:git -R blog.git\n```\n\n### 使用git-hooks同步网站根目录\n\n在这使用的是 `post-receive` 这个钩子，当 `git` 有收发的时候就会调用这个钩子。 在 `blog.git` 裸库的 hooks 文件夹中，新建 `post-receive` 文件。\n\n```\nvim blog.git/hooks/post-receive\n```\n\n填入以下内容，注意myblog应该填入自己的根目录文件名\n\n```\n#!/bin/sh\ngit --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f\n```\n\n保存后，赋予该文件可执行权限\n\n```\nchmod +x /home/git/blog.git/hooks/post-receive\n```\n\n### 本地配置\n\n与部署到GitHub相同，在本地博客文件根目录下的`_config.yml` 文件中修改`deploy`设置如下。SERVER为服务器的公网ip，如果不想部署到GitHub了将`github`一行删去即可。\n\n```\ndeploy:\n  type: git\n  repo:\n    github: git@github.com:xxxx/xxxx.github.io.git\n    git1: git@SERVER:/home/git/blog.git \n  branch: master\n```\n\n之后正常配置\n\n```\nhexo clean\nhexo g\nhexo d\n```\n\n这是输入你的公网ip即可进入你的博客，要实现域名访问，在你的域名内解析你的公网ip即可。","source":"_posts/前端/Hexo/Hexo博客部署到腾讯云服务器全流程.md","raw":"---\ntitle: Hexo博客部署到腾讯云服务器全流程\ndate: 2020-03-13 02:48:15\ntags:\n\t- hexo\n\t- 云服务器\ncategories:\n\t- 前端\n\t- hexo\nfileName: hexo2\n---\n\n部署到Githubpage上在国内访问速度很慢，正好前段时间买了一个腾讯云服务器，就干脆把hexo生成的博客文件直接放到云上跑算了，本文记录将hexo同时部署到GitHub与腾讯云服务器的过程。参考博客https://blog.csdn.net/StaunchKai/article/details/82878928\n\n部署到Githubpage上在国内访问速度很慢，正好前段时间买了一个腾讯云服务器，就干脆把hexo生成的博客文件直接放到云上跑算了，本文记录将hexo同时部署到GitHub与腾讯云服务器的过程。参考博客https://blog.csdn.net/StaunchKai/article/details/82878928\n\n\n\nHexo署到Githubpage上在国内访问速度很慢，正好前段时间买了一个腾讯云服务器，就干脆把hexo生成的博客文件直接放到云上跑算了，本文记录将hexo同时部署到GitHub与腾讯云服务器的过程。参考博客https://blog.csdn.net/StaunchKai/article/details/82878928\n\n## 部署环境\n\n* 本地环境\n  * Ubuntu 18.04（64bit）\n  * 所需环境：git，Node.js，hexo\n* 服务器环境\n  * 腾讯云（CentOS 7.6 64bit）\n  * 所需环境：git，Nginx\n\n## 服务器配置\n\n### 安装git\n\n安装依赖包：\n\n```\nyum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel\nyum install  gcc perl-ExtUtils-MakeMaker\n```\n\n卸载旧版本git（如果服务器自带git太旧的话）\n\n```\ncd /usr/local/src   // 选择文件保存位置\nwget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.19.0.tar.gz   // 下载链接\ntar -zxvf git-2.19.0.tar.gz   // 解压\n```\n\n具体的版本选择可在https://mirrors.edge.kernel.org/pub/software/scm/git/ 查看。\n\n编译安装\n\n```\ncd git-2.19.0   // 进入文件夹\nmake prefix=/usr/local/git all  // 编译源码\nmake prefix=/usr/local/git install  // 安装至 /usr/local/git 路径\n```\n\n之后正常的话`git --version`就可以看到git的版本了，如果在终端输入git没反应，则应该将git的安装位置加入环境变量中。\n\n### 创建git用户\n\n```\nadduser git\npasswd git\nchmod 740 /etc/sudoers\nvim /etc/sudoers\n```\n\n找到以下内容\n\n```\n## Allow root to run any commands anywhere\nroot    ALL=(ALL)       ALL\n```\n\n在root的下面添加一行\n\n```\ngit ALL=(ALL) ALL\n```\n\n保存退出后将权限改回来\n\n```\nchmod 400 /etc/sudoers\n```\n\n### 密匙配置\n\n与将本地博客文件连接至GitHub一样，将本地的`id_rsa.pub`复制好，在服务器创建.ssh下的文件，粘贴进去。\n\n```\nsu git\nmkdir ~/.ssh\nvim ~/.ssh/authorized_keys\n```\n\n修改权限\n\n```\ncd ~\nchmod 600 .ssh/authorzied_keys\nchmod 700 .ssh\n```\n\n### 测试连接\n\n在本地终端输入\n\n```\nssh -v git@SERVER\n```\n\nSERVER为你的服务器的公网地址，在控制台可以找到，如果成功连接说明服务器git配置成功。\n\n### 创建网站根目录\n\n网站根目录就是之后存放博客静态文件与资源的位置，你可以自己挑选位置创建你的根目录，之后再赋予权限。\n\n```\nsu root\nmkdir /home/myblog    # 此目录为网站的根目录\nchown git:git -R /home/myblog\n```\n\n### 安装Nginx\n\n```\nyum install -y nginx    // 安装\nsystemctl start nginx.service     // 启动服务\n```\n\n此时访问**公网ip/80**应该就能看到nginx的初始界面。\n\n### 配置Nginx\n\n使用`nginx -t`查看配置文件位置，一般为`/etc/nginx/nginx.conf`\n\n打开nginx.conf文件，修改配置文件如下\n\n```\nserver {\n    listen       80 default_server;\n    listen       [::]:80 default_server;\n    server_name  www.ziyedy.top;    # 修改为自己的域名\n    root         /home/myblog;    # 修改为网站的根目录\n\n    # Load configuration files for the default server block.\n    include /etc/nginx/default.d/*.conf;\n\n    location / {\n    \tindex index.html\t# 设置自己的index网页\n    }\n\n    error_page 404 /404.html;\n        location = /40x.html {\n    }\n\n    error_page 500 502 503 504 /50x.html;\n        location = /50x.html {\n    }\n}\n\n```\n\n之后可以使用`nginx -t`检查配置文件中是否有语法错误，之后重启服务即可。\n\n## hexo自动部署\n\n### 建立git裸库\n\n在与文件同一根目录下建立裸库\n\n```\nsu root\ngit init --bare blog.git\n```\n\n这时，`git` 用户的 `~` 目录下就存在一个 `blog.git` 文件夹，可使用 `ls` 命令查看。再修改 `blog.git` 的权限。\n\n```\nchown git:git -R blog.git\n```\n\n### 使用git-hooks同步网站根目录\n\n在这使用的是 `post-receive` 这个钩子，当 `git` 有收发的时候就会调用这个钩子。 在 `blog.git` 裸库的 hooks 文件夹中，新建 `post-receive` 文件。\n\n```\nvim blog.git/hooks/post-receive\n```\n\n填入以下内容，注意myblog应该填入自己的根目录文件名\n\n```\n#!/bin/sh\ngit --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f\n```\n\n保存后，赋予该文件可执行权限\n\n```\nchmod +x /home/git/blog.git/hooks/post-receive\n```\n\n### 本地配置\n\n与部署到GitHub相同，在本地博客文件根目录下的`_config.yml` 文件中修改`deploy`设置如下。SERVER为服务器的公网ip，如果不想部署到GitHub了将`github`一行删去即可。\n\n```\ndeploy:\n  type: git\n  repo:\n    github: git@github.com:xxxx/xxxx.github.io.git\n    git1: git@SERVER:/home/git/blog.git \n  branch: master\n```\n\n之后正常配置\n\n```\nhexo clean\nhexo g\nhexo d\n```\n\n这是输入你的公网ip即可进入你的博客，要实现域名访问，在你的域名内解析你的公网ip即可。","slug":"前端/Hexo/Hexo博客部署到腾讯云服务器全流程","published":1,"updated":"2020-07-16T15:55:04.633Z","_id":"ckcox2plr000p68js9kze4iy6","comments":1,"layout":"post","photos":[],"link":"","content":"<p>部署到Githubpage上在国内访问速度很慢，正好前段时间买了一个腾讯云服务器，就干脆把hexo生成的博客文件直接放到云上跑算了，本文记录将hexo同时部署到GitHub与腾讯云服务器的过程。参考博客<a href=\"https://blog.csdn.net/StaunchKai/article/details/82878928\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/StaunchKai/article/details/82878928</a></p>\n<p>部署到Githubpage上在国内访问速度很慢，正好前段时间买了一个腾讯云服务器，就干脆把hexo生成的博客文件直接放到云上跑算了，本文记录将hexo同时部署到GitHub与腾讯云服务器的过程。参考博客<a href=\"https://blog.csdn.net/StaunchKai/article/details/82878928\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/StaunchKai/article/details/82878928</a></p>\n<p>Hexo署到Githubpage上在国内访问速度很慢，正好前段时间买了一个腾讯云服务器，就干脆把hexo生成的博客文件直接放到云上跑算了，本文记录将hexo同时部署到GitHub与腾讯云服务器的过程。参考博客<a href=\"https://blog.csdn.net/StaunchKai/article/details/82878928\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/StaunchKai/article/details/82878928</a></p>\n<h2 id=\"部署环境\"><a href=\"#部署环境\" class=\"headerlink\" title=\"部署环境\"></a>部署环境</h2><ul>\n<li>本地环境<ul>\n<li>Ubuntu 18.04（64bit）</li>\n<li>所需环境：git，Node.js，hexo</li>\n</ul>\n</li>\n<li>服务器环境<ul>\n<li>腾讯云（CentOS 7.6 64bit）</li>\n<li>所需环境：git，Nginx</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h2><h3 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h3><p>安装依赖包：</p>\n<pre><code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel\nyum install  gcc perl-ExtUtils-MakeMaker</code></pre><p>卸载旧版本git（如果服务器自带git太旧的话）</p>\n<pre><code>cd /usr/local/src   // 选择文件保存位置\nwget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.19.0.tar.gz   // 下载链接\ntar -zxvf git-2.19.0.tar.gz   // 解压</code></pre><p>具体的版本选择可在<a href=\"https://mirrors.edge.kernel.org/pub/software/scm/git/\" target=\"_blank\" rel=\"noopener\">https://mirrors.edge.kernel.org/pub/software/scm/git/</a> 查看。</p>\n<p>编译安装</p>\n<pre><code>cd git-2.19.0   // 进入文件夹\nmake prefix=/usr/local/git all  // 编译源码\nmake prefix=/usr/local/git install  // 安装至 /usr/local/git 路径</code></pre><p>之后正常的话<code>git --version</code>就可以看到git的版本了，如果在终端输入git没反应，则应该将git的安装位置加入环境变量中。</p>\n<h3 id=\"创建git用户\"><a href=\"#创建git用户\" class=\"headerlink\" title=\"创建git用户\"></a>创建git用户</h3><pre><code>adduser git\npasswd git\nchmod 740 /etc/sudoers\nvim /etc/sudoers</code></pre><p>找到以下内容</p>\n<pre><code>## Allow root to run any commands anywhere\nroot    ALL=(ALL)       ALL</code></pre><p>在root的下面添加一行</p>\n<pre><code>git ALL=(ALL) ALL</code></pre><p>保存退出后将权限改回来</p>\n<pre><code>chmod 400 /etc/sudoers</code></pre><h3 id=\"密匙配置\"><a href=\"#密匙配置\" class=\"headerlink\" title=\"密匙配置\"></a>密匙配置</h3><p>与将本地博客文件连接至GitHub一样，将本地的<code>id_rsa.pub</code>复制好，在服务器创建.ssh下的文件，粘贴进去。</p>\n<pre><code>su git\nmkdir ~/.ssh\nvim ~/.ssh/authorized_keys</code></pre><p>修改权限</p>\n<pre><code>cd ~\nchmod 600 .ssh/authorzied_keys\nchmod 700 .ssh</code></pre><h3 id=\"测试连接\"><a href=\"#测试连接\" class=\"headerlink\" title=\"测试连接\"></a>测试连接</h3><p>在本地终端输入</p>\n<pre><code>ssh -v git@SERVER</code></pre><p>SERVER为你的服务器的公网地址，在控制台可以找到，如果成功连接说明服务器git配置成功。</p>\n<h3 id=\"创建网站根目录\"><a href=\"#创建网站根目录\" class=\"headerlink\" title=\"创建网站根目录\"></a>创建网站根目录</h3><p>网站根目录就是之后存放博客静态文件与资源的位置，你可以自己挑选位置创建你的根目录，之后再赋予权限。</p>\n<pre><code>su root\nmkdir /home/myblog    # 此目录为网站的根目录\nchown git:git -R /home/myblog</code></pre><h3 id=\"安装Nginx\"><a href=\"#安装Nginx\" class=\"headerlink\" title=\"安装Nginx\"></a>安装Nginx</h3><pre><code>yum install -y nginx    // 安装\nsystemctl start nginx.service     // 启动服务</code></pre><p>此时访问<strong>公网ip/80</strong>应该就能看到nginx的初始界面。</p>\n<h3 id=\"配置Nginx\"><a href=\"#配置Nginx\" class=\"headerlink\" title=\"配置Nginx\"></a>配置Nginx</h3><p>使用<code>nginx -t</code>查看配置文件位置，一般为<code>/etc/nginx/nginx.conf</code></p>\n<p>打开nginx.conf文件，修改配置文件如下</p>\n<pre><code>server {\n    listen       80 default_server;\n    listen       [::]:80 default_server;\n    server_name  www.ziyedy.top;    # 修改为自己的域名\n    root         /home/myblog;    # 修改为网站的根目录\n\n    # Load configuration files for the default server block.\n    include /etc/nginx/default.d/*.conf;\n\n    location / {\n        index index.html    # 设置自己的index网页\n    }\n\n    error_page 404 /404.html;\n        location = /40x.html {\n    }\n\n    error_page 500 502 503 504 /50x.html;\n        location = /50x.html {\n    }\n}\n</code></pre><p>之后可以使用<code>nginx -t</code>检查配置文件中是否有语法错误，之后重启服务即可。</p>\n<h2 id=\"hexo自动部署\"><a href=\"#hexo自动部署\" class=\"headerlink\" title=\"hexo自动部署\"></a>hexo自动部署</h2><h3 id=\"建立git裸库\"><a href=\"#建立git裸库\" class=\"headerlink\" title=\"建立git裸库\"></a>建立git裸库</h3><p>在与文件同一根目录下建立裸库</p>\n<pre><code>su root\ngit init --bare blog.git</code></pre><p>这时，<code>git</code> 用户的 <code>~</code> 目录下就存在一个 <code>blog.git</code> 文件夹，可使用 <code>ls</code> 命令查看。再修改 <code>blog.git</code> 的权限。</p>\n<pre><code>chown git:git -R blog.git</code></pre><h3 id=\"使用git-hooks同步网站根目录\"><a href=\"#使用git-hooks同步网站根目录\" class=\"headerlink\" title=\"使用git-hooks同步网站根目录\"></a>使用git-hooks同步网站根目录</h3><p>在这使用的是 <code>post-receive</code> 这个钩子，当 <code>git</code> 有收发的时候就会调用这个钩子。 在 <code>blog.git</code> 裸库的 hooks 文件夹中，新建 <code>post-receive</code> 文件。</p>\n<pre><code>vim blog.git/hooks/post-receive</code></pre><p>填入以下内容，注意myblog应该填入自己的根目录文件名</p>\n<pre><code>#!/bin/sh\ngit --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f</code></pre><p>保存后，赋予该文件可执行权限</p>\n<pre><code>chmod +x /home/git/blog.git/hooks/post-receive</code></pre><h3 id=\"本地配置\"><a href=\"#本地配置\" class=\"headerlink\" title=\"本地配置\"></a>本地配置</h3><p>与部署到GitHub相同，在本地博客文件根目录下的<code>_config.yml</code> 文件中修改<code>deploy</code>设置如下。SERVER为服务器的公网ip，如果不想部署到GitHub了将<code>github</code>一行删去即可。</p>\n<pre><code>deploy:\n  type: git\n  repo:\n    github: git@github.com:xxxx/xxxx.github.io.git\n    git1: git@SERVER:/home/git/blog.git \n  branch: master</code></pre><p>之后正常配置</p>\n<pre><code>hexo clean\nhexo g\nhexo d</code></pre><p>这是输入你的公网ip即可进入你的博客，要实现域名访问，在你的域名内解析你的公网ip即可。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>部署到Githubpage上在国内访问速度很慢，正好前段时间买了一个腾讯云服务器，就干脆把hexo生成的博客文件直接放到云上跑算了，本文记录将hexo同时部署到GitHub与腾讯云服务器的过程。参考博客<a href=\"https://blog.csdn.net/StaunchKai/article/details/82878928\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/StaunchKai/article/details/82878928</a></p>\n<p>部署到Githubpage上在国内访问速度很慢，正好前段时间买了一个腾讯云服务器，就干脆把hexo生成的博客文件直接放到云上跑算了，本文记录将hexo同时部署到GitHub与腾讯云服务器的过程。参考博客<a href=\"https://blog.csdn.net/StaunchKai/article/details/82878928\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/StaunchKai/article/details/82878928</a></p>\n<p>Hexo署到Githubpage上在国内访问速度很慢，正好前段时间买了一个腾讯云服务器，就干脆把hexo生成的博客文件直接放到云上跑算了，本文记录将hexo同时部署到GitHub与腾讯云服务器的过程。参考博客<a href=\"https://blog.csdn.net/StaunchKai/article/details/82878928\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/StaunchKai/article/details/82878928</a></p>\n<h2 id=\"部署环境\"><a href=\"#部署环境\" class=\"headerlink\" title=\"部署环境\"></a>部署环境</h2><ul>\n<li>本地环境<ul>\n<li>Ubuntu 18.04（64bit）</li>\n<li>所需环境：git，Node.js，hexo</li>\n</ul>\n</li>\n<li>服务器环境<ul>\n<li>腾讯云（CentOS 7.6 64bit）</li>\n<li>所需环境：git，Nginx</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h2><h3 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h3><p>安装依赖包：</p>\n<pre><code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel\nyum install  gcc perl-ExtUtils-MakeMaker</code></pre><p>卸载旧版本git（如果服务器自带git太旧的话）</p>\n<pre><code>cd /usr/local/src   // 选择文件保存位置\nwget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.19.0.tar.gz   // 下载链接\ntar -zxvf git-2.19.0.tar.gz   // 解压</code></pre><p>具体的版本选择可在<a href=\"https://mirrors.edge.kernel.org/pub/software/scm/git/\" target=\"_blank\" rel=\"noopener\">https://mirrors.edge.kernel.org/pub/software/scm/git/</a> 查看。</p>\n<p>编译安装</p>\n<pre><code>cd git-2.19.0   // 进入文件夹\nmake prefix=/usr/local/git all  // 编译源码\nmake prefix=/usr/local/git install  // 安装至 /usr/local/git 路径</code></pre><p>之后正常的话<code>git --version</code>就可以看到git的版本了，如果在终端输入git没反应，则应该将git的安装位置加入环境变量中。</p>\n<h3 id=\"创建git用户\"><a href=\"#创建git用户\" class=\"headerlink\" title=\"创建git用户\"></a>创建git用户</h3><pre><code>adduser git\npasswd git\nchmod 740 /etc/sudoers\nvim /etc/sudoers</code></pre><p>找到以下内容</p>\n<pre><code>## Allow root to run any commands anywhere\nroot    ALL=(ALL)       ALL</code></pre><p>在root的下面添加一行</p>\n<pre><code>git ALL=(ALL) ALL</code></pre><p>保存退出后将权限改回来</p>\n<pre><code>chmod 400 /etc/sudoers</code></pre><h3 id=\"密匙配置\"><a href=\"#密匙配置\" class=\"headerlink\" title=\"密匙配置\"></a>密匙配置</h3><p>与将本地博客文件连接至GitHub一样，将本地的<code>id_rsa.pub</code>复制好，在服务器创建.ssh下的文件，粘贴进去。</p>\n<pre><code>su git\nmkdir ~/.ssh\nvim ~/.ssh/authorized_keys</code></pre><p>修改权限</p>\n<pre><code>cd ~\nchmod 600 .ssh/authorzied_keys\nchmod 700 .ssh</code></pre><h3 id=\"测试连接\"><a href=\"#测试连接\" class=\"headerlink\" title=\"测试连接\"></a>测试连接</h3><p>在本地终端输入</p>\n<pre><code>ssh -v git@SERVER</code></pre><p>SERVER为你的服务器的公网地址，在控制台可以找到，如果成功连接说明服务器git配置成功。</p>\n<h3 id=\"创建网站根目录\"><a href=\"#创建网站根目录\" class=\"headerlink\" title=\"创建网站根目录\"></a>创建网站根目录</h3><p>网站根目录就是之后存放博客静态文件与资源的位置，你可以自己挑选位置创建你的根目录，之后再赋予权限。</p>\n<pre><code>su root\nmkdir /home/myblog    # 此目录为网站的根目录\nchown git:git -R /home/myblog</code></pre><h3 id=\"安装Nginx\"><a href=\"#安装Nginx\" class=\"headerlink\" title=\"安装Nginx\"></a>安装Nginx</h3><pre><code>yum install -y nginx    // 安装\nsystemctl start nginx.service     // 启动服务</code></pre><p>此时访问<strong>公网ip/80</strong>应该就能看到nginx的初始界面。</p>\n<h3 id=\"配置Nginx\"><a href=\"#配置Nginx\" class=\"headerlink\" title=\"配置Nginx\"></a>配置Nginx</h3><p>使用<code>nginx -t</code>查看配置文件位置，一般为<code>/etc/nginx/nginx.conf</code></p>\n<p>打开nginx.conf文件，修改配置文件如下</p>\n<pre><code>server {\n    listen       80 default_server;\n    listen       [::]:80 default_server;\n    server_name  www.ziyedy.top;    # 修改为自己的域名\n    root         /home/myblog;    # 修改为网站的根目录\n\n    # Load configuration files for the default server block.\n    include /etc/nginx/default.d/*.conf;\n\n    location / {\n        index index.html    # 设置自己的index网页\n    }\n\n    error_page 404 /404.html;\n        location = /40x.html {\n    }\n\n    error_page 500 502 503 504 /50x.html;\n        location = /50x.html {\n    }\n}\n</code></pre><p>之后可以使用<code>nginx -t</code>检查配置文件中是否有语法错误，之后重启服务即可。</p>\n<h2 id=\"hexo自动部署\"><a href=\"#hexo自动部署\" class=\"headerlink\" title=\"hexo自动部署\"></a>hexo自动部署</h2><h3 id=\"建立git裸库\"><a href=\"#建立git裸库\" class=\"headerlink\" title=\"建立git裸库\"></a>建立git裸库</h3><p>在与文件同一根目录下建立裸库</p>\n<pre><code>su root\ngit init --bare blog.git</code></pre><p>这时，<code>git</code> 用户的 <code>~</code> 目录下就存在一个 <code>blog.git</code> 文件夹，可使用 <code>ls</code> 命令查看。再修改 <code>blog.git</code> 的权限。</p>\n<pre><code>chown git:git -R blog.git</code></pre><h3 id=\"使用git-hooks同步网站根目录\"><a href=\"#使用git-hooks同步网站根目录\" class=\"headerlink\" title=\"使用git-hooks同步网站根目录\"></a>使用git-hooks同步网站根目录</h3><p>在这使用的是 <code>post-receive</code> 这个钩子，当 <code>git</code> 有收发的时候就会调用这个钩子。 在 <code>blog.git</code> 裸库的 hooks 文件夹中，新建 <code>post-receive</code> 文件。</p>\n<pre><code>vim blog.git/hooks/post-receive</code></pre><p>填入以下内容，注意myblog应该填入自己的根目录文件名</p>\n<pre><code>#!/bin/sh\ngit --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f</code></pre><p>保存后，赋予该文件可执行权限</p>\n<pre><code>chmod +x /home/git/blog.git/hooks/post-receive</code></pre><h3 id=\"本地配置\"><a href=\"#本地配置\" class=\"headerlink\" title=\"本地配置\"></a>本地配置</h3><p>与部署到GitHub相同，在本地博客文件根目录下的<code>_config.yml</code> 文件中修改<code>deploy</code>设置如下。SERVER为服务器的公网ip，如果不想部署到GitHub了将<code>github</code>一行删去即可。</p>\n<pre><code>deploy:\n  type: git\n  repo:\n    github: git@github.com:xxxx/xxxx.github.io.git\n    git1: git@SERVER:/home/git/blog.git \n  branch: master</code></pre><p>之后正常配置</p>\n<pre><code>hexo clean\nhexo g\nhexo d</code></pre><p>这是输入你的公网ip即可进入你的博客，要实现域名访问，在你的域名内解析你的公网ip即可。</p>\n"},{"title":"Hexo博客搭建","date":"2020-03-12T14:24:43.000Z","fileName":"hexo1","_content":"hexo是一个基于Node.js的静态网页生成器，能直接将markdown文件生成为html文件，部署起来十分方便且有许多丰富的开源主题，是搭建博客的不二选择，具体可见[hexo官网](https://hexo.io/zh-cn/)，本文主要记录在Ubuntu 18.04下的Hexo博客的搭建过程。\n\n### 准备环境\n#### 安装git\n```\nsudo apt-get install git\n```\n可以直接使用命令行进行安装，但这种情况git版本往往较低，因此推荐前往[git官网](https://git-scm.com/)进行下载安装。安装完成后可以使用`git --version`查看一下版本。\n\n#### 安装Node.js\n进入[官网](http://nodejs.cn/download/)选择下载相关版本的Linux二进制文件（Hexo官网建议使用10.0及以上版本，而apt-get下载版本过老因此此处建议在官网下载最新版本），输入以下命令\n```\ntar xf  node-yourversion-linux-x64.tar.xz\ncd node-yourversion-linux-x64/\n./bin/node -v\n```\n如果显示了版本，说明解压安装成功，但此时在命令行输入node是没有反应的，因此还要输入以下命令设置软连接\n```\nln -s /yourlocation/nodejs/bin/npm /usr/local/bin/ \nln -s /yourlocation/nodejs/bin/node /usr/local/bin/ \n```\n之后在命令行调用npm与node的相关命令，如果未显示“未找到命令”则说明安装成功。\n\n#### 安装Hexo\n```\nnpm install -g hexo-cli\n```\n在命令行输入以上命令即可安装hexo，但安装过后在命令行输入hexo显示未找到命令（hexo默认安装在与npm相同的位置），因此也要输入以下命令建立软链接。\n```\nln -s /yourlocation/nodejs/bin/hexo /usr/local/bin/ \n```\n之后在命令行测试无误，即安装成功。\n\n#### 初始化博客本地目录\n在你打算作为博客本地目录的文件夹下打开终端输入以下命令即可完成对hexo博客的初始化。\n```\nhexo init\nnpm install\n```\n此时文件夹下会出现如下目录：\n```\n.\n├── _config.yml     //配置文件，用于配置网站基本信息\n├── package.json    //安装相关插件的信息，一般可以忽略其内容\n├── scaffolds   //模板文件夹，里面可以更改之后构建相关md文件的模板\n├── source  //存放文章与各类资源的地方，被解析后相关内容会被放到生成的public文件夹内\n|   ├── _drafts\n|   └── _posts\n└── themes  //存放主题的地方，可以自己选择或开发主题放进来\n```\n此时在终端输入\n```\nhexo s\n```\n如果不出bug，在http://localhost:4000/ 便能访问到博客的初始界面了。\n\n#### Windows下的安装方法\nWindows下的安装方法更简单，到相关依赖项的官网上下载一直确定就能够安装成功。之后在git bash下的操作就与Linux基本一致了。\n\n### 网站部署\n#### GithubPage\n1. 创建github账户并在本地创建ssh密匙，之后在github网站中的**setting**中找到SSH相关选项，将本地的ssh密匙添加进去即可（本地的ssh密匙都是在`.ssh\\id_rsa.pub`中可以找到）。\n\n2. 在github下新建仓库，仓库命名必须为`<账户名称>.github.io`\n3. 修改本地博客文件中_config.yml中的设置如下\n```\ndeploy:\n  type: git\n  repo: git@github.com:<Github账号名称>/<Github账号名称>.github.io.git\n  branch: master\n```\n4. 在博客本地目录下使用如下命令即可完成网页的生成与部署。之后在https://<Github账号名称>.github.io即可访问到自己的页面了。\n```\nhexo g  //生成\nhexo d  //部署\n```\n\n#### 云服务器\n\n","source":"_posts/前端/Hexo/Hexo博客搭建.md","raw":"---\ntitle: Hexo博客搭建\ndate: 2020-03-12 22:24:43\ntags:\n    - hexo\ncategories:\n    - 前端\n    - hexo\nfileName: hexo1\n---\nhexo是一个基于Node.js的静态网页生成器，能直接将markdown文件生成为html文件，部署起来十分方便且有许多丰富的开源主题，是搭建博客的不二选择，具体可见[hexo官网](https://hexo.io/zh-cn/)，本文主要记录在Ubuntu 18.04下的Hexo博客的搭建过程。\n\n### 准备环境\n#### 安装git\n```\nsudo apt-get install git\n```\n可以直接使用命令行进行安装，但这种情况git版本往往较低，因此推荐前往[git官网](https://git-scm.com/)进行下载安装。安装完成后可以使用`git --version`查看一下版本。\n\n#### 安装Node.js\n进入[官网](http://nodejs.cn/download/)选择下载相关版本的Linux二进制文件（Hexo官网建议使用10.0及以上版本，而apt-get下载版本过老因此此处建议在官网下载最新版本），输入以下命令\n```\ntar xf  node-yourversion-linux-x64.tar.xz\ncd node-yourversion-linux-x64/\n./bin/node -v\n```\n如果显示了版本，说明解压安装成功，但此时在命令行输入node是没有反应的，因此还要输入以下命令设置软连接\n```\nln -s /yourlocation/nodejs/bin/npm /usr/local/bin/ \nln -s /yourlocation/nodejs/bin/node /usr/local/bin/ \n```\n之后在命令行调用npm与node的相关命令，如果未显示“未找到命令”则说明安装成功。\n\n#### 安装Hexo\n```\nnpm install -g hexo-cli\n```\n在命令行输入以上命令即可安装hexo，但安装过后在命令行输入hexo显示未找到命令（hexo默认安装在与npm相同的位置），因此也要输入以下命令建立软链接。\n```\nln -s /yourlocation/nodejs/bin/hexo /usr/local/bin/ \n```\n之后在命令行测试无误，即安装成功。\n\n#### 初始化博客本地目录\n在你打算作为博客本地目录的文件夹下打开终端输入以下命令即可完成对hexo博客的初始化。\n```\nhexo init\nnpm install\n```\n此时文件夹下会出现如下目录：\n```\n.\n├── _config.yml     //配置文件，用于配置网站基本信息\n├── package.json    //安装相关插件的信息，一般可以忽略其内容\n├── scaffolds   //模板文件夹，里面可以更改之后构建相关md文件的模板\n├── source  //存放文章与各类资源的地方，被解析后相关内容会被放到生成的public文件夹内\n|   ├── _drafts\n|   └── _posts\n└── themes  //存放主题的地方，可以自己选择或开发主题放进来\n```\n此时在终端输入\n```\nhexo s\n```\n如果不出bug，在http://localhost:4000/ 便能访问到博客的初始界面了。\n\n#### Windows下的安装方法\nWindows下的安装方法更简单，到相关依赖项的官网上下载一直确定就能够安装成功。之后在git bash下的操作就与Linux基本一致了。\n\n### 网站部署\n#### GithubPage\n1. 创建github账户并在本地创建ssh密匙，之后在github网站中的**setting**中找到SSH相关选项，将本地的ssh密匙添加进去即可（本地的ssh密匙都是在`.ssh\\id_rsa.pub`中可以找到）。\n\n2. 在github下新建仓库，仓库命名必须为`<账户名称>.github.io`\n3. 修改本地博客文件中_config.yml中的设置如下\n```\ndeploy:\n  type: git\n  repo: git@github.com:<Github账号名称>/<Github账号名称>.github.io.git\n  branch: master\n```\n4. 在博客本地目录下使用如下命令即可完成网页的生成与部署。之后在https://<Github账号名称>.github.io即可访问到自己的页面了。\n```\nhexo g  //生成\nhexo d  //部署\n```\n\n#### 云服务器\n\n","slug":"前端/Hexo/Hexo博客搭建","published":1,"updated":"2020-07-16T15:55:16.558Z","_id":"ckcox2plu000u68js8how0myp","comments":1,"layout":"post","photos":[],"link":"","content":"<p>hexo是一个基于Node.js的静态网页生成器，能直接将markdown文件生成为html文件，部署起来十分方便且有许多丰富的开源主题，是搭建博客的不二选择，具体可见<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">hexo官网</a>，本文主要记录在Ubuntu 18.04下的Hexo博客的搭建过程。</p>\n<h3 id=\"准备环境\"><a href=\"#准备环境\" class=\"headerlink\" title=\"准备环境\"></a>准备环境</h3><h4 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h4><pre><code>sudo apt-get install git</code></pre><p>可以直接使用命令行进行安装，但这种情况git版本往往较低，因此推荐前往<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">git官网</a>进行下载安装。安装完成后可以使用<code>git --version</code>查看一下版本。</p>\n<h4 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h4><p>进入<a href=\"http://nodejs.cn/download/\" target=\"_blank\" rel=\"noopener\">官网</a>选择下载相关版本的Linux二进制文件（Hexo官网建议使用10.0及以上版本，而apt-get下载版本过老因此此处建议在官网下载最新版本），输入以下命令</p>\n<pre><code>tar xf  node-yourversion-linux-x64.tar.xz\ncd node-yourversion-linux-x64/\n./bin/node -v</code></pre><p>如果显示了版本，说明解压安装成功，但此时在命令行输入node是没有反应的，因此还要输入以下命令设置软连接</p>\n<pre><code>ln -s /yourlocation/nodejs/bin/npm /usr/local/bin/ \nln -s /yourlocation/nodejs/bin/node /usr/local/bin/ </code></pre><p>之后在命令行调用npm与node的相关命令，如果未显示“未找到命令”则说明安装成功。</p>\n<h4 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h4><pre><code>npm install -g hexo-cli</code></pre><p>在命令行输入以上命令即可安装hexo，但安装过后在命令行输入hexo显示未找到命令（hexo默认安装在与npm相同的位置），因此也要输入以下命令建立软链接。</p>\n<pre><code>ln -s /yourlocation/nodejs/bin/hexo /usr/local/bin/ </code></pre><p>之后在命令行测试无误，即安装成功。</p>\n<h4 id=\"初始化博客本地目录\"><a href=\"#初始化博客本地目录\" class=\"headerlink\" title=\"初始化博客本地目录\"></a>初始化博客本地目录</h4><p>在你打算作为博客本地目录的文件夹下打开终端输入以下命令即可完成对hexo博客的初始化。</p>\n<pre><code>hexo init\nnpm install</code></pre><p>此时文件夹下会出现如下目录：</p>\n<pre><code>.\n├── _config.yml     //配置文件，用于配置网站基本信息\n├── package.json    //安装相关插件的信息，一般可以忽略其内容\n├── scaffolds   //模板文件夹，里面可以更改之后构建相关md文件的模板\n├── source  //存放文章与各类资源的地方，被解析后相关内容会被放到生成的public文件夹内\n|   ├── _drafts\n|   └── _posts\n└── themes  //存放主题的地方，可以自己选择或开发主题放进来</code></pre><p>此时在终端输入</p>\n<pre><code>hexo s</code></pre><p>如果不出bug，在<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a> 便能访问到博客的初始界面了。</p>\n<h4 id=\"Windows下的安装方法\"><a href=\"#Windows下的安装方法\" class=\"headerlink\" title=\"Windows下的安装方法\"></a>Windows下的安装方法</h4><p>Windows下的安装方法更简单，到相关依赖项的官网上下载一直确定就能够安装成功。之后在git bash下的操作就与Linux基本一致了。</p>\n<h3 id=\"网站部署\"><a href=\"#网站部署\" class=\"headerlink\" title=\"网站部署\"></a>网站部署</h3><h4 id=\"GithubPage\"><a href=\"#GithubPage\" class=\"headerlink\" title=\"GithubPage\"></a>GithubPage</h4><ol>\n<li><p>创建github账户并在本地创建ssh密匙，之后在github网站中的<strong>setting</strong>中找到SSH相关选项，将本地的ssh密匙添加进去即可（本地的ssh密匙都是在<code>.ssh\\id_rsa.pub</code>中可以找到）。</p>\n</li>\n<li><p>在github下新建仓库，仓库命名必须为<code>&lt;账户名称&gt;.github.io</code></p>\n</li>\n<li><p>修改本地博客文件中_config.yml中的设置如下</p>\n<pre><code>deploy:\ntype: git\nrepo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git\nbranch: master</code></pre></li>\n<li><p>在博客本地目录下使用如下命令即可完成网页的生成与部署。之后在https://&lt;Github账号名称&gt;.github.io即可访问到自己的页面了。</p>\n<pre><code>hexo g  //生成\nhexo d  //部署</code></pre></li>\n</ol>\n<h4 id=\"云服务器\"><a href=\"#云服务器\" class=\"headerlink\" title=\"云服务器\"></a>云服务器</h4>","site":{"data":{}},"excerpt":"","more":"<p>hexo是一个基于Node.js的静态网页生成器，能直接将markdown文件生成为html文件，部署起来十分方便且有许多丰富的开源主题，是搭建博客的不二选择，具体可见<a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">hexo官网</a>，本文主要记录在Ubuntu 18.04下的Hexo博客的搭建过程。</p>\n<h3 id=\"准备环境\"><a href=\"#准备环境\" class=\"headerlink\" title=\"准备环境\"></a>准备环境</h3><h4 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h4><pre><code>sudo apt-get install git</code></pre><p>可以直接使用命令行进行安装，但这种情况git版本往往较低，因此推荐前往<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">git官网</a>进行下载安装。安装完成后可以使用<code>git --version</code>查看一下版本。</p>\n<h4 id=\"安装Node-js\"><a href=\"#安装Node-js\" class=\"headerlink\" title=\"安装Node.js\"></a>安装Node.js</h4><p>进入<a href=\"http://nodejs.cn/download/\" target=\"_blank\" rel=\"noopener\">官网</a>选择下载相关版本的Linux二进制文件（Hexo官网建议使用10.0及以上版本，而apt-get下载版本过老因此此处建议在官网下载最新版本），输入以下命令</p>\n<pre><code>tar xf  node-yourversion-linux-x64.tar.xz\ncd node-yourversion-linux-x64/\n./bin/node -v</code></pre><p>如果显示了版本，说明解压安装成功，但此时在命令行输入node是没有反应的，因此还要输入以下命令设置软连接</p>\n<pre><code>ln -s /yourlocation/nodejs/bin/npm /usr/local/bin/ \nln -s /yourlocation/nodejs/bin/node /usr/local/bin/ </code></pre><p>之后在命令行调用npm与node的相关命令，如果未显示“未找到命令”则说明安装成功。</p>\n<h4 id=\"安装Hexo\"><a href=\"#安装Hexo\" class=\"headerlink\" title=\"安装Hexo\"></a>安装Hexo</h4><pre><code>npm install -g hexo-cli</code></pre><p>在命令行输入以上命令即可安装hexo，但安装过后在命令行输入hexo显示未找到命令（hexo默认安装在与npm相同的位置），因此也要输入以下命令建立软链接。</p>\n<pre><code>ln -s /yourlocation/nodejs/bin/hexo /usr/local/bin/ </code></pre><p>之后在命令行测试无误，即安装成功。</p>\n<h4 id=\"初始化博客本地目录\"><a href=\"#初始化博客本地目录\" class=\"headerlink\" title=\"初始化博客本地目录\"></a>初始化博客本地目录</h4><p>在你打算作为博客本地目录的文件夹下打开终端输入以下命令即可完成对hexo博客的初始化。</p>\n<pre><code>hexo init\nnpm install</code></pre><p>此时文件夹下会出现如下目录：</p>\n<pre><code>.\n├── _config.yml     //配置文件，用于配置网站基本信息\n├── package.json    //安装相关插件的信息，一般可以忽略其内容\n├── scaffolds   //模板文件夹，里面可以更改之后构建相关md文件的模板\n├── source  //存放文章与各类资源的地方，被解析后相关内容会被放到生成的public文件夹内\n|   ├── _drafts\n|   └── _posts\n└── themes  //存放主题的地方，可以自己选择或开发主题放进来</code></pre><p>此时在终端输入</p>\n<pre><code>hexo s</code></pre><p>如果不出bug，在<a href=\"http://localhost:4000/\" target=\"_blank\" rel=\"noopener\">http://localhost:4000/</a> 便能访问到博客的初始界面了。</p>\n<h4 id=\"Windows下的安装方法\"><a href=\"#Windows下的安装方法\" class=\"headerlink\" title=\"Windows下的安装方法\"></a>Windows下的安装方法</h4><p>Windows下的安装方法更简单，到相关依赖项的官网上下载一直确定就能够安装成功。之后在git bash下的操作就与Linux基本一致了。</p>\n<h3 id=\"网站部署\"><a href=\"#网站部署\" class=\"headerlink\" title=\"网站部署\"></a>网站部署</h3><h4 id=\"GithubPage\"><a href=\"#GithubPage\" class=\"headerlink\" title=\"GithubPage\"></a>GithubPage</h4><ol>\n<li><p>创建github账户并在本地创建ssh密匙，之后在github网站中的<strong>setting</strong>中找到SSH相关选项，将本地的ssh密匙添加进去即可（本地的ssh密匙都是在<code>.ssh\\id_rsa.pub</code>中可以找到）。</p>\n</li>\n<li><p>在github下新建仓库，仓库命名必须为<code>&lt;账户名称&gt;.github.io</code></p>\n</li>\n<li><p>修改本地博客文件中_config.yml中的设置如下</p>\n<pre><code>deploy:\ntype: git\nrepo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git\nbranch: master</code></pre></li>\n<li><p>在博客本地目录下使用如下命令即可完成网页的生成与部署。之后在https://&lt;Github账号名称&gt;.github.io即可访问到自己的页面了。</p>\n<pre><code>hexo g  //生成\nhexo d  //部署</code></pre></li>\n</ol>\n<h4 id=\"云服务器\"><a href=\"#云服务器\" class=\"headerlink\" title=\"云服务器\"></a>云服务器</h4>"},{"title":"Hexo实现多台机器同时编写博客","date":"2020-03-13T03:05:41.000Z","fileName":"hexo3","_content":"\n正常情况下，只在一台电脑上使用hexo编写部署博客非常方便，但多台电脑进行部署就需要云盘等媒介进行md文件的传输了。我的电脑是双系统，因此如果要部署的话还得重启，比较麻烦，因此干脆实现一个博客多设备管理，方便快捷。\n\n实现多设备的博客管理关键就是要实现本地hexo源文件的多台设备传输与修改，首先想到的当然是使用git了。本地的`_config.yml`文件中默认使用`hexo d`进行部署是部署在GitHub相应项目（也就是以用户名命名的博客项目）的`master`分支上的，因此，只需要在同一项目上新建一个存储源文件的分支即可解决问题。\n\n### 创建分支\n\n在已经作为博客本地文件的地方打开终端输入以下命令\n\n```\ngit branch <hexo>\t//hexo处为你想建立的分支的名字\n```\n\n之后在github中博客仓库的`->Settings->Branches->Default branch`下将默认分支改为新建的分支，并保存更新。\n\n### 分支连接本地文件\n\n1. 最简单且有效的方法就是将新建的`hexo`分支`git clone`到本地文件夹内，输入`git branch`即可看到当前分支为`hexo`。\n\n2. 再将之前新建的博客文件复制到以上文件夹中，注意将`themes`文件中隐藏的`.git`文件等与git有关的文件删除，否则主题文件会默认为是整个项目的一个子模块而不被上传到你的GitHub。\n3. 将之前部署生成的`.deploy_git`文件删除，否则由于之前删去了部分原来的git信息部署时有可能会发生错误。\n4. 输入如下命令你的博客的源码分支hexo就建立好了。\n\n```\ngit add .\ngit commit -m \"first push\"\ngit push origin hexo\n```\n\n5. 想在另一台电脑上写博客时。只要确保该电脑安装了hexo所需要的各种环境（再在GitHub上加入ssh密匙），只需要在本地建立一个文件夹将博客源文件`clone`下来即可。而每次更新上传后，在另一台计算机上只需每次使用`git pull`更新一下源文件即可十分方便。\n\n### 其他问题\n\n多机同时管理博客其实就是在一个github仓库的`master`分支存储网页静态文件，在`hexo`分支存储博客源文件。由于hexo进行部署时默认是在`master`分支上部署（`_config.yml`文件中可见），因此部署博客时还是输入以下代码即可\n\n```\nhexo g\nhexo d\n```\n\n同时应该注意的是，这样做会使得源文件开源，不想开源的话可以在github仓库中设置该仓库为private。这样该仓库就不可见但gitpage的功能也使用不了了，所以要怎样做仁者见仁智者见智吧。","source":"_posts/前端/Hexo/Hexo实现多台机器同时编写博客.md","raw":"---\ntitle: Hexo实现多台机器同时编写博客\ndate: 2020-03-13 11:05:41\ntags:\n\t- hexo\n\t- git\ncategories:\n\t- 前端\n\t- hexo\nfileName: hexo3\n---\n\n正常情况下，只在一台电脑上使用hexo编写部署博客非常方便，但多台电脑进行部署就需要云盘等媒介进行md文件的传输了。我的电脑是双系统，因此如果要部署的话还得重启，比较麻烦，因此干脆实现一个博客多设备管理，方便快捷。\n\n实现多设备的博客管理关键就是要实现本地hexo源文件的多台设备传输与修改，首先想到的当然是使用git了。本地的`_config.yml`文件中默认使用`hexo d`进行部署是部署在GitHub相应项目（也就是以用户名命名的博客项目）的`master`分支上的，因此，只需要在同一项目上新建一个存储源文件的分支即可解决问题。\n\n### 创建分支\n\n在已经作为博客本地文件的地方打开终端输入以下命令\n\n```\ngit branch <hexo>\t//hexo处为你想建立的分支的名字\n```\n\n之后在github中博客仓库的`->Settings->Branches->Default branch`下将默认分支改为新建的分支，并保存更新。\n\n### 分支连接本地文件\n\n1. 最简单且有效的方法就是将新建的`hexo`分支`git clone`到本地文件夹内，输入`git branch`即可看到当前分支为`hexo`。\n\n2. 再将之前新建的博客文件复制到以上文件夹中，注意将`themes`文件中隐藏的`.git`文件等与git有关的文件删除，否则主题文件会默认为是整个项目的一个子模块而不被上传到你的GitHub。\n3. 将之前部署生成的`.deploy_git`文件删除，否则由于之前删去了部分原来的git信息部署时有可能会发生错误。\n4. 输入如下命令你的博客的源码分支hexo就建立好了。\n\n```\ngit add .\ngit commit -m \"first push\"\ngit push origin hexo\n```\n\n5. 想在另一台电脑上写博客时。只要确保该电脑安装了hexo所需要的各种环境（再在GitHub上加入ssh密匙），只需要在本地建立一个文件夹将博客源文件`clone`下来即可。而每次更新上传后，在另一台计算机上只需每次使用`git pull`更新一下源文件即可十分方便。\n\n### 其他问题\n\n多机同时管理博客其实就是在一个github仓库的`master`分支存储网页静态文件，在`hexo`分支存储博客源文件。由于hexo进行部署时默认是在`master`分支上部署（`_config.yml`文件中可见），因此部署博客时还是输入以下代码即可\n\n```\nhexo g\nhexo d\n```\n\n同时应该注意的是，这样做会使得源文件开源，不想开源的话可以在github仓库中设置该仓库为private。这样该仓库就不可见但gitpage的功能也使用不了了，所以要怎样做仁者见仁智者见智吧。","slug":"前端/Hexo/Hexo实现多台机器同时编写博客","published":1,"updated":"2020-07-16T15:55:23.175Z","_id":"ckcox2plv000v68js0zn79i43","comments":1,"layout":"post","photos":[],"link":"","content":"<p>正常情况下，只在一台电脑上使用hexo编写部署博客非常方便，但多台电脑进行部署就需要云盘等媒介进行md文件的传输了。我的电脑是双系统，因此如果要部署的话还得重启，比较麻烦，因此干脆实现一个博客多设备管理，方便快捷。</p>\n<p>实现多设备的博客管理关键就是要实现本地hexo源文件的多台设备传输与修改，首先想到的当然是使用git了。本地的<code>_config.yml</code>文件中默认使用<code>hexo d</code>进行部署是部署在GitHub相应项目（也就是以用户名命名的博客项目）的<code>master</code>分支上的，因此，只需要在同一项目上新建一个存储源文件的分支即可解决问题。</p>\n<h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><p>在已经作为博客本地文件的地方打开终端输入以下命令</p>\n<pre><code>git branch &lt;hexo&gt;    //hexo处为你想建立的分支的名字</code></pre><p>之后在github中博客仓库的<code>-&gt;Settings-&gt;Branches-&gt;Default branch</code>下将默认分支改为新建的分支，并保存更新。</p>\n<h3 id=\"分支连接本地文件\"><a href=\"#分支连接本地文件\" class=\"headerlink\" title=\"分支连接本地文件\"></a>分支连接本地文件</h3><ol>\n<li><p>最简单且有效的方法就是将新建的<code>hexo</code>分支<code>git clone</code>到本地文件夹内，输入<code>git branch</code>即可看到当前分支为<code>hexo</code>。</p>\n</li>\n<li><p>再将之前新建的博客文件复制到以上文件夹中，注意将<code>themes</code>文件中隐藏的<code>.git</code>文件等与git有关的文件删除，否则主题文件会默认为是整个项目的一个子模块而不被上传到你的GitHub。</p>\n</li>\n<li><p>将之前部署生成的<code>.deploy_git</code>文件删除，否则由于之前删去了部分原来的git信息部署时有可能会发生错误。</p>\n</li>\n<li><p>输入如下命令你的博客的源码分支hexo就建立好了。</p>\n</li>\n</ol>\n<pre><code>git add .\ngit commit -m &quot;first push&quot;\ngit push origin hexo</code></pre><ol start=\"5\">\n<li>想在另一台电脑上写博客时。只要确保该电脑安装了hexo所需要的各种环境（再在GitHub上加入ssh密匙），只需要在本地建立一个文件夹将博客源文件<code>clone</code>下来即可。而每次更新上传后，在另一台计算机上只需每次使用<code>git pull</code>更新一下源文件即可十分方便。</li>\n</ol>\n<h3 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h3><p>多机同时管理博客其实就是在一个github仓库的<code>master</code>分支存储网页静态文件，在<code>hexo</code>分支存储博客源文件。由于hexo进行部署时默认是在<code>master</code>分支上部署（<code>_config.yml</code>文件中可见），因此部署博客时还是输入以下代码即可</p>\n<pre><code>hexo g\nhexo d</code></pre><p>同时应该注意的是，这样做会使得源文件开源，不想开源的话可以在github仓库中设置该仓库为private。这样该仓库就不可见但gitpage的功能也使用不了了，所以要怎样做仁者见仁智者见智吧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>正常情况下，只在一台电脑上使用hexo编写部署博客非常方便，但多台电脑进行部署就需要云盘等媒介进行md文件的传输了。我的电脑是双系统，因此如果要部署的话还得重启，比较麻烦，因此干脆实现一个博客多设备管理，方便快捷。</p>\n<p>实现多设备的博客管理关键就是要实现本地hexo源文件的多台设备传输与修改，首先想到的当然是使用git了。本地的<code>_config.yml</code>文件中默认使用<code>hexo d</code>进行部署是部署在GitHub相应项目（也就是以用户名命名的博客项目）的<code>master</code>分支上的，因此，只需要在同一项目上新建一个存储源文件的分支即可解决问题。</p>\n<h3 id=\"创建分支\"><a href=\"#创建分支\" class=\"headerlink\" title=\"创建分支\"></a>创建分支</h3><p>在已经作为博客本地文件的地方打开终端输入以下命令</p>\n<pre><code>git branch &lt;hexo&gt;    //hexo处为你想建立的分支的名字</code></pre><p>之后在github中博客仓库的<code>-&gt;Settings-&gt;Branches-&gt;Default branch</code>下将默认分支改为新建的分支，并保存更新。</p>\n<h3 id=\"分支连接本地文件\"><a href=\"#分支连接本地文件\" class=\"headerlink\" title=\"分支连接本地文件\"></a>分支连接本地文件</h3><ol>\n<li><p>最简单且有效的方法就是将新建的<code>hexo</code>分支<code>git clone</code>到本地文件夹内，输入<code>git branch</code>即可看到当前分支为<code>hexo</code>。</p>\n</li>\n<li><p>再将之前新建的博客文件复制到以上文件夹中，注意将<code>themes</code>文件中隐藏的<code>.git</code>文件等与git有关的文件删除，否则主题文件会默认为是整个项目的一个子模块而不被上传到你的GitHub。</p>\n</li>\n<li><p>将之前部署生成的<code>.deploy_git</code>文件删除，否则由于之前删去了部分原来的git信息部署时有可能会发生错误。</p>\n</li>\n<li><p>输入如下命令你的博客的源码分支hexo就建立好了。</p>\n</li>\n</ol>\n<pre><code>git add .\ngit commit -m &quot;first push&quot;\ngit push origin hexo</code></pre><ol start=\"5\">\n<li>想在另一台电脑上写博客时。只要确保该电脑安装了hexo所需要的各种环境（再在GitHub上加入ssh密匙），只需要在本地建立一个文件夹将博客源文件<code>clone</code>下来即可。而每次更新上传后，在另一台计算机上只需每次使用<code>git pull</code>更新一下源文件即可十分方便。</li>\n</ol>\n<h3 id=\"其他问题\"><a href=\"#其他问题\" class=\"headerlink\" title=\"其他问题\"></a>其他问题</h3><p>多机同时管理博客其实就是在一个github仓库的<code>master</code>分支存储网页静态文件，在<code>hexo</code>分支存储博客源文件。由于hexo进行部署时默认是在<code>master</code>分支上部署（<code>_config.yml</code>文件中可见），因此部署博客时还是输入以下代码即可</p>\n<pre><code>hexo g\nhexo d</code></pre><p>同时应该注意的是，这样做会使得源文件开源，不想开源的话可以在github仓库中设置该仓库为private。这样该仓库就不可见但gitpage的功能也使用不了了，所以要怎样做仁者见仁智者见智吧。</p>\n"},{"title":"1、JS内置对象与基本语法","date":"2020-06-05T12:18:08.000Z","fileName":"javascript1","_content":"\n### 数组：\n\n基本操作\n\n```\narray.reverse()\t// 颠倒数组\narray.sort()\t// 对数组进行排序（默认升序）\narray.sort(function(a, b) {return b-a})\t// 传入比较函数，变为降序\narray1.concat(array2)\t// 连接array1和array2\narray.slice(start, end)\t// 从start到end的切片\n```\n\n\n\n转化为字符串，默认无参数则用逗号“,”连接。\n\n```\nstr = array.join()\nstr = array.join(\"\")\t// 无连接符号直接连接\n```\n\n\n\n```\n// 删除从index处开始的零个或多个元素\narray.splice(index, count)\n// 在index后插入值\narray.splice(index, 0, item1.....)\n// 替换\narray.splice(index, count, item1.....)\n```\n\n\n\n```\narray.indexOf(value)\t// 查找值为value的索引，没有则返回-1\n```\n\n\n\n### 字符串\n\n```\n// 返回子字符串的位置，若没有，返回-1\nstr.indexOf(\"char\")\n// 从后向前检索\nstr.lastIndexOf(\"char\")\n```\n\n\n\n```\nstr.slice(start, end) // 截取字符串（end索引不在截取范围之内）\n\nstr.substring(start, end) // 功能与slice一致\n\nstr.substr(start, len) // 从start处截取长为len的字符串\n```\n\n\n\n```\nstr.split(separate) // 把字符串分割为字符串数组，参数为分隔符\n\n// 替换字符串，将a替换为b\nstr.replace(a,b)\n```\n\n\n\n```\nstr.toUpperCase()\n\nstr.toLowerCase()\n```\n\n\n\n\n\n### debug方法\n\nJavaScript程序中添加断点，使用debugger。示例如下：\n\n```\n<script>\n    var a = [1,2,3,4,5];\n    for(i=0;i<5;i++){\n        console.log(a[i]);\n        debugger;\n    }\n</script>\n```\n\n刷新Google页面即可进行debug\n\n\n\n","source":"_posts/前端/JS/1、JS内置对象与基本语法.md","raw":"---\ntitle: 1、JS内置对象与基本语法\ndate: 2020-06-05 20:18:08\ntags:\n\t- 前端\ncategories:\n\t- 前端\n\t- JS\nfileName: javascript1\n---\n\n### 数组：\n\n基本操作\n\n```\narray.reverse()\t// 颠倒数组\narray.sort()\t// 对数组进行排序（默认升序）\narray.sort(function(a, b) {return b-a})\t// 传入比较函数，变为降序\narray1.concat(array2)\t// 连接array1和array2\narray.slice(start, end)\t// 从start到end的切片\n```\n\n\n\n转化为字符串，默认无参数则用逗号“,”连接。\n\n```\nstr = array.join()\nstr = array.join(\"\")\t// 无连接符号直接连接\n```\n\n\n\n```\n// 删除从index处开始的零个或多个元素\narray.splice(index, count)\n// 在index后插入值\narray.splice(index, 0, item1.....)\n// 替换\narray.splice(index, count, item1.....)\n```\n\n\n\n```\narray.indexOf(value)\t// 查找值为value的索引，没有则返回-1\n```\n\n\n\n### 字符串\n\n```\n// 返回子字符串的位置，若没有，返回-1\nstr.indexOf(\"char\")\n// 从后向前检索\nstr.lastIndexOf(\"char\")\n```\n\n\n\n```\nstr.slice(start, end) // 截取字符串（end索引不在截取范围之内）\n\nstr.substring(start, end) // 功能与slice一致\n\nstr.substr(start, len) // 从start处截取长为len的字符串\n```\n\n\n\n```\nstr.split(separate) // 把字符串分割为字符串数组，参数为分隔符\n\n// 替换字符串，将a替换为b\nstr.replace(a,b)\n```\n\n\n\n```\nstr.toUpperCase()\n\nstr.toLowerCase()\n```\n\n\n\n\n\n### debug方法\n\nJavaScript程序中添加断点，使用debugger。示例如下：\n\n```\n<script>\n    var a = [1,2,3,4,5];\n    for(i=0;i<5;i++){\n        console.log(a[i]);\n        debugger;\n    }\n</script>\n```\n\n刷新Google页面即可进行debug\n\n\n\n","slug":"前端/JS/1、JS内置对象与基本语法","published":1,"updated":"2020-06-21T07:32:48.100Z","_id":"ckcox2wxz001368js7e8862ic","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"数组：\"><a href=\"#数组：\" class=\"headerlink\" title=\"数组：\"></a>数组：</h3><p>基本操作</p>\n<pre><code>array.reverse()    // 颠倒数组\narray.sort()    // 对数组进行排序（默认升序）\narray.sort(function(a, b) {return b-a})    // 传入比较函数，变为降序\narray1.concat(array2)    // 连接array1和array2\narray.slice(start, end)    // 从start到end的切片</code></pre><p>转化为字符串，默认无参数则用逗号“,”连接。</p>\n<pre><code>str = array.join()\nstr = array.join(&quot;&quot;)    // 无连接符号直接连接</code></pre><pre><code>// 删除从index处开始的零个或多个元素\narray.splice(index, count)\n// 在index后插入值\narray.splice(index, 0, item1.....)\n// 替换\narray.splice(index, count, item1.....)</code></pre><pre><code>array.indexOf(value)    // 查找值为value的索引，没有则返回-1</code></pre><h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><pre><code>// 返回子字符串的位置，若没有，返回-1\nstr.indexOf(&quot;char&quot;)\n// 从后向前检索\nstr.lastIndexOf(&quot;char&quot;)</code></pre><pre><code>str.slice(start, end) // 截取字符串（end索引不在截取范围之内）\n\nstr.substring(start, end) // 功能与slice一致\n\nstr.substr(start, len) // 从start处截取长为len的字符串</code></pre><pre><code>str.split(separate) // 把字符串分割为字符串数组，参数为分隔符\n\n// 替换字符串，将a替换为b\nstr.replace(a,b)</code></pre><pre><code>str.toUpperCase()\n\nstr.toLowerCase()</code></pre><h3 id=\"debug方法\"><a href=\"#debug方法\" class=\"headerlink\" title=\"debug方法\"></a>debug方法</h3><p>JavaScript程序中添加断点，使用debugger。示例如下：</p>\n<pre><code>&lt;script&gt;\n    var a = [1,2,3,4,5];\n    for(i=0;i&lt;5;i++){\n        console.log(a[i]);\n        debugger;\n    }\n&lt;/script&gt;</code></pre><p>刷新Google页面即可进行debug</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"数组：\"><a href=\"#数组：\" class=\"headerlink\" title=\"数组：\"></a>数组：</h3><p>基本操作</p>\n<pre><code>array.reverse()    // 颠倒数组\narray.sort()    // 对数组进行排序（默认升序）\narray.sort(function(a, b) {return b-a})    // 传入比较函数，变为降序\narray1.concat(array2)    // 连接array1和array2\narray.slice(start, end)    // 从start到end的切片</code></pre><p>转化为字符串，默认无参数则用逗号“,”连接。</p>\n<pre><code>str = array.join()\nstr = array.join(&quot;&quot;)    // 无连接符号直接连接</code></pre><pre><code>// 删除从index处开始的零个或多个元素\narray.splice(index, count)\n// 在index后插入值\narray.splice(index, 0, item1.....)\n// 替换\narray.splice(index, count, item1.....)</code></pre><pre><code>array.indexOf(value)    // 查找值为value的索引，没有则返回-1</code></pre><h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><pre><code>// 返回子字符串的位置，若没有，返回-1\nstr.indexOf(&quot;char&quot;)\n// 从后向前检索\nstr.lastIndexOf(&quot;char&quot;)</code></pre><pre><code>str.slice(start, end) // 截取字符串（end索引不在截取范围之内）\n\nstr.substring(start, end) // 功能与slice一致\n\nstr.substr(start, len) // 从start处截取长为len的字符串</code></pre><pre><code>str.split(separate) // 把字符串分割为字符串数组，参数为分隔符\n\n// 替换字符串，将a替换为b\nstr.replace(a,b)</code></pre><pre><code>str.toUpperCase()\n\nstr.toLowerCase()</code></pre><h3 id=\"debug方法\"><a href=\"#debug方法\" class=\"headerlink\" title=\"debug方法\"></a>debug方法</h3><p>JavaScript程序中添加断点，使用debugger。示例如下：</p>\n<pre><code>&lt;script&gt;\n    var a = [1,2,3,4,5];\n    for(i=0;i&lt;5;i++){\n        console.log(a[i]);\n        debugger;\n    }\n&lt;/script&gt;</code></pre><p>刷新Google页面即可进行debug</p>\n"},{"title":"OSM数据基本操作","date":"2019-02-23T15:26:10.000Z","fileName":"osm_data_process","_content":"## .osm文件在ArcGis中打开\n.osm有一万种方式可以转化为ArcGis支持的格式，但本人有些强迫症就是想让ArcGis能够直接打开.osm文件，好在官方已经提供了插件，不过只支持ArcGis 10.6的版本，所以版本滞后的小伙伴请先进行更新。\n更新完之后，请移步[传送门](https://www.esri.com/en-us/arcgis/products/arcgis-editor-for-openstreetmap),里面只有一个选项，相信诸位不会弄错。之后，解压安装包，选择电脑相应位数安装即可，十分方便。安装完成后，打开arcgis后，在ArcToolbox中你会发现新增了一个**OSM Toolbox**，其中内容如下，接下来根据英文与帮助文档，就可以很轻松地进行相应的处理了。在这儿，我们使用*Load OSM File*，选择文件路径与数据库后，即可打开OSM文件，效果如下。\n![OSM工具](OSM数据基本操作\\arcgis.png)\n![生成的查询代码](OSM数据基本操作\\arcgis1.png)\n\n## Overpass Turbo\n### Overview\n**Overpass Turbo**[传送门](http://overpass-turbo.eu/)我认为是提供了一个用于查询与分析OSM数据的平台吧，它的较为标准的说明以及功能描述如下：\nA web-based data filtering tool for OpenStreetMap. With overpass turbo you can run Overpass API queries and analyse the resulting OSM data interactively on a map. There is an integrated Wizard which makes creating queries super easy.\n下面简单记录一下其中常用到的操作，有些命名不是其文档的标准命名，反正领会其意即可。如下是Overpass Turbo的整个界面，其中**红色笔**圈出区域内为工具条（toolbar），**黄色笔**圈出的区域内为查询代码的编写处，其右侧相信大家都能猜到了，就是用于显示所查询内容的部分，其中显示方式的话可以在**绿色笔**圈出的区域内调整。\n![整体界面](OSM数据基本操作\\total.jpg)\n该界面的工具条很简单，没有什么选项，都是一些常见的英文因此简单说一说吧。**Run**就是运行查询代码并在右侧区域进行结果显示，刚进去Overpass Turbo时会有一个例子代码如上图，`node`自然代表一个点要素，`amenity=*****`同OSM中的标签进行查找，很好理解。**Share**自然就是分享；**Export**是下载数据；**Wizard**同其意，作为搜索向导简化查找过程；**Load**则可以载入包括示例之类的东西，其余三个都同其字面意思，在此不做赘述。\n\n### Example\n下面简单做一次使用。\n首先点击**Wizard**，在其对话框中输入*bus route*，完成后可见左侧代码区自动生成了查询代码，如下图，其上方注释表明这是由wizard生成的。接下来点击**Run**（若在Wizard中已经运行过请忽略这一步），可见其查找结果（查找的大致范围为武昌地区），如下。\n\n```\n<center>\n<img src=\"/assets/BlogPic/GIS/1/query.png\">\n<img src=\"/assets/BlogPic/GIS/1/map1.png\" width=\"35%\" height=\"35%\">\n<img src=\"/assets/BlogPic/GIS/1/code.png\" width=\"65%\" height=\"65%\">\n</center>\n```\n\n\n\n接下来如果想把查找的数据下载的话可以点击**Export**了，如下对话框，选择数据格式之后等内容之后即可进行下载。至于数据咋用就随你咯。当然如果数据量过大时，地图渲染可能需要很多时间，可以耐心等待一下（平台也会有提示）\n<img src=\"OSM数据基本操作\\exports.png\">","source":"_posts/GIS/OSM数据基本操作.md","raw":"---\ntitle: OSM数据基本操作\ndate: 2019-02-23 23:26:10\ntags:\n    - GIS\ncategories:\n    - GIS\nfileName: osm_data_process\n---\n## .osm文件在ArcGis中打开\n.osm有一万种方式可以转化为ArcGis支持的格式，但本人有些强迫症就是想让ArcGis能够直接打开.osm文件，好在官方已经提供了插件，不过只支持ArcGis 10.6的版本，所以版本滞后的小伙伴请先进行更新。\n更新完之后，请移步[传送门](https://www.esri.com/en-us/arcgis/products/arcgis-editor-for-openstreetmap),里面只有一个选项，相信诸位不会弄错。之后，解压安装包，选择电脑相应位数安装即可，十分方便。安装完成后，打开arcgis后，在ArcToolbox中你会发现新增了一个**OSM Toolbox**，其中内容如下，接下来根据英文与帮助文档，就可以很轻松地进行相应的处理了。在这儿，我们使用*Load OSM File*，选择文件路径与数据库后，即可打开OSM文件，效果如下。\n![OSM工具](OSM数据基本操作\\arcgis.png)\n![生成的查询代码](OSM数据基本操作\\arcgis1.png)\n\n## Overpass Turbo\n### Overview\n**Overpass Turbo**[传送门](http://overpass-turbo.eu/)我认为是提供了一个用于查询与分析OSM数据的平台吧，它的较为标准的说明以及功能描述如下：\nA web-based data filtering tool for OpenStreetMap. With overpass turbo you can run Overpass API queries and analyse the resulting OSM data interactively on a map. There is an integrated Wizard which makes creating queries super easy.\n下面简单记录一下其中常用到的操作，有些命名不是其文档的标准命名，反正领会其意即可。如下是Overpass Turbo的整个界面，其中**红色笔**圈出区域内为工具条（toolbar），**黄色笔**圈出的区域内为查询代码的编写处，其右侧相信大家都能猜到了，就是用于显示所查询内容的部分，其中显示方式的话可以在**绿色笔**圈出的区域内调整。\n![整体界面](OSM数据基本操作\\total.jpg)\n该界面的工具条很简单，没有什么选项，都是一些常见的英文因此简单说一说吧。**Run**就是运行查询代码并在右侧区域进行结果显示，刚进去Overpass Turbo时会有一个例子代码如上图，`node`自然代表一个点要素，`amenity=*****`同OSM中的标签进行查找，很好理解。**Share**自然就是分享；**Export**是下载数据；**Wizard**同其意，作为搜索向导简化查找过程；**Load**则可以载入包括示例之类的东西，其余三个都同其字面意思，在此不做赘述。\n\n### Example\n下面简单做一次使用。\n首先点击**Wizard**，在其对话框中输入*bus route*，完成后可见左侧代码区自动生成了查询代码，如下图，其上方注释表明这是由wizard生成的。接下来点击**Run**（若在Wizard中已经运行过请忽略这一步），可见其查找结果（查找的大致范围为武昌地区），如下。\n\n```\n<center>\n<img src=\"/assets/BlogPic/GIS/1/query.png\">\n<img src=\"/assets/BlogPic/GIS/1/map1.png\" width=\"35%\" height=\"35%\">\n<img src=\"/assets/BlogPic/GIS/1/code.png\" width=\"65%\" height=\"65%\">\n</center>\n```\n\n\n\n接下来如果想把查找的数据下载的话可以点击**Export**了，如下对话框，选择数据格式之后等内容之后即可进行下载。至于数据咋用就随你咯。当然如果数据量过大时，地图渲染可能需要很多时间，可以耐心等待一下（平台也会有提示）\n<img src=\"OSM数据基本操作\\exports.png\">","slug":"GIS/OSM数据基本操作","published":1,"updated":"2020-06-14T14:29:45.605Z","_id":"ckcox355q001768js9e62ga2t","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"osm文件在ArcGis中打开\"><a href=\"#osm文件在ArcGis中打开\" class=\"headerlink\" title=\".osm文件在ArcGis中打开\"></a>.osm文件在ArcGis中打开</h2><p>.osm有一万种方式可以转化为ArcGis支持的格式，但本人有些强迫症就是想让ArcGis能够直接打开.osm文件，好在官方已经提供了插件，不过只支持ArcGis 10.6的版本，所以版本滞后的小伙伴请先进行更新。<br>更新完之后，请移步<a href=\"https://www.esri.com/en-us/arcgis/products/arcgis-editor-for-openstreetmap\" target=\"_blank\" rel=\"noopener\">传送门</a>,里面只有一个选项，相信诸位不会弄错。之后，解压安装包，选择电脑相应位数安装即可，十分方便。安装完成后，打开arcgis后，在ArcToolbox中你会发现新增了一个<strong>OSM Toolbox</strong>，其中内容如下，接下来根据英文与帮助文档，就可以很轻松地进行相应的处理了。在这儿，我们使用<em>Load OSM File</em>，选择文件路径与数据库后，即可打开OSM文件，效果如下。<br><img src=\"/page/osm_data_process/OSM%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%5Carcgis.png\" alt=\"OSM工具\"><br><img src=\"/page/osm_data_process/OSM%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%5Carcgis1.png\" alt=\"生成的查询代码\"></p>\n<h2 id=\"Overpass-Turbo\"><a href=\"#Overpass-Turbo\" class=\"headerlink\" title=\"Overpass Turbo\"></a>Overpass Turbo</h2><h3 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h3><p><strong>Overpass Turbo</strong><a href=\"http://overpass-turbo.eu/\" target=\"_blank\" rel=\"noopener\">传送门</a>我认为是提供了一个用于查询与分析OSM数据的平台吧，它的较为标准的说明以及功能描述如下：<br>A web-based data filtering tool for OpenStreetMap. With overpass turbo you can run Overpass API queries and analyse the resulting OSM data interactively on a map. There is an integrated Wizard which makes creating queries super easy.<br>下面简单记录一下其中常用到的操作，有些命名不是其文档的标准命名，反正领会其意即可。如下是Overpass Turbo的整个界面，其中<strong>红色笔</strong>圈出区域内为工具条（toolbar），<strong>黄色笔</strong>圈出的区域内为查询代码的编写处，其右侧相信大家都能猜到了，就是用于显示所查询内容的部分，其中显示方式的话可以在<strong>绿色笔</strong>圈出的区域内调整。<br><img src=\"/page/osm_data_process/OSM%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%5Ctotal.jpg\" alt=\"整体界面\"><br>该界面的工具条很简单，没有什么选项，都是一些常见的英文因此简单说一说吧。<strong>Run</strong>就是运行查询代码并在右侧区域进行结果显示，刚进去Overpass Turbo时会有一个例子代码如上图，<code>node</code>自然代表一个点要素，<code>amenity=*****</code>同OSM中的标签进行查找，很好理解。<strong>Share</strong>自然就是分享；<strong>Export</strong>是下载数据；<strong>Wizard</strong>同其意，作为搜索向导简化查找过程；<strong>Load</strong>则可以载入包括示例之类的东西，其余三个都同其字面意思，在此不做赘述。</p>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>下面简单做一次使用。<br>首先点击<strong>Wizard</strong>，在其对话框中输入<em>bus route</em>，完成后可见左侧代码区自动生成了查询代码，如下图，其上方注释表明这是由wizard生成的。接下来点击<strong>Run</strong>（若在Wizard中已经运行过请忽略这一步），可见其查找结果（查找的大致范围为武昌地区），如下。</p>\n<pre><code>&lt;center&gt;\n&lt;img src=&quot;/assets/BlogPic/GIS/1/query.png&quot;&gt;\n&lt;img src=&quot;/assets/BlogPic/GIS/1/map1.png&quot; width=&quot;35%&quot; height=&quot;35%&quot;&gt;\n&lt;img src=&quot;/assets/BlogPic/GIS/1/code.png&quot; width=&quot;65%&quot; height=&quot;65%&quot;&gt;\n&lt;/center&gt;</code></pre><p>接下来如果想把查找的数据下载的话可以点击<strong>Export</strong>了，如下对话框，选择数据格式之后等内容之后即可进行下载。至于数据咋用就随你咯。当然如果数据量过大时，地图渲染可能需要很多时间，可以耐心等待一下（平台也会有提示）<br><img src=\"/page/osm_data_process/exports.png\"></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"osm文件在ArcGis中打开\"><a href=\"#osm文件在ArcGis中打开\" class=\"headerlink\" title=\".osm文件在ArcGis中打开\"></a>.osm文件在ArcGis中打开</h2><p>.osm有一万种方式可以转化为ArcGis支持的格式，但本人有些强迫症就是想让ArcGis能够直接打开.osm文件，好在官方已经提供了插件，不过只支持ArcGis 10.6的版本，所以版本滞后的小伙伴请先进行更新。<br>更新完之后，请移步<a href=\"https://www.esri.com/en-us/arcgis/products/arcgis-editor-for-openstreetmap\" target=\"_blank\" rel=\"noopener\">传送门</a>,里面只有一个选项，相信诸位不会弄错。之后，解压安装包，选择电脑相应位数安装即可，十分方便。安装完成后，打开arcgis后，在ArcToolbox中你会发现新增了一个<strong>OSM Toolbox</strong>，其中内容如下，接下来根据英文与帮助文档，就可以很轻松地进行相应的处理了。在这儿，我们使用<em>Load OSM File</em>，选择文件路径与数据库后，即可打开OSM文件，效果如下。<br><img src=\"/page/osm_data_process/OSM%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%5Carcgis.png\" alt=\"OSM工具\"><br><img src=\"/page/osm_data_process/OSM%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%5Carcgis1.png\" alt=\"生成的查询代码\"></p>\n<h2 id=\"Overpass-Turbo\"><a href=\"#Overpass-Turbo\" class=\"headerlink\" title=\"Overpass Turbo\"></a>Overpass Turbo</h2><h3 id=\"Overview\"><a href=\"#Overview\" class=\"headerlink\" title=\"Overview\"></a>Overview</h3><p><strong>Overpass Turbo</strong><a href=\"http://overpass-turbo.eu/\" target=\"_blank\" rel=\"noopener\">传送门</a>我认为是提供了一个用于查询与分析OSM数据的平台吧，它的较为标准的说明以及功能描述如下：<br>A web-based data filtering tool for OpenStreetMap. With overpass turbo you can run Overpass API queries and analyse the resulting OSM data interactively on a map. There is an integrated Wizard which makes creating queries super easy.<br>下面简单记录一下其中常用到的操作，有些命名不是其文档的标准命名，反正领会其意即可。如下是Overpass Turbo的整个界面，其中<strong>红色笔</strong>圈出区域内为工具条（toolbar），<strong>黄色笔</strong>圈出的区域内为查询代码的编写处，其右侧相信大家都能猜到了，就是用于显示所查询内容的部分，其中显示方式的话可以在<strong>绿色笔</strong>圈出的区域内调整。<br><img src=\"/page/osm_data_process/OSM%E6%95%B0%E6%8D%AE%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C%5Ctotal.jpg\" alt=\"整体界面\"><br>该界面的工具条很简单，没有什么选项，都是一些常见的英文因此简单说一说吧。<strong>Run</strong>就是运行查询代码并在右侧区域进行结果显示，刚进去Overpass Turbo时会有一个例子代码如上图，<code>node</code>自然代表一个点要素，<code>amenity=*****</code>同OSM中的标签进行查找，很好理解。<strong>Share</strong>自然就是分享；<strong>Export</strong>是下载数据；<strong>Wizard</strong>同其意，作为搜索向导简化查找过程；<strong>Load</strong>则可以载入包括示例之类的东西，其余三个都同其字面意思，在此不做赘述。</p>\n<h3 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h3><p>下面简单做一次使用。<br>首先点击<strong>Wizard</strong>，在其对话框中输入<em>bus route</em>，完成后可见左侧代码区自动生成了查询代码，如下图，其上方注释表明这是由wizard生成的。接下来点击<strong>Run</strong>（若在Wizard中已经运行过请忽略这一步），可见其查找结果（查找的大致范围为武昌地区），如下。</p>\n<pre><code>&lt;center&gt;\n&lt;img src=&quot;/assets/BlogPic/GIS/1/query.png&quot;&gt;\n&lt;img src=&quot;/assets/BlogPic/GIS/1/map1.png&quot; width=&quot;35%&quot; height=&quot;35%&quot;&gt;\n&lt;img src=&quot;/assets/BlogPic/GIS/1/code.png&quot; width=&quot;65%&quot; height=&quot;65%&quot;&gt;\n&lt;/center&gt;</code></pre><p>接下来如果想把查找的数据下载的话可以点击<strong>Export</strong>了，如下对话框，选择数据格式之后等内容之后即可进行下载。至于数据咋用就随你咯。当然如果数据量过大时，地图渲染可能需要很多时间，可以耐心等待一下（平台也会有提示）<br><img src=\"/page/osm_data_process/exports.png\"></p>\n"},{"title":"SQL的一些机制","date":"2020-06-12T02:39:37.000Z","fileName":"mysql3","_content":"\n123\n\n事务机制\n\n事务是一个或多个SQL语句组成的整体，要么全部执行成功，要么全部执行失败\n\n```\nSTART TRANSACTION\nSQL语句\n[COMMIT | ROLLBACK]\n```\n\n\n\n\n\n导出SQL文件\n\n```\n\n```\n\n\n\n导出\n\n\n\nSQL注入攻击：\n\n\n\nSQL预编译机制\n\n\n\n\n\n\n\n\n\n数据加密\n\n对称加密（DES加密、AES加密）\n\n\n\nAES加密函数：`AES_ENCRYPT(原始数据，密钥字符串)`\n\nAES解密函数：`AES_DECRYPT(加密结果，密钥字符串)`\n\n\n\n非对称加密（RSA加密、DSA加密、ECC加密）\n\n\n\n\n\n数据库连接池（Connection Pool）：预先创建一些数据库连接，然后缓存起来，避免了程序语言反复创建和销毁连接的昂贵代价\n\n","source":"_posts/数据库/SQL的一些机制.md","raw":"---\ntitle: SQL的一些机制\ndate: 2020-06-12 10:39:37\ntags:\n\t- 数据库\ncategories:\n\t- 数据库\n\t- MySQL\nfileName: mysql3\n---\n\n123\n\n事务机制\n\n事务是一个或多个SQL语句组成的整体，要么全部执行成功，要么全部执行失败\n\n```\nSTART TRANSACTION\nSQL语句\n[COMMIT | ROLLBACK]\n```\n\n\n\n\n\n导出SQL文件\n\n```\n\n```\n\n\n\n导出\n\n\n\nSQL注入攻击：\n\n\n\nSQL预编译机制\n\n\n\n\n\n\n\n\n\n数据加密\n\n对称加密（DES加密、AES加密）\n\n\n\nAES加密函数：`AES_ENCRYPT(原始数据，密钥字符串)`\n\nAES解密函数：`AES_DECRYPT(加密结果，密钥字符串)`\n\n\n\n非对称加密（RSA加密、DSA加密、ECC加密）\n\n\n\n\n\n数据库连接池（Connection Pool）：预先创建一些数据库连接，然后缓存起来，避免了程序语言反复创建和销毁连接的昂贵代价\n\n","slug":"数据库/SQL的一些机制","published":1,"updated":"2020-06-16T15:28:14.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcox3wli001a68js97npdw1o","content":"<p>123</p>\n<p>事务机制</p>\n<p>事务是一个或多个SQL语句组成的整体，要么全部执行成功，要么全部执行失败</p>\n<pre><code>START TRANSACTION\nSQL语句\n[COMMIT | ROLLBACK]</code></pre><p>导出SQL文件</p>\n<pre><code></code></pre><p>导出</p>\n<p>SQL注入攻击：</p>\n<p>SQL预编译机制</p>\n<p>数据加密</p>\n<p>对称加密（DES加密、AES加密）</p>\n<p>AES加密函数：<code>AES_ENCRYPT(原始数据，密钥字符串)</code></p>\n<p>AES解密函数：<code>AES_DECRYPT(加密结果，密钥字符串)</code></p>\n<p>非对称加密（RSA加密、DSA加密、ECC加密）</p>\n<p>数据库连接池（Connection Pool）：预先创建一些数据库连接，然后缓存起来，避免了程序语言反复创建和销毁连接的昂贵代价</p>\n","site":{"data":{}},"excerpt":"","more":"<p>123</p>\n<p>事务机制</p>\n<p>事务是一个或多个SQL语句组成的整体，要么全部执行成功，要么全部执行失败</p>\n<pre><code>START TRANSACTION\nSQL语句\n[COMMIT | ROLLBACK]</code></pre><p>导出SQL文件</p>\n<pre><code></code></pre><p>导出</p>\n<p>SQL注入攻击：</p>\n<p>SQL预编译机制</p>\n<p>数据加密</p>\n<p>对称加密（DES加密、AES加密）</p>\n<p>AES加密函数：<code>AES_ENCRYPT(原始数据，密钥字符串)</code></p>\n<p>AES解密函数：<code>AES_DECRYPT(加密结果，密钥字符串)</code></p>\n<p>非对称加密（RSA加密、DSA加密、ECC加密）</p>\n<p>数据库连接池（Connection Pool）：预先创建一些数据库连接，然后缓存起来，避免了程序语言反复创建和销毁连接的昂贵代价</p>\n"},{"title":"SQL的增删改等语句","date":"2020-06-07T01:44:15.000Z","fileName":"mysql1","_content":"\n\n\n逻辑库\n\n```\nCREATE DATABASE; 逻辑库名称\nSHOW DATABASES;\nDROP DATABASE 逻辑库名称;\nUSE 逻辑库名称;\n```\n\n数据表\n\n```\nCREATE TABLE 数据表(\n\t\t\t列名 数据类型 [约束] [COMMENT 注释],\n\t\t\t列名 数据类型 [约束] [COMMENT 注释],\n\t\t\t)[COMMENT 注释];\n```\n\n```\nSHOW 表名;\nDESC 表名; // 查看表的情况\nSHOW CREATE TABLE 表名;\t// 查看创建该表时的SQL语句\nDROP TABLEE 表名;\t// 删除数据表\n```\n\n\n\n添加字段\n\n```\nALTER TABLE 表名\nADD 列名 数据类型 [约束] [COMMENT 注释],\n...\nADD 列名 数据类型 [约束] [COMMENT 注释];\n```\n\n修改字段数据类型等信息\n\n```\nALTER TABLE 表名\nMODIFY 列名 数据类型 [约束] [COMMENT 注释],\n...\nMODIFY 列名 数据类型 [约束] [COMMENT 注释];\n```\n\n修改字段名称\n\n```\nALTER TABLE 表名\nCHANGE 列名 新列名 数据类型 [约束] [COMMENT 注释],\n...\nCHANGE 列名 新列名 数据类型 [约束] [COMMENT 注释];\n```\n\n删除字段\n\n```\nALTER TABLE 表名\nDROP 字段名称,\n...\nDROP 字段名称;\n```\n\n\n\n添加索引\n\n```\nCREATE TABLE *(\n\t\tINDEX 索引名称 (字段名称),\n\t\t);\n```\n\n添加、显示、删除索引\n\n```\nCREATE INDEX 索引名称 ON 表名(字段);\nALTER TABLE 表名 ADD INDEX [索引名](字段);\n\nSHOW INDEX FROM 表名;\nDROP INDEX 索引名称 ON 表名;\n```\n\n\n\n\n\n向数据表中写入记录\n\n```\nINSERT INTO 表名(字段1,字段2......)\nVALUES(值1,值2......);\n```\n\n\n\n```\n// 当插入数据有问题时直接忽略\nNSERT IGNORE INTO\n```\n\n\n\n修改表的记录\n\n```\nUPDATE [IGNORE] 表名\nSET 字段1=值1, 字段2=值2 ......\nWHERE\nORDER BY\nLIMIT\n```\n\n\n\n删除数据\n\n```\nDELETE [IGNORE] FROM 表名\n[WHERE]\n[ORDER BY]\n[LIMIT]\n```\n\n\n\n","source":"_posts/数据库/SQL的增删改等语句.md","raw":"---\ntitle: SQL的增删改等语句\ndate: 2020-06-07 09:44:15\ntags:\n\t- 数据库\ncategories:\n\t- 数据库\n\t- MySQL\nfileName: mysql1\n---\n\n\n\n逻辑库\n\n```\nCREATE DATABASE; 逻辑库名称\nSHOW DATABASES;\nDROP DATABASE 逻辑库名称;\nUSE 逻辑库名称;\n```\n\n数据表\n\n```\nCREATE TABLE 数据表(\n\t\t\t列名 数据类型 [约束] [COMMENT 注释],\n\t\t\t列名 数据类型 [约束] [COMMENT 注释],\n\t\t\t)[COMMENT 注释];\n```\n\n```\nSHOW 表名;\nDESC 表名; // 查看表的情况\nSHOW CREATE TABLE 表名;\t// 查看创建该表时的SQL语句\nDROP TABLEE 表名;\t// 删除数据表\n```\n\n\n\n添加字段\n\n```\nALTER TABLE 表名\nADD 列名 数据类型 [约束] [COMMENT 注释],\n...\nADD 列名 数据类型 [约束] [COMMENT 注释];\n```\n\n修改字段数据类型等信息\n\n```\nALTER TABLE 表名\nMODIFY 列名 数据类型 [约束] [COMMENT 注释],\n...\nMODIFY 列名 数据类型 [约束] [COMMENT 注释];\n```\n\n修改字段名称\n\n```\nALTER TABLE 表名\nCHANGE 列名 新列名 数据类型 [约束] [COMMENT 注释],\n...\nCHANGE 列名 新列名 数据类型 [约束] [COMMENT 注释];\n```\n\n删除字段\n\n```\nALTER TABLE 表名\nDROP 字段名称,\n...\nDROP 字段名称;\n```\n\n\n\n添加索引\n\n```\nCREATE TABLE *(\n\t\tINDEX 索引名称 (字段名称),\n\t\t);\n```\n\n添加、显示、删除索引\n\n```\nCREATE INDEX 索引名称 ON 表名(字段);\nALTER TABLE 表名 ADD INDEX [索引名](字段);\n\nSHOW INDEX FROM 表名;\nDROP INDEX 索引名称 ON 表名;\n```\n\n\n\n\n\n向数据表中写入记录\n\n```\nINSERT INTO 表名(字段1,字段2......)\nVALUES(值1,值2......);\n```\n\n\n\n```\n// 当插入数据有问题时直接忽略\nNSERT IGNORE INTO\n```\n\n\n\n修改表的记录\n\n```\nUPDATE [IGNORE] 表名\nSET 字段1=值1, 字段2=值2 ......\nWHERE\nORDER BY\nLIMIT\n```\n\n\n\n删除数据\n\n```\nDELETE [IGNORE] FROM 表名\n[WHERE]\n[ORDER BY]\n[LIMIT]\n```\n\n\n\n","slug":"数据库/SQL的增删改等语句","published":1,"updated":"2020-06-14T14:34:16.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcox3wlp001e68js1ekl2tu3","content":"<p>逻辑库</p>\n<pre><code>CREATE DATABASE; 逻辑库名称\nSHOW DATABASES;\nDROP DATABASE 逻辑库名称;\nUSE 逻辑库名称;</code></pre><p>数据表</p>\n<pre><code>CREATE TABLE 数据表(\n            列名 数据类型 [约束] [COMMENT 注释],\n            列名 数据类型 [约束] [COMMENT 注释],\n            )[COMMENT 注释];</code></pre><pre><code>SHOW 表名;\nDESC 表名; // 查看表的情况\nSHOW CREATE TABLE 表名;    // 查看创建该表时的SQL语句\nDROP TABLEE 表名;    // 删除数据表</code></pre><p>添加字段</p>\n<pre><code>ALTER TABLE 表名\nADD 列名 数据类型 [约束] [COMMENT 注释],\n...\nADD 列名 数据类型 [约束] [COMMENT 注释];</code></pre><p>修改字段数据类型等信息</p>\n<pre><code>ALTER TABLE 表名\nMODIFY 列名 数据类型 [约束] [COMMENT 注释],\n...\nMODIFY 列名 数据类型 [约束] [COMMENT 注释];</code></pre><p>修改字段名称</p>\n<pre><code>ALTER TABLE 表名\nCHANGE 列名 新列名 数据类型 [约束] [COMMENT 注释],\n...\nCHANGE 列名 新列名 数据类型 [约束] [COMMENT 注释];</code></pre><p>删除字段</p>\n<pre><code>ALTER TABLE 表名\nDROP 字段名称,\n...\nDROP 字段名称;</code></pre><p>添加索引</p>\n<pre><code>CREATE TABLE *(\n        INDEX 索引名称 (字段名称),\n        );</code></pre><p>添加、显示、删除索引</p>\n<pre><code>CREATE INDEX 索引名称 ON 表名(字段);\nALTER TABLE 表名 ADD INDEX [索引名](字段);\n\nSHOW INDEX FROM 表名;\nDROP INDEX 索引名称 ON 表名;</code></pre><p>向数据表中写入记录</p>\n<pre><code>INSERT INTO 表名(字段1,字段2......)\nVALUES(值1,值2......);</code></pre><pre><code>// 当插入数据有问题时直接忽略\nNSERT IGNORE INTO</code></pre><p>修改表的记录</p>\n<pre><code>UPDATE [IGNORE] 表名\nSET 字段1=值1, 字段2=值2 ......\nWHERE\nORDER BY\nLIMIT</code></pre><p>删除数据</p>\n<pre><code>DELETE [IGNORE] FROM 表名\n[WHERE]\n[ORDER BY]\n[LIMIT]</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>逻辑库</p>\n<pre><code>CREATE DATABASE; 逻辑库名称\nSHOW DATABASES;\nDROP DATABASE 逻辑库名称;\nUSE 逻辑库名称;</code></pre><p>数据表</p>\n<pre><code>CREATE TABLE 数据表(\n            列名 数据类型 [约束] [COMMENT 注释],\n            列名 数据类型 [约束] [COMMENT 注释],\n            )[COMMENT 注释];</code></pre><pre><code>SHOW 表名;\nDESC 表名; // 查看表的情况\nSHOW CREATE TABLE 表名;    // 查看创建该表时的SQL语句\nDROP TABLEE 表名;    // 删除数据表</code></pre><p>添加字段</p>\n<pre><code>ALTER TABLE 表名\nADD 列名 数据类型 [约束] [COMMENT 注释],\n...\nADD 列名 数据类型 [约束] [COMMENT 注释];</code></pre><p>修改字段数据类型等信息</p>\n<pre><code>ALTER TABLE 表名\nMODIFY 列名 数据类型 [约束] [COMMENT 注释],\n...\nMODIFY 列名 数据类型 [约束] [COMMENT 注释];</code></pre><p>修改字段名称</p>\n<pre><code>ALTER TABLE 表名\nCHANGE 列名 新列名 数据类型 [约束] [COMMENT 注释],\n...\nCHANGE 列名 新列名 数据类型 [约束] [COMMENT 注释];</code></pre><p>删除字段</p>\n<pre><code>ALTER TABLE 表名\nDROP 字段名称,\n...\nDROP 字段名称;</code></pre><p>添加索引</p>\n<pre><code>CREATE TABLE *(\n        INDEX 索引名称 (字段名称),\n        );</code></pre><p>添加、显示、删除索引</p>\n<pre><code>CREATE INDEX 索引名称 ON 表名(字段);\nALTER TABLE 表名 ADD INDEX [索引名](字段);\n\nSHOW INDEX FROM 表名;\nDROP INDEX 索引名称 ON 表名;</code></pre><p>向数据表中写入记录</p>\n<pre><code>INSERT INTO 表名(字段1,字段2......)\nVALUES(值1,值2......);</code></pre><pre><code>// 当插入数据有问题时直接忽略\nNSERT IGNORE INTO</code></pre><p>修改表的记录</p>\n<pre><code>UPDATE [IGNORE] 表名\nSET 字段1=值1, 字段2=值2 ......\nWHERE\nORDER BY\nLIMIT</code></pre><p>删除数据</p>\n<pre><code>DELETE [IGNORE] FROM 表名\n[WHERE]\n[ORDER BY]\n[LIMIT]</code></pre>"},{"title":"SQL语句——查","date":"2020-06-10T09:30:10.000Z","fileName":"mysql2","_content":"\n### SELECT语句\n\n1、基本使用框架\n\n```\nSELECT * FROM 数据表\n[WHERE]\n[LIMIT]\n[OFFSET]\n```\n\n2、使用别名\n\n```\nSELECT\n\t字段名 AS 别名\nFROM 数据表\n```\n\n3、查询语句的执行顺序：\n\n先进行语法分析和优化，找到关键字优先级，先执行FROM，再执行SELECT\n\n\n\n\n\n### 查询相关功能\n\n1、**ORDER BY**子句功能，对查询的结果进行**排序**，示例如下\n\n```\n// 按照相关信息进行排序\nSELECT * FROM * ORDER BY 列名 [ASC|DESC]\n// 多个排序信息\nSELECT * FROM * ORDER BY 列名 [ASC|DESC],列名 [ASC|DESC]\n```\n\n\n\n2、去除结果中的**重复记录**，在字段名称前加上**DISTINCT**字段，只支持一个字段名。\n\n```\nSELECT DISTINCT 字段名 FROM *;\n```\n\n\n\n3、**条件查询**，使用**WHERE**语句指定查询的条件逻辑，中间使用AND|OR等逻辑连接符连接，同时注意判断相等的条件是“=”而不是“==”。\n\n```\nSELECT * FROM * WHERE 条件1 [AND|OR] 条件2 ......;\n```\n\n\n\n4、使用**聚合函数**。所谓聚合函数，也就是平均值、最大值等函数，以下为求该字段名下的平均值函数（AVG），其他函数使用方法与此类似。该类方法在实际使用时可以将统计结果作为一个子表进行查询。\n\n```\nSELECT AVG(字段名) FROM 表名\n```\n\n**COUNT(*)**用于获得包含空值的记录数，**COUNT(字段名)**用于获取包含非空值的记录数。\n\n\n\n5、**分组查询**，使用**GROUP BY**字句。即通过一定规则将数据集分为若干个部分进行查询处理。以下即为使用字段1进行分组统计每一组中字段2的平均值。\n\n```\nSELECT 字段1,AVG(字段2) FROM 表名 GROUP BY 字段1;\n```\n\n使用分组查询SELECT语句中只能出现用以分组的字段以及其他字段的聚合函数，否则会报错（由于产生了**一对多**的关系）。为解决这个问题，可以使用`GROUP_CONCAT`函数，这个函数可以将符合条件的值连接起来进行输出，可以理解为将“多”的部分进行了字符串拼接。\n\n```\nSELECT 字段1,GROUP_CONCAT(字段2) FROM 表名 GROUP BY 字段1;\n```\n\n同时可以加上`WITH ROLLUP`再进行一次汇总运算（即在返回的查询结果之下再加上一条汇总记录）。\n\n```\nSELECT 字段1,AVG(字段2) FROM 表名 GROUP BY 字段1 WITH ROLLUP;\n```\n\n\n\n6、**HAVING**子句，以及为何要使用HAVING子句\n\n由于WHERE子句执行在GROUP BY子句之前，因此如果WHERE子句中出现了如平均值等信息时SQL会不知道在哪个范围内进行平均，因此会出错，如以下代码即为错误的（聚合函数作为判断条件）。所以需要使用`HAVING`子句。\n\n```\n# 使用错误\nSELECT f1\nFROM table\nWHERE AVG(f2) > 10\nGROUP BY f1;\n```\n\n```\n# 使用正确\nSELECT f1\nFROM table\nGROUP BY f1 HAVING AVG(f2) > 10;\n```\n\n\n\n\n\n### 表的连接\n\n表的连接很重要，具体有内外两种连接构成。\n\n1、**内连接**：结果集中只保留符合连接条件的记录\n\n```\nSELECT * FROM 表1 [INNER] JOIN 表2 ON 连接条件;\n\nSELECT * FROM 表1 [INNER] JOIN 表2 WHERE 连接条件;\n\nSELECT * FROM 表1, 表2 WHERE 连接条件;\n```\n\n\n\n2、**外连接**：不管是否符合连接条件，记录都要保留在结果集里\n\n```\n// 右表出NULL值和左表连接\nLEFT JOIN \n```\n\n\n\n3、**内外连接的区别**。具体如图所示（图片摘自LeetCode）\n\n1）左联结（left join），联结结果保留左表的全部数据\n2）右联结（right join），联结结果保留右表的全部数据\n3）内联结（inner join），取两表的公共数据\n\n![](\\SQL语句——查\\sql连接.png)\n\n应用在[175.组合两个表中](https://leetcode-cn.com/problems/combine-two-tables/)。该题需要满足“无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息”，所以当person表在左时采用左连接。\n\n\n\n### 一些注意事项\n\n1、**表连接时on和where的区别**\n\n\n\n\n\n以下不推荐，因为查询速度会很慢，每一次都会执行WHERE语句中的内容。\n\n```\nSELECT ename \nFROM t_emp\nWHERE deptno = (SELECT deptno FROM t_emp WHERE ename=\"SCOTT\")\n```\n\n\n\n```\nSELECT e2.ename\nFROM t_emp e1 JOIN t_emp e2 ON e1.deptno=e2.deptno\nWHERE e1.ename = \"SCOTT\"\n```\n\n\n\n将AVG的结果视为一个表，与原表进行连接。\n\n错误\n\n```\nSELECT e2.ename\nFROM t_emp e1 JOIN t_emp e2 ON e2.sal >= AVG(e1.sal)\n```\n\n正确\n\n```\nSELECT e.ename\nFROM t_emp e \nJOIN (SELECT AVG(sal) avg FROM t_emp) t\nON e.sal >= t.avg;\n```\n\n","source":"_posts/数据库/SQL语句——查.md","raw":"---\ntitle: SQL语句——查\ndate: 2020-06-10 17:30:10\ntags:\n\t- 数据库\ncategories:\n\t- 数据库\n\t- MySQL\nfileName: mysql2\n---\n\n### SELECT语句\n\n1、基本使用框架\n\n```\nSELECT * FROM 数据表\n[WHERE]\n[LIMIT]\n[OFFSET]\n```\n\n2、使用别名\n\n```\nSELECT\n\t字段名 AS 别名\nFROM 数据表\n```\n\n3、查询语句的执行顺序：\n\n先进行语法分析和优化，找到关键字优先级，先执行FROM，再执行SELECT\n\n\n\n\n\n### 查询相关功能\n\n1、**ORDER BY**子句功能，对查询的结果进行**排序**，示例如下\n\n```\n// 按照相关信息进行排序\nSELECT * FROM * ORDER BY 列名 [ASC|DESC]\n// 多个排序信息\nSELECT * FROM * ORDER BY 列名 [ASC|DESC],列名 [ASC|DESC]\n```\n\n\n\n2、去除结果中的**重复记录**，在字段名称前加上**DISTINCT**字段，只支持一个字段名。\n\n```\nSELECT DISTINCT 字段名 FROM *;\n```\n\n\n\n3、**条件查询**，使用**WHERE**语句指定查询的条件逻辑，中间使用AND|OR等逻辑连接符连接，同时注意判断相等的条件是“=”而不是“==”。\n\n```\nSELECT * FROM * WHERE 条件1 [AND|OR] 条件2 ......;\n```\n\n\n\n4、使用**聚合函数**。所谓聚合函数，也就是平均值、最大值等函数，以下为求该字段名下的平均值函数（AVG），其他函数使用方法与此类似。该类方法在实际使用时可以将统计结果作为一个子表进行查询。\n\n```\nSELECT AVG(字段名) FROM 表名\n```\n\n**COUNT(*)**用于获得包含空值的记录数，**COUNT(字段名)**用于获取包含非空值的记录数。\n\n\n\n5、**分组查询**，使用**GROUP BY**字句。即通过一定规则将数据集分为若干个部分进行查询处理。以下即为使用字段1进行分组统计每一组中字段2的平均值。\n\n```\nSELECT 字段1,AVG(字段2) FROM 表名 GROUP BY 字段1;\n```\n\n使用分组查询SELECT语句中只能出现用以分组的字段以及其他字段的聚合函数，否则会报错（由于产生了**一对多**的关系）。为解决这个问题，可以使用`GROUP_CONCAT`函数，这个函数可以将符合条件的值连接起来进行输出，可以理解为将“多”的部分进行了字符串拼接。\n\n```\nSELECT 字段1,GROUP_CONCAT(字段2) FROM 表名 GROUP BY 字段1;\n```\n\n同时可以加上`WITH ROLLUP`再进行一次汇总运算（即在返回的查询结果之下再加上一条汇总记录）。\n\n```\nSELECT 字段1,AVG(字段2) FROM 表名 GROUP BY 字段1 WITH ROLLUP;\n```\n\n\n\n6、**HAVING**子句，以及为何要使用HAVING子句\n\n由于WHERE子句执行在GROUP BY子句之前，因此如果WHERE子句中出现了如平均值等信息时SQL会不知道在哪个范围内进行平均，因此会出错，如以下代码即为错误的（聚合函数作为判断条件）。所以需要使用`HAVING`子句。\n\n```\n# 使用错误\nSELECT f1\nFROM table\nWHERE AVG(f2) > 10\nGROUP BY f1;\n```\n\n```\n# 使用正确\nSELECT f1\nFROM table\nGROUP BY f1 HAVING AVG(f2) > 10;\n```\n\n\n\n\n\n### 表的连接\n\n表的连接很重要，具体有内外两种连接构成。\n\n1、**内连接**：结果集中只保留符合连接条件的记录\n\n```\nSELECT * FROM 表1 [INNER] JOIN 表2 ON 连接条件;\n\nSELECT * FROM 表1 [INNER] JOIN 表2 WHERE 连接条件;\n\nSELECT * FROM 表1, 表2 WHERE 连接条件;\n```\n\n\n\n2、**外连接**：不管是否符合连接条件，记录都要保留在结果集里\n\n```\n// 右表出NULL值和左表连接\nLEFT JOIN \n```\n\n\n\n3、**内外连接的区别**。具体如图所示（图片摘自LeetCode）\n\n1）左联结（left join），联结结果保留左表的全部数据\n2）右联结（right join），联结结果保留右表的全部数据\n3）内联结（inner join），取两表的公共数据\n\n![](\\SQL语句——查\\sql连接.png)\n\n应用在[175.组合两个表中](https://leetcode-cn.com/problems/combine-two-tables/)。该题需要满足“无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息”，所以当person表在左时采用左连接。\n\n\n\n### 一些注意事项\n\n1、**表连接时on和where的区别**\n\n\n\n\n\n以下不推荐，因为查询速度会很慢，每一次都会执行WHERE语句中的内容。\n\n```\nSELECT ename \nFROM t_emp\nWHERE deptno = (SELECT deptno FROM t_emp WHERE ename=\"SCOTT\")\n```\n\n\n\n```\nSELECT e2.ename\nFROM t_emp e1 JOIN t_emp e2 ON e1.deptno=e2.deptno\nWHERE e1.ename = \"SCOTT\"\n```\n\n\n\n将AVG的结果视为一个表，与原表进行连接。\n\n错误\n\n```\nSELECT e2.ename\nFROM t_emp e1 JOIN t_emp e2 ON e2.sal >= AVG(e1.sal)\n```\n\n正确\n\n```\nSELECT e.ename\nFROM t_emp e \nJOIN (SELECT AVG(sal) avg FROM t_emp) t\nON e.sal >= t.avg;\n```\n\n","slug":"数据库/SQL语句——查","published":1,"updated":"2020-06-29T07:10:29.612Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcox3wls001i68js3kuk3art","content":"<h3 id=\"SELECT语句\"><a href=\"#SELECT语句\" class=\"headerlink\" title=\"SELECT语句\"></a>SELECT语句</h3><p>1、基本使用框架</p>\n<pre><code>SELECT * FROM 数据表\n[WHERE]\n[LIMIT]\n[OFFSET]</code></pre><p>2、使用别名</p>\n<pre><code>SELECT\n    字段名 AS 别名\nFROM 数据表</code></pre><p>3、查询语句的执行顺序：</p>\n<p>先进行语法分析和优化，找到关键字优先级，先执行FROM，再执行SELECT</p>\n<h3 id=\"查询相关功能\"><a href=\"#查询相关功能\" class=\"headerlink\" title=\"查询相关功能\"></a>查询相关功能</h3><p>1、<strong>ORDER BY</strong>子句功能，对查询的结果进行<strong>排序</strong>，示例如下</p>\n<pre><code>// 按照相关信息进行排序\nSELECT * FROM * ORDER BY 列名 [ASC|DESC]\n// 多个排序信息\nSELECT * FROM * ORDER BY 列名 [ASC|DESC],列名 [ASC|DESC]</code></pre><p>2、去除结果中的<strong>重复记录</strong>，在字段名称前加上<strong>DISTINCT</strong>字段，只支持一个字段名。</p>\n<pre><code>SELECT DISTINCT 字段名 FROM *;</code></pre><p>3、<strong>条件查询</strong>，使用<strong>WHERE</strong>语句指定查询的条件逻辑，中间使用AND|OR等逻辑连接符连接，同时注意判断相等的条件是“=”而不是“==”。</p>\n<pre><code>SELECT * FROM * WHERE 条件1 [AND|OR] 条件2 ......;</code></pre><p>4、使用<strong>聚合函数</strong>。所谓聚合函数，也就是平均值、最大值等函数，以下为求该字段名下的平均值函数（AVG），其他函数使用方法与此类似。该类方法在实际使用时可以将统计结果作为一个子表进行查询。</p>\n<pre><code>SELECT AVG(字段名) FROM 表名</code></pre><p><strong>COUNT(*)</strong>用于获得包含空值的记录数，<strong>COUNT(字段名)</strong>用于获取包含非空值的记录数。</p>\n<p>5、<strong>分组查询</strong>，使用<strong>GROUP BY</strong>字句。即通过一定规则将数据集分为若干个部分进行查询处理。以下即为使用字段1进行分组统计每一组中字段2的平均值。</p>\n<pre><code>SELECT 字段1,AVG(字段2) FROM 表名 GROUP BY 字段1;</code></pre><p>使用分组查询SELECT语句中只能出现用以分组的字段以及其他字段的聚合函数，否则会报错（由于产生了<strong>一对多</strong>的关系）。为解决这个问题，可以使用<code>GROUP_CONCAT</code>函数，这个函数可以将符合条件的值连接起来进行输出，可以理解为将“多”的部分进行了字符串拼接。</p>\n<pre><code>SELECT 字段1,GROUP_CONCAT(字段2) FROM 表名 GROUP BY 字段1;</code></pre><p>同时可以加上<code>WITH ROLLUP</code>再进行一次汇总运算（即在返回的查询结果之下再加上一条汇总记录）。</p>\n<pre><code>SELECT 字段1,AVG(字段2) FROM 表名 GROUP BY 字段1 WITH ROLLUP;</code></pre><p>6、<strong>HAVING</strong>子句，以及为何要使用HAVING子句</p>\n<p>由于WHERE子句执行在GROUP BY子句之前，因此如果WHERE子句中出现了如平均值等信息时SQL会不知道在哪个范围内进行平均，因此会出错，如以下代码即为错误的（聚合函数作为判断条件）。所以需要使用<code>HAVING</code>子句。</p>\n<pre><code># 使用错误\nSELECT f1\nFROM table\nWHERE AVG(f2) &gt; 10\nGROUP BY f1;</code></pre><pre><code># 使用正确\nSELECT f1\nFROM table\nGROUP BY f1 HAVING AVG(f2) &gt; 10;</code></pre><h3 id=\"表的连接\"><a href=\"#表的连接\" class=\"headerlink\" title=\"表的连接\"></a>表的连接</h3><p>表的连接很重要，具体有内外两种连接构成。</p>\n<p>1、<strong>内连接</strong>：结果集中只保留符合连接条件的记录</p>\n<pre><code>SELECT * FROM 表1 [INNER] JOIN 表2 ON 连接条件;\n\nSELECT * FROM 表1 [INNER] JOIN 表2 WHERE 连接条件;\n\nSELECT * FROM 表1, 表2 WHERE 连接条件;</code></pre><p>2、<strong>外连接</strong>：不管是否符合连接条件，记录都要保留在结果集里</p>\n<pre><code>// 右表出NULL值和左表连接\nLEFT JOIN </code></pre><p>3、<strong>内外连接的区别</strong>。具体如图所示（图片摘自LeetCode）</p>\n<p>1）左联结（left join），联结结果保留左表的全部数据<br>2）右联结（right join），联结结果保留右表的全部数据<br>3）内联结（inner join），取两表的公共数据</p>\n<p><img src=\"/page/mysql2/%5CSQL%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94%E6%9F%A5%5Csql%E8%BF%9E%E6%8E%A5.png\" alt></p>\n<p>应用在<a href=\"https://leetcode-cn.com/problems/combine-two-tables/\" target=\"_blank\" rel=\"noopener\">175.组合两个表中</a>。该题需要满足“无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息”，所以当person表在左时采用左连接。</p>\n<h3 id=\"一些注意事项\"><a href=\"#一些注意事项\" class=\"headerlink\" title=\"一些注意事项\"></a>一些注意事项</h3><p>1、<strong>表连接时on和where的区别</strong></p>\n<p>以下不推荐，因为查询速度会很慢，每一次都会执行WHERE语句中的内容。</p>\n<pre><code>SELECT ename \nFROM t_emp\nWHERE deptno = (SELECT deptno FROM t_emp WHERE ename=&quot;SCOTT&quot;)</code></pre><pre><code>SELECT e2.ename\nFROM t_emp e1 JOIN t_emp e2 ON e1.deptno=e2.deptno\nWHERE e1.ename = &quot;SCOTT&quot;</code></pre><p>将AVG的结果视为一个表，与原表进行连接。</p>\n<p>错误</p>\n<pre><code>SELECT e2.ename\nFROM t_emp e1 JOIN t_emp e2 ON e2.sal &gt;= AVG(e1.sal)</code></pre><p>正确</p>\n<pre><code>SELECT e.ename\nFROM t_emp e \nJOIN (SELECT AVG(sal) avg FROM t_emp) t\nON e.sal &gt;= t.avg;</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"SELECT语句\"><a href=\"#SELECT语句\" class=\"headerlink\" title=\"SELECT语句\"></a>SELECT语句</h3><p>1、基本使用框架</p>\n<pre><code>SELECT * FROM 数据表\n[WHERE]\n[LIMIT]\n[OFFSET]</code></pre><p>2、使用别名</p>\n<pre><code>SELECT\n    字段名 AS 别名\nFROM 数据表</code></pre><p>3、查询语句的执行顺序：</p>\n<p>先进行语法分析和优化，找到关键字优先级，先执行FROM，再执行SELECT</p>\n<h3 id=\"查询相关功能\"><a href=\"#查询相关功能\" class=\"headerlink\" title=\"查询相关功能\"></a>查询相关功能</h3><p>1、<strong>ORDER BY</strong>子句功能，对查询的结果进行<strong>排序</strong>，示例如下</p>\n<pre><code>// 按照相关信息进行排序\nSELECT * FROM * ORDER BY 列名 [ASC|DESC]\n// 多个排序信息\nSELECT * FROM * ORDER BY 列名 [ASC|DESC],列名 [ASC|DESC]</code></pre><p>2、去除结果中的<strong>重复记录</strong>，在字段名称前加上<strong>DISTINCT</strong>字段，只支持一个字段名。</p>\n<pre><code>SELECT DISTINCT 字段名 FROM *;</code></pre><p>3、<strong>条件查询</strong>，使用<strong>WHERE</strong>语句指定查询的条件逻辑，中间使用AND|OR等逻辑连接符连接，同时注意判断相等的条件是“=”而不是“==”。</p>\n<pre><code>SELECT * FROM * WHERE 条件1 [AND|OR] 条件2 ......;</code></pre><p>4、使用<strong>聚合函数</strong>。所谓聚合函数，也就是平均值、最大值等函数，以下为求该字段名下的平均值函数（AVG），其他函数使用方法与此类似。该类方法在实际使用时可以将统计结果作为一个子表进行查询。</p>\n<pre><code>SELECT AVG(字段名) FROM 表名</code></pre><p><strong>COUNT(*)</strong>用于获得包含空值的记录数，<strong>COUNT(字段名)</strong>用于获取包含非空值的记录数。</p>\n<p>5、<strong>分组查询</strong>，使用<strong>GROUP BY</strong>字句。即通过一定规则将数据集分为若干个部分进行查询处理。以下即为使用字段1进行分组统计每一组中字段2的平均值。</p>\n<pre><code>SELECT 字段1,AVG(字段2) FROM 表名 GROUP BY 字段1;</code></pre><p>使用分组查询SELECT语句中只能出现用以分组的字段以及其他字段的聚合函数，否则会报错（由于产生了<strong>一对多</strong>的关系）。为解决这个问题，可以使用<code>GROUP_CONCAT</code>函数，这个函数可以将符合条件的值连接起来进行输出，可以理解为将“多”的部分进行了字符串拼接。</p>\n<pre><code>SELECT 字段1,GROUP_CONCAT(字段2) FROM 表名 GROUP BY 字段1;</code></pre><p>同时可以加上<code>WITH ROLLUP</code>再进行一次汇总运算（即在返回的查询结果之下再加上一条汇总记录）。</p>\n<pre><code>SELECT 字段1,AVG(字段2) FROM 表名 GROUP BY 字段1 WITH ROLLUP;</code></pre><p>6、<strong>HAVING</strong>子句，以及为何要使用HAVING子句</p>\n<p>由于WHERE子句执行在GROUP BY子句之前，因此如果WHERE子句中出现了如平均值等信息时SQL会不知道在哪个范围内进行平均，因此会出错，如以下代码即为错误的（聚合函数作为判断条件）。所以需要使用<code>HAVING</code>子句。</p>\n<pre><code># 使用错误\nSELECT f1\nFROM table\nWHERE AVG(f2) &gt; 10\nGROUP BY f1;</code></pre><pre><code># 使用正确\nSELECT f1\nFROM table\nGROUP BY f1 HAVING AVG(f2) &gt; 10;</code></pre><h3 id=\"表的连接\"><a href=\"#表的连接\" class=\"headerlink\" title=\"表的连接\"></a>表的连接</h3><p>表的连接很重要，具体有内外两种连接构成。</p>\n<p>1、<strong>内连接</strong>：结果集中只保留符合连接条件的记录</p>\n<pre><code>SELECT * FROM 表1 [INNER] JOIN 表2 ON 连接条件;\n\nSELECT * FROM 表1 [INNER] JOIN 表2 WHERE 连接条件;\n\nSELECT * FROM 表1, 表2 WHERE 连接条件;</code></pre><p>2、<strong>外连接</strong>：不管是否符合连接条件，记录都要保留在结果集里</p>\n<pre><code>// 右表出NULL值和左表连接\nLEFT JOIN </code></pre><p>3、<strong>内外连接的区别</strong>。具体如图所示（图片摘自LeetCode）</p>\n<p>1）左联结（left join），联结结果保留左表的全部数据<br>2）右联结（right join），联结结果保留右表的全部数据<br>3）内联结（inner join），取两表的公共数据</p>\n<p><img src=\"/page/mysql2/%5CSQL%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94%E6%9F%A5%5Csql%E8%BF%9E%E6%8E%A5.png\" alt></p>\n<p>应用在<a href=\"https://leetcode-cn.com/problems/combine-two-tables/\" target=\"_blank\" rel=\"noopener\">175.组合两个表中</a>。该题需要满足“无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息”，所以当person表在左时采用左连接。</p>\n<h3 id=\"一些注意事项\"><a href=\"#一些注意事项\" class=\"headerlink\" title=\"一些注意事项\"></a>一些注意事项</h3><p>1、<strong>表连接时on和where的区别</strong></p>\n<p>以下不推荐，因为查询速度会很慢，每一次都会执行WHERE语句中的内容。</p>\n<pre><code>SELECT ename \nFROM t_emp\nWHERE deptno = (SELECT deptno FROM t_emp WHERE ename=&quot;SCOTT&quot;)</code></pre><pre><code>SELECT e2.ename\nFROM t_emp e1 JOIN t_emp e2 ON e1.deptno=e2.deptno\nWHERE e1.ename = &quot;SCOTT&quot;</code></pre><p>将AVG的结果视为一个表，与原表进行连接。</p>\n<p>错误</p>\n<pre><code>SELECT e2.ename\nFROM t_emp e1 JOIN t_emp e2 ON e2.sal &gt;= AVG(e1.sal)</code></pre><p>正确</p>\n<pre><code>SELECT e.ename\nFROM t_emp e \nJOIN (SELECT AVG(sal) avg FROM t_emp) t\nON e.sal &gt;= t.avg;</code></pre>"},{"title":"务虚时代下的国贼——李鸿章","date":"2020-03-04T04:17:16.000Z","fileName":"Li_Hongzhang","_content":"<center>一</center>\n\n近日看老剧《走向共和》，其前半段多以李鸿章之视角演绎，李鸿章何许人也，若非要集这百年悠悠之口套出几个词来，想必就是汉奸卖国贼之类的了，至少用于普及基本历史常识的历史课本中，作为百年国耻代表的《马关条约》与《辛丑条约》之上，就铸着该君的名字，所以这样说也没错。\n\n所谓汉奸，所谓卖国贼，这两个词至少在中华文化体系下是一种性质非常恶劣的词了吧，这与百年辛酸史，或者说在国家危亡之际国人对所谓“忠臣名将”的向往是分不开的，无论何人，无论何时，只要在身份认同上认为自己是中国人的，对待这些人都可以堂而皇之的啐一口唾沫，道一声“呸”。因为在我们中国人眼中，对历史的“通俗看法”（所谓通俗看法，是指不专门研究某一段历史的普通人，对身处该时段历史人物的主观看法，或说评价）是有底线和顶线的，底线想必就是卖国攘民等龌龊行径了，而顶线就是所谓为国请命的英雄们了，或者说以死明志的气节。当然除此之外，在看待历史人物时，顶线与底线往往还联络着主角道德的好与坏。\n\n<center>二</center>\n\n底线之下，无论之前干过什么，无论这个人作为一个人来讲怎么样，都不值得原谅，参考秦桧与汪精卫（前者还跪着呢）；而顶线之上，有所作为当然更好，但似乎事情做没做成也没有太大所谓，死谏，不趋附权贵，最好再带点文采写些个正气凛然的东西或者稀里糊涂的处在一段展现美好品行的故事中心，都值得树碑立传，万世景仰（至少在大部分国人心目中此类人物的形象是好的），参考孔融。\n\n底线之下，无甚好说，做了过分引人注目的坏事情，难道还会有很多人愿意去考虑你干这坏事之前的心路？大部分人会憎恶你，少部分脑袋勤快点的人会在憎恶中加上一些同情，还有极小部分人会把你当成一个工具，表达他们“看清事实”与“与众不同”的工具，这一类人不谈也罢，他们不懂得当瑕疵多到一种程度时，瑕不掩瑜这个词是不适用的。\n\n但顶线之上就会有一些问题了，在史书中活成这一类的人心念一动就能想出很多，他们大部分都可以作为鲁迅先生笔下我中华的脊梁，但我偏偏把孔融放在这里，为何呢？是因为我想说明这条适用于大众的对历史人物看法的惯性思维多半有些不客观。“孔四岁，能让梨”，这是大部分人都清楚的故事，别的不说，我在痴迷三国的那个年龄，总还是把孔融当成个人物的。但稍稍读点书，以今日之眼光，想瞧得上孔融这个人实在是难，可他却在未来的两千年里享尽英德之名，被无数父母当作启蒙孩子的一个典范，与古往今来无数仁人志士枭雄豪杰并排而立，我以为实在是忝列其中啊。\n\n<center>三</center>\n\n让一个梨便得以流芳千古，这个梨也实在是贵的很啊，让梨这个操作也算是东汉末年一个最成功的炒作了吧。但我实在是不明白大一点的梨子是孔融吃掉还是他哥哥吃掉到底对他们一家或者说对他们兄弟二人能有多大干系呢。非要说的话，难道梨子在东汉越大越香？而大到一定程度会产生口感上的质变？还是一个天生不太喜欢吃梨子的小孩在东汉不太常见？\n\n我以为是后者，毕竟在一个百姓连饭都吃不饱的时代，产生一个类似孔融这种不喜欢梨的小孩实在是困难，这也是保证这件事合理性的唯一解释了，不然孔融一家想必都有癔症。\n\n但遗憾的是，事实来看他们一家就是有癔症，也许是遗传的吧。毕竟硬要说的话，他们的老祖宗孔丘也有癔症，但孔夫子的癔症到底是在我这个两千多年后的后生眼里才能得见的，在孔夫子那个时代就算是癔症也多少有些可爱。但一种病毒也许两千年前无伤大雅甚至可以说是可爱，到一千年前病毒几经变异变成了值得称颂的一个身体特征，而到了一百多年前当一个群体把感染了这个病毒当成荣耀并认为人人便该如此的时候，来了另一群没得病且更强壮的人使得感染这个病毒变成了自然选择的一个逆选项时，有一些病人开始尝试治病但囿于同胞掣肘与病毒几经进化下的狡诈以及自身体内病毒的顽固，失败了，对于这种人，在考虑失败后果之前，我以为首先得感慨一下其知其不可而为之的勇气，至少这是我尊敬孔子的一个重要原因，也是我认为对卖国贼李鸿章，有必要进行另一番议论的原因。\n\n<center>四</center>\n\n以上所述的“癔症”，我想与今年的新冠肺炎多少有些类似，症状复杂容易变异，只是这癔症并不作用在生理上而是作用在精神上。其症状很多，五花八门，但我今天想谈谈的只有务虚。\n\n就像孔融让梨得到赞扬一样，赞扬的不是让梨这个动作而是其谦让的品德。我从不否认谦让是个美德，但让一个历史上实实在在活生生的人，因为这样一个简单的动作就成为了根植一个名族内心千年的道德符号，我认为实在是荒谬了些，哲学上喜欢将一件事情推到极端而后再观察其是否仍然符合某一标准，而长大后的孔融倒着实使这个荒谬的意味更深了些。\n\n几乎没有付出任何代价与个人的努力，一件名门世家随意记录的小小的事情，让一个人毫不费力收获了也许是古往今来来自孩子和家长们最多的赞誉，这不是偶然，而是自先秦到清末国人一直存在的务虚观念，几个小小的汉字，所谓仁义礼智信孝廉，都是好的优秀的修身品德，也从来都是封建时代的国人精英们竞相模仿参照的对象，可仔细想想，这几个字有所谓放之四海而皆准的具体的标准与定义吗？是所谓的标准管用还是历代大儒帝王的一声惊叹或者流传坊间的一段传奇更加管用呢？普通人是实实在在的做事更能得到赞扬还是卧冰求鲤式的“作秀”更能得到赞扬呢？\n\n这些品德确立之初的好坏我无从得知，但由于上述文字解释权等原因，这几个字或者说我中华中世纪所追求的那些抽象的概念，渐渐变为了权力与利益的代言人，成为了统治者所谓推行“王治”的工具（与其说是王治，不如说是愚民）。而随着皇权的愈加集中，传播这些务虚概念的工具，即我们引以为傲的科举，使得无数中世纪乃至近代的国人精英沦为了务虚的奴隶，深陷囹圄而自以为自由（李鸿章有改变很多事物的资本，但他囿于所谓忠君之类的概念敷衍其事含糊其词，想必也是务虚已入骨髓矣）。在没有西方文化冲击的情况下，整个民族和国家都浸沐在这务虚的汤药中，难以自拔。\n\n我本身是一个很懒惰的人，所谓磨洋工的一把好手，所以倘若我在百年千年前的话，肯定会变着花样以把自己弄死为标准去对应这些百姓追求统治者喜欢的概念，也许周围正好来了个大儒书圣，听说了我的故事的话还能把我的事迹记录一些，这样“流芳百世”的难度的确是大，但想必也比实干勤学的概率要大的多，还省去了不论是脑力还是体力带来的困难与麻烦，整不好运气更好点倒是能成为孔融一样的道德符号，实在是妙啊，妙不可言。\n\n既然务虚便能带来一切能够自我宽慰还得社会认可的东西，那作为贵族官员干嘛要务实呢？留着指甲，以商贾为耻，以农桑为耻，以一切实干为耻（当然社会是需要人做实事的，但做实事在我们的文化里受待见吗？所谓君子远庖厨，历朝历代各个英雄豪杰当然也有很多实干的，但实干的基础仍然是这个务虚的社会，这本身就给这个实干抹上了一层务虚的阴影），专注虚妄的经学便能高人一等，有文才胸富万经的为官一处自是高高在上，没有这个本事的寒窗苦读一番也能落个“读书人的偷能叫偷吗”的阿Q式精神胜利，在精神上又是高高在上，都是高高在上，在1793年英国使团来华时是高高在上，在19世纪被英国揍、被日本揍之后还是高高在上。永远都是高高在上，这一词也许便能概括李鸿章一生大部分清廷官员的心理了吧，即使对洋人卑躬屈膝，对着百姓照样还是高高在上，照样是所谓“牧民于野”的当代俊杰。\n\n欺民，罔民，愚民，却将这种行为解释为王化，“王化”过后便使牧民如放牧牛羊那般简单（如此看来儒家的王治倒是能够作为畜牧业一个很好的理论），古语中的这个“牧”字用的很是精髓啊。这也概括了务虚之道能够得以盛行，国人能够自欺欺人的原因，在这样一个务虚时代之末，则有国贼李鸿章。\n\n<center>五</center>\n\n梁任公先生在1901年为李鸿章做的传记里，有这样一段话：\n\n>*夫李鸿章果足称为中国第一人与否吾不敢知，而要之现今五十岁以上之人，三四品以上之官，无一可以望李之肩背者，则吾所能断言也。李之死，于中国全局有关系与否吾不敢知，而要之现在政府失一李鸿章，如虎之丧其伥，前途岌岌，愈益多事，此又吾所敢断言也*\n\n加之记述一下李鸿章光绪元年所上之奏疏：\n\n>*近时拘谨之儒，多以交涉洋务为涴人之具；取巧之士，又以引避洋务为自便之图。若非朝廷力开风气，破拘挛之故习，求制胜之实际，天下危局，终不可支，日后乏才，且有甚于今日者。以中国之大，而无自立之时，非惟可忧，抑亦可耻*\n\n摘录至此，不由扼腕感慨百多年前洋务之艰难，掣肘之猖獗。\n\n引避洋务以自便，多轻松的自便之法啊，从前务虚以留其名，尚且还得付出诸多代价，而洋人来了后为一个高风亮节之名，却只需对奇技淫巧表达不屑，对操办洋务以自强求富之人以鄙夷眼光视之。多轻便啊，居庙堂之高则上书参劾，处江湖之远则煽民怨怼，永远站在务虚下道德的制高点，倒颇像今天的键盘侠，下笔滔滔如有千言，若问韬略胸无一策。可惜的是今天的键盘侠倒是稍讲道理的人就会心生厌恶，而那个时代做一个真正杀人的键盘侠倒成了政治正确。\n\n而“求制胜之实际”这句话倒着实让我奇怪，我实在不知道制胜的实际为什么要求。在一个逝者如斯夫的三维世界，什么东西都是一锤子买卖，制胜难道还有实际与不实际的分别？一个管理着四亿五千万人口的朝廷，于国事竟要以“实际”与否为争论点，实在荒唐（也许以往务虚之实际对洋人不管用吧，毕竟洋人大部分人都不给你“牧”，明明这才是现在看来正常的表现到了晚清士大夫眼中成了蛮夷无廉耻的表现，估计他们也很苦恼吧），也难怪任公先生有以上断言了。\n\n这就是那个时代我国的头号国贼了，倒不知他卖的国是虚妄概念上的国还是实际意义上的国了，不知道满清朝廷在马关之后的朝堂上有没有这一议论。\n\n<center>六</center>\n\n说李是国贼的论据，我以为归纳起来大约有四个大点。其一为边防塞防之争；其二为甲午战争之败；其三为辛丑条约之耻；其四为死后余产之巨。针对这几点，我也想简单谈谈我的看法。\n\n关于边防塞防之争，以今日结果的眼光来看李鸿章所谓的“放弃新疆”自然是妥妥卖国行为，引述其作此决策的理由大致如下：\n\n>*历代备边，多在西北，其强弱之势，主客之形，皆适相埒，且犹有中外界限。今则东南海疆万余里，各国通商传教，往来自如，麇集京师，及各省腹地，阳托和好之名，阴怀吞噬之计，一国生事，诸国构煽，实为数千年来未有之变局。轮船、电报之速，瞬息千里，军器、机事之精，工力百倍，又为数千年来未有之强敌。外患之乘，变幻如此，而我犹以成法制之，譬如医者疗疾，不问何症，概投之以古方，诚未见其效也*\n\n彼时背景正为日本寻衅侵略台湾，海防压力巨大，若忽略新疆一事，我以为兴建海防实在算是清末洋务少有的高瞻远瞩之举了，而对于新疆问题，李鸿章倒似乎想以外交途径解决（这也是他的惯用伎俩了，甲午之败这也是因素之一）。唉，彼时之人哪里懂得弱国无外交的道理呢，如此看来若无左宗棠收复新疆，也许新疆在那时候就成为了永远收不回的东三省了吧（九一八事变后民国政府也企图通过外交途径解决东北问题）。\n\n也正应如此，世人往往厚左而薄李，但以我之见，左宗棠与李鸿章并无大分别，李并非一意放弃塞防而是以为边防更为紧迫，而左亦非务虚守旧之人，只是认为新疆之失已迫在眉睫而海上之难尚可以时日斡旋。边防塞防之争，与其说是善恶之争，倒不如说是厉害得失之争。可叹啊，百年后的课本中，左宗棠成了英雄，而李鸿章却成了国贼，实在只是命长与命短的分别啊。\n\n而对甲午战争之败，我没有什么好说的，整个战争我仿佛看到的不是战争，而是一帮小孩在拿人命、鲜血与一个民族的尊严为筹码玩过家家，仿佛这个国，不是实际意义上的国。世人皆知甲午海战北洋水师全军覆没，是以为耻，却不知陆军在朝鲜更是一败涂地。对此战的总结梁任公先生在为李所作传记中已经分析的很透彻了，我不再赘言，遂摘录如下。\n\n>*当中日战事之际，李鸿章以一身为万矢之的，几于身无完肤，人皆欲杀。平心而论，李鸿章诚有不能辞其咎者，其始误劝朝鲜与外国立约，昧于公法，咎一；既许立约，默认其自主，而复以兵干涉其内乱，授人口实，咎二；日本既调兵，势固有进无退，而不察先机，辄欲倚赖他国调停，致误时日，咎三；聂士成请乘日军未集之时，以兵直捣韩城以制敌而不能用，咎四；高升事未起之前，丁汝昌请以北洋海军先鏖敌舰，而不能用，遂令反客为主，敌坐大而我愈危，综其原因，皆由不欲衅自我开，以为外交之道应尔，而不知当甲午五六月间，中日早成敌国，而非友邦矣，误以交邻之道施诸兵机，咎五；鸿章将自解曰：量我兵力不足以敌日本，故惮于发难也。虽然，身任北洋整军经武二十年，何以不能一战？咎六；彼又将自解曰：政府掣肘，经费不足也。虽然，此不过不能扩充已耳，何以其所现有者，如叶志超、卫汝贵诸军，素以久练著名，亦脆弱乃尔，且克减口粮盗掠民妇之事，时有所闻，乃并纪律而无之也，咎七；枪或苦窳，弹或赝物，弹不对枪，药不随械，谓从前管军械局之人皆廉明，谁能信之，咎八；平壤之役，军无统帅，此兵家所忌，李乃蹈之，咎九；始终坐待敌攻，致于人而不能致人，畏敌如虎，咎十；海军不知用快船快炮，咎十一；旅顺天险，西人谓以数百兵守之，粮食苟足，三年不能破，乃委之于所亲昵阘冗恇怯之人，闻风先遁，咎十二。此皆可以为李鸿章罪者。若夫甲午九十月以后，则群盲狂吠，筑室道谋，号令不出自一人，则责备自不得归于一点。若尽以为李鸿章咎，李固不任受也。又岂惟不任受而已，吾见彼责李罪李者，其可责可罪，更倍蓰于李而未有已也。是役将帅无一人不辱国，不待言矣。然比较于百步五十步之间，则海军优于陆军，李鸿章部下之陆军，又较优于他军也。*\n\n战争之后，尚有广东水师向日本索要被俘舰只，理由竟是此次战役与广东无涉。荒唐至此，毫无国家民族观念，以五十步笑百步之典，李倒着实是那五十步之人，但一个国家只有五十步与百步的分别，岂不谬哉！\n\n至于辛丑条约，我以为无甚好说，前两者对李都有切实可责可恨之处，凡是认为李无一点错误责任，无一点卖国嫌疑者都是巧言令色之人。惟此辛丑条约，说李是代国背锅言辞尚可牵强而去。只是可惜可恨啊，面对务实之世界，务虚者仍活在往日虚幻的天朝大国的旧梦里，可惜是针对那时被虚妄的概念奴役却自以为自由的愚民，可恨是针对朝堂上自私自利毫无理性的那几家几姓。\n\n最后也就是死后遗产之巨了，关于这个我没有观点，也没做什么考证，四千万家产的言论没有什么根据，但清正廉洁的说法也就是自娱自乐了，而对于因为李鸿章财产甚多而输了甲午战争的言论，我也无话可说，见解如此，与键盘侠无异。以下摘录任公所作传记中的一段话，仁者见仁，智者见智吧。\n\n>*世人竞传李鸿章富甲天下，此其事殆不足信，大约数百万金之产业，意中事也。招商局、电报局、开平煤矿、中国通商银行，其股份皆不少，或言南京、上海各地之当铺银号，多属其管业云*\n\n以上四点，第一、第三、第四点我认为以此为依据对李进行口诛笔伐只是视李为国贼带来的惯性思维所致，即在摆出论据之前心中已有答案，而后用这些论据中的点去套已有的结论。这样做虽然看起来不够客观，但我认为实在是人心所向。而第二点则是“国贼论”的核心，也是李鸿章以及所谓大清帝国的转折点吧，在这一点上李鸿章有直接责任。从前被英法等一流列强欺负，但装饰门面倒还对的起“帝国”这两个字的隐形含义，今而兴洋务练出的新军在日本人面前不堪一击，以使敌人在朝鲜都不相信战胜的就是所谓清廷按照西法练成的精锐部队。\n\n由此看来，这些活在近代的中古士大夫在务虚本领之上倒还是实在的啊，能够做到让外人不辨雌雄。\n\n<center>七</center>\n\n对李鸿章，梁任公先生总结其为“时势所造之英雄，非造时势之英雄”，又对其一生事迹评价为“不学无术，不敢破格，是其所短也；不避劳苦，不畏谤言，是其所长也”。\n\n是英雄造时势还是时势造英雄，这一直可以视为是一个悖论问题，这一问题有诸多解法的原因其实也只是因为对英雄与时势有诸多不同的定义与见解而已。\n\n英雄是什么，一怒之下伏尸百万流血千里的应该能算，这是就其权威而论的；率性任侠义气为先的想必也能算，这是就其个性担当而言的；富国强兵振兴朝政的一定能算，这是就其能力而论的；而为国请命鞠躬尽瘁死而后已的也一定能算，这是就其一片赤子之心而论的。这四点似乎都没错，但偏偏国贼李鸿章似乎与后三点都沾些边，对部下讲情义，为国事不避艰难，临死之前尚在为国事操心，按这个道理，他该是英雄啊，在通俗历史评价上他该是顶线以上的人啊，怎么会落得底线以下的看法与待遇呢？还是引用任公先生的话。\n\n>*十九世纪列国皆有英雄，而我国独无一英雄，则吾辈安得不指鹿为马，聊自解嘲，翘李鸿章以示于世界曰，此我国之英雄也。呜呼！亦适我国之英雄而已矣，亦适成为我国十九世纪以前之英雄而已矣*\n\n是啊，自始皇帝嬴政开创中央集权政体之日起，五经四书浸染之下的千年务虚时代，又哪有什么英雄造时势的事情呢？始皇殁后有项羽，一个勇武过人的英雄在乎的是如何让锦衣不夜行，在意这种虚妄的概念使他重新推行分封。后有刘邦，有曹操，有李世民，有赵匡胤，有朱洪武，再有所谓康乾盛世，有所谓同治中兴，那么多个皇帝之下有那么多个能人猛士堪称英雄，可有谁真正造就过时势吗？似乎有，如周瑜赤壁的那一把火，似乎又没有，因为我只看到了一个个朝代的更替与牧民锁链的加重。也许以百年局部的眼光来看，总有公瑾一般的豪杰改造时势，但以千年民族国家的眼光来看，十九世纪前所谓的英雄，不过是在同一片天空之下翻手为云覆手为雨罢了，他们从没有改天换日的见识与气魄。\n\n话虽这样说，但英雄在他们的时代仍然是英雄，非要以今日之眼光视昨日之旧人未免落入历史虚无主义的窠臼。而对李鸿章以国贼的态度进行苛责，与此同理，无非是以今日之评价观点视旧时之英雄罢了。在对李一系列失误的讨论之外，我认为不应该让一个旧时代的先行者为他所处的整个时代背锅。\n\n但话又说回来，这样一个不避劳苦的旧时代先行者，究其一生却为何在历史上仍落个身败名裂的下场呢？\n\n千年务虚时代，治经论典自然是务虚，可人毕竟是活在现实世界的啊，“务实”必不可少，闻鸡起舞者有之，改政变法者有之，“格物致知”者亦有之，为何集数千年这亿万之人，却无一个堪当变务虚时势为务实的英雄呢？自是千年务虚痼疾已深，不彻底打碎更变实在是无从谈起啊。否定了这一点，就是对20世纪我们中国人长达一个世纪的更革奋斗视而不见。\n\n而以李鸿章为汉奸国贼者，必为甲午之败辛丑之耻痛惜扼腕，仿佛杀李则能改变战局避免国耻，而清廷则仍是堂堂正正的大清帝国，这实在是癔梦啊。想当造时势之英雄，则必须要能真正的打破务虚学而有术，这在当时几乎是与整个千年文化积习为敌，事实证明李鸿章这种务虚时代的实干家不行，翁同龢这种务虚时代的所谓君子、康有为这种务虚时代所谓的改革家都不行，那些务虚时代的小人就更不必说了。\n\n以李鸿章之务实敢干不辞辛劳生于务虚时代都难以学而有术，洋务半生尚“不识国民之原理，不通世界之大势，不知政治之本原”，一生兢兢业业如履薄冰都难以在后世摆脱一个“国贼”的骂名，可见务虚痼疾程度之深了。以务虚时代之英雄而成务实时代之国贼，英雄和国贼果然有所谓巨大的间隙吗？还是李鸿章生平前后的主流文化之间有这般巨大的间隙呢？这百年来，那么多只如鲁迅先生般的如椽巨笔，才堪堪扭转千年痼疾在人心中的荼毒之深，将这种荼毒所表现出的后果让李一人一力承担，我觉得实在是肤浅过分的言论。\n\n唉，以旧英雄之身份而成新时代之国贼，以今日之眼光，到底该视为李鸿章的过错还是千年务虚文化的过错呢？\n\n<center>八</center>\n\n作为一个中国人，对历史总会心存一些假如（毕竟有强汉盛唐，现在的口号也还是复兴）。总有人会说满清误国，认为遇上19世纪那千年未有之变局的假如不是满清朝廷而是汉人王朝情况会完全不同；也有人会想若遭遇此事的中国统治者不是咸丰，不是光绪，不是慈禧，而是秦皇汉武唐宗宋祖，结局也会不一样；还有人说明朝的资本主义萌芽是被满清给消灭的，否则中国也会自然而然的成为近代西方那样发达的资本主义国家。\n\n诸如此类的想法很多，但历史没有偶然，即使有偶然，在一个模拟器中能够重现历史，让那些明君圣君放弃一家一姓特权，让那些世家门阀放弃所有地方权益的概率能有多少呢？即使有人真的愿意，他能够扳的过整个旧文化的手腕吗？（过继当上皇帝的想尊自己的生父历朝历代士大夫都会罗里吧嗦的，没有点手腕的皇帝连这种事都搞不定，即使手腕通天难道能搞定整个文化变革的事情吗？因此在中国这种务虚文化的千年体系下，自上而下的改革是不可能行的通的，想变革只有改变一个民族的思想，这又哪里是一个人能够办得到的呢），孟子说过“人之所以异于禽兽者几希，庶民去之，君子存之”，孟子当然是惯于骂人禽兽，而放弃他这种庶民君子的成见，还智于百姓，让“君子”与“禽兽”平起平坐，历代有君王与权臣能够做到吗？（也许中国能够依赖如明治天皇那样的明君通过变革依靠广阔的土地在19世纪成为列强，但这种强国方式与英美等国还是有根本区别，日本明治维新后是变强了，但仍然有华族这种旧时代产物，我以为仍然带着野蛮不理性的气息，以中国之大，如此，更甚矣，仍然只会成为如沙皇俄国那样的纸老虎）王莽的改制引来了千古骂名只是因为其制过激而使掣肘过厉，而“科举”的产生也只是得益于旧门阀势力的削弱，而这种削弱，无不是血与铁的结果，而后再看19世纪末李鸿章所遭之非议，守旧势力在19世纪到20世纪的关口还指望着把洋人赶走继续上古时期的统治方法。这是他们幼稚吗？不是，实在是千年务虚积疾过深，使得四万万国人人人为鸵鸟而不自知，大才如严复尚且崇尚科举，务实如李鸿章尚且惋惜自己一生没做成军机大臣。\n\n在这种千年务虚观念深入骨髓的情况下，小修小补有用吗？剜肉补疮有用吗？我看把血全换了都未必有用。在这种情况下，将千年务虚积累下导致的癔病产生的痛苦全部归咎给李鸿章这种只会小医小补的郎中，合理吗？骂李是国贼，那必须带上当时满朝文武，带上当时被欺罔了数千年的四万万百姓，带上数千年政治文化风俗的方方面面。雪崩之时，没有一片雪花是无辜的，但作为压死骆驼的最后一根稻草，难道李鸿章留给历史的意义只是让后人怒斥痛骂吗？\n\n十九世纪以前的英雄，配上了务虚思想引导下的务实，却成了日后人们眼中的国贼，应该感到悲哀吗？不应该感到悲哀吗？对着那个由务虚向务实转化的时代，是继续痛斥那务虚时代下的国贼或者说英雄，还是应该对我们19世纪以前的文化多做一些反思呢？\n\n后者，我以为才是李鸿章这个历史车轮扭动间隙下产生的矛盾人物该给我们带来的意义。\n\n<center>后记</center>\n\n本文基本可以视为是《走向共和》电视剧前半段以及梁任公先生的传记《李鸿章》的观后感吧，写之前没想过要什么纲领也没有确定什么中心论点，写到现在洋洋洒洒有八千多字，也渐渐形成了一个很不清晰的脉络吧。\n\n全文的中心其实也就是以李鸿章个人在通俗历史评价上的矛盾为引，引出对19世纪前中华传统文化的反思吧。一个代表着那段历史的人物，以两种文化的眼光看待，会得出英雄和国贼两个迥异的看法，这种激烈的矛盾也着实可以说明旧文化的一些荒谬之处了。\n\n当然全文只是借用了务实与务虚这一对矛盾在19世纪末那个节点上所爆发出来的强弱态势，并没有对中西文化或者说中国传统文化与现代文化进行所谓优劣对比及形成原因说明。因为非要进行详细的对比说明的话，我认为恐怕得从先秦思想和古希腊哲学的迥异说起，那话题就大了，所以全文对这种矛盾在我国中世纪的表现仅仅以叙代议，所表达的仅仅只是矛盾本身而不是对矛盾产生原因的分析论证。\n\n全文以李鸿章为引，但对李鸿章一生的事迹仅仅摘捡了其作为国贼原因的几个大点论述，如果对李鸿章或那个时代感兴趣，着实推荐任公先生的传记《李鸿章》（即《同光以来大事记》），其文作于1901年李鸿章死后不久，集合了那个时代的视角与梁公极其客观的评价，我认为堪称是了解李鸿章的第一手资料，也是了解那个时代的一个不错的POV。\n\n再来谈谈文章的另一个引子孔融，也许以知人论世而言他该算是在文学上卓有成就（建安七子之首），气节上也不错（堪称魏晋风骨，虽然我以为孔融这种气节不要也罢）。我在文章中如此苛责他说实话与大众苛责李鸿章也许没有什么本质的区别吧，要说区别，其实也是因为孔融所代表的这种务虚做派着实让我disgusting吧（细细想来，古人会写字的不多，所以键盘侠才会如此弥足珍贵吧），之前读过一些孔融的史料，有机会会写写我为啥那么不喜欢孔融，在此不再说明了。\n\n最后，谈谈为何我写着写着就以务虚作为一个主线了吧，这个原因说来惭愧，实在是自己的务虚行为所致，如今三月，还有三个月本科就该画上句号，但纵观自己这四年，基本没干成什么实在的事情（书读的好当然是实在的，游戏打出了名堂也是实在的啊，唯独什么都没做的像样倒是值得思考的一个点），遂作此文以自勉。\n\n子夜，记于2020.3.4 九江。希望疫情退散武汉加油。","source":"_posts/瞎侃/杂文/务虚时代下的国贼——李鸿章.md","raw":"---\ntitle: 务虚时代下的国贼——李鸿章\ndate: 2020-03-04 12:17:16\ntags:\n    - 杂文\ncategories:\n    - 瞎侃\n    - 杂文\nfileName: Li_Hongzhang\n---\n<center>一</center>\n\n近日看老剧《走向共和》，其前半段多以李鸿章之视角演绎，李鸿章何许人也，若非要集这百年悠悠之口套出几个词来，想必就是汉奸卖国贼之类的了，至少用于普及基本历史常识的历史课本中，作为百年国耻代表的《马关条约》与《辛丑条约》之上，就铸着该君的名字，所以这样说也没错。\n\n所谓汉奸，所谓卖国贼，这两个词至少在中华文化体系下是一种性质非常恶劣的词了吧，这与百年辛酸史，或者说在国家危亡之际国人对所谓“忠臣名将”的向往是分不开的，无论何人，无论何时，只要在身份认同上认为自己是中国人的，对待这些人都可以堂而皇之的啐一口唾沫，道一声“呸”。因为在我们中国人眼中，对历史的“通俗看法”（所谓通俗看法，是指不专门研究某一段历史的普通人，对身处该时段历史人物的主观看法，或说评价）是有底线和顶线的，底线想必就是卖国攘民等龌龊行径了，而顶线就是所谓为国请命的英雄们了，或者说以死明志的气节。当然除此之外，在看待历史人物时，顶线与底线往往还联络着主角道德的好与坏。\n\n<center>二</center>\n\n底线之下，无论之前干过什么，无论这个人作为一个人来讲怎么样，都不值得原谅，参考秦桧与汪精卫（前者还跪着呢）；而顶线之上，有所作为当然更好，但似乎事情做没做成也没有太大所谓，死谏，不趋附权贵，最好再带点文采写些个正气凛然的东西或者稀里糊涂的处在一段展现美好品行的故事中心，都值得树碑立传，万世景仰（至少在大部分国人心目中此类人物的形象是好的），参考孔融。\n\n底线之下，无甚好说，做了过分引人注目的坏事情，难道还会有很多人愿意去考虑你干这坏事之前的心路？大部分人会憎恶你，少部分脑袋勤快点的人会在憎恶中加上一些同情，还有极小部分人会把你当成一个工具，表达他们“看清事实”与“与众不同”的工具，这一类人不谈也罢，他们不懂得当瑕疵多到一种程度时，瑕不掩瑜这个词是不适用的。\n\n但顶线之上就会有一些问题了，在史书中活成这一类的人心念一动就能想出很多，他们大部分都可以作为鲁迅先生笔下我中华的脊梁，但我偏偏把孔融放在这里，为何呢？是因为我想说明这条适用于大众的对历史人物看法的惯性思维多半有些不客观。“孔四岁，能让梨”，这是大部分人都清楚的故事，别的不说，我在痴迷三国的那个年龄，总还是把孔融当成个人物的。但稍稍读点书，以今日之眼光，想瞧得上孔融这个人实在是难，可他却在未来的两千年里享尽英德之名，被无数父母当作启蒙孩子的一个典范，与古往今来无数仁人志士枭雄豪杰并排而立，我以为实在是忝列其中啊。\n\n<center>三</center>\n\n让一个梨便得以流芳千古，这个梨也实在是贵的很啊，让梨这个操作也算是东汉末年一个最成功的炒作了吧。但我实在是不明白大一点的梨子是孔融吃掉还是他哥哥吃掉到底对他们一家或者说对他们兄弟二人能有多大干系呢。非要说的话，难道梨子在东汉越大越香？而大到一定程度会产生口感上的质变？还是一个天生不太喜欢吃梨子的小孩在东汉不太常见？\n\n我以为是后者，毕竟在一个百姓连饭都吃不饱的时代，产生一个类似孔融这种不喜欢梨的小孩实在是困难，这也是保证这件事合理性的唯一解释了，不然孔融一家想必都有癔症。\n\n但遗憾的是，事实来看他们一家就是有癔症，也许是遗传的吧。毕竟硬要说的话，他们的老祖宗孔丘也有癔症，但孔夫子的癔症到底是在我这个两千多年后的后生眼里才能得见的，在孔夫子那个时代就算是癔症也多少有些可爱。但一种病毒也许两千年前无伤大雅甚至可以说是可爱，到一千年前病毒几经变异变成了值得称颂的一个身体特征，而到了一百多年前当一个群体把感染了这个病毒当成荣耀并认为人人便该如此的时候，来了另一群没得病且更强壮的人使得感染这个病毒变成了自然选择的一个逆选项时，有一些病人开始尝试治病但囿于同胞掣肘与病毒几经进化下的狡诈以及自身体内病毒的顽固，失败了，对于这种人，在考虑失败后果之前，我以为首先得感慨一下其知其不可而为之的勇气，至少这是我尊敬孔子的一个重要原因，也是我认为对卖国贼李鸿章，有必要进行另一番议论的原因。\n\n<center>四</center>\n\n以上所述的“癔症”，我想与今年的新冠肺炎多少有些类似，症状复杂容易变异，只是这癔症并不作用在生理上而是作用在精神上。其症状很多，五花八门，但我今天想谈谈的只有务虚。\n\n就像孔融让梨得到赞扬一样，赞扬的不是让梨这个动作而是其谦让的品德。我从不否认谦让是个美德，但让一个历史上实实在在活生生的人，因为这样一个简单的动作就成为了根植一个名族内心千年的道德符号，我认为实在是荒谬了些，哲学上喜欢将一件事情推到极端而后再观察其是否仍然符合某一标准，而长大后的孔融倒着实使这个荒谬的意味更深了些。\n\n几乎没有付出任何代价与个人的努力，一件名门世家随意记录的小小的事情，让一个人毫不费力收获了也许是古往今来来自孩子和家长们最多的赞誉，这不是偶然，而是自先秦到清末国人一直存在的务虚观念，几个小小的汉字，所谓仁义礼智信孝廉，都是好的优秀的修身品德，也从来都是封建时代的国人精英们竞相模仿参照的对象，可仔细想想，这几个字有所谓放之四海而皆准的具体的标准与定义吗？是所谓的标准管用还是历代大儒帝王的一声惊叹或者流传坊间的一段传奇更加管用呢？普通人是实实在在的做事更能得到赞扬还是卧冰求鲤式的“作秀”更能得到赞扬呢？\n\n这些品德确立之初的好坏我无从得知，但由于上述文字解释权等原因，这几个字或者说我中华中世纪所追求的那些抽象的概念，渐渐变为了权力与利益的代言人，成为了统治者所谓推行“王治”的工具（与其说是王治，不如说是愚民）。而随着皇权的愈加集中，传播这些务虚概念的工具，即我们引以为傲的科举，使得无数中世纪乃至近代的国人精英沦为了务虚的奴隶，深陷囹圄而自以为自由（李鸿章有改变很多事物的资本，但他囿于所谓忠君之类的概念敷衍其事含糊其词，想必也是务虚已入骨髓矣）。在没有西方文化冲击的情况下，整个民族和国家都浸沐在这务虚的汤药中，难以自拔。\n\n我本身是一个很懒惰的人，所谓磨洋工的一把好手，所以倘若我在百年千年前的话，肯定会变着花样以把自己弄死为标准去对应这些百姓追求统治者喜欢的概念，也许周围正好来了个大儒书圣，听说了我的故事的话还能把我的事迹记录一些，这样“流芳百世”的难度的确是大，但想必也比实干勤学的概率要大的多，还省去了不论是脑力还是体力带来的困难与麻烦，整不好运气更好点倒是能成为孔融一样的道德符号，实在是妙啊，妙不可言。\n\n既然务虚便能带来一切能够自我宽慰还得社会认可的东西，那作为贵族官员干嘛要务实呢？留着指甲，以商贾为耻，以农桑为耻，以一切实干为耻（当然社会是需要人做实事的，但做实事在我们的文化里受待见吗？所谓君子远庖厨，历朝历代各个英雄豪杰当然也有很多实干的，但实干的基础仍然是这个务虚的社会，这本身就给这个实干抹上了一层务虚的阴影），专注虚妄的经学便能高人一等，有文才胸富万经的为官一处自是高高在上，没有这个本事的寒窗苦读一番也能落个“读书人的偷能叫偷吗”的阿Q式精神胜利，在精神上又是高高在上，都是高高在上，在1793年英国使团来华时是高高在上，在19世纪被英国揍、被日本揍之后还是高高在上。永远都是高高在上，这一词也许便能概括李鸿章一生大部分清廷官员的心理了吧，即使对洋人卑躬屈膝，对着百姓照样还是高高在上，照样是所谓“牧民于野”的当代俊杰。\n\n欺民，罔民，愚民，却将这种行为解释为王化，“王化”过后便使牧民如放牧牛羊那般简单（如此看来儒家的王治倒是能够作为畜牧业一个很好的理论），古语中的这个“牧”字用的很是精髓啊。这也概括了务虚之道能够得以盛行，国人能够自欺欺人的原因，在这样一个务虚时代之末，则有国贼李鸿章。\n\n<center>五</center>\n\n梁任公先生在1901年为李鸿章做的传记里，有这样一段话：\n\n>*夫李鸿章果足称为中国第一人与否吾不敢知，而要之现今五十岁以上之人，三四品以上之官，无一可以望李之肩背者，则吾所能断言也。李之死，于中国全局有关系与否吾不敢知，而要之现在政府失一李鸿章，如虎之丧其伥，前途岌岌，愈益多事，此又吾所敢断言也*\n\n加之记述一下李鸿章光绪元年所上之奏疏：\n\n>*近时拘谨之儒，多以交涉洋务为涴人之具；取巧之士，又以引避洋务为自便之图。若非朝廷力开风气，破拘挛之故习，求制胜之实际，天下危局，终不可支，日后乏才，且有甚于今日者。以中国之大，而无自立之时，非惟可忧，抑亦可耻*\n\n摘录至此，不由扼腕感慨百多年前洋务之艰难，掣肘之猖獗。\n\n引避洋务以自便，多轻松的自便之法啊，从前务虚以留其名，尚且还得付出诸多代价，而洋人来了后为一个高风亮节之名，却只需对奇技淫巧表达不屑，对操办洋务以自强求富之人以鄙夷眼光视之。多轻便啊，居庙堂之高则上书参劾，处江湖之远则煽民怨怼，永远站在务虚下道德的制高点，倒颇像今天的键盘侠，下笔滔滔如有千言，若问韬略胸无一策。可惜的是今天的键盘侠倒是稍讲道理的人就会心生厌恶，而那个时代做一个真正杀人的键盘侠倒成了政治正确。\n\n而“求制胜之实际”这句话倒着实让我奇怪，我实在不知道制胜的实际为什么要求。在一个逝者如斯夫的三维世界，什么东西都是一锤子买卖，制胜难道还有实际与不实际的分别？一个管理着四亿五千万人口的朝廷，于国事竟要以“实际”与否为争论点，实在荒唐（也许以往务虚之实际对洋人不管用吧，毕竟洋人大部分人都不给你“牧”，明明这才是现在看来正常的表现到了晚清士大夫眼中成了蛮夷无廉耻的表现，估计他们也很苦恼吧），也难怪任公先生有以上断言了。\n\n这就是那个时代我国的头号国贼了，倒不知他卖的国是虚妄概念上的国还是实际意义上的国了，不知道满清朝廷在马关之后的朝堂上有没有这一议论。\n\n<center>六</center>\n\n说李是国贼的论据，我以为归纳起来大约有四个大点。其一为边防塞防之争；其二为甲午战争之败；其三为辛丑条约之耻；其四为死后余产之巨。针对这几点，我也想简单谈谈我的看法。\n\n关于边防塞防之争，以今日结果的眼光来看李鸿章所谓的“放弃新疆”自然是妥妥卖国行为，引述其作此决策的理由大致如下：\n\n>*历代备边，多在西北，其强弱之势，主客之形，皆适相埒，且犹有中外界限。今则东南海疆万余里，各国通商传教，往来自如，麇集京师，及各省腹地，阳托和好之名，阴怀吞噬之计，一国生事，诸国构煽，实为数千年来未有之变局。轮船、电报之速，瞬息千里，军器、机事之精，工力百倍，又为数千年来未有之强敌。外患之乘，变幻如此，而我犹以成法制之，譬如医者疗疾，不问何症，概投之以古方，诚未见其效也*\n\n彼时背景正为日本寻衅侵略台湾，海防压力巨大，若忽略新疆一事，我以为兴建海防实在算是清末洋务少有的高瞻远瞩之举了，而对于新疆问题，李鸿章倒似乎想以外交途径解决（这也是他的惯用伎俩了，甲午之败这也是因素之一）。唉，彼时之人哪里懂得弱国无外交的道理呢，如此看来若无左宗棠收复新疆，也许新疆在那时候就成为了永远收不回的东三省了吧（九一八事变后民国政府也企图通过外交途径解决东北问题）。\n\n也正应如此，世人往往厚左而薄李，但以我之见，左宗棠与李鸿章并无大分别，李并非一意放弃塞防而是以为边防更为紧迫，而左亦非务虚守旧之人，只是认为新疆之失已迫在眉睫而海上之难尚可以时日斡旋。边防塞防之争，与其说是善恶之争，倒不如说是厉害得失之争。可叹啊，百年后的课本中，左宗棠成了英雄，而李鸿章却成了国贼，实在只是命长与命短的分别啊。\n\n而对甲午战争之败，我没有什么好说的，整个战争我仿佛看到的不是战争，而是一帮小孩在拿人命、鲜血与一个民族的尊严为筹码玩过家家，仿佛这个国，不是实际意义上的国。世人皆知甲午海战北洋水师全军覆没，是以为耻，却不知陆军在朝鲜更是一败涂地。对此战的总结梁任公先生在为李所作传记中已经分析的很透彻了，我不再赘言，遂摘录如下。\n\n>*当中日战事之际，李鸿章以一身为万矢之的，几于身无完肤，人皆欲杀。平心而论，李鸿章诚有不能辞其咎者，其始误劝朝鲜与外国立约，昧于公法，咎一；既许立约，默认其自主，而复以兵干涉其内乱，授人口实，咎二；日本既调兵，势固有进无退，而不察先机，辄欲倚赖他国调停，致误时日，咎三；聂士成请乘日军未集之时，以兵直捣韩城以制敌而不能用，咎四；高升事未起之前，丁汝昌请以北洋海军先鏖敌舰，而不能用，遂令反客为主，敌坐大而我愈危，综其原因，皆由不欲衅自我开，以为外交之道应尔，而不知当甲午五六月间，中日早成敌国，而非友邦矣，误以交邻之道施诸兵机，咎五；鸿章将自解曰：量我兵力不足以敌日本，故惮于发难也。虽然，身任北洋整军经武二十年，何以不能一战？咎六；彼又将自解曰：政府掣肘，经费不足也。虽然，此不过不能扩充已耳，何以其所现有者，如叶志超、卫汝贵诸军，素以久练著名，亦脆弱乃尔，且克减口粮盗掠民妇之事，时有所闻，乃并纪律而无之也，咎七；枪或苦窳，弹或赝物，弹不对枪，药不随械，谓从前管军械局之人皆廉明，谁能信之，咎八；平壤之役，军无统帅，此兵家所忌，李乃蹈之，咎九；始终坐待敌攻，致于人而不能致人，畏敌如虎，咎十；海军不知用快船快炮，咎十一；旅顺天险，西人谓以数百兵守之，粮食苟足，三年不能破，乃委之于所亲昵阘冗恇怯之人，闻风先遁，咎十二。此皆可以为李鸿章罪者。若夫甲午九十月以后，则群盲狂吠，筑室道谋，号令不出自一人，则责备自不得归于一点。若尽以为李鸿章咎，李固不任受也。又岂惟不任受而已，吾见彼责李罪李者，其可责可罪，更倍蓰于李而未有已也。是役将帅无一人不辱国，不待言矣。然比较于百步五十步之间，则海军优于陆军，李鸿章部下之陆军，又较优于他军也。*\n\n战争之后，尚有广东水师向日本索要被俘舰只，理由竟是此次战役与广东无涉。荒唐至此，毫无国家民族观念，以五十步笑百步之典，李倒着实是那五十步之人，但一个国家只有五十步与百步的分别，岂不谬哉！\n\n至于辛丑条约，我以为无甚好说，前两者对李都有切实可责可恨之处，凡是认为李无一点错误责任，无一点卖国嫌疑者都是巧言令色之人。惟此辛丑条约，说李是代国背锅言辞尚可牵强而去。只是可惜可恨啊，面对务实之世界，务虚者仍活在往日虚幻的天朝大国的旧梦里，可惜是针对那时被虚妄的概念奴役却自以为自由的愚民，可恨是针对朝堂上自私自利毫无理性的那几家几姓。\n\n最后也就是死后遗产之巨了，关于这个我没有观点，也没做什么考证，四千万家产的言论没有什么根据，但清正廉洁的说法也就是自娱自乐了，而对于因为李鸿章财产甚多而输了甲午战争的言论，我也无话可说，见解如此，与键盘侠无异。以下摘录任公所作传记中的一段话，仁者见仁，智者见智吧。\n\n>*世人竞传李鸿章富甲天下，此其事殆不足信，大约数百万金之产业，意中事也。招商局、电报局、开平煤矿、中国通商银行，其股份皆不少，或言南京、上海各地之当铺银号，多属其管业云*\n\n以上四点，第一、第三、第四点我认为以此为依据对李进行口诛笔伐只是视李为国贼带来的惯性思维所致，即在摆出论据之前心中已有答案，而后用这些论据中的点去套已有的结论。这样做虽然看起来不够客观，但我认为实在是人心所向。而第二点则是“国贼论”的核心，也是李鸿章以及所谓大清帝国的转折点吧，在这一点上李鸿章有直接责任。从前被英法等一流列强欺负，但装饰门面倒还对的起“帝国”这两个字的隐形含义，今而兴洋务练出的新军在日本人面前不堪一击，以使敌人在朝鲜都不相信战胜的就是所谓清廷按照西法练成的精锐部队。\n\n由此看来，这些活在近代的中古士大夫在务虚本领之上倒还是实在的啊，能够做到让外人不辨雌雄。\n\n<center>七</center>\n\n对李鸿章，梁任公先生总结其为“时势所造之英雄，非造时势之英雄”，又对其一生事迹评价为“不学无术，不敢破格，是其所短也；不避劳苦，不畏谤言，是其所长也”。\n\n是英雄造时势还是时势造英雄，这一直可以视为是一个悖论问题，这一问题有诸多解法的原因其实也只是因为对英雄与时势有诸多不同的定义与见解而已。\n\n英雄是什么，一怒之下伏尸百万流血千里的应该能算，这是就其权威而论的；率性任侠义气为先的想必也能算，这是就其个性担当而言的；富国强兵振兴朝政的一定能算，这是就其能力而论的；而为国请命鞠躬尽瘁死而后已的也一定能算，这是就其一片赤子之心而论的。这四点似乎都没错，但偏偏国贼李鸿章似乎与后三点都沾些边，对部下讲情义，为国事不避艰难，临死之前尚在为国事操心，按这个道理，他该是英雄啊，在通俗历史评价上他该是顶线以上的人啊，怎么会落得底线以下的看法与待遇呢？还是引用任公先生的话。\n\n>*十九世纪列国皆有英雄，而我国独无一英雄，则吾辈安得不指鹿为马，聊自解嘲，翘李鸿章以示于世界曰，此我国之英雄也。呜呼！亦适我国之英雄而已矣，亦适成为我国十九世纪以前之英雄而已矣*\n\n是啊，自始皇帝嬴政开创中央集权政体之日起，五经四书浸染之下的千年务虚时代，又哪有什么英雄造时势的事情呢？始皇殁后有项羽，一个勇武过人的英雄在乎的是如何让锦衣不夜行，在意这种虚妄的概念使他重新推行分封。后有刘邦，有曹操，有李世民，有赵匡胤，有朱洪武，再有所谓康乾盛世，有所谓同治中兴，那么多个皇帝之下有那么多个能人猛士堪称英雄，可有谁真正造就过时势吗？似乎有，如周瑜赤壁的那一把火，似乎又没有，因为我只看到了一个个朝代的更替与牧民锁链的加重。也许以百年局部的眼光来看，总有公瑾一般的豪杰改造时势，但以千年民族国家的眼光来看，十九世纪前所谓的英雄，不过是在同一片天空之下翻手为云覆手为雨罢了，他们从没有改天换日的见识与气魄。\n\n话虽这样说，但英雄在他们的时代仍然是英雄，非要以今日之眼光视昨日之旧人未免落入历史虚无主义的窠臼。而对李鸿章以国贼的态度进行苛责，与此同理，无非是以今日之评价观点视旧时之英雄罢了。在对李一系列失误的讨论之外，我认为不应该让一个旧时代的先行者为他所处的整个时代背锅。\n\n但话又说回来，这样一个不避劳苦的旧时代先行者，究其一生却为何在历史上仍落个身败名裂的下场呢？\n\n千年务虚时代，治经论典自然是务虚，可人毕竟是活在现实世界的啊，“务实”必不可少，闻鸡起舞者有之，改政变法者有之，“格物致知”者亦有之，为何集数千年这亿万之人，却无一个堪当变务虚时势为务实的英雄呢？自是千年务虚痼疾已深，不彻底打碎更变实在是无从谈起啊。否定了这一点，就是对20世纪我们中国人长达一个世纪的更革奋斗视而不见。\n\n而以李鸿章为汉奸国贼者，必为甲午之败辛丑之耻痛惜扼腕，仿佛杀李则能改变战局避免国耻，而清廷则仍是堂堂正正的大清帝国，这实在是癔梦啊。想当造时势之英雄，则必须要能真正的打破务虚学而有术，这在当时几乎是与整个千年文化积习为敌，事实证明李鸿章这种务虚时代的实干家不行，翁同龢这种务虚时代的所谓君子、康有为这种务虚时代所谓的改革家都不行，那些务虚时代的小人就更不必说了。\n\n以李鸿章之务实敢干不辞辛劳生于务虚时代都难以学而有术，洋务半生尚“不识国民之原理，不通世界之大势，不知政治之本原”，一生兢兢业业如履薄冰都难以在后世摆脱一个“国贼”的骂名，可见务虚痼疾程度之深了。以务虚时代之英雄而成务实时代之国贼，英雄和国贼果然有所谓巨大的间隙吗？还是李鸿章生平前后的主流文化之间有这般巨大的间隙呢？这百年来，那么多只如鲁迅先生般的如椽巨笔，才堪堪扭转千年痼疾在人心中的荼毒之深，将这种荼毒所表现出的后果让李一人一力承担，我觉得实在是肤浅过分的言论。\n\n唉，以旧英雄之身份而成新时代之国贼，以今日之眼光，到底该视为李鸿章的过错还是千年务虚文化的过错呢？\n\n<center>八</center>\n\n作为一个中国人，对历史总会心存一些假如（毕竟有强汉盛唐，现在的口号也还是复兴）。总有人会说满清误国，认为遇上19世纪那千年未有之变局的假如不是满清朝廷而是汉人王朝情况会完全不同；也有人会想若遭遇此事的中国统治者不是咸丰，不是光绪，不是慈禧，而是秦皇汉武唐宗宋祖，结局也会不一样；还有人说明朝的资本主义萌芽是被满清给消灭的，否则中国也会自然而然的成为近代西方那样发达的资本主义国家。\n\n诸如此类的想法很多，但历史没有偶然，即使有偶然，在一个模拟器中能够重现历史，让那些明君圣君放弃一家一姓特权，让那些世家门阀放弃所有地方权益的概率能有多少呢？即使有人真的愿意，他能够扳的过整个旧文化的手腕吗？（过继当上皇帝的想尊自己的生父历朝历代士大夫都会罗里吧嗦的，没有点手腕的皇帝连这种事都搞不定，即使手腕通天难道能搞定整个文化变革的事情吗？因此在中国这种务虚文化的千年体系下，自上而下的改革是不可能行的通的，想变革只有改变一个民族的思想，这又哪里是一个人能够办得到的呢），孟子说过“人之所以异于禽兽者几希，庶民去之，君子存之”，孟子当然是惯于骂人禽兽，而放弃他这种庶民君子的成见，还智于百姓，让“君子”与“禽兽”平起平坐，历代有君王与权臣能够做到吗？（也许中国能够依赖如明治天皇那样的明君通过变革依靠广阔的土地在19世纪成为列强，但这种强国方式与英美等国还是有根本区别，日本明治维新后是变强了，但仍然有华族这种旧时代产物，我以为仍然带着野蛮不理性的气息，以中国之大，如此，更甚矣，仍然只会成为如沙皇俄国那样的纸老虎）王莽的改制引来了千古骂名只是因为其制过激而使掣肘过厉，而“科举”的产生也只是得益于旧门阀势力的削弱，而这种削弱，无不是血与铁的结果，而后再看19世纪末李鸿章所遭之非议，守旧势力在19世纪到20世纪的关口还指望着把洋人赶走继续上古时期的统治方法。这是他们幼稚吗？不是，实在是千年务虚积疾过深，使得四万万国人人人为鸵鸟而不自知，大才如严复尚且崇尚科举，务实如李鸿章尚且惋惜自己一生没做成军机大臣。\n\n在这种千年务虚观念深入骨髓的情况下，小修小补有用吗？剜肉补疮有用吗？我看把血全换了都未必有用。在这种情况下，将千年务虚积累下导致的癔病产生的痛苦全部归咎给李鸿章这种只会小医小补的郎中，合理吗？骂李是国贼，那必须带上当时满朝文武，带上当时被欺罔了数千年的四万万百姓，带上数千年政治文化风俗的方方面面。雪崩之时，没有一片雪花是无辜的，但作为压死骆驼的最后一根稻草，难道李鸿章留给历史的意义只是让后人怒斥痛骂吗？\n\n十九世纪以前的英雄，配上了务虚思想引导下的务实，却成了日后人们眼中的国贼，应该感到悲哀吗？不应该感到悲哀吗？对着那个由务虚向务实转化的时代，是继续痛斥那务虚时代下的国贼或者说英雄，还是应该对我们19世纪以前的文化多做一些反思呢？\n\n后者，我以为才是李鸿章这个历史车轮扭动间隙下产生的矛盾人物该给我们带来的意义。\n\n<center>后记</center>\n\n本文基本可以视为是《走向共和》电视剧前半段以及梁任公先生的传记《李鸿章》的观后感吧，写之前没想过要什么纲领也没有确定什么中心论点，写到现在洋洋洒洒有八千多字，也渐渐形成了一个很不清晰的脉络吧。\n\n全文的中心其实也就是以李鸿章个人在通俗历史评价上的矛盾为引，引出对19世纪前中华传统文化的反思吧。一个代表着那段历史的人物，以两种文化的眼光看待，会得出英雄和国贼两个迥异的看法，这种激烈的矛盾也着实可以说明旧文化的一些荒谬之处了。\n\n当然全文只是借用了务实与务虚这一对矛盾在19世纪末那个节点上所爆发出来的强弱态势，并没有对中西文化或者说中国传统文化与现代文化进行所谓优劣对比及形成原因说明。因为非要进行详细的对比说明的话，我认为恐怕得从先秦思想和古希腊哲学的迥异说起，那话题就大了，所以全文对这种矛盾在我国中世纪的表现仅仅以叙代议，所表达的仅仅只是矛盾本身而不是对矛盾产生原因的分析论证。\n\n全文以李鸿章为引，但对李鸿章一生的事迹仅仅摘捡了其作为国贼原因的几个大点论述，如果对李鸿章或那个时代感兴趣，着实推荐任公先生的传记《李鸿章》（即《同光以来大事记》），其文作于1901年李鸿章死后不久，集合了那个时代的视角与梁公极其客观的评价，我认为堪称是了解李鸿章的第一手资料，也是了解那个时代的一个不错的POV。\n\n再来谈谈文章的另一个引子孔融，也许以知人论世而言他该算是在文学上卓有成就（建安七子之首），气节上也不错（堪称魏晋风骨，虽然我以为孔融这种气节不要也罢）。我在文章中如此苛责他说实话与大众苛责李鸿章也许没有什么本质的区别吧，要说区别，其实也是因为孔融所代表的这种务虚做派着实让我disgusting吧（细细想来，古人会写字的不多，所以键盘侠才会如此弥足珍贵吧），之前读过一些孔融的史料，有机会会写写我为啥那么不喜欢孔融，在此不再说明了。\n\n最后，谈谈为何我写着写着就以务虚作为一个主线了吧，这个原因说来惭愧，实在是自己的务虚行为所致，如今三月，还有三个月本科就该画上句号，但纵观自己这四年，基本没干成什么实在的事情（书读的好当然是实在的，游戏打出了名堂也是实在的啊，唯独什么都没做的像样倒是值得思考的一个点），遂作此文以自勉。\n\n子夜，记于2020.3.4 九江。希望疫情退散武汉加油。","slug":"瞎侃/杂文/务虚时代下的国贼——李鸿章","published":1,"updated":"2020-07-16T14:58:56.208Z","_id":"ckcox5qk0001z68jscwtn5m2v","comments":1,"layout":"post","photos":[],"link":"","content":"<center>一</center>\n\n<p>近日看老剧《走向共和》，其前半段多以李鸿章之视角演绎，李鸿章何许人也，若非要集这百年悠悠之口套出几个词来，想必就是汉奸卖国贼之类的了，至少用于普及基本历史常识的历史课本中，作为百年国耻代表的《马关条约》与《辛丑条约》之上，就铸着该君的名字，所以这样说也没错。</p>\n<p>所谓汉奸，所谓卖国贼，这两个词至少在中华文化体系下是一种性质非常恶劣的词了吧，这与百年辛酸史，或者说在国家危亡之际国人对所谓“忠臣名将”的向往是分不开的，无论何人，无论何时，只要在身份认同上认为自己是中国人的，对待这些人都可以堂而皇之的啐一口唾沫，道一声“呸”。因为在我们中国人眼中，对历史的“通俗看法”（所谓通俗看法，是指不专门研究某一段历史的普通人，对身处该时段历史人物的主观看法，或说评价）是有底线和顶线的，底线想必就是卖国攘民等龌龊行径了，而顶线就是所谓为国请命的英雄们了，或者说以死明志的气节。当然除此之外，在看待历史人物时，顶线与底线往往还联络着主角道德的好与坏。</p>\n<center>二</center>\n\n<p>底线之下，无论之前干过什么，无论这个人作为一个人来讲怎么样，都不值得原谅，参考秦桧与汪精卫（前者还跪着呢）；而顶线之上，有所作为当然更好，但似乎事情做没做成也没有太大所谓，死谏，不趋附权贵，最好再带点文采写些个正气凛然的东西或者稀里糊涂的处在一段展现美好品行的故事中心，都值得树碑立传，万世景仰（至少在大部分国人心目中此类人物的形象是好的），参考孔融。</p>\n<p>底线之下，无甚好说，做了过分引人注目的坏事情，难道还会有很多人愿意去考虑你干这坏事之前的心路？大部分人会憎恶你，少部分脑袋勤快点的人会在憎恶中加上一些同情，还有极小部分人会把你当成一个工具，表达他们“看清事实”与“与众不同”的工具，这一类人不谈也罢，他们不懂得当瑕疵多到一种程度时，瑕不掩瑜这个词是不适用的。</p>\n<p>但顶线之上就会有一些问题了，在史书中活成这一类的人心念一动就能想出很多，他们大部分都可以作为鲁迅先生笔下我中华的脊梁，但我偏偏把孔融放在这里，为何呢？是因为我想说明这条适用于大众的对历史人物看法的惯性思维多半有些不客观。“孔四岁，能让梨”，这是大部分人都清楚的故事，别的不说，我在痴迷三国的那个年龄，总还是把孔融当成个人物的。但稍稍读点书，以今日之眼光，想瞧得上孔融这个人实在是难，可他却在未来的两千年里享尽英德之名，被无数父母当作启蒙孩子的一个典范，与古往今来无数仁人志士枭雄豪杰并排而立，我以为实在是忝列其中啊。</p>\n<center>三</center>\n\n<p>让一个梨便得以流芳千古，这个梨也实在是贵的很啊，让梨这个操作也算是东汉末年一个最成功的炒作了吧。但我实在是不明白大一点的梨子是孔融吃掉还是他哥哥吃掉到底对他们一家或者说对他们兄弟二人能有多大干系呢。非要说的话，难道梨子在东汉越大越香？而大到一定程度会产生口感上的质变？还是一个天生不太喜欢吃梨子的小孩在东汉不太常见？</p>\n<p>我以为是后者，毕竟在一个百姓连饭都吃不饱的时代，产生一个类似孔融这种不喜欢梨的小孩实在是困难，这也是保证这件事合理性的唯一解释了，不然孔融一家想必都有癔症。</p>\n<p>但遗憾的是，事实来看他们一家就是有癔症，也许是遗传的吧。毕竟硬要说的话，他们的老祖宗孔丘也有癔症，但孔夫子的癔症到底是在我这个两千多年后的后生眼里才能得见的，在孔夫子那个时代就算是癔症也多少有些可爱。但一种病毒也许两千年前无伤大雅甚至可以说是可爱，到一千年前病毒几经变异变成了值得称颂的一个身体特征，而到了一百多年前当一个群体把感染了这个病毒当成荣耀并认为人人便该如此的时候，来了另一群没得病且更强壮的人使得感染这个病毒变成了自然选择的一个逆选项时，有一些病人开始尝试治病但囿于同胞掣肘与病毒几经进化下的狡诈以及自身体内病毒的顽固，失败了，对于这种人，在考虑失败后果之前，我以为首先得感慨一下其知其不可而为之的勇气，至少这是我尊敬孔子的一个重要原因，也是我认为对卖国贼李鸿章，有必要进行另一番议论的原因。</p>\n<center>四</center>\n\n<p>以上所述的“癔症”，我想与今年的新冠肺炎多少有些类似，症状复杂容易变异，只是这癔症并不作用在生理上而是作用在精神上。其症状很多，五花八门，但我今天想谈谈的只有务虚。</p>\n<p>就像孔融让梨得到赞扬一样，赞扬的不是让梨这个动作而是其谦让的品德。我从不否认谦让是个美德，但让一个历史上实实在在活生生的人，因为这样一个简单的动作就成为了根植一个名族内心千年的道德符号，我认为实在是荒谬了些，哲学上喜欢将一件事情推到极端而后再观察其是否仍然符合某一标准，而长大后的孔融倒着实使这个荒谬的意味更深了些。</p>\n<p>几乎没有付出任何代价与个人的努力，一件名门世家随意记录的小小的事情，让一个人毫不费力收获了也许是古往今来来自孩子和家长们最多的赞誉，这不是偶然，而是自先秦到清末国人一直存在的务虚观念，几个小小的汉字，所谓仁义礼智信孝廉，都是好的优秀的修身品德，也从来都是封建时代的国人精英们竞相模仿参照的对象，可仔细想想，这几个字有所谓放之四海而皆准的具体的标准与定义吗？是所谓的标准管用还是历代大儒帝王的一声惊叹或者流传坊间的一段传奇更加管用呢？普通人是实实在在的做事更能得到赞扬还是卧冰求鲤式的“作秀”更能得到赞扬呢？</p>\n<p>这些品德确立之初的好坏我无从得知，但由于上述文字解释权等原因，这几个字或者说我中华中世纪所追求的那些抽象的概念，渐渐变为了权力与利益的代言人，成为了统治者所谓推行“王治”的工具（与其说是王治，不如说是愚民）。而随着皇权的愈加集中，传播这些务虚概念的工具，即我们引以为傲的科举，使得无数中世纪乃至近代的国人精英沦为了务虚的奴隶，深陷囹圄而自以为自由（李鸿章有改变很多事物的资本，但他囿于所谓忠君之类的概念敷衍其事含糊其词，想必也是务虚已入骨髓矣）。在没有西方文化冲击的情况下，整个民族和国家都浸沐在这务虚的汤药中，难以自拔。</p>\n<p>我本身是一个很懒惰的人，所谓磨洋工的一把好手，所以倘若我在百年千年前的话，肯定会变着花样以把自己弄死为标准去对应这些百姓追求统治者喜欢的概念，也许周围正好来了个大儒书圣，听说了我的故事的话还能把我的事迹记录一些，这样“流芳百世”的难度的确是大，但想必也比实干勤学的概率要大的多，还省去了不论是脑力还是体力带来的困难与麻烦，整不好运气更好点倒是能成为孔融一样的道德符号，实在是妙啊，妙不可言。</p>\n<p>既然务虚便能带来一切能够自我宽慰还得社会认可的东西，那作为贵族官员干嘛要务实呢？留着指甲，以商贾为耻，以农桑为耻，以一切实干为耻（当然社会是需要人做实事的，但做实事在我们的文化里受待见吗？所谓君子远庖厨，历朝历代各个英雄豪杰当然也有很多实干的，但实干的基础仍然是这个务虚的社会，这本身就给这个实干抹上了一层务虚的阴影），专注虚妄的经学便能高人一等，有文才胸富万经的为官一处自是高高在上，没有这个本事的寒窗苦读一番也能落个“读书人的偷能叫偷吗”的阿Q式精神胜利，在精神上又是高高在上，都是高高在上，在1793年英国使团来华时是高高在上，在19世纪被英国揍、被日本揍之后还是高高在上。永远都是高高在上，这一词也许便能概括李鸿章一生大部分清廷官员的心理了吧，即使对洋人卑躬屈膝，对着百姓照样还是高高在上，照样是所谓“牧民于野”的当代俊杰。</p>\n<p>欺民，罔民，愚民，却将这种行为解释为王化，“王化”过后便使牧民如放牧牛羊那般简单（如此看来儒家的王治倒是能够作为畜牧业一个很好的理论），古语中的这个“牧”字用的很是精髓啊。这也概括了务虚之道能够得以盛行，国人能够自欺欺人的原因，在这样一个务虚时代之末，则有国贼李鸿章。</p>\n<center>五</center>\n\n<p>梁任公先生在1901年为李鸿章做的传记里，有这样一段话：</p>\n<blockquote>\n<p><em>夫李鸿章果足称为中国第一人与否吾不敢知，而要之现今五十岁以上之人，三四品以上之官，无一可以望李之肩背者，则吾所能断言也。李之死，于中国全局有关系与否吾不敢知，而要之现在政府失一李鸿章，如虎之丧其伥，前途岌岌，愈益多事，此又吾所敢断言也</em></p>\n</blockquote>\n<p>加之记述一下李鸿章光绪元年所上之奏疏：</p>\n<blockquote>\n<p><em>近时拘谨之儒，多以交涉洋务为涴人之具；取巧之士，又以引避洋务为自便之图。若非朝廷力开风气，破拘挛之故习，求制胜之实际，天下危局，终不可支，日后乏才，且有甚于今日者。以中国之大，而无自立之时，非惟可忧，抑亦可耻</em></p>\n</blockquote>\n<p>摘录至此，不由扼腕感慨百多年前洋务之艰难，掣肘之猖獗。</p>\n<p>引避洋务以自便，多轻松的自便之法啊，从前务虚以留其名，尚且还得付出诸多代价，而洋人来了后为一个高风亮节之名，却只需对奇技淫巧表达不屑，对操办洋务以自强求富之人以鄙夷眼光视之。多轻便啊，居庙堂之高则上书参劾，处江湖之远则煽民怨怼，永远站在务虚下道德的制高点，倒颇像今天的键盘侠，下笔滔滔如有千言，若问韬略胸无一策。可惜的是今天的键盘侠倒是稍讲道理的人就会心生厌恶，而那个时代做一个真正杀人的键盘侠倒成了政治正确。</p>\n<p>而“求制胜之实际”这句话倒着实让我奇怪，我实在不知道制胜的实际为什么要求。在一个逝者如斯夫的三维世界，什么东西都是一锤子买卖，制胜难道还有实际与不实际的分别？一个管理着四亿五千万人口的朝廷，于国事竟要以“实际”与否为争论点，实在荒唐（也许以往务虚之实际对洋人不管用吧，毕竟洋人大部分人都不给你“牧”，明明这才是现在看来正常的表现到了晚清士大夫眼中成了蛮夷无廉耻的表现，估计他们也很苦恼吧），也难怪任公先生有以上断言了。</p>\n<p>这就是那个时代我国的头号国贼了，倒不知他卖的国是虚妄概念上的国还是实际意义上的国了，不知道满清朝廷在马关之后的朝堂上有没有这一议论。</p>\n<center>六</center>\n\n<p>说李是国贼的论据，我以为归纳起来大约有四个大点。其一为边防塞防之争；其二为甲午战争之败；其三为辛丑条约之耻；其四为死后余产之巨。针对这几点，我也想简单谈谈我的看法。</p>\n<p>关于边防塞防之争，以今日结果的眼光来看李鸿章所谓的“放弃新疆”自然是妥妥卖国行为，引述其作此决策的理由大致如下：</p>\n<blockquote>\n<p><em>历代备边，多在西北，其强弱之势，主客之形，皆适相埒，且犹有中外界限。今则东南海疆万余里，各国通商传教，往来自如，麇集京师，及各省腹地，阳托和好之名，阴怀吞噬之计，一国生事，诸国构煽，实为数千年来未有之变局。轮船、电报之速，瞬息千里，军器、机事之精，工力百倍，又为数千年来未有之强敌。外患之乘，变幻如此，而我犹以成法制之，譬如医者疗疾，不问何症，概投之以古方，诚未见其效也</em></p>\n</blockquote>\n<p>彼时背景正为日本寻衅侵略台湾，海防压力巨大，若忽略新疆一事，我以为兴建海防实在算是清末洋务少有的高瞻远瞩之举了，而对于新疆问题，李鸿章倒似乎想以外交途径解决（这也是他的惯用伎俩了，甲午之败这也是因素之一）。唉，彼时之人哪里懂得弱国无外交的道理呢，如此看来若无左宗棠收复新疆，也许新疆在那时候就成为了永远收不回的东三省了吧（九一八事变后民国政府也企图通过外交途径解决东北问题）。</p>\n<p>也正应如此，世人往往厚左而薄李，但以我之见，左宗棠与李鸿章并无大分别，李并非一意放弃塞防而是以为边防更为紧迫，而左亦非务虚守旧之人，只是认为新疆之失已迫在眉睫而海上之难尚可以时日斡旋。边防塞防之争，与其说是善恶之争，倒不如说是厉害得失之争。可叹啊，百年后的课本中，左宗棠成了英雄，而李鸿章却成了国贼，实在只是命长与命短的分别啊。</p>\n<p>而对甲午战争之败，我没有什么好说的，整个战争我仿佛看到的不是战争，而是一帮小孩在拿人命、鲜血与一个民族的尊严为筹码玩过家家，仿佛这个国，不是实际意义上的国。世人皆知甲午海战北洋水师全军覆没，是以为耻，却不知陆军在朝鲜更是一败涂地。对此战的总结梁任公先生在为李所作传记中已经分析的很透彻了，我不再赘言，遂摘录如下。</p>\n<blockquote>\n<p><em>当中日战事之际，李鸿章以一身为万矢之的，几于身无完肤，人皆欲杀。平心而论，李鸿章诚有不能辞其咎者，其始误劝朝鲜与外国立约，昧于公法，咎一；既许立约，默认其自主，而复以兵干涉其内乱，授人口实，咎二；日本既调兵，势固有进无退，而不察先机，辄欲倚赖他国调停，致误时日，咎三；聂士成请乘日军未集之时，以兵直捣韩城以制敌而不能用，咎四；高升事未起之前，丁汝昌请以北洋海军先鏖敌舰，而不能用，遂令反客为主，敌坐大而我愈危，综其原因，皆由不欲衅自我开，以为外交之道应尔，而不知当甲午五六月间，中日早成敌国，而非友邦矣，误以交邻之道施诸兵机，咎五；鸿章将自解曰：量我兵力不足以敌日本，故惮于发难也。虽然，身任北洋整军经武二十年，何以不能一战？咎六；彼又将自解曰：政府掣肘，经费不足也。虽然，此不过不能扩充已耳，何以其所现有者，如叶志超、卫汝贵诸军，素以久练著名，亦脆弱乃尔，且克减口粮盗掠民妇之事，时有所闻，乃并纪律而无之也，咎七；枪或苦窳，弹或赝物，弹不对枪，药不随械，谓从前管军械局之人皆廉明，谁能信之，咎八；平壤之役，军无统帅，此兵家所忌，李乃蹈之，咎九；始终坐待敌攻，致于人而不能致人，畏敌如虎，咎十；海军不知用快船快炮，咎十一；旅顺天险，西人谓以数百兵守之，粮食苟足，三年不能破，乃委之于所亲昵阘冗恇怯之人，闻风先遁，咎十二。此皆可以为李鸿章罪者。若夫甲午九十月以后，则群盲狂吠，筑室道谋，号令不出自一人，则责备自不得归于一点。若尽以为李鸿章咎，李固不任受也。又岂惟不任受而已，吾见彼责李罪李者，其可责可罪，更倍蓰于李而未有已也。是役将帅无一人不辱国，不待言矣。然比较于百步五十步之间，则海军优于陆军，李鸿章部下之陆军，又较优于他军也。</em></p>\n</blockquote>\n<p>战争之后，尚有广东水师向日本索要被俘舰只，理由竟是此次战役与广东无涉。荒唐至此，毫无国家民族观念，以五十步笑百步之典，李倒着实是那五十步之人，但一个国家只有五十步与百步的分别，岂不谬哉！</p>\n<p>至于辛丑条约，我以为无甚好说，前两者对李都有切实可责可恨之处，凡是认为李无一点错误责任，无一点卖国嫌疑者都是巧言令色之人。惟此辛丑条约，说李是代国背锅言辞尚可牵强而去。只是可惜可恨啊，面对务实之世界，务虚者仍活在往日虚幻的天朝大国的旧梦里，可惜是针对那时被虚妄的概念奴役却自以为自由的愚民，可恨是针对朝堂上自私自利毫无理性的那几家几姓。</p>\n<p>最后也就是死后遗产之巨了，关于这个我没有观点，也没做什么考证，四千万家产的言论没有什么根据，但清正廉洁的说法也就是自娱自乐了，而对于因为李鸿章财产甚多而输了甲午战争的言论，我也无话可说，见解如此，与键盘侠无异。以下摘录任公所作传记中的一段话，仁者见仁，智者见智吧。</p>\n<blockquote>\n<p><em>世人竞传李鸿章富甲天下，此其事殆不足信，大约数百万金之产业，意中事也。招商局、电报局、开平煤矿、中国通商银行，其股份皆不少，或言南京、上海各地之当铺银号，多属其管业云</em></p>\n</blockquote>\n<p>以上四点，第一、第三、第四点我认为以此为依据对李进行口诛笔伐只是视李为国贼带来的惯性思维所致，即在摆出论据之前心中已有答案，而后用这些论据中的点去套已有的结论。这样做虽然看起来不够客观，但我认为实在是人心所向。而第二点则是“国贼论”的核心，也是李鸿章以及所谓大清帝国的转折点吧，在这一点上李鸿章有直接责任。从前被英法等一流列强欺负，但装饰门面倒还对的起“帝国”这两个字的隐形含义，今而兴洋务练出的新军在日本人面前不堪一击，以使敌人在朝鲜都不相信战胜的就是所谓清廷按照西法练成的精锐部队。</p>\n<p>由此看来，这些活在近代的中古士大夫在务虚本领之上倒还是实在的啊，能够做到让外人不辨雌雄。</p>\n<center>七</center>\n\n<p>对李鸿章，梁任公先生总结其为“时势所造之英雄，非造时势之英雄”，又对其一生事迹评价为“不学无术，不敢破格，是其所短也；不避劳苦，不畏谤言，是其所长也”。</p>\n<p>是英雄造时势还是时势造英雄，这一直可以视为是一个悖论问题，这一问题有诸多解法的原因其实也只是因为对英雄与时势有诸多不同的定义与见解而已。</p>\n<p>英雄是什么，一怒之下伏尸百万流血千里的应该能算，这是就其权威而论的；率性任侠义气为先的想必也能算，这是就其个性担当而言的；富国强兵振兴朝政的一定能算，这是就其能力而论的；而为国请命鞠躬尽瘁死而后已的也一定能算，这是就其一片赤子之心而论的。这四点似乎都没错，但偏偏国贼李鸿章似乎与后三点都沾些边，对部下讲情义，为国事不避艰难，临死之前尚在为国事操心，按这个道理，他该是英雄啊，在通俗历史评价上他该是顶线以上的人啊，怎么会落得底线以下的看法与待遇呢？还是引用任公先生的话。</p>\n<blockquote>\n<p><em>十九世纪列国皆有英雄，而我国独无一英雄，则吾辈安得不指鹿为马，聊自解嘲，翘李鸿章以示于世界曰，此我国之英雄也。呜呼！亦适我国之英雄而已矣，亦适成为我国十九世纪以前之英雄而已矣</em></p>\n</blockquote>\n<p>是啊，自始皇帝嬴政开创中央集权政体之日起，五经四书浸染之下的千年务虚时代，又哪有什么英雄造时势的事情呢？始皇殁后有项羽，一个勇武过人的英雄在乎的是如何让锦衣不夜行，在意这种虚妄的概念使他重新推行分封。后有刘邦，有曹操，有李世民，有赵匡胤，有朱洪武，再有所谓康乾盛世，有所谓同治中兴，那么多个皇帝之下有那么多个能人猛士堪称英雄，可有谁真正造就过时势吗？似乎有，如周瑜赤壁的那一把火，似乎又没有，因为我只看到了一个个朝代的更替与牧民锁链的加重。也许以百年局部的眼光来看，总有公瑾一般的豪杰改造时势，但以千年民族国家的眼光来看，十九世纪前所谓的英雄，不过是在同一片天空之下翻手为云覆手为雨罢了，他们从没有改天换日的见识与气魄。</p>\n<p>话虽这样说，但英雄在他们的时代仍然是英雄，非要以今日之眼光视昨日之旧人未免落入历史虚无主义的窠臼。而对李鸿章以国贼的态度进行苛责，与此同理，无非是以今日之评价观点视旧时之英雄罢了。在对李一系列失误的讨论之外，我认为不应该让一个旧时代的先行者为他所处的整个时代背锅。</p>\n<p>但话又说回来，这样一个不避劳苦的旧时代先行者，究其一生却为何在历史上仍落个身败名裂的下场呢？</p>\n<p>千年务虚时代，治经论典自然是务虚，可人毕竟是活在现实世界的啊，“务实”必不可少，闻鸡起舞者有之，改政变法者有之，“格物致知”者亦有之，为何集数千年这亿万之人，却无一个堪当变务虚时势为务实的英雄呢？自是千年务虚痼疾已深，不彻底打碎更变实在是无从谈起啊。否定了这一点，就是对20世纪我们中国人长达一个世纪的更革奋斗视而不见。</p>\n<p>而以李鸿章为汉奸国贼者，必为甲午之败辛丑之耻痛惜扼腕，仿佛杀李则能改变战局避免国耻，而清廷则仍是堂堂正正的大清帝国，这实在是癔梦啊。想当造时势之英雄，则必须要能真正的打破务虚学而有术，这在当时几乎是与整个千年文化积习为敌，事实证明李鸿章这种务虚时代的实干家不行，翁同龢这种务虚时代的所谓君子、康有为这种务虚时代所谓的改革家都不行，那些务虚时代的小人就更不必说了。</p>\n<p>以李鸿章之务实敢干不辞辛劳生于务虚时代都难以学而有术，洋务半生尚“不识国民之原理，不通世界之大势，不知政治之本原”，一生兢兢业业如履薄冰都难以在后世摆脱一个“国贼”的骂名，可见务虚痼疾程度之深了。以务虚时代之英雄而成务实时代之国贼，英雄和国贼果然有所谓巨大的间隙吗？还是李鸿章生平前后的主流文化之间有这般巨大的间隙呢？这百年来，那么多只如鲁迅先生般的如椽巨笔，才堪堪扭转千年痼疾在人心中的荼毒之深，将这种荼毒所表现出的后果让李一人一力承担，我觉得实在是肤浅过分的言论。</p>\n<p>唉，以旧英雄之身份而成新时代之国贼，以今日之眼光，到底该视为李鸿章的过错还是千年务虚文化的过错呢？</p>\n<center>八</center>\n\n<p>作为一个中国人，对历史总会心存一些假如（毕竟有强汉盛唐，现在的口号也还是复兴）。总有人会说满清误国，认为遇上19世纪那千年未有之变局的假如不是满清朝廷而是汉人王朝情况会完全不同；也有人会想若遭遇此事的中国统治者不是咸丰，不是光绪，不是慈禧，而是秦皇汉武唐宗宋祖，结局也会不一样；还有人说明朝的资本主义萌芽是被满清给消灭的，否则中国也会自然而然的成为近代西方那样发达的资本主义国家。</p>\n<p>诸如此类的想法很多，但历史没有偶然，即使有偶然，在一个模拟器中能够重现历史，让那些明君圣君放弃一家一姓特权，让那些世家门阀放弃所有地方权益的概率能有多少呢？即使有人真的愿意，他能够扳的过整个旧文化的手腕吗？（过继当上皇帝的想尊自己的生父历朝历代士大夫都会罗里吧嗦的，没有点手腕的皇帝连这种事都搞不定，即使手腕通天难道能搞定整个文化变革的事情吗？因此在中国这种务虚文化的千年体系下，自上而下的改革是不可能行的通的，想变革只有改变一个民族的思想，这又哪里是一个人能够办得到的呢），孟子说过“人之所以异于禽兽者几希，庶民去之，君子存之”，孟子当然是惯于骂人禽兽，而放弃他这种庶民君子的成见，还智于百姓，让“君子”与“禽兽”平起平坐，历代有君王与权臣能够做到吗？（也许中国能够依赖如明治天皇那样的明君通过变革依靠广阔的土地在19世纪成为列强，但这种强国方式与英美等国还是有根本区别，日本明治维新后是变强了，但仍然有华族这种旧时代产物，我以为仍然带着野蛮不理性的气息，以中国之大，如此，更甚矣，仍然只会成为如沙皇俄国那样的纸老虎）王莽的改制引来了千古骂名只是因为其制过激而使掣肘过厉，而“科举”的产生也只是得益于旧门阀势力的削弱，而这种削弱，无不是血与铁的结果，而后再看19世纪末李鸿章所遭之非议，守旧势力在19世纪到20世纪的关口还指望着把洋人赶走继续上古时期的统治方法。这是他们幼稚吗？不是，实在是千年务虚积疾过深，使得四万万国人人人为鸵鸟而不自知，大才如严复尚且崇尚科举，务实如李鸿章尚且惋惜自己一生没做成军机大臣。</p>\n<p>在这种千年务虚观念深入骨髓的情况下，小修小补有用吗？剜肉补疮有用吗？我看把血全换了都未必有用。在这种情况下，将千年务虚积累下导致的癔病产生的痛苦全部归咎给李鸿章这种只会小医小补的郎中，合理吗？骂李是国贼，那必须带上当时满朝文武，带上当时被欺罔了数千年的四万万百姓，带上数千年政治文化风俗的方方面面。雪崩之时，没有一片雪花是无辜的，但作为压死骆驼的最后一根稻草，难道李鸿章留给历史的意义只是让后人怒斥痛骂吗？</p>\n<p>十九世纪以前的英雄，配上了务虚思想引导下的务实，却成了日后人们眼中的国贼，应该感到悲哀吗？不应该感到悲哀吗？对着那个由务虚向务实转化的时代，是继续痛斥那务虚时代下的国贼或者说英雄，还是应该对我们19世纪以前的文化多做一些反思呢？</p>\n<p>后者，我以为才是李鸿章这个历史车轮扭动间隙下产生的矛盾人物该给我们带来的意义。</p>\n<center>后记</center>\n\n<p>本文基本可以视为是《走向共和》电视剧前半段以及梁任公先生的传记《李鸿章》的观后感吧，写之前没想过要什么纲领也没有确定什么中心论点，写到现在洋洋洒洒有八千多字，也渐渐形成了一个很不清晰的脉络吧。</p>\n<p>全文的中心其实也就是以李鸿章个人在通俗历史评价上的矛盾为引，引出对19世纪前中华传统文化的反思吧。一个代表着那段历史的人物，以两种文化的眼光看待，会得出英雄和国贼两个迥异的看法，这种激烈的矛盾也着实可以说明旧文化的一些荒谬之处了。</p>\n<p>当然全文只是借用了务实与务虚这一对矛盾在19世纪末那个节点上所爆发出来的强弱态势，并没有对中西文化或者说中国传统文化与现代文化进行所谓优劣对比及形成原因说明。因为非要进行详细的对比说明的话，我认为恐怕得从先秦思想和古希腊哲学的迥异说起，那话题就大了，所以全文对这种矛盾在我国中世纪的表现仅仅以叙代议，所表达的仅仅只是矛盾本身而不是对矛盾产生原因的分析论证。</p>\n<p>全文以李鸿章为引，但对李鸿章一生的事迹仅仅摘捡了其作为国贼原因的几个大点论述，如果对李鸿章或那个时代感兴趣，着实推荐任公先生的传记《李鸿章》（即《同光以来大事记》），其文作于1901年李鸿章死后不久，集合了那个时代的视角与梁公极其客观的评价，我认为堪称是了解李鸿章的第一手资料，也是了解那个时代的一个不错的POV。</p>\n<p>再来谈谈文章的另一个引子孔融，也许以知人论世而言他该算是在文学上卓有成就（建安七子之首），气节上也不错（堪称魏晋风骨，虽然我以为孔融这种气节不要也罢）。我在文章中如此苛责他说实话与大众苛责李鸿章也许没有什么本质的区别吧，要说区别，其实也是因为孔融所代表的这种务虚做派着实让我disgusting吧（细细想来，古人会写字的不多，所以键盘侠才会如此弥足珍贵吧），之前读过一些孔融的史料，有机会会写写我为啥那么不喜欢孔融，在此不再说明了。</p>\n<p>最后，谈谈为何我写着写着就以务虚作为一个主线了吧，这个原因说来惭愧，实在是自己的务虚行为所致，如今三月，还有三个月本科就该画上句号，但纵观自己这四年，基本没干成什么实在的事情（书读的好当然是实在的，游戏打出了名堂也是实在的啊，唯独什么都没做的像样倒是值得思考的一个点），遂作此文以自勉。</p>\n<p>子夜，记于2020.3.4 九江。希望疫情退散武汉加油。</p>\n","site":{"data":{}},"excerpt":"","more":"<center>一</center>\n\n<p>近日看老剧《走向共和》，其前半段多以李鸿章之视角演绎，李鸿章何许人也，若非要集这百年悠悠之口套出几个词来，想必就是汉奸卖国贼之类的了，至少用于普及基本历史常识的历史课本中，作为百年国耻代表的《马关条约》与《辛丑条约》之上，就铸着该君的名字，所以这样说也没错。</p>\n<p>所谓汉奸，所谓卖国贼，这两个词至少在中华文化体系下是一种性质非常恶劣的词了吧，这与百年辛酸史，或者说在国家危亡之际国人对所谓“忠臣名将”的向往是分不开的，无论何人，无论何时，只要在身份认同上认为自己是中国人的，对待这些人都可以堂而皇之的啐一口唾沫，道一声“呸”。因为在我们中国人眼中，对历史的“通俗看法”（所谓通俗看法，是指不专门研究某一段历史的普通人，对身处该时段历史人物的主观看法，或说评价）是有底线和顶线的，底线想必就是卖国攘民等龌龊行径了，而顶线就是所谓为国请命的英雄们了，或者说以死明志的气节。当然除此之外，在看待历史人物时，顶线与底线往往还联络着主角道德的好与坏。</p>\n<center>二</center>\n\n<p>底线之下，无论之前干过什么，无论这个人作为一个人来讲怎么样，都不值得原谅，参考秦桧与汪精卫（前者还跪着呢）；而顶线之上，有所作为当然更好，但似乎事情做没做成也没有太大所谓，死谏，不趋附权贵，最好再带点文采写些个正气凛然的东西或者稀里糊涂的处在一段展现美好品行的故事中心，都值得树碑立传，万世景仰（至少在大部分国人心目中此类人物的形象是好的），参考孔融。</p>\n<p>底线之下，无甚好说，做了过分引人注目的坏事情，难道还会有很多人愿意去考虑你干这坏事之前的心路？大部分人会憎恶你，少部分脑袋勤快点的人会在憎恶中加上一些同情，还有极小部分人会把你当成一个工具，表达他们“看清事实”与“与众不同”的工具，这一类人不谈也罢，他们不懂得当瑕疵多到一种程度时，瑕不掩瑜这个词是不适用的。</p>\n<p>但顶线之上就会有一些问题了，在史书中活成这一类的人心念一动就能想出很多，他们大部分都可以作为鲁迅先生笔下我中华的脊梁，但我偏偏把孔融放在这里，为何呢？是因为我想说明这条适用于大众的对历史人物看法的惯性思维多半有些不客观。“孔四岁，能让梨”，这是大部分人都清楚的故事，别的不说，我在痴迷三国的那个年龄，总还是把孔融当成个人物的。但稍稍读点书，以今日之眼光，想瞧得上孔融这个人实在是难，可他却在未来的两千年里享尽英德之名，被无数父母当作启蒙孩子的一个典范，与古往今来无数仁人志士枭雄豪杰并排而立，我以为实在是忝列其中啊。</p>\n<center>三</center>\n\n<p>让一个梨便得以流芳千古，这个梨也实在是贵的很啊，让梨这个操作也算是东汉末年一个最成功的炒作了吧。但我实在是不明白大一点的梨子是孔融吃掉还是他哥哥吃掉到底对他们一家或者说对他们兄弟二人能有多大干系呢。非要说的话，难道梨子在东汉越大越香？而大到一定程度会产生口感上的质变？还是一个天生不太喜欢吃梨子的小孩在东汉不太常见？</p>\n<p>我以为是后者，毕竟在一个百姓连饭都吃不饱的时代，产生一个类似孔融这种不喜欢梨的小孩实在是困难，这也是保证这件事合理性的唯一解释了，不然孔融一家想必都有癔症。</p>\n<p>但遗憾的是，事实来看他们一家就是有癔症，也许是遗传的吧。毕竟硬要说的话，他们的老祖宗孔丘也有癔症，但孔夫子的癔症到底是在我这个两千多年后的后生眼里才能得见的，在孔夫子那个时代就算是癔症也多少有些可爱。但一种病毒也许两千年前无伤大雅甚至可以说是可爱，到一千年前病毒几经变异变成了值得称颂的一个身体特征，而到了一百多年前当一个群体把感染了这个病毒当成荣耀并认为人人便该如此的时候，来了另一群没得病且更强壮的人使得感染这个病毒变成了自然选择的一个逆选项时，有一些病人开始尝试治病但囿于同胞掣肘与病毒几经进化下的狡诈以及自身体内病毒的顽固，失败了，对于这种人，在考虑失败后果之前，我以为首先得感慨一下其知其不可而为之的勇气，至少这是我尊敬孔子的一个重要原因，也是我认为对卖国贼李鸿章，有必要进行另一番议论的原因。</p>\n<center>四</center>\n\n<p>以上所述的“癔症”，我想与今年的新冠肺炎多少有些类似，症状复杂容易变异，只是这癔症并不作用在生理上而是作用在精神上。其症状很多，五花八门，但我今天想谈谈的只有务虚。</p>\n<p>就像孔融让梨得到赞扬一样，赞扬的不是让梨这个动作而是其谦让的品德。我从不否认谦让是个美德，但让一个历史上实实在在活生生的人，因为这样一个简单的动作就成为了根植一个名族内心千年的道德符号，我认为实在是荒谬了些，哲学上喜欢将一件事情推到极端而后再观察其是否仍然符合某一标准，而长大后的孔融倒着实使这个荒谬的意味更深了些。</p>\n<p>几乎没有付出任何代价与个人的努力，一件名门世家随意记录的小小的事情，让一个人毫不费力收获了也许是古往今来来自孩子和家长们最多的赞誉，这不是偶然，而是自先秦到清末国人一直存在的务虚观念，几个小小的汉字，所谓仁义礼智信孝廉，都是好的优秀的修身品德，也从来都是封建时代的国人精英们竞相模仿参照的对象，可仔细想想，这几个字有所谓放之四海而皆准的具体的标准与定义吗？是所谓的标准管用还是历代大儒帝王的一声惊叹或者流传坊间的一段传奇更加管用呢？普通人是实实在在的做事更能得到赞扬还是卧冰求鲤式的“作秀”更能得到赞扬呢？</p>\n<p>这些品德确立之初的好坏我无从得知，但由于上述文字解释权等原因，这几个字或者说我中华中世纪所追求的那些抽象的概念，渐渐变为了权力与利益的代言人，成为了统治者所谓推行“王治”的工具（与其说是王治，不如说是愚民）。而随着皇权的愈加集中，传播这些务虚概念的工具，即我们引以为傲的科举，使得无数中世纪乃至近代的国人精英沦为了务虚的奴隶，深陷囹圄而自以为自由（李鸿章有改变很多事物的资本，但他囿于所谓忠君之类的概念敷衍其事含糊其词，想必也是务虚已入骨髓矣）。在没有西方文化冲击的情况下，整个民族和国家都浸沐在这务虚的汤药中，难以自拔。</p>\n<p>我本身是一个很懒惰的人，所谓磨洋工的一把好手，所以倘若我在百年千年前的话，肯定会变着花样以把自己弄死为标准去对应这些百姓追求统治者喜欢的概念，也许周围正好来了个大儒书圣，听说了我的故事的话还能把我的事迹记录一些，这样“流芳百世”的难度的确是大，但想必也比实干勤学的概率要大的多，还省去了不论是脑力还是体力带来的困难与麻烦，整不好运气更好点倒是能成为孔融一样的道德符号，实在是妙啊，妙不可言。</p>\n<p>既然务虚便能带来一切能够自我宽慰还得社会认可的东西，那作为贵族官员干嘛要务实呢？留着指甲，以商贾为耻，以农桑为耻，以一切实干为耻（当然社会是需要人做实事的，但做实事在我们的文化里受待见吗？所谓君子远庖厨，历朝历代各个英雄豪杰当然也有很多实干的，但实干的基础仍然是这个务虚的社会，这本身就给这个实干抹上了一层务虚的阴影），专注虚妄的经学便能高人一等，有文才胸富万经的为官一处自是高高在上，没有这个本事的寒窗苦读一番也能落个“读书人的偷能叫偷吗”的阿Q式精神胜利，在精神上又是高高在上，都是高高在上，在1793年英国使团来华时是高高在上，在19世纪被英国揍、被日本揍之后还是高高在上。永远都是高高在上，这一词也许便能概括李鸿章一生大部分清廷官员的心理了吧，即使对洋人卑躬屈膝，对着百姓照样还是高高在上，照样是所谓“牧民于野”的当代俊杰。</p>\n<p>欺民，罔民，愚民，却将这种行为解释为王化，“王化”过后便使牧民如放牧牛羊那般简单（如此看来儒家的王治倒是能够作为畜牧业一个很好的理论），古语中的这个“牧”字用的很是精髓啊。这也概括了务虚之道能够得以盛行，国人能够自欺欺人的原因，在这样一个务虚时代之末，则有国贼李鸿章。</p>\n<center>五</center>\n\n<p>梁任公先生在1901年为李鸿章做的传记里，有这样一段话：</p>\n<blockquote>\n<p><em>夫李鸿章果足称为中国第一人与否吾不敢知，而要之现今五十岁以上之人，三四品以上之官，无一可以望李之肩背者，则吾所能断言也。李之死，于中国全局有关系与否吾不敢知，而要之现在政府失一李鸿章，如虎之丧其伥，前途岌岌，愈益多事，此又吾所敢断言也</em></p>\n</blockquote>\n<p>加之记述一下李鸿章光绪元年所上之奏疏：</p>\n<blockquote>\n<p><em>近时拘谨之儒，多以交涉洋务为涴人之具；取巧之士，又以引避洋务为自便之图。若非朝廷力开风气，破拘挛之故习，求制胜之实际，天下危局，终不可支，日后乏才，且有甚于今日者。以中国之大，而无自立之时，非惟可忧，抑亦可耻</em></p>\n</blockquote>\n<p>摘录至此，不由扼腕感慨百多年前洋务之艰难，掣肘之猖獗。</p>\n<p>引避洋务以自便，多轻松的自便之法啊，从前务虚以留其名，尚且还得付出诸多代价，而洋人来了后为一个高风亮节之名，却只需对奇技淫巧表达不屑，对操办洋务以自强求富之人以鄙夷眼光视之。多轻便啊，居庙堂之高则上书参劾，处江湖之远则煽民怨怼，永远站在务虚下道德的制高点，倒颇像今天的键盘侠，下笔滔滔如有千言，若问韬略胸无一策。可惜的是今天的键盘侠倒是稍讲道理的人就会心生厌恶，而那个时代做一个真正杀人的键盘侠倒成了政治正确。</p>\n<p>而“求制胜之实际”这句话倒着实让我奇怪，我实在不知道制胜的实际为什么要求。在一个逝者如斯夫的三维世界，什么东西都是一锤子买卖，制胜难道还有实际与不实际的分别？一个管理着四亿五千万人口的朝廷，于国事竟要以“实际”与否为争论点，实在荒唐（也许以往务虚之实际对洋人不管用吧，毕竟洋人大部分人都不给你“牧”，明明这才是现在看来正常的表现到了晚清士大夫眼中成了蛮夷无廉耻的表现，估计他们也很苦恼吧），也难怪任公先生有以上断言了。</p>\n<p>这就是那个时代我国的头号国贼了，倒不知他卖的国是虚妄概念上的国还是实际意义上的国了，不知道满清朝廷在马关之后的朝堂上有没有这一议论。</p>\n<center>六</center>\n\n<p>说李是国贼的论据，我以为归纳起来大约有四个大点。其一为边防塞防之争；其二为甲午战争之败；其三为辛丑条约之耻；其四为死后余产之巨。针对这几点，我也想简单谈谈我的看法。</p>\n<p>关于边防塞防之争，以今日结果的眼光来看李鸿章所谓的“放弃新疆”自然是妥妥卖国行为，引述其作此决策的理由大致如下：</p>\n<blockquote>\n<p><em>历代备边，多在西北，其强弱之势，主客之形，皆适相埒，且犹有中外界限。今则东南海疆万余里，各国通商传教，往来自如，麇集京师，及各省腹地，阳托和好之名，阴怀吞噬之计，一国生事，诸国构煽，实为数千年来未有之变局。轮船、电报之速，瞬息千里，军器、机事之精，工力百倍，又为数千年来未有之强敌。外患之乘，变幻如此，而我犹以成法制之，譬如医者疗疾，不问何症，概投之以古方，诚未见其效也</em></p>\n</blockquote>\n<p>彼时背景正为日本寻衅侵略台湾，海防压力巨大，若忽略新疆一事，我以为兴建海防实在算是清末洋务少有的高瞻远瞩之举了，而对于新疆问题，李鸿章倒似乎想以外交途径解决（这也是他的惯用伎俩了，甲午之败这也是因素之一）。唉，彼时之人哪里懂得弱国无外交的道理呢，如此看来若无左宗棠收复新疆，也许新疆在那时候就成为了永远收不回的东三省了吧（九一八事变后民国政府也企图通过外交途径解决东北问题）。</p>\n<p>也正应如此，世人往往厚左而薄李，但以我之见，左宗棠与李鸿章并无大分别，李并非一意放弃塞防而是以为边防更为紧迫，而左亦非务虚守旧之人，只是认为新疆之失已迫在眉睫而海上之难尚可以时日斡旋。边防塞防之争，与其说是善恶之争，倒不如说是厉害得失之争。可叹啊，百年后的课本中，左宗棠成了英雄，而李鸿章却成了国贼，实在只是命长与命短的分别啊。</p>\n<p>而对甲午战争之败，我没有什么好说的，整个战争我仿佛看到的不是战争，而是一帮小孩在拿人命、鲜血与一个民族的尊严为筹码玩过家家，仿佛这个国，不是实际意义上的国。世人皆知甲午海战北洋水师全军覆没，是以为耻，却不知陆军在朝鲜更是一败涂地。对此战的总结梁任公先生在为李所作传记中已经分析的很透彻了，我不再赘言，遂摘录如下。</p>\n<blockquote>\n<p><em>当中日战事之际，李鸿章以一身为万矢之的，几于身无完肤，人皆欲杀。平心而论，李鸿章诚有不能辞其咎者，其始误劝朝鲜与外国立约，昧于公法，咎一；既许立约，默认其自主，而复以兵干涉其内乱，授人口实，咎二；日本既调兵，势固有进无退，而不察先机，辄欲倚赖他国调停，致误时日，咎三；聂士成请乘日军未集之时，以兵直捣韩城以制敌而不能用，咎四；高升事未起之前，丁汝昌请以北洋海军先鏖敌舰，而不能用，遂令反客为主，敌坐大而我愈危，综其原因，皆由不欲衅自我开，以为外交之道应尔，而不知当甲午五六月间，中日早成敌国，而非友邦矣，误以交邻之道施诸兵机，咎五；鸿章将自解曰：量我兵力不足以敌日本，故惮于发难也。虽然，身任北洋整军经武二十年，何以不能一战？咎六；彼又将自解曰：政府掣肘，经费不足也。虽然，此不过不能扩充已耳，何以其所现有者，如叶志超、卫汝贵诸军，素以久练著名，亦脆弱乃尔，且克减口粮盗掠民妇之事，时有所闻，乃并纪律而无之也，咎七；枪或苦窳，弹或赝物，弹不对枪，药不随械，谓从前管军械局之人皆廉明，谁能信之，咎八；平壤之役，军无统帅，此兵家所忌，李乃蹈之，咎九；始终坐待敌攻，致于人而不能致人，畏敌如虎，咎十；海军不知用快船快炮，咎十一；旅顺天险，西人谓以数百兵守之，粮食苟足，三年不能破，乃委之于所亲昵阘冗恇怯之人，闻风先遁，咎十二。此皆可以为李鸿章罪者。若夫甲午九十月以后，则群盲狂吠，筑室道谋，号令不出自一人，则责备自不得归于一点。若尽以为李鸿章咎，李固不任受也。又岂惟不任受而已，吾见彼责李罪李者，其可责可罪，更倍蓰于李而未有已也。是役将帅无一人不辱国，不待言矣。然比较于百步五十步之间，则海军优于陆军，李鸿章部下之陆军，又较优于他军也。</em></p>\n</blockquote>\n<p>战争之后，尚有广东水师向日本索要被俘舰只，理由竟是此次战役与广东无涉。荒唐至此，毫无国家民族观念，以五十步笑百步之典，李倒着实是那五十步之人，但一个国家只有五十步与百步的分别，岂不谬哉！</p>\n<p>至于辛丑条约，我以为无甚好说，前两者对李都有切实可责可恨之处，凡是认为李无一点错误责任，无一点卖国嫌疑者都是巧言令色之人。惟此辛丑条约，说李是代国背锅言辞尚可牵强而去。只是可惜可恨啊，面对务实之世界，务虚者仍活在往日虚幻的天朝大国的旧梦里，可惜是针对那时被虚妄的概念奴役却自以为自由的愚民，可恨是针对朝堂上自私自利毫无理性的那几家几姓。</p>\n<p>最后也就是死后遗产之巨了，关于这个我没有观点，也没做什么考证，四千万家产的言论没有什么根据，但清正廉洁的说法也就是自娱自乐了，而对于因为李鸿章财产甚多而输了甲午战争的言论，我也无话可说，见解如此，与键盘侠无异。以下摘录任公所作传记中的一段话，仁者见仁，智者见智吧。</p>\n<blockquote>\n<p><em>世人竞传李鸿章富甲天下，此其事殆不足信，大约数百万金之产业，意中事也。招商局、电报局、开平煤矿、中国通商银行，其股份皆不少，或言南京、上海各地之当铺银号，多属其管业云</em></p>\n</blockquote>\n<p>以上四点，第一、第三、第四点我认为以此为依据对李进行口诛笔伐只是视李为国贼带来的惯性思维所致，即在摆出论据之前心中已有答案，而后用这些论据中的点去套已有的结论。这样做虽然看起来不够客观，但我认为实在是人心所向。而第二点则是“国贼论”的核心，也是李鸿章以及所谓大清帝国的转折点吧，在这一点上李鸿章有直接责任。从前被英法等一流列强欺负，但装饰门面倒还对的起“帝国”这两个字的隐形含义，今而兴洋务练出的新军在日本人面前不堪一击，以使敌人在朝鲜都不相信战胜的就是所谓清廷按照西法练成的精锐部队。</p>\n<p>由此看来，这些活在近代的中古士大夫在务虚本领之上倒还是实在的啊，能够做到让外人不辨雌雄。</p>\n<center>七</center>\n\n<p>对李鸿章，梁任公先生总结其为“时势所造之英雄，非造时势之英雄”，又对其一生事迹评价为“不学无术，不敢破格，是其所短也；不避劳苦，不畏谤言，是其所长也”。</p>\n<p>是英雄造时势还是时势造英雄，这一直可以视为是一个悖论问题，这一问题有诸多解法的原因其实也只是因为对英雄与时势有诸多不同的定义与见解而已。</p>\n<p>英雄是什么，一怒之下伏尸百万流血千里的应该能算，这是就其权威而论的；率性任侠义气为先的想必也能算，这是就其个性担当而言的；富国强兵振兴朝政的一定能算，这是就其能力而论的；而为国请命鞠躬尽瘁死而后已的也一定能算，这是就其一片赤子之心而论的。这四点似乎都没错，但偏偏国贼李鸿章似乎与后三点都沾些边，对部下讲情义，为国事不避艰难，临死之前尚在为国事操心，按这个道理，他该是英雄啊，在通俗历史评价上他该是顶线以上的人啊，怎么会落得底线以下的看法与待遇呢？还是引用任公先生的话。</p>\n<blockquote>\n<p><em>十九世纪列国皆有英雄，而我国独无一英雄，则吾辈安得不指鹿为马，聊自解嘲，翘李鸿章以示于世界曰，此我国之英雄也。呜呼！亦适我国之英雄而已矣，亦适成为我国十九世纪以前之英雄而已矣</em></p>\n</blockquote>\n<p>是啊，自始皇帝嬴政开创中央集权政体之日起，五经四书浸染之下的千年务虚时代，又哪有什么英雄造时势的事情呢？始皇殁后有项羽，一个勇武过人的英雄在乎的是如何让锦衣不夜行，在意这种虚妄的概念使他重新推行分封。后有刘邦，有曹操，有李世民，有赵匡胤，有朱洪武，再有所谓康乾盛世，有所谓同治中兴，那么多个皇帝之下有那么多个能人猛士堪称英雄，可有谁真正造就过时势吗？似乎有，如周瑜赤壁的那一把火，似乎又没有，因为我只看到了一个个朝代的更替与牧民锁链的加重。也许以百年局部的眼光来看，总有公瑾一般的豪杰改造时势，但以千年民族国家的眼光来看，十九世纪前所谓的英雄，不过是在同一片天空之下翻手为云覆手为雨罢了，他们从没有改天换日的见识与气魄。</p>\n<p>话虽这样说，但英雄在他们的时代仍然是英雄，非要以今日之眼光视昨日之旧人未免落入历史虚无主义的窠臼。而对李鸿章以国贼的态度进行苛责，与此同理，无非是以今日之评价观点视旧时之英雄罢了。在对李一系列失误的讨论之外，我认为不应该让一个旧时代的先行者为他所处的整个时代背锅。</p>\n<p>但话又说回来，这样一个不避劳苦的旧时代先行者，究其一生却为何在历史上仍落个身败名裂的下场呢？</p>\n<p>千年务虚时代，治经论典自然是务虚，可人毕竟是活在现实世界的啊，“务实”必不可少，闻鸡起舞者有之，改政变法者有之，“格物致知”者亦有之，为何集数千年这亿万之人，却无一个堪当变务虚时势为务实的英雄呢？自是千年务虚痼疾已深，不彻底打碎更变实在是无从谈起啊。否定了这一点，就是对20世纪我们中国人长达一个世纪的更革奋斗视而不见。</p>\n<p>而以李鸿章为汉奸国贼者，必为甲午之败辛丑之耻痛惜扼腕，仿佛杀李则能改变战局避免国耻，而清廷则仍是堂堂正正的大清帝国，这实在是癔梦啊。想当造时势之英雄，则必须要能真正的打破务虚学而有术，这在当时几乎是与整个千年文化积习为敌，事实证明李鸿章这种务虚时代的实干家不行，翁同龢这种务虚时代的所谓君子、康有为这种务虚时代所谓的改革家都不行，那些务虚时代的小人就更不必说了。</p>\n<p>以李鸿章之务实敢干不辞辛劳生于务虚时代都难以学而有术，洋务半生尚“不识国民之原理，不通世界之大势，不知政治之本原”，一生兢兢业业如履薄冰都难以在后世摆脱一个“国贼”的骂名，可见务虚痼疾程度之深了。以务虚时代之英雄而成务实时代之国贼，英雄和国贼果然有所谓巨大的间隙吗？还是李鸿章生平前后的主流文化之间有这般巨大的间隙呢？这百年来，那么多只如鲁迅先生般的如椽巨笔，才堪堪扭转千年痼疾在人心中的荼毒之深，将这种荼毒所表现出的后果让李一人一力承担，我觉得实在是肤浅过分的言论。</p>\n<p>唉，以旧英雄之身份而成新时代之国贼，以今日之眼光，到底该视为李鸿章的过错还是千年务虚文化的过错呢？</p>\n<center>八</center>\n\n<p>作为一个中国人，对历史总会心存一些假如（毕竟有强汉盛唐，现在的口号也还是复兴）。总有人会说满清误国，认为遇上19世纪那千年未有之变局的假如不是满清朝廷而是汉人王朝情况会完全不同；也有人会想若遭遇此事的中国统治者不是咸丰，不是光绪，不是慈禧，而是秦皇汉武唐宗宋祖，结局也会不一样；还有人说明朝的资本主义萌芽是被满清给消灭的，否则中国也会自然而然的成为近代西方那样发达的资本主义国家。</p>\n<p>诸如此类的想法很多，但历史没有偶然，即使有偶然，在一个模拟器中能够重现历史，让那些明君圣君放弃一家一姓特权，让那些世家门阀放弃所有地方权益的概率能有多少呢？即使有人真的愿意，他能够扳的过整个旧文化的手腕吗？（过继当上皇帝的想尊自己的生父历朝历代士大夫都会罗里吧嗦的，没有点手腕的皇帝连这种事都搞不定，即使手腕通天难道能搞定整个文化变革的事情吗？因此在中国这种务虚文化的千年体系下，自上而下的改革是不可能行的通的，想变革只有改变一个民族的思想，这又哪里是一个人能够办得到的呢），孟子说过“人之所以异于禽兽者几希，庶民去之，君子存之”，孟子当然是惯于骂人禽兽，而放弃他这种庶民君子的成见，还智于百姓，让“君子”与“禽兽”平起平坐，历代有君王与权臣能够做到吗？（也许中国能够依赖如明治天皇那样的明君通过变革依靠广阔的土地在19世纪成为列强，但这种强国方式与英美等国还是有根本区别，日本明治维新后是变强了，但仍然有华族这种旧时代产物，我以为仍然带着野蛮不理性的气息，以中国之大，如此，更甚矣，仍然只会成为如沙皇俄国那样的纸老虎）王莽的改制引来了千古骂名只是因为其制过激而使掣肘过厉，而“科举”的产生也只是得益于旧门阀势力的削弱，而这种削弱，无不是血与铁的结果，而后再看19世纪末李鸿章所遭之非议，守旧势力在19世纪到20世纪的关口还指望着把洋人赶走继续上古时期的统治方法。这是他们幼稚吗？不是，实在是千年务虚积疾过深，使得四万万国人人人为鸵鸟而不自知，大才如严复尚且崇尚科举，务实如李鸿章尚且惋惜自己一生没做成军机大臣。</p>\n<p>在这种千年务虚观念深入骨髓的情况下，小修小补有用吗？剜肉补疮有用吗？我看把血全换了都未必有用。在这种情况下，将千年务虚积累下导致的癔病产生的痛苦全部归咎给李鸿章这种只会小医小补的郎中，合理吗？骂李是国贼，那必须带上当时满朝文武，带上当时被欺罔了数千年的四万万百姓，带上数千年政治文化风俗的方方面面。雪崩之时，没有一片雪花是无辜的，但作为压死骆驼的最后一根稻草，难道李鸿章留给历史的意义只是让后人怒斥痛骂吗？</p>\n<p>十九世纪以前的英雄，配上了务虚思想引导下的务实，却成了日后人们眼中的国贼，应该感到悲哀吗？不应该感到悲哀吗？对着那个由务虚向务实转化的时代，是继续痛斥那务虚时代下的国贼或者说英雄，还是应该对我们19世纪以前的文化多做一些反思呢？</p>\n<p>后者，我以为才是李鸿章这个历史车轮扭动间隙下产生的矛盾人物该给我们带来的意义。</p>\n<center>后记</center>\n\n<p>本文基本可以视为是《走向共和》电视剧前半段以及梁任公先生的传记《李鸿章》的观后感吧，写之前没想过要什么纲领也没有确定什么中心论点，写到现在洋洋洒洒有八千多字，也渐渐形成了一个很不清晰的脉络吧。</p>\n<p>全文的中心其实也就是以李鸿章个人在通俗历史评价上的矛盾为引，引出对19世纪前中华传统文化的反思吧。一个代表着那段历史的人物，以两种文化的眼光看待，会得出英雄和国贼两个迥异的看法，这种激烈的矛盾也着实可以说明旧文化的一些荒谬之处了。</p>\n<p>当然全文只是借用了务实与务虚这一对矛盾在19世纪末那个节点上所爆发出来的强弱态势，并没有对中西文化或者说中国传统文化与现代文化进行所谓优劣对比及形成原因说明。因为非要进行详细的对比说明的话，我认为恐怕得从先秦思想和古希腊哲学的迥异说起，那话题就大了，所以全文对这种矛盾在我国中世纪的表现仅仅以叙代议，所表达的仅仅只是矛盾本身而不是对矛盾产生原因的分析论证。</p>\n<p>全文以李鸿章为引，但对李鸿章一生的事迹仅仅摘捡了其作为国贼原因的几个大点论述，如果对李鸿章或那个时代感兴趣，着实推荐任公先生的传记《李鸿章》（即《同光以来大事记》），其文作于1901年李鸿章死后不久，集合了那个时代的视角与梁公极其客观的评价，我认为堪称是了解李鸿章的第一手资料，也是了解那个时代的一个不错的POV。</p>\n<p>再来谈谈文章的另一个引子孔融，也许以知人论世而言他该算是在文学上卓有成就（建安七子之首），气节上也不错（堪称魏晋风骨，虽然我以为孔融这种气节不要也罢）。我在文章中如此苛责他说实话与大众苛责李鸿章也许没有什么本质的区别吧，要说区别，其实也是因为孔融所代表的这种务虚做派着实让我disgusting吧（细细想来，古人会写字的不多，所以键盘侠才会如此弥足珍贵吧），之前读过一些孔融的史料，有机会会写写我为啥那么不喜欢孔融，在此不再说明了。</p>\n<p>最后，谈谈为何我写着写着就以务虚作为一个主线了吧，这个原因说来惭愧，实在是自己的务虚行为所致，如今三月，还有三个月本科就该画上句号，但纵观自己这四年，基本没干成什么实在的事情（书读的好当然是实在的，游戏打出了名堂也是实在的啊，唯独什么都没做的像样倒是值得思考的一个点），遂作此文以自勉。</p>\n<p>子夜，记于2020.3.4 九江。希望疫情退散武汉加油。</p>\n"},{"title":"雨与晴","date":"2019-03-20T11:13:06.000Z","fileName":"the_rain_and_the_shine","_content":"今天早上8点半左右，我像往常一样上三楼接水，在楼梯间的窗户向外瞥，围墙外的篮球场的塑胶地上湿了一片。围墙略显斑驳，是本来就不那么年经了的建筑被大水冲洗过后的一种自然姿态，带着一些年迈的美丽。\n\n没事的时候我很喜欢透过这里向外望，但这次不是，因为我的眼光里多少带了些形色匆匆的味道。被水洗过的塑胶绿和围墙这边的绿色的植物，与其说是我看到了她们，不如说是她们的颜色主宰了那一秒内我的视神经。现在窗外夜色朦胧，是置身城市里很少见到的那种纯粹的墨蓝，纯粹的证明也并非是我自情自愿，是因为我抬头能看到星星。\n\n不对，在东边的天空，还有一轮月亮，也许足够用皓月来形容。\n\n我并不像一些下午一样，站在那个楼梯间的窗户面前带着什么思考或者纯粹性的发呆向外望。清晨的我手里拿着洗面奶和脸盆毛巾经过了那里，我现在也只能以上帝的姿态回顾那个瞬间我究竟是迈开了左腿还是右腿，脑子中想的究竟是窗外的绿还是一些什么别的乱七八糟的东西。这到底是模拟，有一万种不同的可能，这花了我很长的时间，沉淀了许多情感。我并不喜欢喝白酒，事实上也的确没怎么喝过，但我觉得所谓后劲，就是如此吧。在张开嘴的瞬间，咽下的酒精会让觥筹交错之后的你花上几个小时醉在自己的梦里，所需要的契机也只是热闹向平淡的自然转变。\n\n雨是早就要下的了，昨晚睡前就已经开始了，但我并没有太在意，只记得它很大，像是夏天的雷雨，全然不同于上个月那阴雨绵绵的枯燥，倒是热烈洒脱，干脆利落。昨晚12点左右的时候，我躺在床上，感觉很累很累。我不知道“累”这种感觉的产生是基于什么，也许是某种激素，那我觉得自己想必是有些内分泌失调了。我并没有什么能过得去的让我感觉到疲惫的理由，但我就是很累。这一个月来我思考了很多，这个多也只是相对于我某种程度上放弃思考开始自欺欺人的那大段时间而已，只是一个正常水平，就像冬末的阴雨只要地球还在正常的轨道上，只要太阳不出什么问题，就一定会消散一样。阴天和晴天，只不过是地球表面的两种正常状态，但其微小的不同，的确会对地表的生物造成一些困扰，这我想是肯定的。\n\n半夜的时候我被雨声惊醒了，这很少见，除去呼噜声与钟表的滴答，我是很难被别的声音惊醒的。半夜醒来的人对时间是没法计数的，一切理性和情感都处于朦胧的状态，也许这道朦胧会在大脑留下沙滩上城堡般的记忆，也许不会。但我却记得，那算是雨后的阴沉的味道吧。翠绿的世界总是会给人一种虽然充满生气但却脆弱稚嫩的感觉，在这脆弱稚嫩之下不知纯粹为何物，但被大雨蹂躏过后的植物的墨绿虽然给人阴沉郁结之感，却又十足纯粹。淅沥小雨下的天空阴沉混沌，赶时间的人会痛恨这种“欲擒故纵”般的感觉，世界并不是在接受清洗，而是在把污浊借雨水之名平摊到各地，也许是为了遮瑕，但却使原来作为“瑜”的部分都消失殆尽，纯粹一词无处藏身。而大雨磅礴的天空也许更是阴沉可怖，但却给人以十足的命令感，再赶时间你也不会为“走”或“不走”而面露难色，只有在屋檐下耐心等待。等待的过程也许是生活中难得的纯粹的仪式，因为静坐听雨的意境在当代实在是少的可怜，就连裤腿被大雨淋湿的触感都变得弥足珍贵。\n\n雨后，空气中会有清爽的纯粹，世界接受清洗之后，无论是借着日光还是霓虹，路面倒映出的射影，是世界的另一种面貌，印着纯粹二字。\n\n但我并不知道纯粹为何物，它是最狡诈多变的一个词。在我有不同的情感时，思考不同的问题时，面临不同的选择时，它是我最后的仪仗，是我追求的东西，尽管为此我注定没有方向。\n\n我不知道小时候庐山上的蓝天白云与我的无忧无虑算不算纯粹，也许无忧无虑只是假象，是人丢掉一段时间内的大部分记忆的一种自然而然的感受。我马上21了，在我以1开头的年岁里，我的确很少看到记忆中的那种蓝天了。在熬过二月的阴雨之后，最近武汉的天气晴空万里，就连今天早上阴沉潮湿的墨绿在我中午再一次以相同的视角观望时都已经消失殆尽了，但蓝天上仍然有一层阴霾，蓝的并不纯粹，而我已经习惯了这种蓝，并且也开始用湛蓝形容它。没事的时候我也会在教五门口的广场上休息，或者在万林艺术馆的天台上坐着以一个不至于让太阳抢去风头的角度欣赏蓝天，我为这种天气而欣喜，但内心中又似乎对一场夏天的雷雨更为期待。我不知道是因为暴雨真的能够洗刷世界，还是因为我仅仅期待那雨声给我带来的视觉、听觉再到触觉的全方位的模拟，能够带我回到小时候，或者说情感更加纯粹的年岁。\n\n现在外面天很黑，皓月当空，高悬东方，在宿舍门口我看到有人在用微单拍摄。我很遗憾单反不在身边，同时又很庆幸单反不在身边。我尝试用手机对这个美丽的夜色进行记录，但最后发现它只属于我的眼睛，属于在我记忆中注定渐渐消散的那一块区域。我很快会把昨晚的雨、清晨的绿以及东方的月这些印记着今天的一切特征给淡忘，因为未来还会有无数个相同的日子，武大的樱花会一直开下去，我的路，我的追求，我的思考也不会停下，至死方休。时不时想想上一个今天自己对纯粹的定义，也许会发现愚蠢，也许会发现美丽，但更重要的是找到不同日子纯粹变化的轨迹。文字的意义总会是虚无缥缈的，但追求的东西如果套用一个词来表达的话我认为总不至于两个时间的方向会是南北迥异的吧。\n\n说句实话，我想家了。\n\n人只有在意识到自己脆弱的时候才会顿生羁旅之情。\n\n但也从来没有用羁旅表达自己状态的人会停下脚步。\n\n> 记于 19.3.20 武汉","source":"_posts/瞎侃/散文/雨与晴.md","raw":"---\ntitle: 雨与晴\ndate: 2019-03-20 19:13:06\ntags:\n    - 日志\n    - 散文\ncategories:\n    - 瞎侃\n    - 散文\nfileName: the_rain_and_the_shine\n---\n今天早上8点半左右，我像往常一样上三楼接水，在楼梯间的窗户向外瞥，围墙外的篮球场的塑胶地上湿了一片。围墙略显斑驳，是本来就不那么年经了的建筑被大水冲洗过后的一种自然姿态，带着一些年迈的美丽。\n\n没事的时候我很喜欢透过这里向外望，但这次不是，因为我的眼光里多少带了些形色匆匆的味道。被水洗过的塑胶绿和围墙这边的绿色的植物，与其说是我看到了她们，不如说是她们的颜色主宰了那一秒内我的视神经。现在窗外夜色朦胧，是置身城市里很少见到的那种纯粹的墨蓝，纯粹的证明也并非是我自情自愿，是因为我抬头能看到星星。\n\n不对，在东边的天空，还有一轮月亮，也许足够用皓月来形容。\n\n我并不像一些下午一样，站在那个楼梯间的窗户面前带着什么思考或者纯粹性的发呆向外望。清晨的我手里拿着洗面奶和脸盆毛巾经过了那里，我现在也只能以上帝的姿态回顾那个瞬间我究竟是迈开了左腿还是右腿，脑子中想的究竟是窗外的绿还是一些什么别的乱七八糟的东西。这到底是模拟，有一万种不同的可能，这花了我很长的时间，沉淀了许多情感。我并不喜欢喝白酒，事实上也的确没怎么喝过，但我觉得所谓后劲，就是如此吧。在张开嘴的瞬间，咽下的酒精会让觥筹交错之后的你花上几个小时醉在自己的梦里，所需要的契机也只是热闹向平淡的自然转变。\n\n雨是早就要下的了，昨晚睡前就已经开始了，但我并没有太在意，只记得它很大，像是夏天的雷雨，全然不同于上个月那阴雨绵绵的枯燥，倒是热烈洒脱，干脆利落。昨晚12点左右的时候，我躺在床上，感觉很累很累。我不知道“累”这种感觉的产生是基于什么，也许是某种激素，那我觉得自己想必是有些内分泌失调了。我并没有什么能过得去的让我感觉到疲惫的理由，但我就是很累。这一个月来我思考了很多，这个多也只是相对于我某种程度上放弃思考开始自欺欺人的那大段时间而已，只是一个正常水平，就像冬末的阴雨只要地球还在正常的轨道上，只要太阳不出什么问题，就一定会消散一样。阴天和晴天，只不过是地球表面的两种正常状态，但其微小的不同，的确会对地表的生物造成一些困扰，这我想是肯定的。\n\n半夜的时候我被雨声惊醒了，这很少见，除去呼噜声与钟表的滴答，我是很难被别的声音惊醒的。半夜醒来的人对时间是没法计数的，一切理性和情感都处于朦胧的状态，也许这道朦胧会在大脑留下沙滩上城堡般的记忆，也许不会。但我却记得，那算是雨后的阴沉的味道吧。翠绿的世界总是会给人一种虽然充满生气但却脆弱稚嫩的感觉，在这脆弱稚嫩之下不知纯粹为何物，但被大雨蹂躏过后的植物的墨绿虽然给人阴沉郁结之感，却又十足纯粹。淅沥小雨下的天空阴沉混沌，赶时间的人会痛恨这种“欲擒故纵”般的感觉，世界并不是在接受清洗，而是在把污浊借雨水之名平摊到各地，也许是为了遮瑕，但却使原来作为“瑜”的部分都消失殆尽，纯粹一词无处藏身。而大雨磅礴的天空也许更是阴沉可怖，但却给人以十足的命令感，再赶时间你也不会为“走”或“不走”而面露难色，只有在屋檐下耐心等待。等待的过程也许是生活中难得的纯粹的仪式，因为静坐听雨的意境在当代实在是少的可怜，就连裤腿被大雨淋湿的触感都变得弥足珍贵。\n\n雨后，空气中会有清爽的纯粹，世界接受清洗之后，无论是借着日光还是霓虹，路面倒映出的射影，是世界的另一种面貌，印着纯粹二字。\n\n但我并不知道纯粹为何物，它是最狡诈多变的一个词。在我有不同的情感时，思考不同的问题时，面临不同的选择时，它是我最后的仪仗，是我追求的东西，尽管为此我注定没有方向。\n\n我不知道小时候庐山上的蓝天白云与我的无忧无虑算不算纯粹，也许无忧无虑只是假象，是人丢掉一段时间内的大部分记忆的一种自然而然的感受。我马上21了，在我以1开头的年岁里，我的确很少看到记忆中的那种蓝天了。在熬过二月的阴雨之后，最近武汉的天气晴空万里，就连今天早上阴沉潮湿的墨绿在我中午再一次以相同的视角观望时都已经消失殆尽了，但蓝天上仍然有一层阴霾，蓝的并不纯粹，而我已经习惯了这种蓝，并且也开始用湛蓝形容它。没事的时候我也会在教五门口的广场上休息，或者在万林艺术馆的天台上坐着以一个不至于让太阳抢去风头的角度欣赏蓝天，我为这种天气而欣喜，但内心中又似乎对一场夏天的雷雨更为期待。我不知道是因为暴雨真的能够洗刷世界，还是因为我仅仅期待那雨声给我带来的视觉、听觉再到触觉的全方位的模拟，能够带我回到小时候，或者说情感更加纯粹的年岁。\n\n现在外面天很黑，皓月当空，高悬东方，在宿舍门口我看到有人在用微单拍摄。我很遗憾单反不在身边，同时又很庆幸单反不在身边。我尝试用手机对这个美丽的夜色进行记录，但最后发现它只属于我的眼睛，属于在我记忆中注定渐渐消散的那一块区域。我很快会把昨晚的雨、清晨的绿以及东方的月这些印记着今天的一切特征给淡忘，因为未来还会有无数个相同的日子，武大的樱花会一直开下去，我的路，我的追求，我的思考也不会停下，至死方休。时不时想想上一个今天自己对纯粹的定义，也许会发现愚蠢，也许会发现美丽，但更重要的是找到不同日子纯粹变化的轨迹。文字的意义总会是虚无缥缈的，但追求的东西如果套用一个词来表达的话我认为总不至于两个时间的方向会是南北迥异的吧。\n\n说句实话，我想家了。\n\n人只有在意识到自己脆弱的时候才会顿生羁旅之情。\n\n但也从来没有用羁旅表达自己状态的人会停下脚步。\n\n> 记于 19.3.20 武汉","slug":"瞎侃/散文/雨与晴","published":1,"updated":"2020-07-16T14:59:33.182Z","_id":"ckcox688h002668js6axa5to9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>今天早上8点半左右，我像往常一样上三楼接水，在楼梯间的窗户向外瞥，围墙外的篮球场的塑胶地上湿了一片。围墙略显斑驳，是本来就不那么年经了的建筑被大水冲洗过后的一种自然姿态，带着一些年迈的美丽。</p>\n<p>没事的时候我很喜欢透过这里向外望，但这次不是，因为我的眼光里多少带了些形色匆匆的味道。被水洗过的塑胶绿和围墙这边的绿色的植物，与其说是我看到了她们，不如说是她们的颜色主宰了那一秒内我的视神经。现在窗外夜色朦胧，是置身城市里很少见到的那种纯粹的墨蓝，纯粹的证明也并非是我自情自愿，是因为我抬头能看到星星。</p>\n<p>不对，在东边的天空，还有一轮月亮，也许足够用皓月来形容。</p>\n<p>我并不像一些下午一样，站在那个楼梯间的窗户面前带着什么思考或者纯粹性的发呆向外望。清晨的我手里拿着洗面奶和脸盆毛巾经过了那里，我现在也只能以上帝的姿态回顾那个瞬间我究竟是迈开了左腿还是右腿，脑子中想的究竟是窗外的绿还是一些什么别的乱七八糟的东西。这到底是模拟，有一万种不同的可能，这花了我很长的时间，沉淀了许多情感。我并不喜欢喝白酒，事实上也的确没怎么喝过，但我觉得所谓后劲，就是如此吧。在张开嘴的瞬间，咽下的酒精会让觥筹交错之后的你花上几个小时醉在自己的梦里，所需要的契机也只是热闹向平淡的自然转变。</p>\n<p>雨是早就要下的了，昨晚睡前就已经开始了，但我并没有太在意，只记得它很大，像是夏天的雷雨，全然不同于上个月那阴雨绵绵的枯燥，倒是热烈洒脱，干脆利落。昨晚12点左右的时候，我躺在床上，感觉很累很累。我不知道“累”这种感觉的产生是基于什么，也许是某种激素，那我觉得自己想必是有些内分泌失调了。我并没有什么能过得去的让我感觉到疲惫的理由，但我就是很累。这一个月来我思考了很多，这个多也只是相对于我某种程度上放弃思考开始自欺欺人的那大段时间而已，只是一个正常水平，就像冬末的阴雨只要地球还在正常的轨道上，只要太阳不出什么问题，就一定会消散一样。阴天和晴天，只不过是地球表面的两种正常状态，但其微小的不同，的确会对地表的生物造成一些困扰，这我想是肯定的。</p>\n<p>半夜的时候我被雨声惊醒了，这很少见，除去呼噜声与钟表的滴答，我是很难被别的声音惊醒的。半夜醒来的人对时间是没法计数的，一切理性和情感都处于朦胧的状态，也许这道朦胧会在大脑留下沙滩上城堡般的记忆，也许不会。但我却记得，那算是雨后的阴沉的味道吧。翠绿的世界总是会给人一种虽然充满生气但却脆弱稚嫩的感觉，在这脆弱稚嫩之下不知纯粹为何物，但被大雨蹂躏过后的植物的墨绿虽然给人阴沉郁结之感，却又十足纯粹。淅沥小雨下的天空阴沉混沌，赶时间的人会痛恨这种“欲擒故纵”般的感觉，世界并不是在接受清洗，而是在把污浊借雨水之名平摊到各地，也许是为了遮瑕，但却使原来作为“瑜”的部分都消失殆尽，纯粹一词无处藏身。而大雨磅礴的天空也许更是阴沉可怖，但却给人以十足的命令感，再赶时间你也不会为“走”或“不走”而面露难色，只有在屋檐下耐心等待。等待的过程也许是生活中难得的纯粹的仪式，因为静坐听雨的意境在当代实在是少的可怜，就连裤腿被大雨淋湿的触感都变得弥足珍贵。</p>\n<p>雨后，空气中会有清爽的纯粹，世界接受清洗之后，无论是借着日光还是霓虹，路面倒映出的射影，是世界的另一种面貌，印着纯粹二字。</p>\n<p>但我并不知道纯粹为何物，它是最狡诈多变的一个词。在我有不同的情感时，思考不同的问题时，面临不同的选择时，它是我最后的仪仗，是我追求的东西，尽管为此我注定没有方向。</p>\n<p>我不知道小时候庐山上的蓝天白云与我的无忧无虑算不算纯粹，也许无忧无虑只是假象，是人丢掉一段时间内的大部分记忆的一种自然而然的感受。我马上21了，在我以1开头的年岁里，我的确很少看到记忆中的那种蓝天了。在熬过二月的阴雨之后，最近武汉的天气晴空万里，就连今天早上阴沉潮湿的墨绿在我中午再一次以相同的视角观望时都已经消失殆尽了，但蓝天上仍然有一层阴霾，蓝的并不纯粹，而我已经习惯了这种蓝，并且也开始用湛蓝形容它。没事的时候我也会在教五门口的广场上休息，或者在万林艺术馆的天台上坐着以一个不至于让太阳抢去风头的角度欣赏蓝天，我为这种天气而欣喜，但内心中又似乎对一场夏天的雷雨更为期待。我不知道是因为暴雨真的能够洗刷世界，还是因为我仅仅期待那雨声给我带来的视觉、听觉再到触觉的全方位的模拟，能够带我回到小时候，或者说情感更加纯粹的年岁。</p>\n<p>现在外面天很黑，皓月当空，高悬东方，在宿舍门口我看到有人在用微单拍摄。我很遗憾单反不在身边，同时又很庆幸单反不在身边。我尝试用手机对这个美丽的夜色进行记录，但最后发现它只属于我的眼睛，属于在我记忆中注定渐渐消散的那一块区域。我很快会把昨晚的雨、清晨的绿以及东方的月这些印记着今天的一切特征给淡忘，因为未来还会有无数个相同的日子，武大的樱花会一直开下去，我的路，我的追求，我的思考也不会停下，至死方休。时不时想想上一个今天自己对纯粹的定义，也许会发现愚蠢，也许会发现美丽，但更重要的是找到不同日子纯粹变化的轨迹。文字的意义总会是虚无缥缈的，但追求的东西如果套用一个词来表达的话我认为总不至于两个时间的方向会是南北迥异的吧。</p>\n<p>说句实话，我想家了。</p>\n<p>人只有在意识到自己脆弱的时候才会顿生羁旅之情。</p>\n<p>但也从来没有用羁旅表达自己状态的人会停下脚步。</p>\n<blockquote>\n<p>记于 19.3.20 武汉</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>今天早上8点半左右，我像往常一样上三楼接水，在楼梯间的窗户向外瞥，围墙外的篮球场的塑胶地上湿了一片。围墙略显斑驳，是本来就不那么年经了的建筑被大水冲洗过后的一种自然姿态，带着一些年迈的美丽。</p>\n<p>没事的时候我很喜欢透过这里向外望，但这次不是，因为我的眼光里多少带了些形色匆匆的味道。被水洗过的塑胶绿和围墙这边的绿色的植物，与其说是我看到了她们，不如说是她们的颜色主宰了那一秒内我的视神经。现在窗外夜色朦胧，是置身城市里很少见到的那种纯粹的墨蓝，纯粹的证明也并非是我自情自愿，是因为我抬头能看到星星。</p>\n<p>不对，在东边的天空，还有一轮月亮，也许足够用皓月来形容。</p>\n<p>我并不像一些下午一样，站在那个楼梯间的窗户面前带着什么思考或者纯粹性的发呆向外望。清晨的我手里拿着洗面奶和脸盆毛巾经过了那里，我现在也只能以上帝的姿态回顾那个瞬间我究竟是迈开了左腿还是右腿，脑子中想的究竟是窗外的绿还是一些什么别的乱七八糟的东西。这到底是模拟，有一万种不同的可能，这花了我很长的时间，沉淀了许多情感。我并不喜欢喝白酒，事实上也的确没怎么喝过，但我觉得所谓后劲，就是如此吧。在张开嘴的瞬间，咽下的酒精会让觥筹交错之后的你花上几个小时醉在自己的梦里，所需要的契机也只是热闹向平淡的自然转变。</p>\n<p>雨是早就要下的了，昨晚睡前就已经开始了，但我并没有太在意，只记得它很大，像是夏天的雷雨，全然不同于上个月那阴雨绵绵的枯燥，倒是热烈洒脱，干脆利落。昨晚12点左右的时候，我躺在床上，感觉很累很累。我不知道“累”这种感觉的产生是基于什么，也许是某种激素，那我觉得自己想必是有些内分泌失调了。我并没有什么能过得去的让我感觉到疲惫的理由，但我就是很累。这一个月来我思考了很多，这个多也只是相对于我某种程度上放弃思考开始自欺欺人的那大段时间而已，只是一个正常水平，就像冬末的阴雨只要地球还在正常的轨道上，只要太阳不出什么问题，就一定会消散一样。阴天和晴天，只不过是地球表面的两种正常状态，但其微小的不同，的确会对地表的生物造成一些困扰，这我想是肯定的。</p>\n<p>半夜的时候我被雨声惊醒了，这很少见，除去呼噜声与钟表的滴答，我是很难被别的声音惊醒的。半夜醒来的人对时间是没法计数的，一切理性和情感都处于朦胧的状态，也许这道朦胧会在大脑留下沙滩上城堡般的记忆，也许不会。但我却记得，那算是雨后的阴沉的味道吧。翠绿的世界总是会给人一种虽然充满生气但却脆弱稚嫩的感觉，在这脆弱稚嫩之下不知纯粹为何物，但被大雨蹂躏过后的植物的墨绿虽然给人阴沉郁结之感，却又十足纯粹。淅沥小雨下的天空阴沉混沌，赶时间的人会痛恨这种“欲擒故纵”般的感觉，世界并不是在接受清洗，而是在把污浊借雨水之名平摊到各地，也许是为了遮瑕，但却使原来作为“瑜”的部分都消失殆尽，纯粹一词无处藏身。而大雨磅礴的天空也许更是阴沉可怖，但却给人以十足的命令感，再赶时间你也不会为“走”或“不走”而面露难色，只有在屋檐下耐心等待。等待的过程也许是生活中难得的纯粹的仪式，因为静坐听雨的意境在当代实在是少的可怜，就连裤腿被大雨淋湿的触感都变得弥足珍贵。</p>\n<p>雨后，空气中会有清爽的纯粹，世界接受清洗之后，无论是借着日光还是霓虹，路面倒映出的射影，是世界的另一种面貌，印着纯粹二字。</p>\n<p>但我并不知道纯粹为何物，它是最狡诈多变的一个词。在我有不同的情感时，思考不同的问题时，面临不同的选择时，它是我最后的仪仗，是我追求的东西，尽管为此我注定没有方向。</p>\n<p>我不知道小时候庐山上的蓝天白云与我的无忧无虑算不算纯粹，也许无忧无虑只是假象，是人丢掉一段时间内的大部分记忆的一种自然而然的感受。我马上21了，在我以1开头的年岁里，我的确很少看到记忆中的那种蓝天了。在熬过二月的阴雨之后，最近武汉的天气晴空万里，就连今天早上阴沉潮湿的墨绿在我中午再一次以相同的视角观望时都已经消失殆尽了，但蓝天上仍然有一层阴霾，蓝的并不纯粹，而我已经习惯了这种蓝，并且也开始用湛蓝形容它。没事的时候我也会在教五门口的广场上休息，或者在万林艺术馆的天台上坐着以一个不至于让太阳抢去风头的角度欣赏蓝天，我为这种天气而欣喜，但内心中又似乎对一场夏天的雷雨更为期待。我不知道是因为暴雨真的能够洗刷世界，还是因为我仅仅期待那雨声给我带来的视觉、听觉再到触觉的全方位的模拟，能够带我回到小时候，或者说情感更加纯粹的年岁。</p>\n<p>现在外面天很黑，皓月当空，高悬东方，在宿舍门口我看到有人在用微单拍摄。我很遗憾单反不在身边，同时又很庆幸单反不在身边。我尝试用手机对这个美丽的夜色进行记录，但最后发现它只属于我的眼睛，属于在我记忆中注定渐渐消散的那一块区域。我很快会把昨晚的雨、清晨的绿以及东方的月这些印记着今天的一切特征给淡忘，因为未来还会有无数个相同的日子，武大的樱花会一直开下去，我的路，我的追求，我的思考也不会停下，至死方休。时不时想想上一个今天自己对纯粹的定义，也许会发现愚蠢，也许会发现美丽，但更重要的是找到不同日子纯粹变化的轨迹。文字的意义总会是虚无缥缈的，但追求的东西如果套用一个词来表达的话我认为总不至于两个时间的方向会是南北迥异的吧。</p>\n<p>说句实话，我想家了。</p>\n<p>人只有在意识到自己脆弱的时候才会顿生羁旅之情。</p>\n<p>但也从来没有用羁旅表达自己状态的人会停下脚步。</p>\n<blockquote>\n<p>记于 19.3.20 武汉</p>\n</blockquote>\n"},{"title":"2、Java中的类与接口","date":"2020-07-04T02:43:51.000Z","fileName":"java2","_content":"\n主要参考：https://github.com/Snailclimb/JavaGuide\n\n### 面向对象三大特征\n\n#### 封装\n\n封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。\n\n#### 继承\n\n继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。同时，**Java语言中的继承是单继承**。\n\n1、子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。\n\n2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n\n3、子类可以用自己的方式实现父类的方法（方法重写）。\n\n#### 多态\n\n\n\n\n\n### Object类的常见方法总结\n\nObject类是所有类的父类，主要提供11个方法。\n\n```\n// 用于返回当前运行时对象的Class对象。\npublic final native Class<?> getClass()\n\n// 用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap\npublic native int hashCode()\n\n// 用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等\npublic boolean equals(Object obj)\n\n// 用于创建并返回当前对象的一份拷贝。\n// 一般情况下，对于任何对象 x\n// 表达式 x.clone() != x 为true\n// x.clone().getClass() == x.getClass() 为true\n// Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会产生异常。\nprotected native Object clone() throws CloneNotSupportedException\n\n// 返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。\npublic String toString()\n\n// 不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\npublic final native void notify()\n\n// 不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\npublic final native void notifyAll()\n\n// 不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。\npublic final native void wait(long timeout) throws InterruptedException\n\n// 多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\n// 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\npublic final void wait() throws InterruptedException\n\n// 实例被垃圾回收器回收的时候触发的操作\nprotected void finalize() throws Throwable\n\n```\n\n其中native方法即为调用非Java代码的接口，一个native方法是指该方法的实现由非Java语言实现。\n\n\n\n","source":"_posts/Java/2、Java中的类与接口.md","raw":"---\ntitle: 2、Java中的类与接口\ndate: 2020-07-04 10:43:51\ntags:\n\t- Java\ncategories:\n\t- Java\n\t- 基础知识\nfileName: java2\n---\n\n主要参考：https://github.com/Snailclimb/JavaGuide\n\n### 面向对象三大特征\n\n#### 封装\n\n封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。\n\n#### 继承\n\n继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。同时，**Java语言中的继承是单继承**。\n\n1、子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。\n\n2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n\n3、子类可以用自己的方式实现父类的方法（方法重写）。\n\n#### 多态\n\n\n\n\n\n### Object类的常见方法总结\n\nObject类是所有类的父类，主要提供11个方法。\n\n```\n// 用于返回当前运行时对象的Class对象。\npublic final native Class<?> getClass()\n\n// 用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap\npublic native int hashCode()\n\n// 用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等\npublic boolean equals(Object obj)\n\n// 用于创建并返回当前对象的一份拷贝。\n// 一般情况下，对于任何对象 x\n// 表达式 x.clone() != x 为true\n// x.clone().getClass() == x.getClass() 为true\n// Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会产生异常。\nprotected native Object clone() throws CloneNotSupportedException\n\n// 返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。\npublic String toString()\n\n// 不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\npublic final native void notify()\n\n// 不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\npublic final native void notifyAll()\n\n// 不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。\npublic final native void wait(long timeout) throws InterruptedException\n\n// 多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\n// 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\npublic final void wait() throws InterruptedException\n\n// 实例被垃圾回收器回收的时候触发的操作\nprotected void finalize() throws Throwable\n\n```\n\n其中native方法即为调用非Java代码的接口，一个native方法是指该方法的实现由非Java语言实现。\n\n\n\n","slug":"Java/2、Java中的类与接口","published":1,"updated":"2020-07-16T09:20:09.715Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcox6lju002b68jscc1669lb","content":"<p>主要参考：<a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\" rel=\"noopener\">https://github.com/Snailclimb/JavaGuide</a></p>\n<h3 id=\"面向对象三大特征\"><a href=\"#面向对象三大特征\" class=\"headerlink\" title=\"面向对象三大特征\"></a>面向对象三大特征</h3><h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。同时，<strong>Java语言中的继承是单继承</strong>。</p>\n<p>1、子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</p>\n<p>2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>\n<p>3、子类可以用自己的方式实现父类的方法（方法重写）。</p>\n<h4 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h4><h3 id=\"Object类的常见方法总结\"><a href=\"#Object类的常见方法总结\" class=\"headerlink\" title=\"Object类的常见方法总结\"></a>Object类的常见方法总结</h3><p>Object类是所有类的父类，主要提供11个方法。</p>\n<pre><code>// 用于返回当前运行时对象的Class对象。\npublic final native Class&lt;?&gt; getClass()\n\n// 用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap\npublic native int hashCode()\n\n// 用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等\npublic boolean equals(Object obj)\n\n// 用于创建并返回当前对象的一份拷贝。\n// 一般情况下，对于任何对象 x\n// 表达式 x.clone() != x 为true\n// x.clone().getClass() == x.getClass() 为true\n// Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会产生异常。\nprotected native Object clone() throws CloneNotSupportedException\n\n// 返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。\npublic String toString()\n\n// 不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\npublic final native void notify()\n\n// 不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\npublic final native void notifyAll()\n\n// 不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。\npublic final native void wait(long timeout) throws InterruptedException\n\n// 多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\n// 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\npublic final void wait() throws InterruptedException\n\n// 实例被垃圾回收器回收的时候触发的操作\nprotected void finalize() throws Throwable\n</code></pre><p>其中native方法即为调用非Java代码的接口，一个native方法是指该方法的实现由非Java语言实现。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>主要参考：<a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\" rel=\"noopener\">https://github.com/Snailclimb/JavaGuide</a></p>\n<h3 id=\"面向对象三大特征\"><a href=\"#面向对象三大特征\" class=\"headerlink\" title=\"面向对象三大特征\"></a>面向对象三大特征</h3><h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。同时，<strong>Java语言中的继承是单继承</strong>。</p>\n<p>1、子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</p>\n<p>2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>\n<p>3、子类可以用自己的方式实现父类的方法（方法重写）。</p>\n<h4 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h4><h3 id=\"Object类的常见方法总结\"><a href=\"#Object类的常见方法总结\" class=\"headerlink\" title=\"Object类的常见方法总结\"></a>Object类的常见方法总结</h3><p>Object类是所有类的父类，主要提供11个方法。</p>\n<pre><code>// 用于返回当前运行时对象的Class对象。\npublic final native Class&lt;?&gt; getClass()\n\n// 用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap\npublic native int hashCode()\n\n// 用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等\npublic boolean equals(Object obj)\n\n// 用于创建并返回当前对象的一份拷贝。\n// 一般情况下，对于任何对象 x\n// 表达式 x.clone() != x 为true\n// x.clone().getClass() == x.getClass() 为true\n// Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会产生异常。\nprotected native Object clone() throws CloneNotSupportedException\n\n// 返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。\npublic String toString()\n\n// 不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\npublic final native void notify()\n\n// 不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\npublic final native void notifyAll()\n\n// 不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。\npublic final native void wait(long timeout) throws InterruptedException\n\n// 多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\n// 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\npublic final void wait() throws InterruptedException\n\n// 实例被垃圾回收器回收的时候触发的操作\nprotected void finalize() throws Throwable\n</code></pre><p>其中native方法即为调用非Java代码的接口，一个native方法是指该方法的实现由非Java语言实现。</p>\n"},{"title":"3、Java中的容器","date":"2020-07-10T06:34:11.000Z","fileName":"java3","_content":"\n\n\n\n\n\n\n### 异常\n\nThrowable根类\n\nError、Exception（程序本身可以处理的异常）\n\n\n\ntry块后可以接0或多个catch块，若没有catch块，则必须跟一个finally块\n\n```\ntry {\n\n} catch(Exception e) {\n\te.printStackTrace();\n} finally {\n\n}\n```\n\n\n\nthrows声明方法将要抛出何种异常的声明，通过throw将产生的异常抛出\n\n若一个方法可能出现异常，但没有能力处理异常，可以在方法声明处用throws子句来声明抛出异常\n\n```\npublic void method() throws Exception1, Exception2 {\n\t//可能产生异常的代码\n}\n```\n\n\n\n\n\n### 字符串\n\nequal方法指内容是否相同\n\n==指地址是否相同\n\n\n\nString的对象一旦被创建，则不能修改，是不可变的（即使用substr等函数时其本身是不会变的）\n\n\n\n当频繁操作字符串时，使用StringBuilder\n\n常用方法\n\n```\nStringBuilder str = new StringBuilder(\"hello\");\nstr.append(\" world\");\t// 向后添加字符串\nstr.delete(0,5);\t// 删除第0-4个字符\nstr.insert(4,\"gg\");\t// 在索引4向后插入gg\nstr.replace(4,6,\"aa\");\t// 在缩影4到5处替换为aa\n\n```\n\n\n\n### 集合\n\nCollection：List，Queue，Set\n\nList是元素有序并且可以重复的集合，称为序列\n\n两个主要实现类：ArrayList，LinkedList\n\n\n\nArrayList底层由数组实现，动态增长，其中元素可以为null\n\n```\nArrayList list = new ArrayList();\nlist.add(1);\t// 向后添加\nlist.size();\t// 获取元素数量\nlist.get(1);\t// 取出索引值为1的元素\nlist.remove(2);\t// 移除索引为2的元素\n\n```\n\n\n\nSet\n\n元素无序且不可以重复的集合。\n\nHashSet是Set的一个重要元素，称为哈希集，其中元素无序且不可以重复，只允许一个null元素。\n\n\n\n### 迭代器\n\nIterator接口可以以统一的方式对各种集合元素进行遍历，调用各种集合元素的iterator()方法得到迭代器。\n\nhasNext()方法检测集合中是否还有下一个元素\n\nnext()方法返回集合中的下一个元素\n\n```\nIterator it = set.iterator();\nwhile (it.hasNext()) {\n\tSystem.out.println(it.next());\n}\n```\n\n\n\nhashCode()和equals()，用于判断是否相同，选哟进行重写  \n\n\n\nMap。以键值对的形式存储\n\nHashMap：基于哈希表的Map接口的实现，允许使用null值和null键，无序排列。\n\n\n\n排序\n\n```\nCollections.sort(list);\n```\n\n使用Comparable或Comparator接口对自定义类进行排序\n\n\n\n\n\n### 泛型\n\n变量声明的类型必须匹配传递给实际对象的类型（即前后尖括号中的内容必须相同）\n\n\n\n<? extends 类名>   该类与其子类都可以\n\n<? super 类名> 该类与其父类都可以\n\n\n\n泛型方法不一定要写在泛型类当中\n\n```\n// 泛型方法\npublic class Generic {\n\tpublic <T> void func(T t) {\n\t\t\n\t}\n\t// 可以输入Number的子类\n\tpublic <T extents Number> void func1(T t) {\n\t\n\t}\n}\n```\n\n\n\n\n\n\n\n","source":"_posts/Java/3、Java中的常用容器与方法.md","raw":"---\ntitle: 3、Java中的容器\ndate: 2020-07-10 14:34:11\ntags:\n\t- Java\ncategories:\n\t- Java\n\t- 基础知识\nfileName: java3\n---\n\n\n\n\n\n\n\n### 异常\n\nThrowable根类\n\nError、Exception（程序本身可以处理的异常）\n\n\n\ntry块后可以接0或多个catch块，若没有catch块，则必须跟一个finally块\n\n```\ntry {\n\n} catch(Exception e) {\n\te.printStackTrace();\n} finally {\n\n}\n```\n\n\n\nthrows声明方法将要抛出何种异常的声明，通过throw将产生的异常抛出\n\n若一个方法可能出现异常，但没有能力处理异常，可以在方法声明处用throws子句来声明抛出异常\n\n```\npublic void method() throws Exception1, Exception2 {\n\t//可能产生异常的代码\n}\n```\n\n\n\n\n\n### 字符串\n\nequal方法指内容是否相同\n\n==指地址是否相同\n\n\n\nString的对象一旦被创建，则不能修改，是不可变的（即使用substr等函数时其本身是不会变的）\n\n\n\n当频繁操作字符串时，使用StringBuilder\n\n常用方法\n\n```\nStringBuilder str = new StringBuilder(\"hello\");\nstr.append(\" world\");\t// 向后添加字符串\nstr.delete(0,5);\t// 删除第0-4个字符\nstr.insert(4,\"gg\");\t// 在索引4向后插入gg\nstr.replace(4,6,\"aa\");\t// 在缩影4到5处替换为aa\n\n```\n\n\n\n### 集合\n\nCollection：List，Queue，Set\n\nList是元素有序并且可以重复的集合，称为序列\n\n两个主要实现类：ArrayList，LinkedList\n\n\n\nArrayList底层由数组实现，动态增长，其中元素可以为null\n\n```\nArrayList list = new ArrayList();\nlist.add(1);\t// 向后添加\nlist.size();\t// 获取元素数量\nlist.get(1);\t// 取出索引值为1的元素\nlist.remove(2);\t// 移除索引为2的元素\n\n```\n\n\n\nSet\n\n元素无序且不可以重复的集合。\n\nHashSet是Set的一个重要元素，称为哈希集，其中元素无序且不可以重复，只允许一个null元素。\n\n\n\n### 迭代器\n\nIterator接口可以以统一的方式对各种集合元素进行遍历，调用各种集合元素的iterator()方法得到迭代器。\n\nhasNext()方法检测集合中是否还有下一个元素\n\nnext()方法返回集合中的下一个元素\n\n```\nIterator it = set.iterator();\nwhile (it.hasNext()) {\n\tSystem.out.println(it.next());\n}\n```\n\n\n\nhashCode()和equals()，用于判断是否相同，选哟进行重写  \n\n\n\nMap。以键值对的形式存储\n\nHashMap：基于哈希表的Map接口的实现，允许使用null值和null键，无序排列。\n\n\n\n排序\n\n```\nCollections.sort(list);\n```\n\n使用Comparable或Comparator接口对自定义类进行排序\n\n\n\n\n\n### 泛型\n\n变量声明的类型必须匹配传递给实际对象的类型（即前后尖括号中的内容必须相同）\n\n\n\n<? extends 类名>   该类与其子类都可以\n\n<? super 类名> 该类与其父类都可以\n\n\n\n泛型方法不一定要写在泛型类当中\n\n```\n// 泛型方法\npublic class Generic {\n\tpublic <T> void func(T t) {\n\t\t\n\t}\n\t// 可以输入Number的子类\n\tpublic <T extents Number> void func1(T t) {\n\t\n\t}\n}\n```\n\n\n\n\n\n\n\n","slug":"Java/3、Java中的常用容器与方法","published":1,"updated":"2020-07-16T09:20:51.979Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcox6lk0002f68js55yib0sa","content":"<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><p>Throwable根类</p>\n<p>Error、Exception（程序本身可以处理的异常）</p>\n<p>try块后可以接0或多个catch块，若没有catch块，则必须跟一个finally块</p>\n<pre><code>try {\n\n} catch(Exception e) {\n    e.printStackTrace();\n} finally {\n\n}</code></pre><p>throws声明方法将要抛出何种异常的声明，通过throw将产生的异常抛出</p>\n<p>若一个方法可能出现异常，但没有能力处理异常，可以在方法声明处用throws子句来声明抛出异常</p>\n<pre><code>public void method() throws Exception1, Exception2 {\n    //可能产生异常的代码\n}</code></pre><h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>equal方法指内容是否相同</p>\n<p>==指地址是否相同</p>\n<p>String的对象一旦被创建，则不能修改，是不可变的（即使用substr等函数时其本身是不会变的）</p>\n<p>当频繁操作字符串时，使用StringBuilder</p>\n<p>常用方法</p>\n<pre><code>StringBuilder str = new StringBuilder(&quot;hello&quot;);\nstr.append(&quot; world&quot;);    // 向后添加字符串\nstr.delete(0,5);    // 删除第0-4个字符\nstr.insert(4,&quot;gg&quot;);    // 在索引4向后插入gg\nstr.replace(4,6,&quot;aa&quot;);    // 在缩影4到5处替换为aa\n</code></pre><h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>Collection：List，Queue，Set</p>\n<p>List是元素有序并且可以重复的集合，称为序列</p>\n<p>两个主要实现类：ArrayList，LinkedList</p>\n<p>ArrayList底层由数组实现，动态增长，其中元素可以为null</p>\n<pre><code>ArrayList list = new ArrayList();\nlist.add(1);    // 向后添加\nlist.size();    // 获取元素数量\nlist.get(1);    // 取出索引值为1的元素\nlist.remove(2);    // 移除索引为2的元素\n</code></pre><p>Set</p>\n<p>元素无序且不可以重复的集合。</p>\n<p>HashSet是Set的一个重要元素，称为哈希集，其中元素无序且不可以重复，只允许一个null元素。</p>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>Iterator接口可以以统一的方式对各种集合元素进行遍历，调用各种集合元素的iterator()方法得到迭代器。</p>\n<p>hasNext()方法检测集合中是否还有下一个元素</p>\n<p>next()方法返回集合中的下一个元素</p>\n<pre><code>Iterator it = set.iterator();\nwhile (it.hasNext()) {\n    System.out.println(it.next());\n}</code></pre><p>hashCode()和equals()，用于判断是否相同，选哟进行重写  </p>\n<p>Map。以键值对的形式存储</p>\n<p>HashMap：基于哈希表的Map接口的实现，允许使用null值和null键，无序排列。</p>\n<p>排序</p>\n<pre><code>Collections.sort(list);</code></pre><p>使用Comparable或Comparator接口对自定义类进行排序</p>\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><p>变量声明的类型必须匹配传递给实际对象的类型（即前后尖括号中的内容必须相同）</p>\n<p>&lt;? extends 类名&gt;   该类与其子类都可以</p>\n<p>&lt;? super 类名&gt; 该类与其父类都可以</p>\n<p>泛型方法不一定要写在泛型类当中</p>\n<pre><code>// 泛型方法\npublic class Generic {\n    public &lt;T&gt; void func(T t) {\n\n    }\n    // 可以输入Number的子类\n    public &lt;T extents Number&gt; void func1(T t) {\n\n    }\n}</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><p>Throwable根类</p>\n<p>Error、Exception（程序本身可以处理的异常）</p>\n<p>try块后可以接0或多个catch块，若没有catch块，则必须跟一个finally块</p>\n<pre><code>try {\n\n} catch(Exception e) {\n    e.printStackTrace();\n} finally {\n\n}</code></pre><p>throws声明方法将要抛出何种异常的声明，通过throw将产生的异常抛出</p>\n<p>若一个方法可能出现异常，但没有能力处理异常，可以在方法声明处用throws子句来声明抛出异常</p>\n<pre><code>public void method() throws Exception1, Exception2 {\n    //可能产生异常的代码\n}</code></pre><h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>equal方法指内容是否相同</p>\n<p>==指地址是否相同</p>\n<p>String的对象一旦被创建，则不能修改，是不可变的（即使用substr等函数时其本身是不会变的）</p>\n<p>当频繁操作字符串时，使用StringBuilder</p>\n<p>常用方法</p>\n<pre><code>StringBuilder str = new StringBuilder(&quot;hello&quot;);\nstr.append(&quot; world&quot;);    // 向后添加字符串\nstr.delete(0,5);    // 删除第0-4个字符\nstr.insert(4,&quot;gg&quot;);    // 在索引4向后插入gg\nstr.replace(4,6,&quot;aa&quot;);    // 在缩影4到5处替换为aa\n</code></pre><h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>Collection：List，Queue，Set</p>\n<p>List是元素有序并且可以重复的集合，称为序列</p>\n<p>两个主要实现类：ArrayList，LinkedList</p>\n<p>ArrayList底层由数组实现，动态增长，其中元素可以为null</p>\n<pre><code>ArrayList list = new ArrayList();\nlist.add(1);    // 向后添加\nlist.size();    // 获取元素数量\nlist.get(1);    // 取出索引值为1的元素\nlist.remove(2);    // 移除索引为2的元素\n</code></pre><p>Set</p>\n<p>元素无序且不可以重复的集合。</p>\n<p>HashSet是Set的一个重要元素，称为哈希集，其中元素无序且不可以重复，只允许一个null元素。</p>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>Iterator接口可以以统一的方式对各种集合元素进行遍历，调用各种集合元素的iterator()方法得到迭代器。</p>\n<p>hasNext()方法检测集合中是否还有下一个元素</p>\n<p>next()方法返回集合中的下一个元素</p>\n<pre><code>Iterator it = set.iterator();\nwhile (it.hasNext()) {\n    System.out.println(it.next());\n}</code></pre><p>hashCode()和equals()，用于判断是否相同，选哟进行重写  </p>\n<p>Map。以键值对的形式存储</p>\n<p>HashMap：基于哈希表的Map接口的实现，允许使用null值和null键，无序排列。</p>\n<p>排序</p>\n<pre><code>Collections.sort(list);</code></pre><p>使用Comparable或Comparator接口对自定义类进行排序</p>\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><p>变量声明的类型必须匹配传递给实际对象的类型（即前后尖括号中的内容必须相同）</p>\n<p>&lt;? extends 类名&gt;   该类与其子类都可以</p>\n<p>&lt;? super 类名&gt; 该类与其父类都可以</p>\n<p>泛型方法不一定要写在泛型类当中</p>\n<pre><code>// 泛型方法\npublic class Generic {\n    public &lt;T&gt; void func(T t) {\n\n    }\n    // 可以输入Number的子类\n    public &lt;T extents Number&gt; void func1(T t) {\n\n    }\n}</code></pre>"},{"title":"4、Java多线程","date":"2020-07-12T10:47:21.000Z","fileName":"java4","_content":"\n### 线程的创建\n\n1、创建一个Thread类，或者一个Thread子类的对象\n\n2、创建一个实现Runnable接口的类的对象（解决Java只能单继承的限制，同时可以避免重写Thread类中的其他方法）\n\n```\nclass Test implements Runnable {\n\t@Override\n\tpublic void run() {\n\t\t// 添加你的代码\n\t}\n}\n```\n\n之后在主函数中输入\n\n```\nTest t = new Test();\nThread t1 = new Thread(pr);\t// 将创建好的通过参数传入Thread\nt1.start();\n```\n\n\n\n\n\nThread类的常用方法\n\n```\n# 线程相关的代码写入该方法，一般需要重写\npublic void run()\n\n# 启动线程\npublic void start()\n\n# 线程休眠m毫秒的方法\npublic static void sleep(long m)\n\n# 优先执行调用join()方法的线程\npublic void join()\n# 等待该线程终止的最长时间为millis毫秒\npublic final void join(long millis)\n```\n\n\n\nRunnable接口\n\nRunnable是Java中用以实现线程的接口，只有一个方法run()\n\n任何实现线程功能的类都必须实现该接口\n\n\n\n### 线程优先级\n\nJava为线程类提供了10个优先级，优先级可以用整数1-10表示，超过范围会抛出异常，主线程默认优先级为5\n\n优先级常量\n\n```\nMAX_PRIORITY：线程的最高优先级10\nMIN_PRIORITY：线程的最低优先级1\nNORM_PRIORITY：线程的默认优先级5\n```\n\n优先级相关方法：\n\n```;\n// 获取线程优先级\npublic int getPriority()\n\n// 设置线程优先级\npublic void setPriority(int newPriority)\n\n// 获取主线程优先级\nint mainpriority = Thread.currentThread().getPriority()\n```\n\n\n\n### 多线程\n\n各线程通过竞争CPU时间而获得运行机会，各线程什么时候得到CPU时间，占用多久，是不可预测的，一个正在运行着的线程在什么地方被暂停是不确定的\n\n\n\nsynchronized\n\n成员方法，静态方法、语句块\n\n```\npublic synchronized void func() {}\npublic static synchronized void func() {}\nsynchronized(obj) {}\n```\n\n\n\n线程间通信\n\n\n\n","source":"_posts/Java/4、Java多线程.md","raw":"---\ntitle: 4、Java多线程\ndate: 2020-07-12 18:47:21\ntags:\n\t- Java\ncategories:\n\t- Java\nfileName: java4\n---\n\n### 线程的创建\n\n1、创建一个Thread类，或者一个Thread子类的对象\n\n2、创建一个实现Runnable接口的类的对象（解决Java只能单继承的限制，同时可以避免重写Thread类中的其他方法）\n\n```\nclass Test implements Runnable {\n\t@Override\n\tpublic void run() {\n\t\t// 添加你的代码\n\t}\n}\n```\n\n之后在主函数中输入\n\n```\nTest t = new Test();\nThread t1 = new Thread(pr);\t// 将创建好的通过参数传入Thread\nt1.start();\n```\n\n\n\n\n\nThread类的常用方法\n\n```\n# 线程相关的代码写入该方法，一般需要重写\npublic void run()\n\n# 启动线程\npublic void start()\n\n# 线程休眠m毫秒的方法\npublic static void sleep(long m)\n\n# 优先执行调用join()方法的线程\npublic void join()\n# 等待该线程终止的最长时间为millis毫秒\npublic final void join(long millis)\n```\n\n\n\nRunnable接口\n\nRunnable是Java中用以实现线程的接口，只有一个方法run()\n\n任何实现线程功能的类都必须实现该接口\n\n\n\n### 线程优先级\n\nJava为线程类提供了10个优先级，优先级可以用整数1-10表示，超过范围会抛出异常，主线程默认优先级为5\n\n优先级常量\n\n```\nMAX_PRIORITY：线程的最高优先级10\nMIN_PRIORITY：线程的最低优先级1\nNORM_PRIORITY：线程的默认优先级5\n```\n\n优先级相关方法：\n\n```;\n// 获取线程优先级\npublic int getPriority()\n\n// 设置线程优先级\npublic void setPriority(int newPriority)\n\n// 获取主线程优先级\nint mainpriority = Thread.currentThread().getPriority()\n```\n\n\n\n### 多线程\n\n各线程通过竞争CPU时间而获得运行机会，各线程什么时候得到CPU时间，占用多久，是不可预测的，一个正在运行着的线程在什么地方被暂停是不确定的\n\n\n\nsynchronized\n\n成员方法，静态方法、语句块\n\n```\npublic synchronized void func() {}\npublic static synchronized void func() {}\nsynchronized(obj) {}\n```\n\n\n\n线程间通信\n\n\n\n","slug":"Java/4、Java多线程","published":1,"updated":"2020-07-16T09:21:12.160Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcox6lk1002g68js20d94tjs","content":"<h3 id=\"线程的创建\"><a href=\"#线程的创建\" class=\"headerlink\" title=\"线程的创建\"></a>线程的创建</h3><p>1、创建一个Thread类，或者一个Thread子类的对象</p>\n<p>2、创建一个实现Runnable接口的类的对象（解决Java只能单继承的限制，同时可以避免重写Thread类中的其他方法）</p>\n<pre><code>class Test implements Runnable {\n    @Override\n    public void run() {\n        // 添加你的代码\n    }\n}</code></pre><p>之后在主函数中输入</p>\n<pre><code>Test t = new Test();\nThread t1 = new Thread(pr);    // 将创建好的通过参数传入Thread\nt1.start();</code></pre><p>Thread类的常用方法</p>\n<pre><code># 线程相关的代码写入该方法，一般需要重写\npublic void run()\n\n# 启动线程\npublic void start()\n\n# 线程休眠m毫秒的方法\npublic static void sleep(long m)\n\n# 优先执行调用join()方法的线程\npublic void join()\n# 等待该线程终止的最长时间为millis毫秒\npublic final void join(long millis)</code></pre><p>Runnable接口</p>\n<p>Runnable是Java中用以实现线程的接口，只有一个方法run()</p>\n<p>任何实现线程功能的类都必须实现该接口</p>\n<h3 id=\"线程优先级\"><a href=\"#线程优先级\" class=\"headerlink\" title=\"线程优先级\"></a>线程优先级</h3><p>Java为线程类提供了10个优先级，优先级可以用整数1-10表示，超过范围会抛出异常，主线程默认优先级为5</p>\n<p>优先级常量</p>\n<pre><code>MAX_PRIORITY：线程的最高优先级10\nMIN_PRIORITY：线程的最低优先级1\nNORM_PRIORITY：线程的默认优先级5</code></pre><p>优先级相关方法：</p>\n<pre><code class=\";\">// 获取线程优先级\npublic int getPriority()\n\n// 设置线程优先级\npublic void setPriority(int newPriority)\n\n// 获取主线程优先级\nint mainpriority = Thread.currentThread().getPriority()</code></pre>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><p>各线程通过竞争CPU时间而获得运行机会，各线程什么时候得到CPU时间，占用多久，是不可预测的，一个正在运行着的线程在什么地方被暂停是不确定的</p>\n<p>synchronized</p>\n<p>成员方法，静态方法、语句块</p>\n<pre><code>public synchronized void func() {}\npublic static synchronized void func() {}\nsynchronized(obj) {}</code></pre><p>线程间通信</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"线程的创建\"><a href=\"#线程的创建\" class=\"headerlink\" title=\"线程的创建\"></a>线程的创建</h3><p>1、创建一个Thread类，或者一个Thread子类的对象</p>\n<p>2、创建一个实现Runnable接口的类的对象（解决Java只能单继承的限制，同时可以避免重写Thread类中的其他方法）</p>\n<pre><code>class Test implements Runnable {\n    @Override\n    public void run() {\n        // 添加你的代码\n    }\n}</code></pre><p>之后在主函数中输入</p>\n<pre><code>Test t = new Test();\nThread t1 = new Thread(pr);    // 将创建好的通过参数传入Thread\nt1.start();</code></pre><p>Thread类的常用方法</p>\n<pre><code># 线程相关的代码写入该方法，一般需要重写\npublic void run()\n\n# 启动线程\npublic void start()\n\n# 线程休眠m毫秒的方法\npublic static void sleep(long m)\n\n# 优先执行调用join()方法的线程\npublic void join()\n# 等待该线程终止的最长时间为millis毫秒\npublic final void join(long millis)</code></pre><p>Runnable接口</p>\n<p>Runnable是Java中用以实现线程的接口，只有一个方法run()</p>\n<p>任何实现线程功能的类都必须实现该接口</p>\n<h3 id=\"线程优先级\"><a href=\"#线程优先级\" class=\"headerlink\" title=\"线程优先级\"></a>线程优先级</h3><p>Java为线程类提供了10个优先级，优先级可以用整数1-10表示，超过范围会抛出异常，主线程默认优先级为5</p>\n<p>优先级常量</p>\n<pre><code>MAX_PRIORITY：线程的最高优先级10\nMIN_PRIORITY：线程的最低优先级1\nNORM_PRIORITY：线程的默认优先级5</code></pre><p>优先级相关方法：</p>\n<pre><code class=\";\">// 获取线程优先级\npublic int getPriority()\n\n// 设置线程优先级\npublic void setPriority(int newPriority)\n\n// 获取主线程优先级\nint mainpriority = Thread.currentThread().getPriority()</code></pre>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><p>各线程通过竞争CPU时间而获得运行机会，各线程什么时候得到CPU时间，占用多久，是不可预测的，一个正在运行着的线程在什么地方被暂停是不确定的</p>\n<p>synchronized</p>\n<p>成员方法，静态方法、语句块</p>\n<pre><code>public synchronized void func() {}\npublic static synchronized void func() {}\nsynchronized(obj) {}</code></pre><p>线程间通信</p>\n"},{"title":"Java父类引用指向子类对象（向上转型）","date":"2020-07-12T07:44:11.000Z","fileName":"java_polymorphic","_content":"\n参考：https://www.cnblogs.com/ChrisMurphy/p/5054256.html\n\n父类的引用指向子类的对象是Java中多态的重要表现形式\n\n#### 表现形式\n\n父类为Animal，子类为Cat，如下即为父类引用指向子类对象的形式，**声明的是父类，实际指向的是子类的一个对象**。（其中Animal可以是类也可以是接口，Cat是继承或实现Animal的子类）\n\n```\nAnimal animal = new Cat()\n```\n\n这种情况也即为**向上转型**，父类引用指向子类实例。**可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法**。\n\n\n\n#### 意义\n\n子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特， 定义一个父类类型的引用指向一个子类的对象既可以**使用子类强大的功能**，又可以**抽取父类的共性**。 所以，父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，父类引用是无法调用的\n\n\n\n#### 示例\n\n父类\n\n```\npublic class Father {\n    // 父类中的func1方法\n    // 由于子类中对该方法只是进行了重载而没有进行重写\n    // 因此该方法仍然有效\n    public void func1() {\n        System.out.println(\"Father func1\");\n    }\n\n    // 父类中的func2方法\n    // 由于在子类中重写了该方法\n    // 所以在“向上转型”中，该方法不再有效\n    // 取而代之的是子类中的fun2方法\n    public void func2() {\n        System.out.println(\"Father func2\");\n    }\n}\n```\n\n子类\n\n```\npublic class Child extends Father {\n    // 对func1方法的一个重载\n    // 由于在父类中没有定义该方法，所以该方法不能被父类的引用调用\n    // 如果进行调用即会报错\n    public void func1(int i) {\n        System.out.println(\"Child func1\");\n    }\n\n    // 对父类方法的重写\n    // 能够起作用\n    public void func2() {\n        System.out.println(\"Child func2\");\n    }\n}\n```\n\n主函数\n\n```\npublic class Main {\n    public static void main(String[] args) {\n\t// write your code here\n        Father test = new Child();\n        test.func1();   // Father func1\n        test.func2();   // Child func2\n        test.func1(10); // 报错\n    }\n}\n```\n\n上述示例中，子类Child继承了父类Father，并重载了父类的func1()方法，重写了父类的func2()方法。重载后的func1(int i)和func1()不再是同一个方法，由于父类中没有func1(int i)，那么，父类类型的引用child就不能调用func1(int i)方法。而子类重写了func2()方法，那么父类类型的引用child在调用该方法时将会调用子类中重写的func2()。 \n\n\n\n#### 总结\n\n1、**使用父类类型的引用指向子类的对象；** \n\n2、**该引用只能调用父类中定义的方法和变量；** \n\n3、**如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）** \n\n4、**变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了父类中的变量，那么在编译时会报错。**\n\n\n\n\n\n","source":"_posts/Java/Java父类引用指向子类对象.md","raw":"---\ntitle: Java父类引用指向子类对象（向上转型）\ndate: 2020-07-12 15:44:11\ntags:\n\t- Java\ncategories:\n\t- Java\n\t- 基础知识\nfileName: java_polymorphic\n---\n\n参考：https://www.cnblogs.com/ChrisMurphy/p/5054256.html\n\n父类的引用指向子类的对象是Java中多态的重要表现形式\n\n#### 表现形式\n\n父类为Animal，子类为Cat，如下即为父类引用指向子类对象的形式，**声明的是父类，实际指向的是子类的一个对象**。（其中Animal可以是类也可以是接口，Cat是继承或实现Animal的子类）\n\n```\nAnimal animal = new Cat()\n```\n\n这种情况也即为**向上转型**，父类引用指向子类实例。**可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法**。\n\n\n\n#### 意义\n\n子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特， 定义一个父类类型的引用指向一个子类的对象既可以**使用子类强大的功能**，又可以**抽取父类的共性**。 所以，父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，父类引用是无法调用的\n\n\n\n#### 示例\n\n父类\n\n```\npublic class Father {\n    // 父类中的func1方法\n    // 由于子类中对该方法只是进行了重载而没有进行重写\n    // 因此该方法仍然有效\n    public void func1() {\n        System.out.println(\"Father func1\");\n    }\n\n    // 父类中的func2方法\n    // 由于在子类中重写了该方法\n    // 所以在“向上转型”中，该方法不再有效\n    // 取而代之的是子类中的fun2方法\n    public void func2() {\n        System.out.println(\"Father func2\");\n    }\n}\n```\n\n子类\n\n```\npublic class Child extends Father {\n    // 对func1方法的一个重载\n    // 由于在父类中没有定义该方法，所以该方法不能被父类的引用调用\n    // 如果进行调用即会报错\n    public void func1(int i) {\n        System.out.println(\"Child func1\");\n    }\n\n    // 对父类方法的重写\n    // 能够起作用\n    public void func2() {\n        System.out.println(\"Child func2\");\n    }\n}\n```\n\n主函数\n\n```\npublic class Main {\n    public static void main(String[] args) {\n\t// write your code here\n        Father test = new Child();\n        test.func1();   // Father func1\n        test.func2();   // Child func2\n        test.func1(10); // 报错\n    }\n}\n```\n\n上述示例中，子类Child继承了父类Father，并重载了父类的func1()方法，重写了父类的func2()方法。重载后的func1(int i)和func1()不再是同一个方法，由于父类中没有func1(int i)，那么，父类类型的引用child就不能调用func1(int i)方法。而子类重写了func2()方法，那么父类类型的引用child在调用该方法时将会调用子类中重写的func2()。 \n\n\n\n#### 总结\n\n1、**使用父类类型的引用指向子类的对象；** \n\n2、**该引用只能调用父类中定义的方法和变量；** \n\n3、**如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）** \n\n4、**变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了父类中的变量，那么在编译时会报错。**\n\n\n\n\n\n","slug":"Java/Java父类引用指向子类对象","published":1,"updated":"2020-07-16T09:21:37.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcox6qti002m68js3y3b9vov","content":"<p>参考：<a href=\"https://www.cnblogs.com/ChrisMurphy/p/5054256.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/ChrisMurphy/p/5054256.html</a></p>\n<p>父类的引用指向子类的对象是Java中多态的重要表现形式</p>\n<h4 id=\"表现形式\"><a href=\"#表现形式\" class=\"headerlink\" title=\"表现形式\"></a>表现形式</h4><p>父类为Animal，子类为Cat，如下即为父类引用指向子类对象的形式，<strong>声明的是父类，实际指向的是子类的一个对象</strong>。（其中Animal可以是类也可以是接口，Cat是继承或实现Animal的子类）</p>\n<pre><code>Animal animal = new Cat()</code></pre><p>这种情况也即为<strong>向上转型</strong>，父类引用指向子类实例。<strong>可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法</strong>。</p>\n<h4 id=\"意义\"><a href=\"#意义\" class=\"headerlink\" title=\"意义\"></a>意义</h4><p>子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特， 定义一个父类类型的引用指向一个子类的对象既可以<strong>使用子类强大的功能</strong>，又可以<strong>抽取父类的共性</strong>。 所以，父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，父类引用是无法调用的</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>父类</p>\n<pre><code>public class Father {\n    // 父类中的func1方法\n    // 由于子类中对该方法只是进行了重载而没有进行重写\n    // 因此该方法仍然有效\n    public void func1() {\n        System.out.println(&quot;Father func1&quot;);\n    }\n\n    // 父类中的func2方法\n    // 由于在子类中重写了该方法\n    // 所以在“向上转型”中，该方法不再有效\n    // 取而代之的是子类中的fun2方法\n    public void func2() {\n        System.out.println(&quot;Father func2&quot;);\n    }\n}</code></pre><p>子类</p>\n<pre><code>public class Child extends Father {\n    // 对func1方法的一个重载\n    // 由于在父类中没有定义该方法，所以该方法不能被父类的引用调用\n    // 如果进行调用即会报错\n    public void func1(int i) {\n        System.out.println(&quot;Child func1&quot;);\n    }\n\n    // 对父类方法的重写\n    // 能够起作用\n    public void func2() {\n        System.out.println(&quot;Child func2&quot;);\n    }\n}</code></pre><p>主函数</p>\n<pre><code>public class Main {\n    public static void main(String[] args) {\n    // write your code here\n        Father test = new Child();\n        test.func1();   // Father func1\n        test.func2();   // Child func2\n        test.func1(10); // 报错\n    }\n}</code></pre><p>上述示例中，子类Child继承了父类Father，并重载了父类的func1()方法，重写了父类的func2()方法。重载后的func1(int i)和func1()不再是同一个方法，由于父类中没有func1(int i)，那么，父类类型的引用child就不能调用func1(int i)方法。而子类重写了func2()方法，那么父类类型的引用child在调用该方法时将会调用子类中重写的func2()。 </p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>1、<strong>使用父类类型的引用指向子类的对象；</strong> </p>\n<p>2、<strong>该引用只能调用父类中定义的方法和变量；</strong> </p>\n<p>3、<strong>如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）</strong> </p>\n<p>4、<strong>变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了父类中的变量，那么在编译时会报错。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考：<a href=\"https://www.cnblogs.com/ChrisMurphy/p/5054256.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/ChrisMurphy/p/5054256.html</a></p>\n<p>父类的引用指向子类的对象是Java中多态的重要表现形式</p>\n<h4 id=\"表现形式\"><a href=\"#表现形式\" class=\"headerlink\" title=\"表现形式\"></a>表现形式</h4><p>父类为Animal，子类为Cat，如下即为父类引用指向子类对象的形式，<strong>声明的是父类，实际指向的是子类的一个对象</strong>。（其中Animal可以是类也可以是接口，Cat是继承或实现Animal的子类）</p>\n<pre><code>Animal animal = new Cat()</code></pre><p>这种情况也即为<strong>向上转型</strong>，父类引用指向子类实例。<strong>可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法</strong>。</p>\n<h4 id=\"意义\"><a href=\"#意义\" class=\"headerlink\" title=\"意义\"></a>意义</h4><p>子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特， 定义一个父类类型的引用指向一个子类的对象既可以<strong>使用子类强大的功能</strong>，又可以<strong>抽取父类的共性</strong>。 所以，父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，父类引用是无法调用的</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>父类</p>\n<pre><code>public class Father {\n    // 父类中的func1方法\n    // 由于子类中对该方法只是进行了重载而没有进行重写\n    // 因此该方法仍然有效\n    public void func1() {\n        System.out.println(&quot;Father func1&quot;);\n    }\n\n    // 父类中的func2方法\n    // 由于在子类中重写了该方法\n    // 所以在“向上转型”中，该方法不再有效\n    // 取而代之的是子类中的fun2方法\n    public void func2() {\n        System.out.println(&quot;Father func2&quot;);\n    }\n}</code></pre><p>子类</p>\n<pre><code>public class Child extends Father {\n    // 对func1方法的一个重载\n    // 由于在父类中没有定义该方法，所以该方法不能被父类的引用调用\n    // 如果进行调用即会报错\n    public void func1(int i) {\n        System.out.println(&quot;Child func1&quot;);\n    }\n\n    // 对父类方法的重写\n    // 能够起作用\n    public void func2() {\n        System.out.println(&quot;Child func2&quot;);\n    }\n}</code></pre><p>主函数</p>\n<pre><code>public class Main {\n    public static void main(String[] args) {\n    // write your code here\n        Father test = new Child();\n        test.func1();   // Father func1\n        test.func2();   // Child func2\n        test.func1(10); // 报错\n    }\n}</code></pre><p>上述示例中，子类Child继承了父类Father，并重载了父类的func1()方法，重写了父类的func2()方法。重载后的func1(int i)和func1()不再是同一个方法，由于父类中没有func1(int i)，那么，父类类型的引用child就不能调用func1(int i)方法。而子类重写了func2()方法，那么父类类型的引用child在调用该方法时将会调用子类中重写的func2()。 </p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>1、<strong>使用父类类型的引用指向子类的对象；</strong> </p>\n<p>2、<strong>该引用只能调用父类中定义的方法和变量；</strong> </p>\n<p>3、<strong>如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）</strong> </p>\n<p>4、<strong>变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了父类中的变量，那么在编译时会报错。</strong></p>\n"},{"title":"2、DOM节点操作","date":"2020-06-21T06:38:46.000Z","fileName":"javascript2","_content":"\n1\n\n\n\ncreat\n\n\n\ndocument.createElement(标签名)\n\ndocument.createTextNode(新的文本节点)\n\ndocument.createDocumentFragment() 创建文档片段\n\ndocument.createComment() 创建注释节点","source":"_posts/前端/JS/2、DOM节点操作.md","raw":"---\ntitle: 2、DOM节点操作\ndate: 2020-06-21 14:38:46\ntags:\n\t- 前端\ncategories:\n\t- 前端\n\t- JS\nfileName: javascript2\n---\n\n1\n\n\n\ncreat\n\n\n\ndocument.createElement(标签名)\n\ndocument.createTextNode(新的文本节点)\n\ndocument.createDocumentFragment() 创建文档片段\n\ndocument.createComment() 创建注释节点","slug":"前端/JS/2、DOM节点操作","published":1,"updated":"2020-07-16T15:55:42.631Z","_id":"ckcox7saf002z68jsb43p9365","comments":1,"layout":"post","photos":[],"link":"","content":"<p>1</p>\n<p>creat</p>\n<p>document.createElement(标签名)</p>\n<p>document.createTextNode(新的文本节点)</p>\n<p>document.createDocumentFragment() 创建文档片段</p>\n<p>document.createComment() 创建注释节点</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1</p>\n<p>creat</p>\n<p>document.createElement(标签名)</p>\n<p>document.createTextNode(新的文本节点)</p>\n<p>document.createDocumentFragment() 创建文档片段</p>\n<p>document.createComment() 创建注释节点</p>\n"},{"title":"改变","date":"2019-05-04T11:46:58.000Z","fileName":"the_change","_content":"时光本身没有魔力，它的奇妙来自于人们很容易愣神。\n\n当你发呆的时候，当你全身心地在做一件事的时候，当你摊在沙发上消磨时光的时候，它总会轻而易举地从你的指尖溜走。“溜”，这是个形容时光已经用烂了的动词，但大可不必对这种形容做一些所谓老生常谈的说教，因为这在汉语中确实用的很妙。\n\n小学生用文字形容时光是一把好手，因为似乎我们的教育自小到大一个很大的主题就是劝人切莫虚度时光。所谓“少壮不努力，老大徒伤悲”也可以视为是对时光的隐喻，这种隐喻隐藏在许许多多与时光本身看似并不相关的事物上，但作为两种状态之间的对比却往往体现出时光的作用来。从这个角度来看，也许本身就没有什么隐喻不隐喻的吧，毕竟活在时光长河里的生物，怎么可能规避的了时光二字呢。如此看来“时光”这两个汉字也着实幸运，明明是人造出的东西，表达的却是一种任何人也捉摸不透却又身在其中的感觉。\n\n现在已经五月份了，其实我也很纳闷怎么就五月份了。我不记得上一次愣神是在什么时候，大概是今年二月？或者是去年的什么时间，或许是十年前？总之现在已经快要接近我生命中的第21个年头了。我在愣神当中曾经说过我才18，也曾经说过我才20，但我现在快满21了。这是一种相当奇妙的感觉，你不知道起点在哪，也无法推算终点何在，你一次又一次的愣神，又一次又一次地回过神来开始思考，可每次回忆起自己上一次的思考，又会发现那不过是无数次愣神递归过程之中的某个终止条件。人的一生永远是在愣神中度过，而时光却又如此狡猾，永远会在你愣神的时候从你的指尖溜走。\n\n仿佛避开守卫出逃的囚犯，仿佛透过缝隙射入的阳光。\n\n今年的五一假期，武汉的阳光十分强烈，但温度并不高，是让人很舒服的那种天气，但又给人以预示，夏天显然快要来了。\n\n我很喜欢夏天，现在回想起来也许是因为夏天是成长过程中唯一可以自由自在的季节吧。庐山上的夏天并不热，反而充满着慵懒的感觉。其他地方的夏天虽然普遍地能够被称为酷暑，但酷热之中却又蕴含了随意与激情，透露着狄俄倪索斯的气息，我很喜欢去品尝这种缺乏理性的味道，它会让愣神与发呆变得顺理成章。\n\n这不是我今年第一次感到夏天要来了。我依稀可以记得，度过清明节假期之后的那天，很热。在回汉的路上，高铁里那种通过机器进行流通的空气的味道。呆板，麻木，但每每闻到它我总能想起旅行的过程，想起我四处寻找不同城市中别样的迪厄尼多斯的故事。这种感觉将过去的我和现在的我融为一体，时刻提醒从前的我与现在的我还是同一个人。这种非人的物质不断地通过嗅觉神经冲击你的大脑，一遍又一遍地通过一种缺乏科学与理性的方法强迫你去相信一个没有理性能够论证的哲学命题，强行告诉你你已经惫藾了多久以及你是否将永远以这种状态惫藾下去。\n\n我还能够记得，从学校南二门回寝室的路上，四月的空气显得过于闷热了，给了我一种很不舒服的感觉。仿佛我还在去年的6月，大病初愈在六月的烈阳下回寝室收拾东西回家，我无法形容那是一种什么感觉，大病过后精神似乎由于充裕的休息变得很好，但总给人以一种缺憾的感觉。就像六月的阳光除去酷热以外似乎于我而言少了一层意义，但少的是什么呢？我苦苦思索也得不到答案。也许今年的夏天我能够找到它，也许永远也找不到了，也许它将被我遗忘，这也是大概率的事情了，也许这种缺憾感只是因为我对阳光多了一层理解而产生的错觉，也许缺憾的感觉与获得的感觉纠缠一起令我无法区分。但不论产生这种感觉的机理是什么，我只知道那时的我与现在的我多少有些不同了，也许是去年躺在病床上痛苦地享受闲暇时光以及六月的天气造成的，也许是命中注定在这个年龄会产生的改变，也许只是一个发展趋势附着于生病这件事情上带给我的错觉。我能写下很多种也许，但也许它们没有一个是答案。\n\n从前有一段时间我热衷于探讨“Riddles of Existence”这个永远也不会有答案的形而上学问题，里面有一种支持宿命论的观点。如果加上空间三维与时间一维的话，在我们的生活中每一个结点的坐标都是固定的，一切事情都是一定会发生的。具体的证明方法我已经记不清了，但的的确确，我们的每一秒，每一个抉择，每一个时间节点上发生的事，都在我们愣神之后被一笔带过，被时光这个东西窃取而空。而下一个时间节点当我们思虑从前那些改变的时候，这种思虑又成为了下下个节点思考的素材。我们就如俄罗斯套娃一般死死地在时光的长河之中套下过去的自己，再被将来的自己套下，无穷无尽。而在我们执着于套娃本身的方法时，时光流逝，间断性地带给我们套下过去自己的满足感，告诉我们有些东西从未改变，就如木制娃娃用颜料画上的微笑的脸庞。\n\n五月出头，这几天天气很好，阳光明媚却不毒辣，路边的梧桐树重新长出了夏天最亮眼的绿，我于道中抬头，看见阳光透过树叶缝隙泛起的柔和的光。\n\n我感觉并不舒服，就像感受到了从前的自己。傍晚看到了属于夏天独有的那种灿烂的夕阳，我于美感之中蹉跎，我想起了海，想起了很多年前在海边的自己，想起了自己惫藾的时光，亦美亦不美，两个时空的我产生了龃龉，这是很难用理性判断的事情。\n\n改变是必然的，“往者不可谏，来者犹可追”这句话永远是苍白无力的，但也没有多少人会纠结于改变本身而放弃对这句话的追求。\n\n毕竟，人们在愣神之时总会开始学会欣赏从前的自己，总会以最柔和的方法面对改变所带来的龃龉。\n\n就像俄罗斯套娃，大的娃娃总会接纳小的，尽管它们是那么不同。\n\n> 记于19.5.5  武汉","source":"_posts/瞎侃/散文/改变.md","raw":"---\ntitle: 改变\ndate: 2019-05-04 19:46:58\ntags:\n    - 散文\ncategories:\n    - 瞎侃\n    - 散文\nfileName: the_change\n---\n时光本身没有魔力，它的奇妙来自于人们很容易愣神。\n\n当你发呆的时候，当你全身心地在做一件事的时候，当你摊在沙发上消磨时光的时候，它总会轻而易举地从你的指尖溜走。“溜”，这是个形容时光已经用烂了的动词，但大可不必对这种形容做一些所谓老生常谈的说教，因为这在汉语中确实用的很妙。\n\n小学生用文字形容时光是一把好手，因为似乎我们的教育自小到大一个很大的主题就是劝人切莫虚度时光。所谓“少壮不努力，老大徒伤悲”也可以视为是对时光的隐喻，这种隐喻隐藏在许许多多与时光本身看似并不相关的事物上，但作为两种状态之间的对比却往往体现出时光的作用来。从这个角度来看，也许本身就没有什么隐喻不隐喻的吧，毕竟活在时光长河里的生物，怎么可能规避的了时光二字呢。如此看来“时光”这两个汉字也着实幸运，明明是人造出的东西，表达的却是一种任何人也捉摸不透却又身在其中的感觉。\n\n现在已经五月份了，其实我也很纳闷怎么就五月份了。我不记得上一次愣神是在什么时候，大概是今年二月？或者是去年的什么时间，或许是十年前？总之现在已经快要接近我生命中的第21个年头了。我在愣神当中曾经说过我才18，也曾经说过我才20，但我现在快满21了。这是一种相当奇妙的感觉，你不知道起点在哪，也无法推算终点何在，你一次又一次的愣神，又一次又一次地回过神来开始思考，可每次回忆起自己上一次的思考，又会发现那不过是无数次愣神递归过程之中的某个终止条件。人的一生永远是在愣神中度过，而时光却又如此狡猾，永远会在你愣神的时候从你的指尖溜走。\n\n仿佛避开守卫出逃的囚犯，仿佛透过缝隙射入的阳光。\n\n今年的五一假期，武汉的阳光十分强烈，但温度并不高，是让人很舒服的那种天气，但又给人以预示，夏天显然快要来了。\n\n我很喜欢夏天，现在回想起来也许是因为夏天是成长过程中唯一可以自由自在的季节吧。庐山上的夏天并不热，反而充满着慵懒的感觉。其他地方的夏天虽然普遍地能够被称为酷暑，但酷热之中却又蕴含了随意与激情，透露着狄俄倪索斯的气息，我很喜欢去品尝这种缺乏理性的味道，它会让愣神与发呆变得顺理成章。\n\n这不是我今年第一次感到夏天要来了。我依稀可以记得，度过清明节假期之后的那天，很热。在回汉的路上，高铁里那种通过机器进行流通的空气的味道。呆板，麻木，但每每闻到它我总能想起旅行的过程，想起我四处寻找不同城市中别样的迪厄尼多斯的故事。这种感觉将过去的我和现在的我融为一体，时刻提醒从前的我与现在的我还是同一个人。这种非人的物质不断地通过嗅觉神经冲击你的大脑，一遍又一遍地通过一种缺乏科学与理性的方法强迫你去相信一个没有理性能够论证的哲学命题，强行告诉你你已经惫藾了多久以及你是否将永远以这种状态惫藾下去。\n\n我还能够记得，从学校南二门回寝室的路上，四月的空气显得过于闷热了，给了我一种很不舒服的感觉。仿佛我还在去年的6月，大病初愈在六月的烈阳下回寝室收拾东西回家，我无法形容那是一种什么感觉，大病过后精神似乎由于充裕的休息变得很好，但总给人以一种缺憾的感觉。就像六月的阳光除去酷热以外似乎于我而言少了一层意义，但少的是什么呢？我苦苦思索也得不到答案。也许今年的夏天我能够找到它，也许永远也找不到了，也许它将被我遗忘，这也是大概率的事情了，也许这种缺憾感只是因为我对阳光多了一层理解而产生的错觉，也许缺憾的感觉与获得的感觉纠缠一起令我无法区分。但不论产生这种感觉的机理是什么，我只知道那时的我与现在的我多少有些不同了，也许是去年躺在病床上痛苦地享受闲暇时光以及六月的天气造成的，也许是命中注定在这个年龄会产生的改变，也许只是一个发展趋势附着于生病这件事情上带给我的错觉。我能写下很多种也许，但也许它们没有一个是答案。\n\n从前有一段时间我热衷于探讨“Riddles of Existence”这个永远也不会有答案的形而上学问题，里面有一种支持宿命论的观点。如果加上空间三维与时间一维的话，在我们的生活中每一个结点的坐标都是固定的，一切事情都是一定会发生的。具体的证明方法我已经记不清了，但的的确确，我们的每一秒，每一个抉择，每一个时间节点上发生的事，都在我们愣神之后被一笔带过，被时光这个东西窃取而空。而下一个时间节点当我们思虑从前那些改变的时候，这种思虑又成为了下下个节点思考的素材。我们就如俄罗斯套娃一般死死地在时光的长河之中套下过去的自己，再被将来的自己套下，无穷无尽。而在我们执着于套娃本身的方法时，时光流逝，间断性地带给我们套下过去自己的满足感，告诉我们有些东西从未改变，就如木制娃娃用颜料画上的微笑的脸庞。\n\n五月出头，这几天天气很好，阳光明媚却不毒辣，路边的梧桐树重新长出了夏天最亮眼的绿，我于道中抬头，看见阳光透过树叶缝隙泛起的柔和的光。\n\n我感觉并不舒服，就像感受到了从前的自己。傍晚看到了属于夏天独有的那种灿烂的夕阳，我于美感之中蹉跎，我想起了海，想起了很多年前在海边的自己，想起了自己惫藾的时光，亦美亦不美，两个时空的我产生了龃龉，这是很难用理性判断的事情。\n\n改变是必然的，“往者不可谏，来者犹可追”这句话永远是苍白无力的，但也没有多少人会纠结于改变本身而放弃对这句话的追求。\n\n毕竟，人们在愣神之时总会开始学会欣赏从前的自己，总会以最柔和的方法面对改变所带来的龃龉。\n\n就像俄罗斯套娃，大的娃娃总会接纳小的，尽管它们是那么不同。\n\n> 记于19.5.5  武汉","slug":"瞎侃/散文/改变","published":1,"updated":"2020-07-16T15:54:31.771Z","_id":"ckcoz0gft003e68jsfw2u7nil","comments":1,"layout":"post","photos":[],"link":"","content":"<p>时光本身没有魔力，它的奇妙来自于人们很容易愣神。</p>\n<p>当你发呆的时候，当你全身心地在做一件事的时候，当你摊在沙发上消磨时光的时候，它总会轻而易举地从你的指尖溜走。“溜”，这是个形容时光已经用烂了的动词，但大可不必对这种形容做一些所谓老生常谈的说教，因为这在汉语中确实用的很妙。</p>\n<p>小学生用文字形容时光是一把好手，因为似乎我们的教育自小到大一个很大的主题就是劝人切莫虚度时光。所谓“少壮不努力，老大徒伤悲”也可以视为是对时光的隐喻，这种隐喻隐藏在许许多多与时光本身看似并不相关的事物上，但作为两种状态之间的对比却往往体现出时光的作用来。从这个角度来看，也许本身就没有什么隐喻不隐喻的吧，毕竟活在时光长河里的生物，怎么可能规避的了时光二字呢。如此看来“时光”这两个汉字也着实幸运，明明是人造出的东西，表达的却是一种任何人也捉摸不透却又身在其中的感觉。</p>\n<p>现在已经五月份了，其实我也很纳闷怎么就五月份了。我不记得上一次愣神是在什么时候，大概是今年二月？或者是去年的什么时间，或许是十年前？总之现在已经快要接近我生命中的第21个年头了。我在愣神当中曾经说过我才18，也曾经说过我才20，但我现在快满21了。这是一种相当奇妙的感觉，你不知道起点在哪，也无法推算终点何在，你一次又一次的愣神，又一次又一次地回过神来开始思考，可每次回忆起自己上一次的思考，又会发现那不过是无数次愣神递归过程之中的某个终止条件。人的一生永远是在愣神中度过，而时光却又如此狡猾，永远会在你愣神的时候从你的指尖溜走。</p>\n<p>仿佛避开守卫出逃的囚犯，仿佛透过缝隙射入的阳光。</p>\n<p>今年的五一假期，武汉的阳光十分强烈，但温度并不高，是让人很舒服的那种天气，但又给人以预示，夏天显然快要来了。</p>\n<p>我很喜欢夏天，现在回想起来也许是因为夏天是成长过程中唯一可以自由自在的季节吧。庐山上的夏天并不热，反而充满着慵懒的感觉。其他地方的夏天虽然普遍地能够被称为酷暑，但酷热之中却又蕴含了随意与激情，透露着狄俄倪索斯的气息，我很喜欢去品尝这种缺乏理性的味道，它会让愣神与发呆变得顺理成章。</p>\n<p>这不是我今年第一次感到夏天要来了。我依稀可以记得，度过清明节假期之后的那天，很热。在回汉的路上，高铁里那种通过机器进行流通的空气的味道。呆板，麻木，但每每闻到它我总能想起旅行的过程，想起我四处寻找不同城市中别样的迪厄尼多斯的故事。这种感觉将过去的我和现在的我融为一体，时刻提醒从前的我与现在的我还是同一个人。这种非人的物质不断地通过嗅觉神经冲击你的大脑，一遍又一遍地通过一种缺乏科学与理性的方法强迫你去相信一个没有理性能够论证的哲学命题，强行告诉你你已经惫藾了多久以及你是否将永远以这种状态惫藾下去。</p>\n<p>我还能够记得，从学校南二门回寝室的路上，四月的空气显得过于闷热了，给了我一种很不舒服的感觉。仿佛我还在去年的6月，大病初愈在六月的烈阳下回寝室收拾东西回家，我无法形容那是一种什么感觉，大病过后精神似乎由于充裕的休息变得很好，但总给人以一种缺憾的感觉。就像六月的阳光除去酷热以外似乎于我而言少了一层意义，但少的是什么呢？我苦苦思索也得不到答案。也许今年的夏天我能够找到它，也许永远也找不到了，也许它将被我遗忘，这也是大概率的事情了，也许这种缺憾感只是因为我对阳光多了一层理解而产生的错觉，也许缺憾的感觉与获得的感觉纠缠一起令我无法区分。但不论产生这种感觉的机理是什么，我只知道那时的我与现在的我多少有些不同了，也许是去年躺在病床上痛苦地享受闲暇时光以及六月的天气造成的，也许是命中注定在这个年龄会产生的改变，也许只是一个发展趋势附着于生病这件事情上带给我的错觉。我能写下很多种也许，但也许它们没有一个是答案。</p>\n<p>从前有一段时间我热衷于探讨“Riddles of Existence”这个永远也不会有答案的形而上学问题，里面有一种支持宿命论的观点。如果加上空间三维与时间一维的话，在我们的生活中每一个结点的坐标都是固定的，一切事情都是一定会发生的。具体的证明方法我已经记不清了，但的的确确，我们的每一秒，每一个抉择，每一个时间节点上发生的事，都在我们愣神之后被一笔带过，被时光这个东西窃取而空。而下一个时间节点当我们思虑从前那些改变的时候，这种思虑又成为了下下个节点思考的素材。我们就如俄罗斯套娃一般死死地在时光的长河之中套下过去的自己，再被将来的自己套下，无穷无尽。而在我们执着于套娃本身的方法时，时光流逝，间断性地带给我们套下过去自己的满足感，告诉我们有些东西从未改变，就如木制娃娃用颜料画上的微笑的脸庞。</p>\n<p>五月出头，这几天天气很好，阳光明媚却不毒辣，路边的梧桐树重新长出了夏天最亮眼的绿，我于道中抬头，看见阳光透过树叶缝隙泛起的柔和的光。</p>\n<p>我感觉并不舒服，就像感受到了从前的自己。傍晚看到了属于夏天独有的那种灿烂的夕阳，我于美感之中蹉跎，我想起了海，想起了很多年前在海边的自己，想起了自己惫藾的时光，亦美亦不美，两个时空的我产生了龃龉，这是很难用理性判断的事情。</p>\n<p>改变是必然的，“往者不可谏，来者犹可追”这句话永远是苍白无力的，但也没有多少人会纠结于改变本身而放弃对这句话的追求。</p>\n<p>毕竟，人们在愣神之时总会开始学会欣赏从前的自己，总会以最柔和的方法面对改变所带来的龃龉。</p>\n<p>就像俄罗斯套娃，大的娃娃总会接纳小的，尽管它们是那么不同。</p>\n<blockquote>\n<p>记于19.5.5  武汉</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>时光本身没有魔力，它的奇妙来自于人们很容易愣神。</p>\n<p>当你发呆的时候，当你全身心地在做一件事的时候，当你摊在沙发上消磨时光的时候，它总会轻而易举地从你的指尖溜走。“溜”，这是个形容时光已经用烂了的动词，但大可不必对这种形容做一些所谓老生常谈的说教，因为这在汉语中确实用的很妙。</p>\n<p>小学生用文字形容时光是一把好手，因为似乎我们的教育自小到大一个很大的主题就是劝人切莫虚度时光。所谓“少壮不努力，老大徒伤悲”也可以视为是对时光的隐喻，这种隐喻隐藏在许许多多与时光本身看似并不相关的事物上，但作为两种状态之间的对比却往往体现出时光的作用来。从这个角度来看，也许本身就没有什么隐喻不隐喻的吧，毕竟活在时光长河里的生物，怎么可能规避的了时光二字呢。如此看来“时光”这两个汉字也着实幸运，明明是人造出的东西，表达的却是一种任何人也捉摸不透却又身在其中的感觉。</p>\n<p>现在已经五月份了，其实我也很纳闷怎么就五月份了。我不记得上一次愣神是在什么时候，大概是今年二月？或者是去年的什么时间，或许是十年前？总之现在已经快要接近我生命中的第21个年头了。我在愣神当中曾经说过我才18，也曾经说过我才20，但我现在快满21了。这是一种相当奇妙的感觉，你不知道起点在哪，也无法推算终点何在，你一次又一次的愣神，又一次又一次地回过神来开始思考，可每次回忆起自己上一次的思考，又会发现那不过是无数次愣神递归过程之中的某个终止条件。人的一生永远是在愣神中度过，而时光却又如此狡猾，永远会在你愣神的时候从你的指尖溜走。</p>\n<p>仿佛避开守卫出逃的囚犯，仿佛透过缝隙射入的阳光。</p>\n<p>今年的五一假期，武汉的阳光十分强烈，但温度并不高，是让人很舒服的那种天气，但又给人以预示，夏天显然快要来了。</p>\n<p>我很喜欢夏天，现在回想起来也许是因为夏天是成长过程中唯一可以自由自在的季节吧。庐山上的夏天并不热，反而充满着慵懒的感觉。其他地方的夏天虽然普遍地能够被称为酷暑，但酷热之中却又蕴含了随意与激情，透露着狄俄倪索斯的气息，我很喜欢去品尝这种缺乏理性的味道，它会让愣神与发呆变得顺理成章。</p>\n<p>这不是我今年第一次感到夏天要来了。我依稀可以记得，度过清明节假期之后的那天，很热。在回汉的路上，高铁里那种通过机器进行流通的空气的味道。呆板，麻木，但每每闻到它我总能想起旅行的过程，想起我四处寻找不同城市中别样的迪厄尼多斯的故事。这种感觉将过去的我和现在的我融为一体，时刻提醒从前的我与现在的我还是同一个人。这种非人的物质不断地通过嗅觉神经冲击你的大脑，一遍又一遍地通过一种缺乏科学与理性的方法强迫你去相信一个没有理性能够论证的哲学命题，强行告诉你你已经惫藾了多久以及你是否将永远以这种状态惫藾下去。</p>\n<p>我还能够记得，从学校南二门回寝室的路上，四月的空气显得过于闷热了，给了我一种很不舒服的感觉。仿佛我还在去年的6月，大病初愈在六月的烈阳下回寝室收拾东西回家，我无法形容那是一种什么感觉，大病过后精神似乎由于充裕的休息变得很好，但总给人以一种缺憾的感觉。就像六月的阳光除去酷热以外似乎于我而言少了一层意义，但少的是什么呢？我苦苦思索也得不到答案。也许今年的夏天我能够找到它，也许永远也找不到了，也许它将被我遗忘，这也是大概率的事情了，也许这种缺憾感只是因为我对阳光多了一层理解而产生的错觉，也许缺憾的感觉与获得的感觉纠缠一起令我无法区分。但不论产生这种感觉的机理是什么，我只知道那时的我与现在的我多少有些不同了，也许是去年躺在病床上痛苦地享受闲暇时光以及六月的天气造成的，也许是命中注定在这个年龄会产生的改变，也许只是一个发展趋势附着于生病这件事情上带给我的错觉。我能写下很多种也许，但也许它们没有一个是答案。</p>\n<p>从前有一段时间我热衷于探讨“Riddles of Existence”这个永远也不会有答案的形而上学问题，里面有一种支持宿命论的观点。如果加上空间三维与时间一维的话，在我们的生活中每一个结点的坐标都是固定的，一切事情都是一定会发生的。具体的证明方法我已经记不清了，但的的确确，我们的每一秒，每一个抉择，每一个时间节点上发生的事，都在我们愣神之后被一笔带过，被时光这个东西窃取而空。而下一个时间节点当我们思虑从前那些改变的时候，这种思虑又成为了下下个节点思考的素材。我们就如俄罗斯套娃一般死死地在时光的长河之中套下过去的自己，再被将来的自己套下，无穷无尽。而在我们执着于套娃本身的方法时，时光流逝，间断性地带给我们套下过去自己的满足感，告诉我们有些东西从未改变，就如木制娃娃用颜料画上的微笑的脸庞。</p>\n<p>五月出头，这几天天气很好，阳光明媚却不毒辣，路边的梧桐树重新长出了夏天最亮眼的绿，我于道中抬头，看见阳光透过树叶缝隙泛起的柔和的光。</p>\n<p>我感觉并不舒服，就像感受到了从前的自己。傍晚看到了属于夏天独有的那种灿烂的夕阳，我于美感之中蹉跎，我想起了海，想起了很多年前在海边的自己，想起了自己惫藾的时光，亦美亦不美，两个时空的我产生了龃龉，这是很难用理性判断的事情。</p>\n<p>改变是必然的，“往者不可谏，来者犹可追”这句话永远是苍白无力的，但也没有多少人会纠结于改变本身而放弃对这句话的追求。</p>\n<p>毕竟，人们在愣神之时总会开始学会欣赏从前的自己，总会以最柔和的方法面对改变所带来的龃龉。</p>\n<p>就像俄罗斯套娃，大的娃娃总会接纳小的，尽管它们是那么不同。</p>\n<blockquote>\n<p>记于19.5.5  武汉</p>\n</blockquote>\n"},{"title":"对一个文件夹下的图像进行整体操作","date":"2019-02-22T09:05:20.000Z","fileName":"batch_RS","_content":"前些日子（其实好几个月前了吧），复现一个遥感图像“填缝”的算法，想想matlab好久没用，便打算记录一点点，当作消遣。下面这个算是一个基底数据获取的小过程吧，可以当成matlab图像批处理的一个模板代码段。<!--more-->\n```\nclear;\nclc;\nsrcDir=uigetdir();\ncd(srcDir);\nallnames=struct2cell(dir('*.tif')); %只处理8位的.tif文件\n[k,len]=size(allnames); %获得tif文件的个数\n\nJ = imread(allnames{1,1});\n[m,n] = size(J);\nT = zeros(m,n);\n\nfor ii=1:len\n%逐次取出文件\n    name=allnames{1,ii};\n    I=imread(name);\n    I(isnan(I))=0; %图像nan处设置为0\n    for jj=1:m\n        for kk = 1:n\n            T(jj,kk) =  T(jj,kk)+I(jj,kk);\n        end\n    end\nend\nT=T/len;\nimshow(T);\nimwrite(T,'test_8.tif');\n```\n下面记几个用到的函数，方便以后忘了用来查查。\nuigetdir：ui get dir\n```\n%打开一个模态对话框，返回path为用户所选择的路径，若用户点击关闭path=0\nfpath = uigetdir\n%打开路径path下的对话框\nfpath = uigetdir(path)\nuigetdir('C:\\') %打开C盘\nuigetdir(matlabroot) %打开matlab默认文件夹\n```\n其余几个：\n```\ncd(path) %这个就不必多说了吧，设置当前文件夹\nc = struct2cell(s) %结构体s转化为元胞数组c\ndir(name) %列出与name匹配的所有文件\nisnan(i) %判断矩阵中为nan的地方并返回1，其余返回0\n```\n其实都蛮好记的了，说起来写完这个我在怀疑我会不会把这些东西忘掉哈哈哈","source":"_posts/GIS/对一个文件夹下的图像进行整体操作.md","raw":"---\ntitle: 对一个文件夹下的图像进行整体操作\ndate: 2019-02-22 17:05:20\ntags:\n    - matlab\n    - 图像\ncategories:\n    - GIS\nfileName: batch_RS\n---\n前些日子（其实好几个月前了吧），复现一个遥感图像“填缝”的算法，想想matlab好久没用，便打算记录一点点，当作消遣。下面这个算是一个基底数据获取的小过程吧，可以当成matlab图像批处理的一个模板代码段。<!--more-->\n```\nclear;\nclc;\nsrcDir=uigetdir();\ncd(srcDir);\nallnames=struct2cell(dir('*.tif')); %只处理8位的.tif文件\n[k,len]=size(allnames); %获得tif文件的个数\n\nJ = imread(allnames{1,1});\n[m,n] = size(J);\nT = zeros(m,n);\n\nfor ii=1:len\n%逐次取出文件\n    name=allnames{1,ii};\n    I=imread(name);\n    I(isnan(I))=0; %图像nan处设置为0\n    for jj=1:m\n        for kk = 1:n\n            T(jj,kk) =  T(jj,kk)+I(jj,kk);\n        end\n    end\nend\nT=T/len;\nimshow(T);\nimwrite(T,'test_8.tif');\n```\n下面记几个用到的函数，方便以后忘了用来查查。\nuigetdir：ui get dir\n```\n%打开一个模态对话框，返回path为用户所选择的路径，若用户点击关闭path=0\nfpath = uigetdir\n%打开路径path下的对话框\nfpath = uigetdir(path)\nuigetdir('C:\\') %打开C盘\nuigetdir(matlabroot) %打开matlab默认文件夹\n```\n其余几个：\n```\ncd(path) %这个就不必多说了吧，设置当前文件夹\nc = struct2cell(s) %结构体s转化为元胞数组c\ndir(name) %列出与name匹配的所有文件\nisnan(i) %判断矩阵中为nan的地方并返回1，其余返回0\n```\n其实都蛮好记的了，说起来写完这个我在怀疑我会不会把这些东西忘掉哈哈哈","slug":"GIS/对一个文件夹下的图像进行整体操作","published":1,"updated":"2020-07-16T16:07:38.333Z","_id":"ckcoz2fv0003v68js3o7w1b5d","comments":1,"layout":"post","photos":[],"link":"","content":"<p>前些日子（其实好几个月前了吧），复现一个遥感图像“填缝”的算法，想想matlab好久没用，便打算记录一点点，当作消遣。下面这个算是一个基底数据获取的小过程吧，可以当成matlab图像批处理的一个模板代码段。<a id=\"more\"></a></p>\n<pre><code>clear;\nclc;\nsrcDir=uigetdir();\ncd(srcDir);\nallnames=struct2cell(dir(&#39;*.tif&#39;)); %只处理8位的.tif文件\n[k,len]=size(allnames); %获得tif文件的个数\n\nJ = imread(allnames{1,1});\n[m,n] = size(J);\nT = zeros(m,n);\n\nfor ii=1:len\n%逐次取出文件\n    name=allnames{1,ii};\n    I=imread(name);\n    I(isnan(I))=0; %图像nan处设置为0\n    for jj=1:m\n        for kk = 1:n\n            T(jj,kk) =  T(jj,kk)+I(jj,kk);\n        end\n    end\nend\nT=T/len;\nimshow(T);\nimwrite(T,&#39;test_8.tif&#39;);</code></pre><p>下面记几个用到的函数，方便以后忘了用来查查。<br>uigetdir：ui get dir</p>\n<pre><code>%打开一个模态对话框，返回path为用户所选择的路径，若用户点击关闭path=0\nfpath = uigetdir\n%打开路径path下的对话框\nfpath = uigetdir(path)\nuigetdir(&#39;C:\\&#39;) %打开C盘\nuigetdir(matlabroot) %打开matlab默认文件夹</code></pre><p>其余几个：</p>\n<pre><code>cd(path) %这个就不必多说了吧，设置当前文件夹\nc = struct2cell(s) %结构体s转化为元胞数组c\ndir(name) %列出与name匹配的所有文件\nisnan(i) %判断矩阵中为nan的地方并返回1，其余返回0</code></pre><p>其实都蛮好记的了，说起来写完这个我在怀疑我会不会把这些东西忘掉哈哈哈</p>\n","site":{"data":{}},"excerpt":"<p>前些日子（其实好几个月前了吧），复现一个遥感图像“填缝”的算法，想想matlab好久没用，便打算记录一点点，当作消遣。下面这个算是一个基底数据获取的小过程吧，可以当成matlab图像批处理的一个模板代码段。</p>","more":"<p></p>\n<pre><code>clear;\nclc;\nsrcDir=uigetdir();\ncd(srcDir);\nallnames=struct2cell(dir(&#39;*.tif&#39;)); %只处理8位的.tif文件\n[k,len]=size(allnames); %获得tif文件的个数\n\nJ = imread(allnames{1,1});\n[m,n] = size(J);\nT = zeros(m,n);\n\nfor ii=1:len\n%逐次取出文件\n    name=allnames{1,ii};\n    I=imread(name);\n    I(isnan(I))=0; %图像nan处设置为0\n    for jj=1:m\n        for kk = 1:n\n            T(jj,kk) =  T(jj,kk)+I(jj,kk);\n        end\n    end\nend\nT=T/len;\nimshow(T);\nimwrite(T,&#39;test_8.tif&#39;);</code></pre><p>下面记几个用到的函数，方便以后忘了用来查查。<br>uigetdir：ui get dir</p>\n<pre><code>%打开一个模态对话框，返回path为用户所选择的路径，若用户点击关闭path=0\nfpath = uigetdir\n%打开路径path下的对话框\nfpath = uigetdir(path)\nuigetdir(&#39;C:\\&#39;) %打开C盘\nuigetdir(matlabroot) %打开matlab默认文件夹</code></pre><p>其余几个：</p>\n<pre><code>cd(path) %这个就不必多说了吧，设置当前文件夹\nc = struct2cell(s) %结构体s转化为元胞数组c\ndir(name) %列出与name匹配的所有文件\nisnan(i) %判断矩阵中为nan的地方并返回1，其余返回0</code></pre><p>其实都蛮好记的了，说起来写完这个我在怀疑我会不会把这些东西忘掉哈哈哈</p>"},{"title":"树（二）二叉树","date":"2019-02-25T05:01:36.000Z","toc":true,"_content":"## 二叉树的基本名词\n满二叉树：树中每层都含有最多的结点\n完全二叉树：简单来讲就是每一个结点编号都与满二叉树相同的二叉树，满二叉树是一种特殊的完全二叉树。**(lchild=father*2)**\n## 二叉树的几种遍历\nPreOrder Traversal\nInOrder Traversal\nPostOrder Traversal\nLevelOrder Traversal\n**规律：**显然，中序遍历可以与其余三种遍历方法的任何一种完成对二叉树的重建（唯一），而其余三种遍历方法任何一种两两结合都无法构建唯一的二叉树。\n这很好理解，其余三种遍历方法告知了我们根节点的位置，而根据这一点我们可以由中序遍历确定左右子树，然后根据二叉树的递归定义完成重建。<!--more-->\n\n## 相应OJ链接\n### 1020 Tree Traversals\n**试题概述：**\ninput：给定二叉树结点个数，二叉树的后序遍历与中序遍历\noutput：二叉树的层序遍历\n[OJ试题传送门](https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072)\n```\n#include <iostream>\n#include <queue>\nusing namespace std;\nconst int x = 31;\nint n;\nint in[x], post[x];//inorder and postorder\n\nstruct Nodes\n{\n\tint data;\n\tNodes *lchild, *rchild;\n};\n\n//recreate the BT\nNodes* creat(int postl, int postr, int inl, int inr) \n{\n\tif (postr<postl)\n\t{\n\t\treturn NULL;\n\t}\n\tNodes *root = new Nodes;\n\troot->data = post[postr];\n\tint k;\n\tfor ( k = inl; k < inr; k++)\n\t{\n\t\tif (in[k] == post[postr]) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tint numl = k - inl;\n\troot->lchild = creat(postl, postl + numl - 1, inl, k - 1);\n\troot->rchild = creat(postl + numl, postr - 1, k + 1, inr);\n\treturn root;\n}\n\nint cou = 0; //用于计数\n\n//用构建好的BT，打印level order \nvoid print_level(Nodes *root) {\n\tqueue<Nodes*> q;\n\tq.push(root);\n\twhile (!q.empty())\n\t{\n\t\tNodes *node = new Nodes;\n\t\tnode = q.front();\n\t\tq.pop();\n\t\tcout << node->data;\n\t\tcou++;\n\t\tif (cou<n)\n\t\t{\n\t\t\tcout << \" \";\n\t\t}\n\t\tif (node->lchild!=NULL)\n\t\t{\n\t\t\tq.push(node->lchild);\n\t\t}\n\t\tif (node->rchild!=NULL)\n\t\t{\n\t\t\tq.push(node->rchild);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> post[i];\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> in[i];\n\t}\n\tNodes *root = creat(0, n - 1, 0, n - 1);\n\tprint_level(root);\n\treturn 0;\n}\n```\n\n### 1086 Tree Traversals Again\n**试题概述：**\ninput：用堆栈描述二叉树的结构\noutput：打印二叉树的后序遍历\n说明：这道题跟Test 1我认为是没有什么区别的，由题设可知这一系列堆栈的操作其实是给出了二叉树的PreOrder与InOrder，只需做一些简单字符串的处理将其提取出来即可，剩下的与Test 1基本没有区别（构造二叉树以及标准的遍历操作）。\n[OJ试题传送门](https://pintia.cn/problem-sets/994805342720868352/problems/994805380754817024)\n```\n#include <iostream>\n#include<stack>\n#include<string>\nusing namespace std;\nconst int N = 31;\nint\tn;\nint pre[N], in[N];\n\nstruct Nodes\n{\n\tint data;\n\tNodes *lchild, *rchild;\n};\n\n//recreate the BT through the preorder traversal and the inorder traversal\nNodes* creat(int preL, int preR, int inL, int inR) {\n\tif (preR<preL)\n\t{\n\t\treturn NULL;\n\t}\n\tNodes *root = new Nodes;\n\troot->data = pre[preL];\n\tint k;\n\tfor ( k = inL; k < inR; k++)\n\t{\n\t\tif (in[k] == pre[preL])\n\t\t\tbreak;\n\t}\n\tint numL = k - inL;\n\troot->lchild = creat(preL + 1, preL + numL, inL, k-1);\n\troot->rchild = creat(preL + numL + 1, preR, k + 1, inR);\n\treturn root;\n}\n\n//print the BT's postorder traversal\nint cou = 0;\nvoid print_post(Nodes* root) {\n\tif (root==NULL)\n\t{\n\t\treturn;\n\t}\n\tprint_post(root->lchild);\n\tprint_post(root->rchild);\n\tcout << root->data;\n\tcou++;\n\tif (cou<n)\n\t{\n\t\tcout << \" \";\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\tstring s;\n\tint x;\n\tint n1 = 0, n2 = 0;\n\tstack<int> ss;\n\tfor (int i = 0; i < 2*n; i++)\n\t{\n\t\tcin >> s;\n\t\tif (s[1]=='u')\n\t\t{\n\t\t\tcin >> x;\n\t\t\tpre[n1++] = x;\n\t\t\tss.push(x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tin[n2++] = ss.top();\n\t\t\tss.pop();\n\t\t}\n\t}\n\tNodes *root = creat(0, n - 1, 0, n - 1);\n\tprint_post(root);\n\treturn 0;\n}\n```","source":"_posts/刷题/binary_tree.md","raw":"---\ntitle: 树（二）二叉树\ndate: 2019-02-25 13:01:36\ntags:\n    - 二叉树\ncategories:\n    - 刷题\ntoc: true\n---\n## 二叉树的基本名词\n满二叉树：树中每层都含有最多的结点\n完全二叉树：简单来讲就是每一个结点编号都与满二叉树相同的二叉树，满二叉树是一种特殊的完全二叉树。**(lchild=father*2)**\n## 二叉树的几种遍历\nPreOrder Traversal\nInOrder Traversal\nPostOrder Traversal\nLevelOrder Traversal\n**规律：**显然，中序遍历可以与其余三种遍历方法的任何一种完成对二叉树的重建（唯一），而其余三种遍历方法任何一种两两结合都无法构建唯一的二叉树。\n这很好理解，其余三种遍历方法告知了我们根节点的位置，而根据这一点我们可以由中序遍历确定左右子树，然后根据二叉树的递归定义完成重建。<!--more-->\n\n## 相应OJ链接\n### 1020 Tree Traversals\n**试题概述：**\ninput：给定二叉树结点个数，二叉树的后序遍历与中序遍历\noutput：二叉树的层序遍历\n[OJ试题传送门](https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072)\n```\n#include <iostream>\n#include <queue>\nusing namespace std;\nconst int x = 31;\nint n;\nint in[x], post[x];//inorder and postorder\n\nstruct Nodes\n{\n\tint data;\n\tNodes *lchild, *rchild;\n};\n\n//recreate the BT\nNodes* creat(int postl, int postr, int inl, int inr) \n{\n\tif (postr<postl)\n\t{\n\t\treturn NULL;\n\t}\n\tNodes *root = new Nodes;\n\troot->data = post[postr];\n\tint k;\n\tfor ( k = inl; k < inr; k++)\n\t{\n\t\tif (in[k] == post[postr]) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tint numl = k - inl;\n\troot->lchild = creat(postl, postl + numl - 1, inl, k - 1);\n\troot->rchild = creat(postl + numl, postr - 1, k + 1, inr);\n\treturn root;\n}\n\nint cou = 0; //用于计数\n\n//用构建好的BT，打印level order \nvoid print_level(Nodes *root) {\n\tqueue<Nodes*> q;\n\tq.push(root);\n\twhile (!q.empty())\n\t{\n\t\tNodes *node = new Nodes;\n\t\tnode = q.front();\n\t\tq.pop();\n\t\tcout << node->data;\n\t\tcou++;\n\t\tif (cou<n)\n\t\t{\n\t\t\tcout << \" \";\n\t\t}\n\t\tif (node->lchild!=NULL)\n\t\t{\n\t\t\tq.push(node->lchild);\n\t\t}\n\t\tif (node->rchild!=NULL)\n\t\t{\n\t\t\tq.push(node->rchild);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> post[i];\n\t}\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tcin >> in[i];\n\t}\n\tNodes *root = creat(0, n - 1, 0, n - 1);\n\tprint_level(root);\n\treturn 0;\n}\n```\n\n### 1086 Tree Traversals Again\n**试题概述：**\ninput：用堆栈描述二叉树的结构\noutput：打印二叉树的后序遍历\n说明：这道题跟Test 1我认为是没有什么区别的，由题设可知这一系列堆栈的操作其实是给出了二叉树的PreOrder与InOrder，只需做一些简单字符串的处理将其提取出来即可，剩下的与Test 1基本没有区别（构造二叉树以及标准的遍历操作）。\n[OJ试题传送门](https://pintia.cn/problem-sets/994805342720868352/problems/994805380754817024)\n```\n#include <iostream>\n#include<stack>\n#include<string>\nusing namespace std;\nconst int N = 31;\nint\tn;\nint pre[N], in[N];\n\nstruct Nodes\n{\n\tint data;\n\tNodes *lchild, *rchild;\n};\n\n//recreate the BT through the preorder traversal and the inorder traversal\nNodes* creat(int preL, int preR, int inL, int inR) {\n\tif (preR<preL)\n\t{\n\t\treturn NULL;\n\t}\n\tNodes *root = new Nodes;\n\troot->data = pre[preL];\n\tint k;\n\tfor ( k = inL; k < inR; k++)\n\t{\n\t\tif (in[k] == pre[preL])\n\t\t\tbreak;\n\t}\n\tint numL = k - inL;\n\troot->lchild = creat(preL + 1, preL + numL, inL, k-1);\n\troot->rchild = creat(preL + numL + 1, preR, k + 1, inR);\n\treturn root;\n}\n\n//print the BT's postorder traversal\nint cou = 0;\nvoid print_post(Nodes* root) {\n\tif (root==NULL)\n\t{\n\t\treturn;\n\t}\n\tprint_post(root->lchild);\n\tprint_post(root->rchild);\n\tcout << root->data;\n\tcou++;\n\tif (cou<n)\n\t{\n\t\tcout << \" \";\n\t}\n}\n\nint main()\n{\n\tcin >> n;\n\tstring s;\n\tint x;\n\tint n1 = 0, n2 = 0;\n\tstack<int> ss;\n\tfor (int i = 0; i < 2*n; i++)\n\t{\n\t\tcin >> s;\n\t\tif (s[1]=='u')\n\t\t{\n\t\t\tcin >> x;\n\t\t\tpre[n1++] = x;\n\t\t\tss.push(x);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tin[n2++] = ss.top();\n\t\t\tss.pop();\n\t\t}\n\t}\n\tNodes *root = creat(0, n - 1, 0, n - 1);\n\tprint_post(root);\n\treturn 0;\n}\n```","slug":"刷题/binary_tree","published":1,"updated":"2020-07-16T15:53:48.080Z","_id":"ckcoz3dve004r68js639rdgm6","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"二叉树的基本名词\"><a href=\"#二叉树的基本名词\" class=\"headerlink\" title=\"二叉树的基本名词\"></a>二叉树的基本名词</h2><p>满二叉树：树中每层都含有最多的结点<br>完全二叉树：简单来讲就是每一个结点编号都与满二叉树相同的二叉树，满二叉树是一种特殊的完全二叉树。<strong>(lchild=father*2)</strong></p>\n<h2 id=\"二叉树的几种遍历\"><a href=\"#二叉树的几种遍历\" class=\"headerlink\" title=\"二叉树的几种遍历\"></a>二叉树的几种遍历</h2><p>PreOrder Traversal<br>InOrder Traversal<br>PostOrder Traversal<br>LevelOrder Traversal<br><strong>规律：</strong>显然，中序遍历可以与其余三种遍历方法的任何一种完成对二叉树的重建（唯一），而其余三种遍历方法任何一种两两结合都无法构建唯一的二叉树。<br>这很好理解，其余三种遍历方法告知了我们根节点的位置，而根据这一点我们可以由中序遍历确定左右子树，然后根据二叉树的递归定义完成重建。<a id=\"more\"></a></p>\n<h2 id=\"相应OJ链接\"><a href=\"#相应OJ链接\" class=\"headerlink\" title=\"相应OJ链接\"></a>相应OJ链接</h2><h3 id=\"1020-Tree-Traversals\"><a href=\"#1020-Tree-Traversals\" class=\"headerlink\" title=\"1020 Tree Traversals\"></a>1020 Tree Traversals</h3><p><strong>试题概述：</strong><br>input：给定二叉树结点个数，二叉树的后序遍历与中序遍历<br>output：二叉树的层序遍历<br><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072\" target=\"_blank\" rel=\"noopener\">OJ试题传送门</a></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\nusing namespace std;\nconst int x = 31;\nint n;\nint in[x], post[x];//inorder and postorder\n\nstruct Nodes\n{\n    int data;\n    Nodes *lchild, *rchild;\n};\n\n//recreate the BT\nNodes* creat(int postl, int postr, int inl, int inr) \n{\n    if (postr&lt;postl)\n    {\n        return NULL;\n    }\n    Nodes *root = new Nodes;\n    root-&gt;data = post[postr];\n    int k;\n    for ( k = inl; k &lt; inr; k++)\n    {\n        if (in[k] == post[postr]) {\n            break;\n        }\n    }\n    int numl = k - inl;\n    root-&gt;lchild = creat(postl, postl + numl - 1, inl, k - 1);\n    root-&gt;rchild = creat(postl + numl, postr - 1, k + 1, inr);\n    return root;\n}\n\nint cou = 0; //用于计数\n\n//用构建好的BT，打印level order \nvoid print_level(Nodes *root) {\n    queue&lt;Nodes*&gt; q;\n    q.push(root);\n    while (!q.empty())\n    {\n        Nodes *node = new Nodes;\n        node = q.front();\n        q.pop();\n        cout &lt;&lt; node-&gt;data;\n        cou++;\n        if (cou&lt;n)\n        {\n            cout &lt;&lt; &quot; &quot;;\n        }\n        if (node-&gt;lchild!=NULL)\n        {\n            q.push(node-&gt;lchild);\n        }\n        if (node-&gt;rchild!=NULL)\n        {\n            q.push(node-&gt;rchild);\n        }\n    }\n}\n\nint main()\n{\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; i++)\n    {\n        cin &gt;&gt; post[i];\n    }\n    for (int i = 0; i &lt; n; i++)\n    {\n        cin &gt;&gt; in[i];\n    }\n    Nodes *root = creat(0, n - 1, 0, n - 1);\n    print_level(root);\n    return 0;\n}</code></pre><h3 id=\"1086-Tree-Traversals-Again\"><a href=\"#1086-Tree-Traversals-Again\" class=\"headerlink\" title=\"1086 Tree Traversals Again\"></a>1086 Tree Traversals Again</h3><p><strong>试题概述：</strong><br>input：用堆栈描述二叉树的结构<br>output：打印二叉树的后序遍历<br>说明：这道题跟Test 1我认为是没有什么区别的，由题设可知这一系列堆栈的操作其实是给出了二叉树的PreOrder与InOrder，只需做一些简单字符串的处理将其提取出来即可，剩下的与Test 1基本没有区别（构造二叉树以及标准的遍历操作）。<br><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805380754817024\" target=\"_blank\" rel=\"noopener\">OJ试题传送门</a></p>\n<pre><code>#include &lt;iostream&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\nusing namespace std;\nconst int N = 31;\nint    n;\nint pre[N], in[N];\n\nstruct Nodes\n{\n    int data;\n    Nodes *lchild, *rchild;\n};\n\n//recreate the BT through the preorder traversal and the inorder traversal\nNodes* creat(int preL, int preR, int inL, int inR) {\n    if (preR&lt;preL)\n    {\n        return NULL;\n    }\n    Nodes *root = new Nodes;\n    root-&gt;data = pre[preL];\n    int k;\n    for ( k = inL; k &lt; inR; k++)\n    {\n        if (in[k] == pre[preL])\n            break;\n    }\n    int numL = k - inL;\n    root-&gt;lchild = creat(preL + 1, preL + numL, inL, k-1);\n    root-&gt;rchild = creat(preL + numL + 1, preR, k + 1, inR);\n    return root;\n}\n\n//print the BT&#39;s postorder traversal\nint cou = 0;\nvoid print_post(Nodes* root) {\n    if (root==NULL)\n    {\n        return;\n    }\n    print_post(root-&gt;lchild);\n    print_post(root-&gt;rchild);\n    cout &lt;&lt; root-&gt;data;\n    cou++;\n    if (cou&lt;n)\n    {\n        cout &lt;&lt; &quot; &quot;;\n    }\n}\n\nint main()\n{\n    cin &gt;&gt; n;\n    string s;\n    int x;\n    int n1 = 0, n2 = 0;\n    stack&lt;int&gt; ss;\n    for (int i = 0; i &lt; 2*n; i++)\n    {\n        cin &gt;&gt; s;\n        if (s[1]==&#39;u&#39;)\n        {\n            cin &gt;&gt; x;\n            pre[n1++] = x;\n            ss.push(x);\n        }\n        else\n        {\n            in[n2++] = ss.top();\n            ss.pop();\n        }\n    }\n    Nodes *root = creat(0, n - 1, 0, n - 1);\n    print_post(root);\n    return 0;\n}</code></pre>","site":{"data":{}},"excerpt":"<h2 id=\"二叉树的基本名词\"><a href=\"#二叉树的基本名词\" class=\"headerlink\" title=\"二叉树的基本名词\"></a>二叉树的基本名词</h2><p>满二叉树：树中每层都含有最多的结点<br>完全二叉树：简单来讲就是每一个结点编号都与满二叉树相同的二叉树，满二叉树是一种特殊的完全二叉树。<strong>(lchild=father*2)</strong></p>\n<h2 id=\"二叉树的几种遍历\"><a href=\"#二叉树的几种遍历\" class=\"headerlink\" title=\"二叉树的几种遍历\"></a>二叉树的几种遍历</h2><p>PreOrder Traversal<br>InOrder Traversal<br>PostOrder Traversal<br>LevelOrder Traversal<br><strong>规律：</strong>显然，中序遍历可以与其余三种遍历方法的任何一种完成对二叉树的重建（唯一），而其余三种遍历方法任何一种两两结合都无法构建唯一的二叉树。<br>这很好理解，其余三种遍历方法告知了我们根节点的位置，而根据这一点我们可以由中序遍历确定左右子树，然后根据二叉树的递归定义完成重建。</p>","more":"<p></p>\n<h2 id=\"相应OJ链接\"><a href=\"#相应OJ链接\" class=\"headerlink\" title=\"相应OJ链接\"></a>相应OJ链接</h2><h3 id=\"1020-Tree-Traversals\"><a href=\"#1020-Tree-Traversals\" class=\"headerlink\" title=\"1020 Tree Traversals\"></a>1020 Tree Traversals</h3><p><strong>试题概述：</strong><br>input：给定二叉树结点个数，二叉树的后序遍历与中序遍历<br>output：二叉树的层序遍历<br><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072\" target=\"_blank\" rel=\"noopener\">OJ试题传送门</a></p>\n<pre><code>#include &lt;iostream&gt;\n#include &lt;queue&gt;\nusing namespace std;\nconst int x = 31;\nint n;\nint in[x], post[x];//inorder and postorder\n\nstruct Nodes\n{\n    int data;\n    Nodes *lchild, *rchild;\n};\n\n//recreate the BT\nNodes* creat(int postl, int postr, int inl, int inr) \n{\n    if (postr&lt;postl)\n    {\n        return NULL;\n    }\n    Nodes *root = new Nodes;\n    root-&gt;data = post[postr];\n    int k;\n    for ( k = inl; k &lt; inr; k++)\n    {\n        if (in[k] == post[postr]) {\n            break;\n        }\n    }\n    int numl = k - inl;\n    root-&gt;lchild = creat(postl, postl + numl - 1, inl, k - 1);\n    root-&gt;rchild = creat(postl + numl, postr - 1, k + 1, inr);\n    return root;\n}\n\nint cou = 0; //用于计数\n\n//用构建好的BT，打印level order \nvoid print_level(Nodes *root) {\n    queue&lt;Nodes*&gt; q;\n    q.push(root);\n    while (!q.empty())\n    {\n        Nodes *node = new Nodes;\n        node = q.front();\n        q.pop();\n        cout &lt;&lt; node-&gt;data;\n        cou++;\n        if (cou&lt;n)\n        {\n            cout &lt;&lt; &quot; &quot;;\n        }\n        if (node-&gt;lchild!=NULL)\n        {\n            q.push(node-&gt;lchild);\n        }\n        if (node-&gt;rchild!=NULL)\n        {\n            q.push(node-&gt;rchild);\n        }\n    }\n}\n\nint main()\n{\n    cin &gt;&gt; n;\n    for (int i = 0; i &lt; n; i++)\n    {\n        cin &gt;&gt; post[i];\n    }\n    for (int i = 0; i &lt; n; i++)\n    {\n        cin &gt;&gt; in[i];\n    }\n    Nodes *root = creat(0, n - 1, 0, n - 1);\n    print_level(root);\n    return 0;\n}</code></pre><h3 id=\"1086-Tree-Traversals-Again\"><a href=\"#1086-Tree-Traversals-Again\" class=\"headerlink\" title=\"1086 Tree Traversals Again\"></a>1086 Tree Traversals Again</h3><p><strong>试题概述：</strong><br>input：用堆栈描述二叉树的结构<br>output：打印二叉树的后序遍历<br>说明：这道题跟Test 1我认为是没有什么区别的，由题设可知这一系列堆栈的操作其实是给出了二叉树的PreOrder与InOrder，只需做一些简单字符串的处理将其提取出来即可，剩下的与Test 1基本没有区别（构造二叉树以及标准的遍历操作）。<br><a href=\"https://pintia.cn/problem-sets/994805342720868352/problems/994805380754817024\" target=\"_blank\" rel=\"noopener\">OJ试题传送门</a></p>\n<pre><code>#include &lt;iostream&gt;\n#include&lt;stack&gt;\n#include&lt;string&gt;\nusing namespace std;\nconst int N = 31;\nint    n;\nint pre[N], in[N];\n\nstruct Nodes\n{\n    int data;\n    Nodes *lchild, *rchild;\n};\n\n//recreate the BT through the preorder traversal and the inorder traversal\nNodes* creat(int preL, int preR, int inL, int inR) {\n    if (preR&lt;preL)\n    {\n        return NULL;\n    }\n    Nodes *root = new Nodes;\n    root-&gt;data = pre[preL];\n    int k;\n    for ( k = inL; k &lt; inR; k++)\n    {\n        if (in[k] == pre[preL])\n            break;\n    }\n    int numL = k - inL;\n    root-&gt;lchild = creat(preL + 1, preL + numL, inL, k-1);\n    root-&gt;rchild = creat(preL + numL + 1, preR, k + 1, inR);\n    return root;\n}\n\n//print the BT&#39;s postorder traversal\nint cou = 0;\nvoid print_post(Nodes* root) {\n    if (root==NULL)\n    {\n        return;\n    }\n    print_post(root-&gt;lchild);\n    print_post(root-&gt;rchild);\n    cout &lt;&lt; root-&gt;data;\n    cou++;\n    if (cou&lt;n)\n    {\n        cout &lt;&lt; &quot; &quot;;\n    }\n}\n\nint main()\n{\n    cin &gt;&gt; n;\n    string s;\n    int x;\n    int n1 = 0, n2 = 0;\n    stack&lt;int&gt; ss;\n    for (int i = 0; i &lt; 2*n; i++)\n    {\n        cin &gt;&gt; s;\n        if (s[1]==&#39;u&#39;)\n        {\n            cin &gt;&gt; x;\n            pre[n1++] = x;\n            ss.push(x);\n        }\n        else\n        {\n            in[n2++] = ss.top();\n            ss.pop();\n        }\n    }\n    Nodes *root = creat(0, n - 1, 0, n - 1);\n    print_post(root);\n    return 0;\n}</code></pre>"},{"title":"The Long Night（权力的游戏 S8E3）","date":"2019-04-30T06:03:33.000Z","fileName":"GOT_S8E3","_content":"## 前言\n长夜将至，当许多交交合合的命运汇集到临冬城的那刻，我知道在压抑的北境风雪之下会诞生许许多多有质感的能量，那是人性所带来的温度。不论命运如何曲折，是凛冬还是盛夏，依靠所谓魔法还是普普通通的脆弱不堪的人的身躯，这都有别于没有质感的所谓邪恶，因为这是生与死的区别。\n从S1E01开始，异鬼就是几乎凌驾于所有故事线之外的一个主线，因为它没有邪恶、暴力的划分，它既不比像小剥皮那样纯粹的人之恶要更邪恶，也谈不上比瑟曦·兰尼斯特的野心更极端。用形容词与名词界定夜王及他所创造的异鬼和尸鬼们是很困难的，就像百万年前极地的风，当死寂无人之时，没有语言，没有人声，谈不上形容。这是夜王所要带来的，所要抹去的，所谓世界记忆过的东西。也许那些歌谣、传记、语言乃至人类统统不曾出现过，比十万光年外的宇宙深处还要寂静空旷。\n无法形容的东西，这是汇集在临冬城的人们所要面对的。在漫天寒风的怒吼之中，一丝人性的传达都足以消弭一方冰雪，在世界崩溃的边缘，在死亡降临的前夜，在《Jenny of Oldstones》的歌声中，他们知道下半夜所要面对的是什么。\n“诚既勇兮又以武，终刚强兮不可凌”，献给所有直面过死亡的角色。\n\n## 悼词\n### 席恩·葛雷乔伊\nBorn as a Greyjoy, die as a Stark. \"You are a good man, thank you, Theon.\"\n这也许是席恩这一生最好的写照了吧，也是这个人物最好的归宿，此刻他为保护布兰而死，作为一名史塔克，作为临冬城的一员，作为一个铁种，作为布兰的兄弟。\n\"You father raises me as an honorable man\",\"My your brother, now and always\",\"My sword is yours, from this day, until the last day\"。隔了这么久，我依然能记得席恩对罗柏·史塔克发过的誓言，直到罗柏死在血色婚礼上，直到席恩被小剥皮折磨到成为臭佬，直到他带着珊莎跳下临冬城开始自我救赎的那一刻。\n作为一个质子，当他想在史塔克家族找到自己一席之地的时候，罗柏总会提醒他“It's not your home, you are not a Stark”。当他作为罗柏的兄弟迫切想证明自己的时候，以“铁屿继承人”的身份回到铁群岛时，却发现自己已经不被父亲与姐姐认可。他一直想假装强大，一直想找到自己的身份，一直想做一个英雄，但最后却成了臭佬，忘记了自己的姓名，苟活于世。\n直到他带着珊莎跳下临冬城开始逃亡之路，直到他被铁民殴打倒地仍然从地上爬起，直到他回到临冬城对珊莎说“I want fight for Winterfall lady Sansa if you'll have me”，直到他弹尽粮绝拿着龙晶长枪独身冲向夜王，直到他倒地看着夜王却再也无力爬起，直到他作为史塔克为临冬城拼尽全力。\n让我身为席恩而死，不是臭佬。我是铁种，来自群屿，是派克岛的传人。\nWhat is dead may never die\n\n### 莱安娜·莫尔蒙\nWe are not a large house, but we're a proud one, and every man from Bear Island, fights with the strength of 10 mainlanders.\n就像莫尔蒙家族的箴言“Here we stand”，一个10岁的小女孩，表现出来的刚强果断足以让所有展现出怯懦的大人脸红。她在整个剧中从来不是个重要的人物，熊岛也只是封地在北境西北方一个贫瘠岛屿的普通家族。但其所展现出来的忠贞不二却是维斯特洛大陆上的一道绝对靓丽的风景，使得为了铁王座尔虞我诈的那些大家族变得如飘零柳絮般苍白。\n战斗前夜乔拉与莱安娜的对话令人心碎\nListen to me, you are the future of our house.\nI don't need you to remind me of that.\nYou'll be safer in the crypt...\nI will not hide underground, I pledged to fight for the North and I will fight.\n以及小熊转身对大熊说的那句\"I wish you good fortune, cousin.\"。这句话现在已经成为绝唱，他们一个为保卫北境而死，一个为守护所爱力竭身亡。\n一个10岁的小女孩，在大战前后指挥若定。城池已破之时仍然毫无畏惧，用着还是孩子的嗓音怒吼着冲向巨人尸鬼，在能够感受的到的骨骼碎裂鲜血涌出之时，仍奋力将龙晶匕首插向巨人，在那一刻，她比巨人还要高大。\n我一直在想事情是不是还有转机，也许她还没死，直到夜王抬手，她睁开蓝色的眼睛作为尸鬼再次站起来。\n多希望她能听从乔拉的建议躲到地穴，也许熬过了这场生死之战若干年后她会是熊岛的一个年轻美丽的Lady Mormont。\n但也许那个人就不是她了，她是来自熊岛的莱安娜。\n\n### 乔拉·莫尔蒙\n年轻的乔拉，在铁群岛平叛时一战成名，受封骑士。\n之后为了所谓的爱情，他违反禁令偷卖奴隶，在逃亡途中却被“爱情”抛弃。\n在峡海对岸为了王国的赦免，他作为间谍接近塔格利安兄妹。\n他以为通过出卖他们他会回到从前。\n但当他开始熟悉丹妮，他明白他错了。\n从此不论经历什么，他知道，他会永远站在丹妮的身边。\n在生命的最后一刻，他依然想站起来为丹妮阻挡一切伤害。\n他想告诉丹妮他只是受伤了，他没事。\n但他却连话都没说出口就走了。\n他虽然浑身是血，但却很安详。\n因为他的身边。\n有丹妮，有卓戈。\n就像他们相遇时的模样。\n纯粹是很难定义的，但这一刻它有个别名。\n叫做乔拉。\n\n### 忧郁的艾迪\n人性是复杂的，从来没有两个人会是相同的，哪怕类似都很难。但有时却有一些精神可以很好地概括一群人，在异鬼侵袭之时，长城上的守夜人是王国的坚盾。\n“长夜将至，我从现在开始守望，至死方休”\n“我是黑暗中的利剑，长城上的守卫，守卫王国的坚盾”\n“我将生命与荣耀献给守夜人”\n守夜人的精神是什么？是一边背诵誓词一边冲向巨人的葛兰们，是放弃王位只为坚守誓言的伊蒙·塔格利安，是为了目标孤独地在北境之北骑行的班杨·史塔克。\n“今夜如此，夜夜皆然”。\n随着艾迪的倒下，也许往后再也不会有人再说出这些誓词了。\n\n### 夜王\n行走了整整7季，却在预料之中的一集中以一种戏剧性的方法“死去”。\n你有多少故事，我曾经幻想能够听到答案，\n直到你在“The Night King”的乐曲中被匕首洞穿。\n全片无言，你的故事也许永远是一个谜。\n有人将你比作现实当中的那些自然灾害。\n讽刺五大洲的人们如维斯特洛大陆上的人们一样。\n在内斗中迷失、消亡。\n也有人认为你只是你。\n带着小说与剧集当中的某种隐喻。\n等待有一天编剧或马丁能够给我们答案。\n维斯特洛大陆上无人会喜欢你，\n但也许将来吟游歌者会将你提起。\n因为在生与死，冰与火的交织中，\n你让我们看到了人性。\n\n## 吐槽\n从S8前两集的命运交合开始，这一集生与死、冰与火的战争战前的气氛烘托可谓做到了极致。从大战开头，多斯拉克骑兵的龙晶弯刀开始熊熊燃烧，战斗的气氛似乎被一下扬起，直到骑兵冲向死亡军团，燃烧的火点开始逐渐熄灭直到消失殆尽，一种冰冷的肃杀与绝望的气息瞬间充满了每个人的内心。再到之后的空战，以及夜王带来的暴雪，无法阻挡尸鬼的燃烧的木栅，每个人物的特写，都使这场长达80分钟的战争刻画无比成功。\n但同时，细细思考战术，确实有蛮多地方值得吐槽。\n### 战术槽点\n1. 为什么要怒送多斯拉克骑兵？\n在临冬城大战之前，琼雪等人对异鬼以及尸鬼明显可以说是知根知底了，制定的战术也是以斩杀夜王为根本目的，因为没杀掉夜王尸鬼是杀不完的。那么临冬城保卫战的主要目的显然就应该是保证临冬城守住较长的时间而不是为了斩杀多少异鬼、尸鬼了。一个以拖延时间为目的的守城战，有什么理由让多斯拉克人在战前对杀不尽的异鬼进行冲锋？这支游牧民族骑兵在日后的内战当中是一个战斗力堪称bug的军队，异鬼没有攻来，你等着就好了，凭什么让自己最嫡系的军队先发起进攻？多斯拉克人即使不参加这场战争的效果也远好于上去送。理想的多斯拉克骑兵使用方法应该是在尸鬼冲锋与无垢者纠缠在一起时从侧面进行冲击，或者等两条龙喷火将尸鬼冲散之时进行收割减轻步兵的压力。导演的目的当然是为了表现如上所述的绝望的气息，但这波操作实在是可以说是一个败笔，为从峡海对岸远道而来的多斯拉克人感到不值。\n2. 守城器械准备的不充分\n如上所述，这是一个以拖延时间为目的的守城战，那么所依仗的应该是各种诸如燃烧油之类的守城器械。作为集合全北境以及龙妈力量的庞大军队，我认为装备这些显然不是问题，有了这些东西，守城战至少可以再多坚持一倍的时间。再其次就是木栅的设置了，明显可以很好地减缓尸鬼冲锋的速度，必要时还可以点燃（别说暴雪看不见信号了，这个在准备当中并不需要考虑），那么为什么只在临冬城外设置一圈的木栅就十分奇怪了。还有就是弓箭的问题，尸鬼是被夜王魔法复活的，只要被龙晶戳到就会倒下，那么也就意味着一支弓箭至少能杀死一只尸鬼，为什么不多备弓箭手也很古怪了，一轮弓箭齐射就可以给底下步兵和无垢者减小巨大的压力。当然这些都没有1中的错误致命，毕竟都可以归结为物资的紧缺与准备时间的不充分。\n3. 为什么不准备用来射龙的强弩？\n前面说过，尸鬼虽然疯狂，但其实远比人脆弱，只要被龙晶戳到就会“死去”，那么使用科本的那种强弩显然足够杀死被夜王转化的“韦赛里斯”。就算射不了龙，用重弩清兵也是极好的。当然硬要说的话可以归结于山姆没有那个技术。\n4. 为什么不派骑兵后排切割异鬼\n一个异鬼死后，由他转化的所有尸鬼都会失去“生命”，因此减缓守城压力的有效办法就是让多斯拉克骑兵去切割异鬼。洞悉了异鬼怕瓦哥利亚钢与龙晶之后，就应该知道除去死亡本身带来的恐惧外，异鬼并没有那么强大。派遣骁勇的多斯拉克骑兵在大战时绕后切割，即使不能成功，也能够吸引尸鬼的注意力，大大减轻守城压力，比直接冲锋效果要好的多。\n\n总结一下，和异鬼讲排兵布阵，脑子大概是瓦特了，论指挥，我觉得“私生子之战”中的小剥皮要优越的多，此战能胜，也是光之王显灵了。\n\n### 人物吐槽\n* 囧雪\n囧雪是主角相信在第六季的时候就能够看出来了，但我觉得相对于其他角色的立体与丰满程度，剧本对囧雪（或说伊耿·塔格利安）的塑造实在有些苍白。并没有体现出这个角色应有的包括外交、军事等等方面的智慧。这也是其得名囧·you know nothing·雪诺的一个重要原因。在本次冰与火、生与死之战中，除去空战当中的一点点表现，别的时间基本都在打酱油，要不是二丫神来一笔，满盘皆输。\n* 布兰·史塔克\n作为现在在场的究极神棍，打了全场的酱油，不知道他操控乌鸦去干了什么，本来三眼乌鸦的神棍属性应该是一个大挂之前也很期待在大战中能有所表现，结果啥事都没有发生。\n* 山姆\n山姆为什么不躲进地窖我觉得没太交代清楚，而且他在这次大战中存活下来完全是因为主角光环，但说好的《权力的游戏》没有主角光环呢？\n\n## 后记\n这次大战静下来细细品味的话槽点很多，也有很多朋友认为这有点烂尾。但不得不承认，电视剧也是视觉艺术的一种，而这场大战无论是在视觉上还是情感上做的都很到位，算是战争戏中的标杆了。至于烂尾，其实我早就做好这个打算了，我认为一部剧的跨度达到接近10年的情况下，不烂尾是不可能的。毕竟，一百个读者心中有一百个哈姆雷特。剧中的角色经过这些年的沉淀，在不同的观众眼中早已千差万别，每个人所希望的结局都不同，每个人所想看到的情节都有差异，每个人对待情节逻辑的解读都会有偏差。在这样的情况下，剧的走向只有一条，而观众希望的走向却有千万条，因此，也许在你眼中这儿烂尾了，在他眼中情节涉及却恰到好处，我想说的是，享受这部剧融入我们这些年时光的那一部分，看看他带给了我们自己多少变化，享受精彩的表演即可。茶余饭后吵吵闹闹完全可以，顿生龃龉则无必要。\n享受最后的那三集，希望能带给我们一些惊喜\n子夜dy记于19年五一之前。","source":"_posts/瞎侃/剧评/The Long Night（权力的游戏 S8E3）.md","raw":"---\ntitle: The Long Night（权力的游戏 S8E3）\ndate: 2019-04-30 14:03:33\ntags:\n    - 剧评\ncategories:\n    - 瞎侃\n    - 剧评\nfileName: GOT_S8E3\n---\n## 前言\n长夜将至，当许多交交合合的命运汇集到临冬城的那刻，我知道在压抑的北境风雪之下会诞生许许多多有质感的能量，那是人性所带来的温度。不论命运如何曲折，是凛冬还是盛夏，依靠所谓魔法还是普普通通的脆弱不堪的人的身躯，这都有别于没有质感的所谓邪恶，因为这是生与死的区别。\n从S1E01开始，异鬼就是几乎凌驾于所有故事线之外的一个主线，因为它没有邪恶、暴力的划分，它既不比像小剥皮那样纯粹的人之恶要更邪恶，也谈不上比瑟曦·兰尼斯特的野心更极端。用形容词与名词界定夜王及他所创造的异鬼和尸鬼们是很困难的，就像百万年前极地的风，当死寂无人之时，没有语言，没有人声，谈不上形容。这是夜王所要带来的，所要抹去的，所谓世界记忆过的东西。也许那些歌谣、传记、语言乃至人类统统不曾出现过，比十万光年外的宇宙深处还要寂静空旷。\n无法形容的东西，这是汇集在临冬城的人们所要面对的。在漫天寒风的怒吼之中，一丝人性的传达都足以消弭一方冰雪，在世界崩溃的边缘，在死亡降临的前夜，在《Jenny of Oldstones》的歌声中，他们知道下半夜所要面对的是什么。\n“诚既勇兮又以武，终刚强兮不可凌”，献给所有直面过死亡的角色。\n\n## 悼词\n### 席恩·葛雷乔伊\nBorn as a Greyjoy, die as a Stark. \"You are a good man, thank you, Theon.\"\n这也许是席恩这一生最好的写照了吧，也是这个人物最好的归宿，此刻他为保护布兰而死，作为一名史塔克，作为临冬城的一员，作为一个铁种，作为布兰的兄弟。\n\"You father raises me as an honorable man\",\"My your brother, now and always\",\"My sword is yours, from this day, until the last day\"。隔了这么久，我依然能记得席恩对罗柏·史塔克发过的誓言，直到罗柏死在血色婚礼上，直到席恩被小剥皮折磨到成为臭佬，直到他带着珊莎跳下临冬城开始自我救赎的那一刻。\n作为一个质子，当他想在史塔克家族找到自己一席之地的时候，罗柏总会提醒他“It's not your home, you are not a Stark”。当他作为罗柏的兄弟迫切想证明自己的时候，以“铁屿继承人”的身份回到铁群岛时，却发现自己已经不被父亲与姐姐认可。他一直想假装强大，一直想找到自己的身份，一直想做一个英雄，但最后却成了臭佬，忘记了自己的姓名，苟活于世。\n直到他带着珊莎跳下临冬城开始逃亡之路，直到他被铁民殴打倒地仍然从地上爬起，直到他回到临冬城对珊莎说“I want fight for Winterfall lady Sansa if you'll have me”，直到他弹尽粮绝拿着龙晶长枪独身冲向夜王，直到他倒地看着夜王却再也无力爬起，直到他作为史塔克为临冬城拼尽全力。\n让我身为席恩而死，不是臭佬。我是铁种，来自群屿，是派克岛的传人。\nWhat is dead may never die\n\n### 莱安娜·莫尔蒙\nWe are not a large house, but we're a proud one, and every man from Bear Island, fights with the strength of 10 mainlanders.\n就像莫尔蒙家族的箴言“Here we stand”，一个10岁的小女孩，表现出来的刚强果断足以让所有展现出怯懦的大人脸红。她在整个剧中从来不是个重要的人物，熊岛也只是封地在北境西北方一个贫瘠岛屿的普通家族。但其所展现出来的忠贞不二却是维斯特洛大陆上的一道绝对靓丽的风景，使得为了铁王座尔虞我诈的那些大家族变得如飘零柳絮般苍白。\n战斗前夜乔拉与莱安娜的对话令人心碎\nListen to me, you are the future of our house.\nI don't need you to remind me of that.\nYou'll be safer in the crypt...\nI will not hide underground, I pledged to fight for the North and I will fight.\n以及小熊转身对大熊说的那句\"I wish you good fortune, cousin.\"。这句话现在已经成为绝唱，他们一个为保卫北境而死，一个为守护所爱力竭身亡。\n一个10岁的小女孩，在大战前后指挥若定。城池已破之时仍然毫无畏惧，用着还是孩子的嗓音怒吼着冲向巨人尸鬼，在能够感受的到的骨骼碎裂鲜血涌出之时，仍奋力将龙晶匕首插向巨人，在那一刻，她比巨人还要高大。\n我一直在想事情是不是还有转机，也许她还没死，直到夜王抬手，她睁开蓝色的眼睛作为尸鬼再次站起来。\n多希望她能听从乔拉的建议躲到地穴，也许熬过了这场生死之战若干年后她会是熊岛的一个年轻美丽的Lady Mormont。\n但也许那个人就不是她了，她是来自熊岛的莱安娜。\n\n### 乔拉·莫尔蒙\n年轻的乔拉，在铁群岛平叛时一战成名，受封骑士。\n之后为了所谓的爱情，他违反禁令偷卖奴隶，在逃亡途中却被“爱情”抛弃。\n在峡海对岸为了王国的赦免，他作为间谍接近塔格利安兄妹。\n他以为通过出卖他们他会回到从前。\n但当他开始熟悉丹妮，他明白他错了。\n从此不论经历什么，他知道，他会永远站在丹妮的身边。\n在生命的最后一刻，他依然想站起来为丹妮阻挡一切伤害。\n他想告诉丹妮他只是受伤了，他没事。\n但他却连话都没说出口就走了。\n他虽然浑身是血，但却很安详。\n因为他的身边。\n有丹妮，有卓戈。\n就像他们相遇时的模样。\n纯粹是很难定义的，但这一刻它有个别名。\n叫做乔拉。\n\n### 忧郁的艾迪\n人性是复杂的，从来没有两个人会是相同的，哪怕类似都很难。但有时却有一些精神可以很好地概括一群人，在异鬼侵袭之时，长城上的守夜人是王国的坚盾。\n“长夜将至，我从现在开始守望，至死方休”\n“我是黑暗中的利剑，长城上的守卫，守卫王国的坚盾”\n“我将生命与荣耀献给守夜人”\n守夜人的精神是什么？是一边背诵誓词一边冲向巨人的葛兰们，是放弃王位只为坚守誓言的伊蒙·塔格利安，是为了目标孤独地在北境之北骑行的班杨·史塔克。\n“今夜如此，夜夜皆然”。\n随着艾迪的倒下，也许往后再也不会有人再说出这些誓词了。\n\n### 夜王\n行走了整整7季，却在预料之中的一集中以一种戏剧性的方法“死去”。\n你有多少故事，我曾经幻想能够听到答案，\n直到你在“The Night King”的乐曲中被匕首洞穿。\n全片无言，你的故事也许永远是一个谜。\n有人将你比作现实当中的那些自然灾害。\n讽刺五大洲的人们如维斯特洛大陆上的人们一样。\n在内斗中迷失、消亡。\n也有人认为你只是你。\n带着小说与剧集当中的某种隐喻。\n等待有一天编剧或马丁能够给我们答案。\n维斯特洛大陆上无人会喜欢你，\n但也许将来吟游歌者会将你提起。\n因为在生与死，冰与火的交织中，\n你让我们看到了人性。\n\n## 吐槽\n从S8前两集的命运交合开始，这一集生与死、冰与火的战争战前的气氛烘托可谓做到了极致。从大战开头，多斯拉克骑兵的龙晶弯刀开始熊熊燃烧，战斗的气氛似乎被一下扬起，直到骑兵冲向死亡军团，燃烧的火点开始逐渐熄灭直到消失殆尽，一种冰冷的肃杀与绝望的气息瞬间充满了每个人的内心。再到之后的空战，以及夜王带来的暴雪，无法阻挡尸鬼的燃烧的木栅，每个人物的特写，都使这场长达80分钟的战争刻画无比成功。\n但同时，细细思考战术，确实有蛮多地方值得吐槽。\n### 战术槽点\n1. 为什么要怒送多斯拉克骑兵？\n在临冬城大战之前，琼雪等人对异鬼以及尸鬼明显可以说是知根知底了，制定的战术也是以斩杀夜王为根本目的，因为没杀掉夜王尸鬼是杀不完的。那么临冬城保卫战的主要目的显然就应该是保证临冬城守住较长的时间而不是为了斩杀多少异鬼、尸鬼了。一个以拖延时间为目的的守城战，有什么理由让多斯拉克人在战前对杀不尽的异鬼进行冲锋？这支游牧民族骑兵在日后的内战当中是一个战斗力堪称bug的军队，异鬼没有攻来，你等着就好了，凭什么让自己最嫡系的军队先发起进攻？多斯拉克人即使不参加这场战争的效果也远好于上去送。理想的多斯拉克骑兵使用方法应该是在尸鬼冲锋与无垢者纠缠在一起时从侧面进行冲击，或者等两条龙喷火将尸鬼冲散之时进行收割减轻步兵的压力。导演的目的当然是为了表现如上所述的绝望的气息，但这波操作实在是可以说是一个败笔，为从峡海对岸远道而来的多斯拉克人感到不值。\n2. 守城器械准备的不充分\n如上所述，这是一个以拖延时间为目的的守城战，那么所依仗的应该是各种诸如燃烧油之类的守城器械。作为集合全北境以及龙妈力量的庞大军队，我认为装备这些显然不是问题，有了这些东西，守城战至少可以再多坚持一倍的时间。再其次就是木栅的设置了，明显可以很好地减缓尸鬼冲锋的速度，必要时还可以点燃（别说暴雪看不见信号了，这个在准备当中并不需要考虑），那么为什么只在临冬城外设置一圈的木栅就十分奇怪了。还有就是弓箭的问题，尸鬼是被夜王魔法复活的，只要被龙晶戳到就会倒下，那么也就意味着一支弓箭至少能杀死一只尸鬼，为什么不多备弓箭手也很古怪了，一轮弓箭齐射就可以给底下步兵和无垢者减小巨大的压力。当然这些都没有1中的错误致命，毕竟都可以归结为物资的紧缺与准备时间的不充分。\n3. 为什么不准备用来射龙的强弩？\n前面说过，尸鬼虽然疯狂，但其实远比人脆弱，只要被龙晶戳到就会“死去”，那么使用科本的那种强弩显然足够杀死被夜王转化的“韦赛里斯”。就算射不了龙，用重弩清兵也是极好的。当然硬要说的话可以归结于山姆没有那个技术。\n4. 为什么不派骑兵后排切割异鬼\n一个异鬼死后，由他转化的所有尸鬼都会失去“生命”，因此减缓守城压力的有效办法就是让多斯拉克骑兵去切割异鬼。洞悉了异鬼怕瓦哥利亚钢与龙晶之后，就应该知道除去死亡本身带来的恐惧外，异鬼并没有那么强大。派遣骁勇的多斯拉克骑兵在大战时绕后切割，即使不能成功，也能够吸引尸鬼的注意力，大大减轻守城压力，比直接冲锋效果要好的多。\n\n总结一下，和异鬼讲排兵布阵，脑子大概是瓦特了，论指挥，我觉得“私生子之战”中的小剥皮要优越的多，此战能胜，也是光之王显灵了。\n\n### 人物吐槽\n* 囧雪\n囧雪是主角相信在第六季的时候就能够看出来了，但我觉得相对于其他角色的立体与丰满程度，剧本对囧雪（或说伊耿·塔格利安）的塑造实在有些苍白。并没有体现出这个角色应有的包括外交、军事等等方面的智慧。这也是其得名囧·you know nothing·雪诺的一个重要原因。在本次冰与火、生与死之战中，除去空战当中的一点点表现，别的时间基本都在打酱油，要不是二丫神来一笔，满盘皆输。\n* 布兰·史塔克\n作为现在在场的究极神棍，打了全场的酱油，不知道他操控乌鸦去干了什么，本来三眼乌鸦的神棍属性应该是一个大挂之前也很期待在大战中能有所表现，结果啥事都没有发生。\n* 山姆\n山姆为什么不躲进地窖我觉得没太交代清楚，而且他在这次大战中存活下来完全是因为主角光环，但说好的《权力的游戏》没有主角光环呢？\n\n## 后记\n这次大战静下来细细品味的话槽点很多，也有很多朋友认为这有点烂尾。但不得不承认，电视剧也是视觉艺术的一种，而这场大战无论是在视觉上还是情感上做的都很到位，算是战争戏中的标杆了。至于烂尾，其实我早就做好这个打算了，我认为一部剧的跨度达到接近10年的情况下，不烂尾是不可能的。毕竟，一百个读者心中有一百个哈姆雷特。剧中的角色经过这些年的沉淀，在不同的观众眼中早已千差万别，每个人所希望的结局都不同，每个人所想看到的情节都有差异，每个人对待情节逻辑的解读都会有偏差。在这样的情况下，剧的走向只有一条，而观众希望的走向却有千万条，因此，也许在你眼中这儿烂尾了，在他眼中情节涉及却恰到好处，我想说的是，享受这部剧融入我们这些年时光的那一部分，看看他带给了我们自己多少变化，享受精彩的表演即可。茶余饭后吵吵闹闹完全可以，顿生龃龉则无必要。\n享受最后的那三集，希望能带给我们一些惊喜\n子夜dy记于19年五一之前。","slug":"瞎侃/剧评/The Long Night（权力的游戏 S8E3）","published":1,"updated":"2020-07-16T15:54:14.582Z","_id":"ckcoz48rs004w68js9o0abpnf","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>长夜将至，当许多交交合合的命运汇集到临冬城的那刻，我知道在压抑的北境风雪之下会诞生许许多多有质感的能量，那是人性所带来的温度。不论命运如何曲折，是凛冬还是盛夏，依靠所谓魔法还是普普通通的脆弱不堪的人的身躯，这都有别于没有质感的所谓邪恶，因为这是生与死的区别。<br>从S1E01开始，异鬼就是几乎凌驾于所有故事线之外的一个主线，因为它没有邪恶、暴力的划分，它既不比像小剥皮那样纯粹的人之恶要更邪恶，也谈不上比瑟曦·兰尼斯特的野心更极端。用形容词与名词界定夜王及他所创造的异鬼和尸鬼们是很困难的，就像百万年前极地的风，当死寂无人之时，没有语言，没有人声，谈不上形容。这是夜王所要带来的，所要抹去的，所谓世界记忆过的东西。也许那些歌谣、传记、语言乃至人类统统不曾出现过，比十万光年外的宇宙深处还要寂静空旷。<br>无法形容的东西，这是汇集在临冬城的人们所要面对的。在漫天寒风的怒吼之中，一丝人性的传达都足以消弭一方冰雪，在世界崩溃的边缘，在死亡降临的前夜，在《Jenny of Oldstones》的歌声中，他们知道下半夜所要面对的是什么。<br>“诚既勇兮又以武，终刚强兮不可凌”，献给所有直面过死亡的角色。</p>\n<h2 id=\"悼词\"><a href=\"#悼词\" class=\"headerlink\" title=\"悼词\"></a>悼词</h2><h3 id=\"席恩·葛雷乔伊\"><a href=\"#席恩·葛雷乔伊\" class=\"headerlink\" title=\"席恩·葛雷乔伊\"></a>席恩·葛雷乔伊</h3><p>Born as a Greyjoy, die as a Stark. “You are a good man, thank you, Theon.”<br>这也许是席恩这一生最好的写照了吧，也是这个人物最好的归宿，此刻他为保护布兰而死，作为一名史塔克，作为临冬城的一员，作为一个铁种，作为布兰的兄弟。<br>“You father raises me as an honorable man”,”My your brother, now and always”,”My sword is yours, from this day, until the last day”。隔了这么久，我依然能记得席恩对罗柏·史塔克发过的誓言，直到罗柏死在血色婚礼上，直到席恩被小剥皮折磨到成为臭佬，直到他带着珊莎跳下临冬城开始自我救赎的那一刻。<br>作为一个质子，当他想在史塔克家族找到自己一席之地的时候，罗柏总会提醒他“It’s not your home, you are not a Stark”。当他作为罗柏的兄弟迫切想证明自己的时候，以“铁屿继承人”的身份回到铁群岛时，却发现自己已经不被父亲与姐姐认可。他一直想假装强大，一直想找到自己的身份，一直想做一个英雄，但最后却成了臭佬，忘记了自己的姓名，苟活于世。<br>直到他带着珊莎跳下临冬城开始逃亡之路，直到他被铁民殴打倒地仍然从地上爬起，直到他回到临冬城对珊莎说“I want fight for Winterfall lady Sansa if you’ll have me”，直到他弹尽粮绝拿着龙晶长枪独身冲向夜王，直到他倒地看着夜王却再也无力爬起，直到他作为史塔克为临冬城拼尽全力。<br>让我身为席恩而死，不是臭佬。我是铁种，来自群屿，是派克岛的传人。<br>What is dead may never die</p>\n<h3 id=\"莱安娜·莫尔蒙\"><a href=\"#莱安娜·莫尔蒙\" class=\"headerlink\" title=\"莱安娜·莫尔蒙\"></a>莱安娜·莫尔蒙</h3><p>We are not a large house, but we’re a proud one, and every man from Bear Island, fights with the strength of 10 mainlanders.<br>就像莫尔蒙家族的箴言“Here we stand”，一个10岁的小女孩，表现出来的刚强果断足以让所有展现出怯懦的大人脸红。她在整个剧中从来不是个重要的人物，熊岛也只是封地在北境西北方一个贫瘠岛屿的普通家族。但其所展现出来的忠贞不二却是维斯特洛大陆上的一道绝对靓丽的风景，使得为了铁王座尔虞我诈的那些大家族变得如飘零柳絮般苍白。<br>战斗前夜乔拉与莱安娜的对话令人心碎<br>Listen to me, you are the future of our house.<br>I don’t need you to remind me of that.<br>You’ll be safer in the crypt…<br>I will not hide underground, I pledged to fight for the North and I will fight.<br>以及小熊转身对大熊说的那句”I wish you good fortune, cousin.”。这句话现在已经成为绝唱，他们一个为保卫北境而死，一个为守护所爱力竭身亡。<br>一个10岁的小女孩，在大战前后指挥若定。城池已破之时仍然毫无畏惧，用着还是孩子的嗓音怒吼着冲向巨人尸鬼，在能够感受的到的骨骼碎裂鲜血涌出之时，仍奋力将龙晶匕首插向巨人，在那一刻，她比巨人还要高大。<br>我一直在想事情是不是还有转机，也许她还没死，直到夜王抬手，她睁开蓝色的眼睛作为尸鬼再次站起来。<br>多希望她能听从乔拉的建议躲到地穴，也许熬过了这场生死之战若干年后她会是熊岛的一个年轻美丽的Lady Mormont。<br>但也许那个人就不是她了，她是来自熊岛的莱安娜。</p>\n<h3 id=\"乔拉·莫尔蒙\"><a href=\"#乔拉·莫尔蒙\" class=\"headerlink\" title=\"乔拉·莫尔蒙\"></a>乔拉·莫尔蒙</h3><p>年轻的乔拉，在铁群岛平叛时一战成名，受封骑士。<br>之后为了所谓的爱情，他违反禁令偷卖奴隶，在逃亡途中却被“爱情”抛弃。<br>在峡海对岸为了王国的赦免，他作为间谍接近塔格利安兄妹。<br>他以为通过出卖他们他会回到从前。<br>但当他开始熟悉丹妮，他明白他错了。<br>从此不论经历什么，他知道，他会永远站在丹妮的身边。<br>在生命的最后一刻，他依然想站起来为丹妮阻挡一切伤害。<br>他想告诉丹妮他只是受伤了，他没事。<br>但他却连话都没说出口就走了。<br>他虽然浑身是血，但却很安详。<br>因为他的身边。<br>有丹妮，有卓戈。<br>就像他们相遇时的模样。<br>纯粹是很难定义的，但这一刻它有个别名。<br>叫做乔拉。</p>\n<h3 id=\"忧郁的艾迪\"><a href=\"#忧郁的艾迪\" class=\"headerlink\" title=\"忧郁的艾迪\"></a>忧郁的艾迪</h3><p>人性是复杂的，从来没有两个人会是相同的，哪怕类似都很难。但有时却有一些精神可以很好地概括一群人，在异鬼侵袭之时，长城上的守夜人是王国的坚盾。<br>“长夜将至，我从现在开始守望，至死方休”<br>“我是黑暗中的利剑，长城上的守卫，守卫王国的坚盾”<br>“我将生命与荣耀献给守夜人”<br>守夜人的精神是什么？是一边背诵誓词一边冲向巨人的葛兰们，是放弃王位只为坚守誓言的伊蒙·塔格利安，是为了目标孤独地在北境之北骑行的班杨·史塔克。<br>“今夜如此，夜夜皆然”。<br>随着艾迪的倒下，也许往后再也不会有人再说出这些誓词了。</p>\n<h3 id=\"夜王\"><a href=\"#夜王\" class=\"headerlink\" title=\"夜王\"></a>夜王</h3><p>行走了整整7季，却在预料之中的一集中以一种戏剧性的方法“死去”。<br>你有多少故事，我曾经幻想能够听到答案，<br>直到你在“The Night King”的乐曲中被匕首洞穿。<br>全片无言，你的故事也许永远是一个谜。<br>有人将你比作现实当中的那些自然灾害。<br>讽刺五大洲的人们如维斯特洛大陆上的人们一样。<br>在内斗中迷失、消亡。<br>也有人认为你只是你。<br>带着小说与剧集当中的某种隐喻。<br>等待有一天编剧或马丁能够给我们答案。<br>维斯特洛大陆上无人会喜欢你，<br>但也许将来吟游歌者会将你提起。<br>因为在生与死，冰与火的交织中，<br>你让我们看到了人性。</p>\n<h2 id=\"吐槽\"><a href=\"#吐槽\" class=\"headerlink\" title=\"吐槽\"></a>吐槽</h2><p>从S8前两集的命运交合开始，这一集生与死、冰与火的战争战前的气氛烘托可谓做到了极致。从大战开头，多斯拉克骑兵的龙晶弯刀开始熊熊燃烧，战斗的气氛似乎被一下扬起，直到骑兵冲向死亡军团，燃烧的火点开始逐渐熄灭直到消失殆尽，一种冰冷的肃杀与绝望的气息瞬间充满了每个人的内心。再到之后的空战，以及夜王带来的暴雪，无法阻挡尸鬼的燃烧的木栅，每个人物的特写，都使这场长达80分钟的战争刻画无比成功。<br>但同时，细细思考战术，确实有蛮多地方值得吐槽。</p>\n<h3 id=\"战术槽点\"><a href=\"#战术槽点\" class=\"headerlink\" title=\"战术槽点\"></a>战术槽点</h3><ol>\n<li>为什么要怒送多斯拉克骑兵？<br>在临冬城大战之前，琼雪等人对异鬼以及尸鬼明显可以说是知根知底了，制定的战术也是以斩杀夜王为根本目的，因为没杀掉夜王尸鬼是杀不完的。那么临冬城保卫战的主要目的显然就应该是保证临冬城守住较长的时间而不是为了斩杀多少异鬼、尸鬼了。一个以拖延时间为目的的守城战，有什么理由让多斯拉克人在战前对杀不尽的异鬼进行冲锋？这支游牧民族骑兵在日后的内战当中是一个战斗力堪称bug的军队，异鬼没有攻来，你等着就好了，凭什么让自己最嫡系的军队先发起进攻？多斯拉克人即使不参加这场战争的效果也远好于上去送。理想的多斯拉克骑兵使用方法应该是在尸鬼冲锋与无垢者纠缠在一起时从侧面进行冲击，或者等两条龙喷火将尸鬼冲散之时进行收割减轻步兵的压力。导演的目的当然是为了表现如上所述的绝望的气息，但这波操作实在是可以说是一个败笔，为从峡海对岸远道而来的多斯拉克人感到不值。</li>\n<li>守城器械准备的不充分<br>如上所述，这是一个以拖延时间为目的的守城战，那么所依仗的应该是各种诸如燃烧油之类的守城器械。作为集合全北境以及龙妈力量的庞大军队，我认为装备这些显然不是问题，有了这些东西，守城战至少可以再多坚持一倍的时间。再其次就是木栅的设置了，明显可以很好地减缓尸鬼冲锋的速度，必要时还可以点燃（别说暴雪看不见信号了，这个在准备当中并不需要考虑），那么为什么只在临冬城外设置一圈的木栅就十分奇怪了。还有就是弓箭的问题，尸鬼是被夜王魔法复活的，只要被龙晶戳到就会倒下，那么也就意味着一支弓箭至少能杀死一只尸鬼，为什么不多备弓箭手也很古怪了，一轮弓箭齐射就可以给底下步兵和无垢者减小巨大的压力。当然这些都没有1中的错误致命，毕竟都可以归结为物资的紧缺与准备时间的不充分。</li>\n<li>为什么不准备用来射龙的强弩？<br>前面说过，尸鬼虽然疯狂，但其实远比人脆弱，只要被龙晶戳到就会“死去”，那么使用科本的那种强弩显然足够杀死被夜王转化的“韦赛里斯”。就算射不了龙，用重弩清兵也是极好的。当然硬要说的话可以归结于山姆没有那个技术。</li>\n<li>为什么不派骑兵后排切割异鬼<br>一个异鬼死后，由他转化的所有尸鬼都会失去“生命”，因此减缓守城压力的有效办法就是让多斯拉克骑兵去切割异鬼。洞悉了异鬼怕瓦哥利亚钢与龙晶之后，就应该知道除去死亡本身带来的恐惧外，异鬼并没有那么强大。派遣骁勇的多斯拉克骑兵在大战时绕后切割，即使不能成功，也能够吸引尸鬼的注意力，大大减轻守城压力，比直接冲锋效果要好的多。</li>\n</ol>\n<p>总结一下，和异鬼讲排兵布阵，脑子大概是瓦特了，论指挥，我觉得“私生子之战”中的小剥皮要优越的多，此战能胜，也是光之王显灵了。</p>\n<h3 id=\"人物吐槽\"><a href=\"#人物吐槽\" class=\"headerlink\" title=\"人物吐槽\"></a>人物吐槽</h3><ul>\n<li>囧雪<br>囧雪是主角相信在第六季的时候就能够看出来了，但我觉得相对于其他角色的立体与丰满程度，剧本对囧雪（或说伊耿·塔格利安）的塑造实在有些苍白。并没有体现出这个角色应有的包括外交、军事等等方面的智慧。这也是其得名囧·you know nothing·雪诺的一个重要原因。在本次冰与火、生与死之战中，除去空战当中的一点点表现，别的时间基本都在打酱油，要不是二丫神来一笔，满盘皆输。</li>\n<li>布兰·史塔克<br>作为现在在场的究极神棍，打了全场的酱油，不知道他操控乌鸦去干了什么，本来三眼乌鸦的神棍属性应该是一个大挂之前也很期待在大战中能有所表现，结果啥事都没有发生。</li>\n<li>山姆<br>山姆为什么不躲进地窖我觉得没太交代清楚，而且他在这次大战中存活下来完全是因为主角光环，但说好的《权力的游戏》没有主角光环呢？</li>\n</ul>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>这次大战静下来细细品味的话槽点很多，也有很多朋友认为这有点烂尾。但不得不承认，电视剧也是视觉艺术的一种，而这场大战无论是在视觉上还是情感上做的都很到位，算是战争戏中的标杆了。至于烂尾，其实我早就做好这个打算了，我认为一部剧的跨度达到接近10年的情况下，不烂尾是不可能的。毕竟，一百个读者心中有一百个哈姆雷特。剧中的角色经过这些年的沉淀，在不同的观众眼中早已千差万别，每个人所希望的结局都不同，每个人所想看到的情节都有差异，每个人对待情节逻辑的解读都会有偏差。在这样的情况下，剧的走向只有一条，而观众希望的走向却有千万条，因此，也许在你眼中这儿烂尾了，在他眼中情节涉及却恰到好处，我想说的是，享受这部剧融入我们这些年时光的那一部分，看看他带给了我们自己多少变化，享受精彩的表演即可。茶余饭后吵吵闹闹完全可以，顿生龃龉则无必要。<br>享受最后的那三集，希望能带给我们一些惊喜<br>子夜dy记于19年五一之前。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>长夜将至，当许多交交合合的命运汇集到临冬城的那刻，我知道在压抑的北境风雪之下会诞生许许多多有质感的能量，那是人性所带来的温度。不论命运如何曲折，是凛冬还是盛夏，依靠所谓魔法还是普普通通的脆弱不堪的人的身躯，这都有别于没有质感的所谓邪恶，因为这是生与死的区别。<br>从S1E01开始，异鬼就是几乎凌驾于所有故事线之外的一个主线，因为它没有邪恶、暴力的划分，它既不比像小剥皮那样纯粹的人之恶要更邪恶，也谈不上比瑟曦·兰尼斯特的野心更极端。用形容词与名词界定夜王及他所创造的异鬼和尸鬼们是很困难的，就像百万年前极地的风，当死寂无人之时，没有语言，没有人声，谈不上形容。这是夜王所要带来的，所要抹去的，所谓世界记忆过的东西。也许那些歌谣、传记、语言乃至人类统统不曾出现过，比十万光年外的宇宙深处还要寂静空旷。<br>无法形容的东西，这是汇集在临冬城的人们所要面对的。在漫天寒风的怒吼之中，一丝人性的传达都足以消弭一方冰雪，在世界崩溃的边缘，在死亡降临的前夜，在《Jenny of Oldstones》的歌声中，他们知道下半夜所要面对的是什么。<br>“诚既勇兮又以武，终刚强兮不可凌”，献给所有直面过死亡的角色。</p>\n<h2 id=\"悼词\"><a href=\"#悼词\" class=\"headerlink\" title=\"悼词\"></a>悼词</h2><h3 id=\"席恩·葛雷乔伊\"><a href=\"#席恩·葛雷乔伊\" class=\"headerlink\" title=\"席恩·葛雷乔伊\"></a>席恩·葛雷乔伊</h3><p>Born as a Greyjoy, die as a Stark. “You are a good man, thank you, Theon.”<br>这也许是席恩这一生最好的写照了吧，也是这个人物最好的归宿，此刻他为保护布兰而死，作为一名史塔克，作为临冬城的一员，作为一个铁种，作为布兰的兄弟。<br>“You father raises me as an honorable man”,”My your brother, now and always”,”My sword is yours, from this day, until the last day”。隔了这么久，我依然能记得席恩对罗柏·史塔克发过的誓言，直到罗柏死在血色婚礼上，直到席恩被小剥皮折磨到成为臭佬，直到他带着珊莎跳下临冬城开始自我救赎的那一刻。<br>作为一个质子，当他想在史塔克家族找到自己一席之地的时候，罗柏总会提醒他“It’s not your home, you are not a Stark”。当他作为罗柏的兄弟迫切想证明自己的时候，以“铁屿继承人”的身份回到铁群岛时，却发现自己已经不被父亲与姐姐认可。他一直想假装强大，一直想找到自己的身份，一直想做一个英雄，但最后却成了臭佬，忘记了自己的姓名，苟活于世。<br>直到他带着珊莎跳下临冬城开始逃亡之路，直到他被铁民殴打倒地仍然从地上爬起，直到他回到临冬城对珊莎说“I want fight for Winterfall lady Sansa if you’ll have me”，直到他弹尽粮绝拿着龙晶长枪独身冲向夜王，直到他倒地看着夜王却再也无力爬起，直到他作为史塔克为临冬城拼尽全力。<br>让我身为席恩而死，不是臭佬。我是铁种，来自群屿，是派克岛的传人。<br>What is dead may never die</p>\n<h3 id=\"莱安娜·莫尔蒙\"><a href=\"#莱安娜·莫尔蒙\" class=\"headerlink\" title=\"莱安娜·莫尔蒙\"></a>莱安娜·莫尔蒙</h3><p>We are not a large house, but we’re a proud one, and every man from Bear Island, fights with the strength of 10 mainlanders.<br>就像莫尔蒙家族的箴言“Here we stand”，一个10岁的小女孩，表现出来的刚强果断足以让所有展现出怯懦的大人脸红。她在整个剧中从来不是个重要的人物，熊岛也只是封地在北境西北方一个贫瘠岛屿的普通家族。但其所展现出来的忠贞不二却是维斯特洛大陆上的一道绝对靓丽的风景，使得为了铁王座尔虞我诈的那些大家族变得如飘零柳絮般苍白。<br>战斗前夜乔拉与莱安娜的对话令人心碎<br>Listen to me, you are the future of our house.<br>I don’t need you to remind me of that.<br>You’ll be safer in the crypt…<br>I will not hide underground, I pledged to fight for the North and I will fight.<br>以及小熊转身对大熊说的那句”I wish you good fortune, cousin.”。这句话现在已经成为绝唱，他们一个为保卫北境而死，一个为守护所爱力竭身亡。<br>一个10岁的小女孩，在大战前后指挥若定。城池已破之时仍然毫无畏惧，用着还是孩子的嗓音怒吼着冲向巨人尸鬼，在能够感受的到的骨骼碎裂鲜血涌出之时，仍奋力将龙晶匕首插向巨人，在那一刻，她比巨人还要高大。<br>我一直在想事情是不是还有转机，也许她还没死，直到夜王抬手，她睁开蓝色的眼睛作为尸鬼再次站起来。<br>多希望她能听从乔拉的建议躲到地穴，也许熬过了这场生死之战若干年后她会是熊岛的一个年轻美丽的Lady Mormont。<br>但也许那个人就不是她了，她是来自熊岛的莱安娜。</p>\n<h3 id=\"乔拉·莫尔蒙\"><a href=\"#乔拉·莫尔蒙\" class=\"headerlink\" title=\"乔拉·莫尔蒙\"></a>乔拉·莫尔蒙</h3><p>年轻的乔拉，在铁群岛平叛时一战成名，受封骑士。<br>之后为了所谓的爱情，他违反禁令偷卖奴隶，在逃亡途中却被“爱情”抛弃。<br>在峡海对岸为了王国的赦免，他作为间谍接近塔格利安兄妹。<br>他以为通过出卖他们他会回到从前。<br>但当他开始熟悉丹妮，他明白他错了。<br>从此不论经历什么，他知道，他会永远站在丹妮的身边。<br>在生命的最后一刻，他依然想站起来为丹妮阻挡一切伤害。<br>他想告诉丹妮他只是受伤了，他没事。<br>但他却连话都没说出口就走了。<br>他虽然浑身是血，但却很安详。<br>因为他的身边。<br>有丹妮，有卓戈。<br>就像他们相遇时的模样。<br>纯粹是很难定义的，但这一刻它有个别名。<br>叫做乔拉。</p>\n<h3 id=\"忧郁的艾迪\"><a href=\"#忧郁的艾迪\" class=\"headerlink\" title=\"忧郁的艾迪\"></a>忧郁的艾迪</h3><p>人性是复杂的，从来没有两个人会是相同的，哪怕类似都很难。但有时却有一些精神可以很好地概括一群人，在异鬼侵袭之时，长城上的守夜人是王国的坚盾。<br>“长夜将至，我从现在开始守望，至死方休”<br>“我是黑暗中的利剑，长城上的守卫，守卫王国的坚盾”<br>“我将生命与荣耀献给守夜人”<br>守夜人的精神是什么？是一边背诵誓词一边冲向巨人的葛兰们，是放弃王位只为坚守誓言的伊蒙·塔格利安，是为了目标孤独地在北境之北骑行的班杨·史塔克。<br>“今夜如此，夜夜皆然”。<br>随着艾迪的倒下，也许往后再也不会有人再说出这些誓词了。</p>\n<h3 id=\"夜王\"><a href=\"#夜王\" class=\"headerlink\" title=\"夜王\"></a>夜王</h3><p>行走了整整7季，却在预料之中的一集中以一种戏剧性的方法“死去”。<br>你有多少故事，我曾经幻想能够听到答案，<br>直到你在“The Night King”的乐曲中被匕首洞穿。<br>全片无言，你的故事也许永远是一个谜。<br>有人将你比作现实当中的那些自然灾害。<br>讽刺五大洲的人们如维斯特洛大陆上的人们一样。<br>在内斗中迷失、消亡。<br>也有人认为你只是你。<br>带着小说与剧集当中的某种隐喻。<br>等待有一天编剧或马丁能够给我们答案。<br>维斯特洛大陆上无人会喜欢你，<br>但也许将来吟游歌者会将你提起。<br>因为在生与死，冰与火的交织中，<br>你让我们看到了人性。</p>\n<h2 id=\"吐槽\"><a href=\"#吐槽\" class=\"headerlink\" title=\"吐槽\"></a>吐槽</h2><p>从S8前两集的命运交合开始，这一集生与死、冰与火的战争战前的气氛烘托可谓做到了极致。从大战开头，多斯拉克骑兵的龙晶弯刀开始熊熊燃烧，战斗的气氛似乎被一下扬起，直到骑兵冲向死亡军团，燃烧的火点开始逐渐熄灭直到消失殆尽，一种冰冷的肃杀与绝望的气息瞬间充满了每个人的内心。再到之后的空战，以及夜王带来的暴雪，无法阻挡尸鬼的燃烧的木栅，每个人物的特写，都使这场长达80分钟的战争刻画无比成功。<br>但同时，细细思考战术，确实有蛮多地方值得吐槽。</p>\n<h3 id=\"战术槽点\"><a href=\"#战术槽点\" class=\"headerlink\" title=\"战术槽点\"></a>战术槽点</h3><ol>\n<li>为什么要怒送多斯拉克骑兵？<br>在临冬城大战之前，琼雪等人对异鬼以及尸鬼明显可以说是知根知底了，制定的战术也是以斩杀夜王为根本目的，因为没杀掉夜王尸鬼是杀不完的。那么临冬城保卫战的主要目的显然就应该是保证临冬城守住较长的时间而不是为了斩杀多少异鬼、尸鬼了。一个以拖延时间为目的的守城战，有什么理由让多斯拉克人在战前对杀不尽的异鬼进行冲锋？这支游牧民族骑兵在日后的内战当中是一个战斗力堪称bug的军队，异鬼没有攻来，你等着就好了，凭什么让自己最嫡系的军队先发起进攻？多斯拉克人即使不参加这场战争的效果也远好于上去送。理想的多斯拉克骑兵使用方法应该是在尸鬼冲锋与无垢者纠缠在一起时从侧面进行冲击，或者等两条龙喷火将尸鬼冲散之时进行收割减轻步兵的压力。导演的目的当然是为了表现如上所述的绝望的气息，但这波操作实在是可以说是一个败笔，为从峡海对岸远道而来的多斯拉克人感到不值。</li>\n<li>守城器械准备的不充分<br>如上所述，这是一个以拖延时间为目的的守城战，那么所依仗的应该是各种诸如燃烧油之类的守城器械。作为集合全北境以及龙妈力量的庞大军队，我认为装备这些显然不是问题，有了这些东西，守城战至少可以再多坚持一倍的时间。再其次就是木栅的设置了，明显可以很好地减缓尸鬼冲锋的速度，必要时还可以点燃（别说暴雪看不见信号了，这个在准备当中并不需要考虑），那么为什么只在临冬城外设置一圈的木栅就十分奇怪了。还有就是弓箭的问题，尸鬼是被夜王魔法复活的，只要被龙晶戳到就会倒下，那么也就意味着一支弓箭至少能杀死一只尸鬼，为什么不多备弓箭手也很古怪了，一轮弓箭齐射就可以给底下步兵和无垢者减小巨大的压力。当然这些都没有1中的错误致命，毕竟都可以归结为物资的紧缺与准备时间的不充分。</li>\n<li>为什么不准备用来射龙的强弩？<br>前面说过，尸鬼虽然疯狂，但其实远比人脆弱，只要被龙晶戳到就会“死去”，那么使用科本的那种强弩显然足够杀死被夜王转化的“韦赛里斯”。就算射不了龙，用重弩清兵也是极好的。当然硬要说的话可以归结于山姆没有那个技术。</li>\n<li>为什么不派骑兵后排切割异鬼<br>一个异鬼死后，由他转化的所有尸鬼都会失去“生命”，因此减缓守城压力的有效办法就是让多斯拉克骑兵去切割异鬼。洞悉了异鬼怕瓦哥利亚钢与龙晶之后，就应该知道除去死亡本身带来的恐惧外，异鬼并没有那么强大。派遣骁勇的多斯拉克骑兵在大战时绕后切割，即使不能成功，也能够吸引尸鬼的注意力，大大减轻守城压力，比直接冲锋效果要好的多。</li>\n</ol>\n<p>总结一下，和异鬼讲排兵布阵，脑子大概是瓦特了，论指挥，我觉得“私生子之战”中的小剥皮要优越的多，此战能胜，也是光之王显灵了。</p>\n<h3 id=\"人物吐槽\"><a href=\"#人物吐槽\" class=\"headerlink\" title=\"人物吐槽\"></a>人物吐槽</h3><ul>\n<li>囧雪<br>囧雪是主角相信在第六季的时候就能够看出来了，但我觉得相对于其他角色的立体与丰满程度，剧本对囧雪（或说伊耿·塔格利安）的塑造实在有些苍白。并没有体现出这个角色应有的包括外交、军事等等方面的智慧。这也是其得名囧·you know nothing·雪诺的一个重要原因。在本次冰与火、生与死之战中，除去空战当中的一点点表现，别的时间基本都在打酱油，要不是二丫神来一笔，满盘皆输。</li>\n<li>布兰·史塔克<br>作为现在在场的究极神棍，打了全场的酱油，不知道他操控乌鸦去干了什么，本来三眼乌鸦的神棍属性应该是一个大挂之前也很期待在大战中能有所表现，结果啥事都没有发生。</li>\n<li>山姆<br>山姆为什么不躲进地窖我觉得没太交代清楚，而且他在这次大战中存活下来完全是因为主角光环，但说好的《权力的游戏》没有主角光环呢？</li>\n</ul>\n<h2 id=\"后记\"><a href=\"#后记\" class=\"headerlink\" title=\"后记\"></a>后记</h2><p>这次大战静下来细细品味的话槽点很多，也有很多朋友认为这有点烂尾。但不得不承认，电视剧也是视觉艺术的一种，而这场大战无论是在视觉上还是情感上做的都很到位，算是战争戏中的标杆了。至于烂尾，其实我早就做好这个打算了，我认为一部剧的跨度达到接近10年的情况下，不烂尾是不可能的。毕竟，一百个读者心中有一百个哈姆雷特。剧中的角色经过这些年的沉淀，在不同的观众眼中早已千差万别，每个人所希望的结局都不同，每个人所想看到的情节都有差异，每个人对待情节逻辑的解读都会有偏差。在这样的情况下，剧的走向只有一条，而观众希望的走向却有千万条，因此，也许在你眼中这儿烂尾了，在他眼中情节涉及却恰到好处，我想说的是，享受这部剧融入我们这些年时光的那一部分，看看他带给了我们自己多少变化，享受精彩的表演即可。茶余饭后吵吵闹闹完全可以，顿生龃龉则无必要。<br>享受最后的那三集，希望能带给我们一些惊喜<br>子夜dy记于19年五一之前。</p>\n"},{"title":"Git出现的报错合集","date":"2020-06-15T15:31:46.000Z","fileName":"git_error","_content":"\n\n\n### Git: fatal: refusing to merge unrelated histories解决\n\n今天`git pull`时出现这个错误（在连接远程库与本地库时在远程库上进行了一些删除操作）。原因是两个分支为两个不同的版本，有不同的提交历史，使用以下语句进行强制合并即可解决这个问题。\n\n```\n$git pull origin master --allow-unrelated-histories\n```\n\n\n\n### fatal: remote origin already exists\n\n先将存在的库删除，再进行连接\n\n```\ngit remote rm origin\n```\n\n\n\n### non-fast-forward\n\n没有对代码进行及时的同步产生的问题，应该先合并之前的历史，再进行提交\n\n```\ngit fetch origin master\ngit merge origin FETCH_HEAD \n```\n\n","source":"_posts/其他/debug/Git出现的报错合集.md","raw":"---\ntitle: Git出现的报错合集\ndate: 2020-06-15 23:31:46\ntags:\ncategories:\n\t- 其他\n\t- debug\nfileName: git_error\n---\n\n\n\n### Git: fatal: refusing to merge unrelated histories解决\n\n今天`git pull`时出现这个错误（在连接远程库与本地库时在远程库上进行了一些删除操作）。原因是两个分支为两个不同的版本，有不同的提交历史，使用以下语句进行强制合并即可解决这个问题。\n\n```\n$git pull origin master --allow-unrelated-histories\n```\n\n\n\n### fatal: remote origin already exists\n\n先将存在的库删除，再进行连接\n\n```\ngit remote rm origin\n```\n\n\n\n### non-fast-forward\n\n没有对代码进行及时的同步产生的问题，应该先合并之前的历史，再进行提交\n\n```\ngit fetch origin master\ngit merge origin FETCH_HEAD \n```\n\n","slug":"其他/debug/Git出现的报错合集","published":1,"updated":"2020-07-16T15:56:03.972Z","_id":"ckcoz8l88005o68js3lvl7xgr","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"Git-fatal-refusing-to-merge-unrelated-histories解决\"><a href=\"#Git-fatal-refusing-to-merge-unrelated-histories解决\" class=\"headerlink\" title=\"Git: fatal: refusing to merge unrelated histories解决\"></a>Git: fatal: refusing to merge unrelated histories解决</h3><p>今天<code>git pull</code>时出现这个错误（在连接远程库与本地库时在远程库上进行了一些删除操作）。原因是两个分支为两个不同的版本，有不同的提交历史，使用以下语句进行强制合并即可解决这个问题。</p>\n<pre><code>$git pull origin master --allow-unrelated-histories</code></pre><h3 id=\"fatal-remote-origin-already-exists\"><a href=\"#fatal-remote-origin-already-exists\" class=\"headerlink\" title=\"fatal: remote origin already exists\"></a>fatal: remote origin already exists</h3><p>先将存在的库删除，再进行连接</p>\n<pre><code>git remote rm origin</code></pre><h3 id=\"non-fast-forward\"><a href=\"#non-fast-forward\" class=\"headerlink\" title=\"non-fast-forward\"></a>non-fast-forward</h3><p>没有对代码进行及时的同步产生的问题，应该先合并之前的历史，再进行提交</p>\n<pre><code>git fetch origin master\ngit merge origin FETCH_HEAD </code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Git-fatal-refusing-to-merge-unrelated-histories解决\"><a href=\"#Git-fatal-refusing-to-merge-unrelated-histories解决\" class=\"headerlink\" title=\"Git: fatal: refusing to merge unrelated histories解决\"></a>Git: fatal: refusing to merge unrelated histories解决</h3><p>今天<code>git pull</code>时出现这个错误（在连接远程库与本地库时在远程库上进行了一些删除操作）。原因是两个分支为两个不同的版本，有不同的提交历史，使用以下语句进行强制合并即可解决这个问题。</p>\n<pre><code>$git pull origin master --allow-unrelated-histories</code></pre><h3 id=\"fatal-remote-origin-already-exists\"><a href=\"#fatal-remote-origin-already-exists\" class=\"headerlink\" title=\"fatal: remote origin already exists\"></a>fatal: remote origin already exists</h3><p>先将存在的库删除，再进行连接</p>\n<pre><code>git remote rm origin</code></pre><h3 id=\"non-fast-forward\"><a href=\"#non-fast-forward\" class=\"headerlink\" title=\"non-fast-forward\"></a>non-fast-forward</h3><p>没有对代码进行及时的同步产生的问题，应该先合并之前的历史，再进行提交</p>\n<pre><code>git fetch origin master\ngit merge origin FETCH_HEAD </code></pre>"},{"title":"Ubuntu环境下anaconda出现的问题及解决方法","date":"2020-04-21T16:06:07.000Z","fileName":"ubuntu_anaconda_problem","_content":"\n## 创建新环境报错\n报错如下\n```\nCollecting package metadata (current_repodata.json): failed\n\nNotWritableError: The current user does not have write permissions to a required path.\n  path: /home/ziyedy/.conda/pkgs/urls.txt\n  uid: 1000\n  gid: 1000\n\nIf you feel that permissions on this path are set incorrectly, you can manually\nchange them by executing\n\n  $ sudo chown 1000:1000 /home/ziyedy/.conda/pkgs/urls.txt\n\nIn general, it's not advisable to use 'sudo conda'.\n\n```\n按照提示尝试操作没用，解决方法是命令行输入如下：\n```\nsudo chown -R ziyedy anaconda3 # ziyedy is user name.\n```\n参考：https://blog.csdn.net/PecoHe/article/details/104578700\n\n## 无法改变环境\n正常情况下输入`conda activate <env_name>`时，python应该改变为该环境下的python版本，可以使用`python -V`查看，但有时命令行显示上环境已经更改但实际上所使用的python解释器没有更换，解决方法如下：\n1. 使用记事本打开编辑环境（该目录下的.bashrc存储的为个人的一些配置文件，如别名路径）\n```\nsudo gedit ~/.bashrc\n```\n2. 在末尾按照规律添加如下内容\n```\nexport PATH=\"export PATH=\"~/anaconda3/bin:$PATH\"   #base环境下的python，已有的\nalias python1=\"~/anaconda3/bin/python   # 你需要添加的\n```\n`alias`用于设置指令的别名，下面一条语句的意思就算你输入python1就会自动指向后面\n3. 使得修改生效\n```\nsource ~/.bashrc\n```\n","source":"_posts/其他/debug/Ubuntu环境下anaconda出现的问题及解决方法.md","raw":"---\ntitle: Ubuntu环境下anaconda出现的问题及解决方法\ndate: 2020-04-22 00:06:07\ntags:\n    - Python\ncategories:\n\t- 其他\n\t- debug\nfileName: ubuntu_anaconda_problem\n---\n\n## 创建新环境报错\n报错如下\n```\nCollecting package metadata (current_repodata.json): failed\n\nNotWritableError: The current user does not have write permissions to a required path.\n  path: /home/ziyedy/.conda/pkgs/urls.txt\n  uid: 1000\n  gid: 1000\n\nIf you feel that permissions on this path are set incorrectly, you can manually\nchange them by executing\n\n  $ sudo chown 1000:1000 /home/ziyedy/.conda/pkgs/urls.txt\n\nIn general, it's not advisable to use 'sudo conda'.\n\n```\n按照提示尝试操作没用，解决方法是命令行输入如下：\n```\nsudo chown -R ziyedy anaconda3 # ziyedy is user name.\n```\n参考：https://blog.csdn.net/PecoHe/article/details/104578700\n\n## 无法改变环境\n正常情况下输入`conda activate <env_name>`时，python应该改变为该环境下的python版本，可以使用`python -V`查看，但有时命令行显示上环境已经更改但实际上所使用的python解释器没有更换，解决方法如下：\n1. 使用记事本打开编辑环境（该目录下的.bashrc存储的为个人的一些配置文件，如别名路径）\n```\nsudo gedit ~/.bashrc\n```\n2. 在末尾按照规律添加如下内容\n```\nexport PATH=\"export PATH=\"~/anaconda3/bin:$PATH\"   #base环境下的python，已有的\nalias python1=\"~/anaconda3/bin/python   # 你需要添加的\n```\n`alias`用于设置指令的别名，下面一条语句的意思就算你输入python1就会自动指向后面\n3. 使得修改生效\n```\nsource ~/.bashrc\n```\n","slug":"其他/debug/Ubuntu环境下anaconda出现的问题及解决方法","published":1,"updated":"2020-07-16T15:57:09.121Z","_id":"ckcoz8l8a005r68jsbz7w7g96","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"创建新环境报错\"><a href=\"#创建新环境报错\" class=\"headerlink\" title=\"创建新环境报错\"></a>创建新环境报错</h2><p>报错如下</p>\n<pre><code>Collecting package metadata (current_repodata.json): failed\n\nNotWritableError: The current user does not have write permissions to a required path.\n  path: /home/ziyedy/.conda/pkgs/urls.txt\n  uid: 1000\n  gid: 1000\n\nIf you feel that permissions on this path are set incorrectly, you can manually\nchange them by executing\n\n  $ sudo chown 1000:1000 /home/ziyedy/.conda/pkgs/urls.txt\n\nIn general, it&#39;s not advisable to use &#39;sudo conda&#39;.\n</code></pre><p>按照提示尝试操作没用，解决方法是命令行输入如下：</p>\n<pre><code>sudo chown -R ziyedy anaconda3 # ziyedy is user name.</code></pre><p>参考：<a href=\"https://blog.csdn.net/PecoHe/article/details/104578700\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/PecoHe/article/details/104578700</a></p>\n<h2 id=\"无法改变环境\"><a href=\"#无法改变环境\" class=\"headerlink\" title=\"无法改变环境\"></a>无法改变环境</h2><p>正常情况下输入<code>conda activate &lt;env_name&gt;</code>时，python应该改变为该环境下的python版本，可以使用<code>python -V</code>查看，但有时命令行显示上环境已经更改但实际上所使用的python解释器没有更换，解决方法如下：</p>\n<ol>\n<li>使用记事本打开编辑环境（该目录下的.bashrc存储的为个人的一些配置文件，如别名路径）<pre><code>sudo gedit ~/.bashrc</code></pre></li>\n<li>在末尾按照规律添加如下内容<pre><code>export PATH=&quot;export PATH=&quot;~/anaconda3/bin:$PATH&quot;   #base环境下的python，已有的\nalias python1=&quot;~/anaconda3/bin/python   # 你需要添加的</code></pre><code>alias</code>用于设置指令的别名，下面一条语句的意思就算你输入python1就会自动指向后面</li>\n<li>使得修改生效<pre><code>source ~/.bashrc</code></pre></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"创建新环境报错\"><a href=\"#创建新环境报错\" class=\"headerlink\" title=\"创建新环境报错\"></a>创建新环境报错</h2><p>报错如下</p>\n<pre><code>Collecting package metadata (current_repodata.json): failed\n\nNotWritableError: The current user does not have write permissions to a required path.\n  path: /home/ziyedy/.conda/pkgs/urls.txt\n  uid: 1000\n  gid: 1000\n\nIf you feel that permissions on this path are set incorrectly, you can manually\nchange them by executing\n\n  $ sudo chown 1000:1000 /home/ziyedy/.conda/pkgs/urls.txt\n\nIn general, it&#39;s not advisable to use &#39;sudo conda&#39;.\n</code></pre><p>按照提示尝试操作没用，解决方法是命令行输入如下：</p>\n<pre><code>sudo chown -R ziyedy anaconda3 # ziyedy is user name.</code></pre><p>参考：<a href=\"https://blog.csdn.net/PecoHe/article/details/104578700\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/PecoHe/article/details/104578700</a></p>\n<h2 id=\"无法改变环境\"><a href=\"#无法改变环境\" class=\"headerlink\" title=\"无法改变环境\"></a>无法改变环境</h2><p>正常情况下输入<code>conda activate &lt;env_name&gt;</code>时，python应该改变为该环境下的python版本，可以使用<code>python -V</code>查看，但有时命令行显示上环境已经更改但实际上所使用的python解释器没有更换，解决方法如下：</p>\n<ol>\n<li>使用记事本打开编辑环境（该目录下的.bashrc存储的为个人的一些配置文件，如别名路径）<pre><code>sudo gedit ~/.bashrc</code></pre></li>\n<li>在末尾按照规律添加如下内容<pre><code>export PATH=&quot;export PATH=&quot;~/anaconda3/bin:$PATH&quot;   #base环境下的python，已有的\nalias python1=&quot;~/anaconda3/bin/python   # 你需要添加的</code></pre><code>alias</code>用于设置指令的别名，下面一条语句的意思就算你输入python1就会自动指向后面</li>\n<li>使得修改生效<pre><code>source ~/.bashrc</code></pre></li>\n</ol>\n"},{"title":"git的基本命令","date":"2019-03-04T13:26:47.000Z","fileName":"git1","_content":"## Git 小记\nGit是使用最广泛的版本控制系统，加上GitHub如此闻名（假笑），所以学习Git的一些基本命令还是很重要的，本人是学习了廖雪峰老师的Git相关教程，并将其中Git的一些相关命令记录下来，方便查找，也算一个笔记（本人原来从不记笔记，现在改过自新了）。嘻嘻。\n廖雪峰老师的Git学习[传送门](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n首先应该明确的我认为有这么两个东西，即*工作区（Working Directory）*与*版本库（Repository）*。工作区可以简单理解成存放你工作内容的文件夹（本地），版本库则可以简单理解为记录你修改等操作内容的git生成的一个文件。版本库中又主要包含*暂存区*以及*分支结构master（默认）*。通过git提交项目修改之类的过程，可以简单理解为在本地进行修改后通过**git add**与**git commit**两个命令步骤，由本地到暂存区再到分支结构，这个命令的具体使用，后续会说明，这儿只对原理做一些粗略阐述。\n同时分支结构有啥用呢？我觉得不必细谈，反正就理解为n个人可以一起工作还不会乱的一种机制吧，有Git需求的人想必能够理解，在此不做赘述（三言两语我也讲不清楚嘻嘻）\n## Git 常用命令\n选中文件夹不用一个个cd输入路径，选中相应文件夹鼠标右键选择*Git Bash Here*就行。\n**PS：以下说明中<>括号内表示是你要输入的信息**\n### 初始化git仓库\n即将你选中的目录变为git管理的仓库\n```\n$ git init\n```\n\n### 提交你的修改\n提交单个文件，记得加后缀。同时file后用空格分割可以一次add很多文件\n```\n$ git add <file>\n```\n提交一个文件夹\n```\n$ git add <foldname>/\n```\n把暂存区的内容提交到当前分支（Git小记中的第二过程哦），<message>表示的是你对这此提交做的说明，类似于备忘录，方便你以后查看，同时每次使用*commit*命令后系统会生成一个id来记录这次提交，亦能方便查找\n```\n$ git commit -m <yourmessage>\n```\n\n### 查看仓库中文件修改的信息\n查看仓库当前的状态（文件增删，文件内容改变等）\n```\n$ git status\n```\n查看相应文件修改的具体内容\n```\n$ git diff <file>\n```\n显示从最近到最远的提交日志（包括上一节中你输入的说明，时间等内容），较为详细。在其之后加上相应备注后（行二），可以简略输出（id号码等等）\n```\n$ git log\n$ git log --pretty=oneline\n```\n显示你的每一次命令（可以用来查看之前的每一步操作）\n```\n$ git reflog\n```\n\n### 版本回退\nGit中有一个HEAD指针指向当前版本，而HEAD^表示上个版本，HEAD^^表示上上个版本，HEAD~n表示第n个版本。\n回退到之前的版本于回退到相应版本的命令如下，其中<commit id>相信你已经明白了，这个就是上一节信息当中的版本号。\n```\n$ git reset --hard HEAD^\n$ git reset --hard <commit id>\n```\n撤销工作区的修改，请注意这里的关键词*工作区*，也就是说这个操作只能将你还没有执行**add**命令的文件修改去除。\n```\n$ git checkout -- <file>\n```\n要去除已经使用add进入暂存区的修改，请使用以下命令命令。第一行是将暂存区的修改撤销掉（unstage），第二行就接着使用上面的命令就好，不重复写了。\n```\n$ git reset HEAD <file>\n```\n以上便是应对“工作区修改”、“暂存区修改”、“已提交”这三种情况的版本回退命令，足够应付大部分时间了。\n\n### 删除文件\n第一行命令：删除本地文件。\n第二行命令：从版本库中删除文件(删除后记得再使用commit命令提交一次)\n至于删错了恢复，请见上一节。\n```\n$ rm <file>\n$ git <file>\n```\n\n### 分支操作\n分支在第一大节也有提到，这里列出一些常用操作\n第一行为创建名称为<name>的分支，并将当前分支切换为<name>。第二行为切换当前分支为<name>。（同时，master为默认主分支）\n```\n$ git checkout -b <name>\n$ git checkout <name>\n```\n查看所有分支\n```\n$ git branch\n```\n第一行为把分支<name>合并到当前分支中。第二行为删除<name>分支。第三行为强行删除未进行合并操作的<name>分支。\n```\n$ git merge <name>\n$ git branch -d <name>\n$ git branch -D <name>\n```\n查看分区合并历史以及合并图\n```\n$ git log --graph --pretty=oneline --abbrev-commit\n```\n**PS：**同时应注意，当你在master分支与新建的分支上都进行了修改并执行了commit命令时，直接合并可能会把报错，然后你得去相关文件中手动修改一下再commit。git会在相应文件中给你进行两次修改的醒目标注，很方便\n\n### 标签操作\n大家都知道软件会有版本，比如adobe公司的一堆CS和CC，tag在Git中就起到给一个commit设定一个除去id外更容易记住的别名的作用，方便查找。默认设置tag是设置在最近一次commit上。\n以下第一行为设置一个标签；第二行为在id为commit_id的commit上设置标签；第三行在第二行的基础上给tag一点说明；第四行为查看现有所有标签；第五行查看相应标签详细信息；第六行删除一个本地标签。\n```\n$ git tag <tagname>\n$ git tag <tagname> <commit_id>\n$ git tag -a <tagname> -m <message> <commit_id>\n$ git tag\n$ git show <tagname>\ngit tag -d <tagname>\n```\n\n### 远程操作\n前面提到了GitHub，自然学git远程操作（或者理解成跟GitHub玩游戏也成）是必不可少的，本地下载了git咋和GitHub扯上关系就略过不谈了，以下记录一些相关常用操作。\n刚下好git打开就会有以下这些玩意，你也可以随时使用相应命令查看相应配置，使用**git config -1**可以查看很多信息，试试就知道。\n```\n$ git config --global user.email \"your_email@qq.com\"\n$ git config __global user.name \"your_github_name\"\n```\n将本地库与远程库相关联（origin是远程库的默认名称）\n```\n$ git remote add origin git@<server-name:path/repo-name.git>\n```\n使用*push*命令，将本地库的内容推送到远程库上(第一次)，之后每次本地修改后若要推送可用第二行命令\n```\n$ git push -u origin master\n$ git push origin master\n```\n将GitHub上的内容克隆到本地（注意你要是想对其有修改并推送，应先fork到自己的库里，再克隆）。输入git clone后将你所要克隆的网址复制后加上就好。\n```\n$ git clone <http:~>\n```\n查看远程库详细相关信息\n```\n$ git remote -v\n```\n建立远程库dev分支与本地dev的链接\n```\n$ git branch --set-upstream-to=origin/dev dev\n```\n把最新的提交抓取下来\n```\n$ git pull\n```\n\n### 有关参考\n其实很多命令压根不用记，但要去看每个操作下来git给的提示，很多后续如何操作已经写好了，你所需的往往只是做一做英语阅读。","source":"_posts/其他/工作效率/git的基本命令.md","raw":"---\ntitle: git的基本命令\ndate: 2019-03-04 21:26:47\ntags:\n    - git\ncategories:\n    - 其他\n    - 工作效率\nfileName: git1\n---\n## Git 小记\nGit是使用最广泛的版本控制系统，加上GitHub如此闻名（假笑），所以学习Git的一些基本命令还是很重要的，本人是学习了廖雪峰老师的Git相关教程，并将其中Git的一些相关命令记录下来，方便查找，也算一个笔记（本人原来从不记笔记，现在改过自新了）。嘻嘻。\n廖雪峰老师的Git学习[传送门](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n首先应该明确的我认为有这么两个东西，即*工作区（Working Directory）*与*版本库（Repository）*。工作区可以简单理解成存放你工作内容的文件夹（本地），版本库则可以简单理解为记录你修改等操作内容的git生成的一个文件。版本库中又主要包含*暂存区*以及*分支结构master（默认）*。通过git提交项目修改之类的过程，可以简单理解为在本地进行修改后通过**git add**与**git commit**两个命令步骤，由本地到暂存区再到分支结构，这个命令的具体使用，后续会说明，这儿只对原理做一些粗略阐述。\n同时分支结构有啥用呢？我觉得不必细谈，反正就理解为n个人可以一起工作还不会乱的一种机制吧，有Git需求的人想必能够理解，在此不做赘述（三言两语我也讲不清楚嘻嘻）\n## Git 常用命令\n选中文件夹不用一个个cd输入路径，选中相应文件夹鼠标右键选择*Git Bash Here*就行。\n**PS：以下说明中<>括号内表示是你要输入的信息**\n### 初始化git仓库\n即将你选中的目录变为git管理的仓库\n```\n$ git init\n```\n\n### 提交你的修改\n提交单个文件，记得加后缀。同时file后用空格分割可以一次add很多文件\n```\n$ git add <file>\n```\n提交一个文件夹\n```\n$ git add <foldname>/\n```\n把暂存区的内容提交到当前分支（Git小记中的第二过程哦），<message>表示的是你对这此提交做的说明，类似于备忘录，方便你以后查看，同时每次使用*commit*命令后系统会生成一个id来记录这次提交，亦能方便查找\n```\n$ git commit -m <yourmessage>\n```\n\n### 查看仓库中文件修改的信息\n查看仓库当前的状态（文件增删，文件内容改变等）\n```\n$ git status\n```\n查看相应文件修改的具体内容\n```\n$ git diff <file>\n```\n显示从最近到最远的提交日志（包括上一节中你输入的说明，时间等内容），较为详细。在其之后加上相应备注后（行二），可以简略输出（id号码等等）\n```\n$ git log\n$ git log --pretty=oneline\n```\n显示你的每一次命令（可以用来查看之前的每一步操作）\n```\n$ git reflog\n```\n\n### 版本回退\nGit中有一个HEAD指针指向当前版本，而HEAD^表示上个版本，HEAD^^表示上上个版本，HEAD~n表示第n个版本。\n回退到之前的版本于回退到相应版本的命令如下，其中<commit id>相信你已经明白了，这个就是上一节信息当中的版本号。\n```\n$ git reset --hard HEAD^\n$ git reset --hard <commit id>\n```\n撤销工作区的修改，请注意这里的关键词*工作区*，也就是说这个操作只能将你还没有执行**add**命令的文件修改去除。\n```\n$ git checkout -- <file>\n```\n要去除已经使用add进入暂存区的修改，请使用以下命令命令。第一行是将暂存区的修改撤销掉（unstage），第二行就接着使用上面的命令就好，不重复写了。\n```\n$ git reset HEAD <file>\n```\n以上便是应对“工作区修改”、“暂存区修改”、“已提交”这三种情况的版本回退命令，足够应付大部分时间了。\n\n### 删除文件\n第一行命令：删除本地文件。\n第二行命令：从版本库中删除文件(删除后记得再使用commit命令提交一次)\n至于删错了恢复，请见上一节。\n```\n$ rm <file>\n$ git <file>\n```\n\n### 分支操作\n分支在第一大节也有提到，这里列出一些常用操作\n第一行为创建名称为<name>的分支，并将当前分支切换为<name>。第二行为切换当前分支为<name>。（同时，master为默认主分支）\n```\n$ git checkout -b <name>\n$ git checkout <name>\n```\n查看所有分支\n```\n$ git branch\n```\n第一行为把分支<name>合并到当前分支中。第二行为删除<name>分支。第三行为强行删除未进行合并操作的<name>分支。\n```\n$ git merge <name>\n$ git branch -d <name>\n$ git branch -D <name>\n```\n查看分区合并历史以及合并图\n```\n$ git log --graph --pretty=oneline --abbrev-commit\n```\n**PS：**同时应注意，当你在master分支与新建的分支上都进行了修改并执行了commit命令时，直接合并可能会把报错，然后你得去相关文件中手动修改一下再commit。git会在相应文件中给你进行两次修改的醒目标注，很方便\n\n### 标签操作\n大家都知道软件会有版本，比如adobe公司的一堆CS和CC，tag在Git中就起到给一个commit设定一个除去id外更容易记住的别名的作用，方便查找。默认设置tag是设置在最近一次commit上。\n以下第一行为设置一个标签；第二行为在id为commit_id的commit上设置标签；第三行在第二行的基础上给tag一点说明；第四行为查看现有所有标签；第五行查看相应标签详细信息；第六行删除一个本地标签。\n```\n$ git tag <tagname>\n$ git tag <tagname> <commit_id>\n$ git tag -a <tagname> -m <message> <commit_id>\n$ git tag\n$ git show <tagname>\ngit tag -d <tagname>\n```\n\n### 远程操作\n前面提到了GitHub，自然学git远程操作（或者理解成跟GitHub玩游戏也成）是必不可少的，本地下载了git咋和GitHub扯上关系就略过不谈了，以下记录一些相关常用操作。\n刚下好git打开就会有以下这些玩意，你也可以随时使用相应命令查看相应配置，使用**git config -1**可以查看很多信息，试试就知道。\n```\n$ git config --global user.email \"your_email@qq.com\"\n$ git config __global user.name \"your_github_name\"\n```\n将本地库与远程库相关联（origin是远程库的默认名称）\n```\n$ git remote add origin git@<server-name:path/repo-name.git>\n```\n使用*push*命令，将本地库的内容推送到远程库上(第一次)，之后每次本地修改后若要推送可用第二行命令\n```\n$ git push -u origin master\n$ git push origin master\n```\n将GitHub上的内容克隆到本地（注意你要是想对其有修改并推送，应先fork到自己的库里，再克隆）。输入git clone后将你所要克隆的网址复制后加上就好。\n```\n$ git clone <http:~>\n```\n查看远程库详细相关信息\n```\n$ git remote -v\n```\n建立远程库dev分支与本地dev的链接\n```\n$ git branch --set-upstream-to=origin/dev dev\n```\n把最新的提交抓取下来\n```\n$ git pull\n```\n\n### 有关参考\n其实很多命令压根不用记，但要去看每个操作下来git给的提示，很多后续如何操作已经写好了，你所需的往往只是做一做英语阅读。","slug":"其他/工作效率/git的基本命令","published":1,"updated":"2020-07-16T15:57:43.212Z","_id":"ckcoz8rn5005v68js7lj4h3gp","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"Git-小记\"><a href=\"#Git-小记\" class=\"headerlink\" title=\"Git 小记\"></a>Git 小记</h2><p>Git是使用最广泛的版本控制系统，加上GitHub如此闻名（假笑），所以学习Git的一些基本命令还是很重要的，本人是学习了廖雪峰老师的Git相关教程，并将其中Git的一些相关命令记录下来，方便查找，也算一个笔记（本人原来从不记笔记，现在改过自新了）。嘻嘻。<br>廖雪峰老师的Git学习<a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">传送门</a><br>首先应该明确的我认为有这么两个东西，即<em>工作区（Working Directory）</em>与<em>版本库（Repository）</em>。工作区可以简单理解成存放你工作内容的文件夹（本地），版本库则可以简单理解为记录你修改等操作内容的git生成的一个文件。版本库中又主要包含<em>暂存区</em>以及<em>分支结构master（默认）</em>。通过git提交项目修改之类的过程，可以简单理解为在本地进行修改后通过<strong>git add</strong>与<strong>git commit</strong>两个命令步骤，由本地到暂存区再到分支结构，这个命令的具体使用，后续会说明，这儿只对原理做一些粗略阐述。<br>同时分支结构有啥用呢？我觉得不必细谈，反正就理解为n个人可以一起工作还不会乱的一种机制吧，有Git需求的人想必能够理解，在此不做赘述（三言两语我也讲不清楚嘻嘻）</p>\n<h2 id=\"Git-常用命令\"><a href=\"#Git-常用命令\" class=\"headerlink\" title=\"Git 常用命令\"></a>Git 常用命令</h2><p>选中文件夹不用一个个cd输入路径，选中相应文件夹鼠标右键选择<em>Git Bash Here</em>就行。<br><strong>PS：以下说明中&lt;&gt;括号内表示是你要输入的信息</strong></p>\n<h3 id=\"初始化git仓库\"><a href=\"#初始化git仓库\" class=\"headerlink\" title=\"初始化git仓库\"></a>初始化git仓库</h3><p>即将你选中的目录变为git管理的仓库</p>\n<pre><code>$ git init</code></pre><h3 id=\"提交你的修改\"><a href=\"#提交你的修改\" class=\"headerlink\" title=\"提交你的修改\"></a>提交你的修改</h3><p>提交单个文件，记得加后缀。同时file后用空格分割可以一次add很多文件</p>\n<pre><code>$ git add &lt;file&gt;</code></pre><p>提交一个文件夹</p>\n<pre><code>$ git add &lt;foldname&gt;/</code></pre><p>把暂存区的内容提交到当前分支（Git小记中的第二过程哦），<message>表示的是你对这此提交做的说明，类似于备忘录，方便你以后查看，同时每次使用<em>commit</em>命令后系统会生成一个id来记录这次提交，亦能方便查找</message></p>\n<pre><code>$ git commit -m &lt;yourmessage&gt;</code></pre><h3 id=\"查看仓库中文件修改的信息\"><a href=\"#查看仓库中文件修改的信息\" class=\"headerlink\" title=\"查看仓库中文件修改的信息\"></a>查看仓库中文件修改的信息</h3><p>查看仓库当前的状态（文件增删，文件内容改变等）</p>\n<pre><code>$ git status</code></pre><p>查看相应文件修改的具体内容</p>\n<pre><code>$ git diff &lt;file&gt;</code></pre><p>显示从最近到最远的提交日志（包括上一节中你输入的说明，时间等内容），较为详细。在其之后加上相应备注后（行二），可以简略输出（id号码等等）</p>\n<pre><code>$ git log\n$ git log --pretty=oneline</code></pre><p>显示你的每一次命令（可以用来查看之前的每一步操作）</p>\n<pre><code>$ git reflog</code></pre><h3 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h3><p>Git中有一个HEAD指针指向当前版本，而HEAD^表示上个版本，HEAD^^表示上上个版本，HEAD~n表示第n个版本。<br>回退到之前的版本于回退到相应版本的命令如下，其中<commit id>相信你已经明白了，这个就是上一节信息当中的版本号。</commit></p>\n<pre><code>$ git reset --hard HEAD^\n$ git reset --hard &lt;commit id&gt;</code></pre><p>撤销工作区的修改，请注意这里的关键词<em>工作区</em>，也就是说这个操作只能将你还没有执行<strong>add</strong>命令的文件修改去除。</p>\n<pre><code>$ git checkout -- &lt;file&gt;</code></pre><p>要去除已经使用add进入暂存区的修改，请使用以下命令命令。第一行是将暂存区的修改撤销掉（unstage），第二行就接着使用上面的命令就好，不重复写了。</p>\n<pre><code>$ git reset HEAD &lt;file&gt;</code></pre><p>以上便是应对“工作区修改”、“暂存区修改”、“已提交”这三种情况的版本回退命令，足够应付大部分时间了。</p>\n<h3 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h3><p>第一行命令：删除本地文件。<br>第二行命令：从版本库中删除文件(删除后记得再使用commit命令提交一次)<br>至于删错了恢复，请见上一节。</p>\n<pre><code>$ rm &lt;file&gt;\n$ git &lt;file&gt;</code></pre><h3 id=\"分支操作\"><a href=\"#分支操作\" class=\"headerlink\" title=\"分支操作\"></a>分支操作</h3><p>分支在第一大节也有提到，这里列出一些常用操作<br>第一行为创建名称为<name>的分支，并将当前分支切换为<name>。第二行为切换当前分支为<name>。（同时，master为默认主分支）</name></name></name></p>\n<pre><code>$ git checkout -b &lt;name&gt;\n$ git checkout &lt;name&gt;</code></pre><p>查看所有分支</p>\n<pre><code>$ git branch</code></pre><p>第一行为把分支<name>合并到当前分支中。第二行为删除<name>分支。第三行为强行删除未进行合并操作的<name>分支。</name></name></name></p>\n<pre><code>$ git merge &lt;name&gt;\n$ git branch -d &lt;name&gt;\n$ git branch -D &lt;name&gt;</code></pre><p>查看分区合并历史以及合并图</p>\n<pre><code>$ git log --graph --pretty=oneline --abbrev-commit</code></pre><p><strong>PS：</strong>同时应注意，当你在master分支与新建的分支上都进行了修改并执行了commit命令时，直接合并可能会把报错，然后你得去相关文件中手动修改一下再commit。git会在相应文件中给你进行两次修改的醒目标注，很方便</p>\n<h3 id=\"标签操作\"><a href=\"#标签操作\" class=\"headerlink\" title=\"标签操作\"></a>标签操作</h3><p>大家都知道软件会有版本，比如adobe公司的一堆CS和CC，tag在Git中就起到给一个commit设定一个除去id外更容易记住的别名的作用，方便查找。默认设置tag是设置在最近一次commit上。<br>以下第一行为设置一个标签；第二行为在id为commit_id的commit上设置标签；第三行在第二行的基础上给tag一点说明；第四行为查看现有所有标签；第五行查看相应标签详细信息；第六行删除一个本地标签。</p>\n<pre><code>$ git tag &lt;tagname&gt;\n$ git tag &lt;tagname&gt; &lt;commit_id&gt;\n$ git tag -a &lt;tagname&gt; -m &lt;message&gt; &lt;commit_id&gt;\n$ git tag\n$ git show &lt;tagname&gt;\ngit tag -d &lt;tagname&gt;</code></pre><h3 id=\"远程操作\"><a href=\"#远程操作\" class=\"headerlink\" title=\"远程操作\"></a>远程操作</h3><p>前面提到了GitHub，自然学git远程操作（或者理解成跟GitHub玩游戏也成）是必不可少的，本地下载了git咋和GitHub扯上关系就略过不谈了，以下记录一些相关常用操作。<br>刚下好git打开就会有以下这些玩意，你也可以随时使用相应命令查看相应配置，使用<strong>git config -1</strong>可以查看很多信息，试试就知道。</p>\n<pre><code>$ git config --global user.email &quot;your_email@qq.com&quot;\n$ git config __global user.name &quot;your_github_name&quot;</code></pre><p>将本地库与远程库相关联（origin是远程库的默认名称）</p>\n<pre><code>$ git remote add origin git@&lt;server-name:path/repo-name.git&gt;</code></pre><p>使用<em>push</em>命令，将本地库的内容推送到远程库上(第一次)，之后每次本地修改后若要推送可用第二行命令</p>\n<pre><code>$ git push -u origin master\n$ git push origin master</code></pre><p>将GitHub上的内容克隆到本地（注意你要是想对其有修改并推送，应先fork到自己的库里，再克隆）。输入git clone后将你所要克隆的网址复制后加上就好。</p>\n<pre><code>$ git clone &lt;http:~&gt;</code></pre><p>查看远程库详细相关信息</p>\n<pre><code>$ git remote -v</code></pre><p>建立远程库dev分支与本地dev的链接</p>\n<pre><code>$ git branch --set-upstream-to=origin/dev dev</code></pre><p>把最新的提交抓取下来</p>\n<pre><code>$ git pull</code></pre><h3 id=\"有关参考\"><a href=\"#有关参考\" class=\"headerlink\" title=\"有关参考\"></a>有关参考</h3><p>其实很多命令压根不用记，但要去看每个操作下来git给的提示，很多后续如何操作已经写好了，你所需的往往只是做一做英语阅读。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Git-小记\"><a href=\"#Git-小记\" class=\"headerlink\" title=\"Git 小记\"></a>Git 小记</h2><p>Git是使用最广泛的版本控制系统，加上GitHub如此闻名（假笑），所以学习Git的一些基本命令还是很重要的，本人是学习了廖雪峰老师的Git相关教程，并将其中Git的一些相关命令记录下来，方便查找，也算一个笔记（本人原来从不记笔记，现在改过自新了）。嘻嘻。<br>廖雪峰老师的Git学习<a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">传送门</a><br>首先应该明确的我认为有这么两个东西，即<em>工作区（Working Directory）</em>与<em>版本库（Repository）</em>。工作区可以简单理解成存放你工作内容的文件夹（本地），版本库则可以简单理解为记录你修改等操作内容的git生成的一个文件。版本库中又主要包含<em>暂存区</em>以及<em>分支结构master（默认）</em>。通过git提交项目修改之类的过程，可以简单理解为在本地进行修改后通过<strong>git add</strong>与<strong>git commit</strong>两个命令步骤，由本地到暂存区再到分支结构，这个命令的具体使用，后续会说明，这儿只对原理做一些粗略阐述。<br>同时分支结构有啥用呢？我觉得不必细谈，反正就理解为n个人可以一起工作还不会乱的一种机制吧，有Git需求的人想必能够理解，在此不做赘述（三言两语我也讲不清楚嘻嘻）</p>\n<h2 id=\"Git-常用命令\"><a href=\"#Git-常用命令\" class=\"headerlink\" title=\"Git 常用命令\"></a>Git 常用命令</h2><p>选中文件夹不用一个个cd输入路径，选中相应文件夹鼠标右键选择<em>Git Bash Here</em>就行。<br><strong>PS：以下说明中&lt;&gt;括号内表示是你要输入的信息</strong></p>\n<h3 id=\"初始化git仓库\"><a href=\"#初始化git仓库\" class=\"headerlink\" title=\"初始化git仓库\"></a>初始化git仓库</h3><p>即将你选中的目录变为git管理的仓库</p>\n<pre><code>$ git init</code></pre><h3 id=\"提交你的修改\"><a href=\"#提交你的修改\" class=\"headerlink\" title=\"提交你的修改\"></a>提交你的修改</h3><p>提交单个文件，记得加后缀。同时file后用空格分割可以一次add很多文件</p>\n<pre><code>$ git add &lt;file&gt;</code></pre><p>提交一个文件夹</p>\n<pre><code>$ git add &lt;foldname&gt;/</code></pre><p>把暂存区的内容提交到当前分支（Git小记中的第二过程哦），<message>表示的是你对这此提交做的说明，类似于备忘录，方便你以后查看，同时每次使用<em>commit</em>命令后系统会生成一个id来记录这次提交，亦能方便查找</message></p>\n<pre><code>$ git commit -m &lt;yourmessage&gt;</code></pre><h3 id=\"查看仓库中文件修改的信息\"><a href=\"#查看仓库中文件修改的信息\" class=\"headerlink\" title=\"查看仓库中文件修改的信息\"></a>查看仓库中文件修改的信息</h3><p>查看仓库当前的状态（文件增删，文件内容改变等）</p>\n<pre><code>$ git status</code></pre><p>查看相应文件修改的具体内容</p>\n<pre><code>$ git diff &lt;file&gt;</code></pre><p>显示从最近到最远的提交日志（包括上一节中你输入的说明，时间等内容），较为详细。在其之后加上相应备注后（行二），可以简略输出（id号码等等）</p>\n<pre><code>$ git log\n$ git log --pretty=oneline</code></pre><p>显示你的每一次命令（可以用来查看之前的每一步操作）</p>\n<pre><code>$ git reflog</code></pre><h3 id=\"版本回退\"><a href=\"#版本回退\" class=\"headerlink\" title=\"版本回退\"></a>版本回退</h3><p>Git中有一个HEAD指针指向当前版本，而HEAD^表示上个版本，HEAD^^表示上上个版本，HEAD~n表示第n个版本。<br>回退到之前的版本于回退到相应版本的命令如下，其中<commit id>相信你已经明白了，这个就是上一节信息当中的版本号。</commit></p>\n<pre><code>$ git reset --hard HEAD^\n$ git reset --hard &lt;commit id&gt;</code></pre><p>撤销工作区的修改，请注意这里的关键词<em>工作区</em>，也就是说这个操作只能将你还没有执行<strong>add</strong>命令的文件修改去除。</p>\n<pre><code>$ git checkout -- &lt;file&gt;</code></pre><p>要去除已经使用add进入暂存区的修改，请使用以下命令命令。第一行是将暂存区的修改撤销掉（unstage），第二行就接着使用上面的命令就好，不重复写了。</p>\n<pre><code>$ git reset HEAD &lt;file&gt;</code></pre><p>以上便是应对“工作区修改”、“暂存区修改”、“已提交”这三种情况的版本回退命令，足够应付大部分时间了。</p>\n<h3 id=\"删除文件\"><a href=\"#删除文件\" class=\"headerlink\" title=\"删除文件\"></a>删除文件</h3><p>第一行命令：删除本地文件。<br>第二行命令：从版本库中删除文件(删除后记得再使用commit命令提交一次)<br>至于删错了恢复，请见上一节。</p>\n<pre><code>$ rm &lt;file&gt;\n$ git &lt;file&gt;</code></pre><h3 id=\"分支操作\"><a href=\"#分支操作\" class=\"headerlink\" title=\"分支操作\"></a>分支操作</h3><p>分支在第一大节也有提到，这里列出一些常用操作<br>第一行为创建名称为<name>的分支，并将当前分支切换为<name>。第二行为切换当前分支为<name>。（同时，master为默认主分支）</name></name></name></p>\n<pre><code>$ git checkout -b &lt;name&gt;\n$ git checkout &lt;name&gt;</code></pre><p>查看所有分支</p>\n<pre><code>$ git branch</code></pre><p>第一行为把分支<name>合并到当前分支中。第二行为删除<name>分支。第三行为强行删除未进行合并操作的<name>分支。</name></name></name></p>\n<pre><code>$ git merge &lt;name&gt;\n$ git branch -d &lt;name&gt;\n$ git branch -D &lt;name&gt;</code></pre><p>查看分区合并历史以及合并图</p>\n<pre><code>$ git log --graph --pretty=oneline --abbrev-commit</code></pre><p><strong>PS：</strong>同时应注意，当你在master分支与新建的分支上都进行了修改并执行了commit命令时，直接合并可能会把报错，然后你得去相关文件中手动修改一下再commit。git会在相应文件中给你进行两次修改的醒目标注，很方便</p>\n<h3 id=\"标签操作\"><a href=\"#标签操作\" class=\"headerlink\" title=\"标签操作\"></a>标签操作</h3><p>大家都知道软件会有版本，比如adobe公司的一堆CS和CC，tag在Git中就起到给一个commit设定一个除去id外更容易记住的别名的作用，方便查找。默认设置tag是设置在最近一次commit上。<br>以下第一行为设置一个标签；第二行为在id为commit_id的commit上设置标签；第三行在第二行的基础上给tag一点说明；第四行为查看现有所有标签；第五行查看相应标签详细信息；第六行删除一个本地标签。</p>\n<pre><code>$ git tag &lt;tagname&gt;\n$ git tag &lt;tagname&gt; &lt;commit_id&gt;\n$ git tag -a &lt;tagname&gt; -m &lt;message&gt; &lt;commit_id&gt;\n$ git tag\n$ git show &lt;tagname&gt;\ngit tag -d &lt;tagname&gt;</code></pre><h3 id=\"远程操作\"><a href=\"#远程操作\" class=\"headerlink\" title=\"远程操作\"></a>远程操作</h3><p>前面提到了GitHub，自然学git远程操作（或者理解成跟GitHub玩游戏也成）是必不可少的，本地下载了git咋和GitHub扯上关系就略过不谈了，以下记录一些相关常用操作。<br>刚下好git打开就会有以下这些玩意，你也可以随时使用相应命令查看相应配置，使用<strong>git config -1</strong>可以查看很多信息，试试就知道。</p>\n<pre><code>$ git config --global user.email &quot;your_email@qq.com&quot;\n$ git config __global user.name &quot;your_github_name&quot;</code></pre><p>将本地库与远程库相关联（origin是远程库的默认名称）</p>\n<pre><code>$ git remote add origin git@&lt;server-name:path/repo-name.git&gt;</code></pre><p>使用<em>push</em>命令，将本地库的内容推送到远程库上(第一次)，之后每次本地修改后若要推送可用第二行命令</p>\n<pre><code>$ git push -u origin master\n$ git push origin master</code></pre><p>将GitHub上的内容克隆到本地（注意你要是想对其有修改并推送，应先fork到自己的库里，再克隆）。输入git clone后将你所要克隆的网址复制后加上就好。</p>\n<pre><code>$ git clone &lt;http:~&gt;</code></pre><p>查看远程库详细相关信息</p>\n<pre><code>$ git remote -v</code></pre><p>建立远程库dev分支与本地dev的链接</p>\n<pre><code>$ git branch --set-upstream-to=origin/dev dev</code></pre><p>把最新的提交抓取下来</p>\n<pre><code>$ git pull</code></pre><h3 id=\"有关参考\"><a href=\"#有关参考\" class=\"headerlink\" title=\"有关参考\"></a>有关参考</h3><p>其实很多命令压根不用记，但要去看每个操作下来git给的提示，很多后续如何操作已经写好了，你所需的往往只是做一做英语阅读。</p>\n"},{"title":"latex基本用法","date":"2019-02-20T13:48:16.000Z","fileName":"latex1","_content":"谈到码字与排版大家首先想到的一定是word等办公软件，即一些“所见即所得”的排版与“码字”软件，这些软件功能强大足够应付日常的一切工作。\n但当大家有英文论文的写作与排版需求时，尤其是面对美赛这种“英文写作比赛”时，输出的PDF文件的美观性就尤其重要了（本人也是因为美赛才接触了latex这个让人又爱又恨的软件）。出于实用与给自己进行用法记录的目的，我也就不拿软件的历史之类的凑字数了，直接上可以产生效果的东西。\n**PS：**我个人认为latex 与HTML之类的标签语言十分相似，学习成本低，易用难精（也没必要精），因此本文只针对相应排版的具体问题，不涉及任何latex的理论与底层问题，想精学的朋友建议移步刘海洋的《LaTeX入门》（可以联系本人电子版），同时有其他问题建议百度搜索或混混相应论坛，这儿给一个tackle problems的[传送门](http://www.latexstudio.net/),下载TEXLive请移步[传送](http://tug.org/texlive/),选择相应版本后耐心等待。\n**以下未经说明使用TeXworks编辑器，编译方式选择XELaTeX**\n\n## 目录及其相关设置\n```\n\\tableofcontents            %插入目录，由于latex的“交叉引用”，注意应编译两次\n\\thispagestyle{empty}       %设置目录页不计入页码，用于文章其他部位亦可\n\\clearpage                  %该语句使得文章后面内容另起一页显示，此处使得目录单独写在一页\n\\setcounter{page}{1}        %设置目录后正文第一页目录计数为1\n```\n\n## 正文文章结构的设置\n```\n\\section{一级标题内容}\n正文\n\\subsection{二级标题内容}\n正文\n\\subsubsection{三级标题内容}\n正文\n```\n以上模式相信用过word的朋友都很容易理解了，同时通过上一条所述的目录内容会根据正文中的\\section{}等标签自动生成文章目录，十分方便。\n\n## 字体字号的常用设置\nlatex中包含了很多种字体，但如果没有特殊需求，我认为以下内容完全能够满足需要了\n```\n\\textbf{内容}       %将大括号内字体加粗\n\\textit{内容}       %将大括号内字体变为斜体\n\\emph{内容}         %强调括号内字体内容\n```\n\n## 列表环境\n### 有计数的列表\n```\n\\begin{enumerate}\n    \\item 内容1\n    \\item 内容2\n\\end{enumerate}\n```\n### 无计数的列表（bulleted list）\n```\n\\begin{itemize}\n    \\item 内容1\n    \\item 内容2\n\\end{itemize}\n```\n### 复杂列表\n同时上述各个列表可以相互嵌套，如下即为在一个bulleted list下又嵌套了一个计数列表。\n```\n\\begin{itemize}\n    \\item 内容1\n    \\begin{enumerate}\n        \\item 内容1.1\n        \\item 内容1.2\n    \\end{enumerate}\n\\end{itemize}\n```\n\n## 插入图片\n在正文中插入图片很简单，如果你没有特殊的需求copy下面这段代码并且更改里面一些参数完全够用了，图片的资源文件和其他开发都是一样的，建议在根目录下建立一个img文件夹专门存放，同时记得将文件的命名与格式搞清楚。\n```\n%下行代码中[]内为可选项意义分别为\n%h 代表here,将表格排在当前文字位置\n%t 表示将表格放在下一页的 top (页首)\n%b 表示将表格放在当前页的 bottom (底部)\n%! 表示忽略美观因素，尽可能按照参数指定的方式来处理表格浮动位置\n\\begin{figure}[h]\n    \\centering      %使图片居中\n    %下面这行可以简单理解为载入图片的函数，width=0.6\\textwidth是将图片等比例设为宽度为0.6个间页长（排版的名词不大记得可以简单这么理解），你也可以使用px之类的将其设置为定宽。后面大括号内一定得是如image1.jpg这种格式，后缀不能漏\n    \\includegraphics[width=0.6\\textwidth]{加后缀的图片名}\n    \\caption{图片的名称}    %大括号内为页面显示的图片的名称\n    \\label{fig:1}          %设置图片的标签方便交叉引用\n\\end{figure}\n```\n\n## 插入表格\n表格是一切论文或其他议论文体中非常常见的数据表达形式，由于数据的不同各种类型多种多样，不想上节所述的图片那么一段代码打天下，所以表格内容较多，我尽量将我认为的常用的表格形式的通用代码附上，同时也列举一下表格的基本形式，方便读者进行变换。\n### 普通表格\n普通表格是指一个没有任何改动的最基本的表格（参考word你便知道样式），我也可以借由此说明一下表格中的一些常用参数\n同时，如\\centering；\\caption{};\\label{}等操作，与上一节所述关于图片相同\n```\n\\begin{table}[!htb] %[]内与上一节所述图片相同\n    \\begin{tabular}{|c|r|l|}    %后一个括号内c代表居中，r代表靠右，l代表靠左，|为表格竖线，可以舍去\n        \\hline  %为表格横线，可以舍去\n        内容1 & 内容2 & 内容3 \\\\    %每个单元格间由&分开，\\\\表示换行\n        \\hline\n        内容4 & 内容5 & 内容6 \\\\\n        \\hline\n    \\end{tabular}\n\\end{table}\n```\n### 表格其他的常用设置\n重新定义表格线的宽度代码如下，可随意更改使用相应代号的名称。使用时找到代码相应位置进行相应更改即可。\n注意：**以下内容要放在导言区**\n```\n%定义表格横线\\ttline的线宽为1.4pt，使用时用\\ttline代替上一节中的\\hline即可\n\\newcommand{\\ttline}{\n    \\noalign {\\ifnum 0=`}\\fi \\hrule height 1.4pt\n    \\futurelet \\reserved@a \\@xhline\n}\n%重定义表格竖线！的线宽为2pt，使用时用！代替上一节中的|即可\n\\newcolumntype{!}{@{\\hskip\\tabcolsep\\vrule width 2pt\\hskip\\tabcolsep}}\n\\makeatother\n```\n剩下的一些小功能如下：\n```\n%设置表格标题置于表格上面（默认置于下面）\n\\setlength{\\belowcaptionskip}{6pt}  %置于表格上面6pt\n\n%如果想单独使一个单元格居中，可以这么写\n\\multicolumn{1}{c}{content}\n\n%想调整表格上下间距，可以在\\begin{table}前加（同样适用于更改正文行距）\n\\linespread{倍数} %更改后值为 倍数*默认间距\n\n%合并单元格，合并行列可以使用以下公式进行嵌套\n\\multicolumn{项数}{新列格式}{单元格内容} %合并列\n\\multirow{项数}{新列格式}{单元格内容} %合并行\n\n\\cline{2-3} %表示画出一条位于第2列到第3列的横线段，其他列将不会有横线段\n```\n### 几种特殊表格代码\n下面是几种相对特殊的表格的代码，根据这些代码结合前两小节的内容更改相应部分即可完成自己的制定。\n```\n\\linespread{1.1}\n\\begin{table}[h]\n\\setlength{\\belowcaptionskip}{6pt}\\centering\\caption{dia test}\\label{tab:dia}\n\\begin{tabular}{ccc}\\ttline\n\\diagbox{test1}{test2} & altitude & vavlue \\\\ \\tline\ntesta & $22.2$ & $22.1$ \\\\ \ntestb & $1.22$ & $2.22$ \\\\\n\\end{tabular}\n\\end{table}\n```\n此种表格应记住在导言区加上 **\\usepackage{diagbox}**\n![示例1](/assets/BlogPic/2.1/t1.png)\n三线表是各种论文中较为常用的部分，代码与示例见下\n\n## 插入公式及其他数学式\n公式环境与图片和表格类似，也可以自动编号以及使用交叉引用，只需设置好\\label{}内容即可，具体如下：\n### 公式环境\n一般公式编辑：\n```\n\\begin{equation}\n    公式内容\n    \\label{eq:1}\n\\end{equation}\n```\n分段函数模板：\n```\n\\begin{equation}\np_{j}=\\begin{cases} \n    0,j=2\\\\\n    1,j=1\n\\end{cases}\n\\label{}\n\\end{equation}\n```\n### 常见数学公式的编辑","source":"_posts/其他/工作效率/latex基本用法.md","raw":"---\ntitle: latex基本用法\ndate: 2019-02-20 21:48:16\ntags:\n    - latex\n    - 论文\ncategories:\n    - 其他\n    - 工作效率\nfileName: latex1\n---\n谈到码字与排版大家首先想到的一定是word等办公软件，即一些“所见即所得”的排版与“码字”软件，这些软件功能强大足够应付日常的一切工作。\n但当大家有英文论文的写作与排版需求时，尤其是面对美赛这种“英文写作比赛”时，输出的PDF文件的美观性就尤其重要了（本人也是因为美赛才接触了latex这个让人又爱又恨的软件）。出于实用与给自己进行用法记录的目的，我也就不拿软件的历史之类的凑字数了，直接上可以产生效果的东西。\n**PS：**我个人认为latex 与HTML之类的标签语言十分相似，学习成本低，易用难精（也没必要精），因此本文只针对相应排版的具体问题，不涉及任何latex的理论与底层问题，想精学的朋友建议移步刘海洋的《LaTeX入门》（可以联系本人电子版），同时有其他问题建议百度搜索或混混相应论坛，这儿给一个tackle problems的[传送门](http://www.latexstudio.net/),下载TEXLive请移步[传送](http://tug.org/texlive/),选择相应版本后耐心等待。\n**以下未经说明使用TeXworks编辑器，编译方式选择XELaTeX**\n\n## 目录及其相关设置\n```\n\\tableofcontents            %插入目录，由于latex的“交叉引用”，注意应编译两次\n\\thispagestyle{empty}       %设置目录页不计入页码，用于文章其他部位亦可\n\\clearpage                  %该语句使得文章后面内容另起一页显示，此处使得目录单独写在一页\n\\setcounter{page}{1}        %设置目录后正文第一页目录计数为1\n```\n\n## 正文文章结构的设置\n```\n\\section{一级标题内容}\n正文\n\\subsection{二级标题内容}\n正文\n\\subsubsection{三级标题内容}\n正文\n```\n以上模式相信用过word的朋友都很容易理解了，同时通过上一条所述的目录内容会根据正文中的\\section{}等标签自动生成文章目录，十分方便。\n\n## 字体字号的常用设置\nlatex中包含了很多种字体，但如果没有特殊需求，我认为以下内容完全能够满足需要了\n```\n\\textbf{内容}       %将大括号内字体加粗\n\\textit{内容}       %将大括号内字体变为斜体\n\\emph{内容}         %强调括号内字体内容\n```\n\n## 列表环境\n### 有计数的列表\n```\n\\begin{enumerate}\n    \\item 内容1\n    \\item 内容2\n\\end{enumerate}\n```\n### 无计数的列表（bulleted list）\n```\n\\begin{itemize}\n    \\item 内容1\n    \\item 内容2\n\\end{itemize}\n```\n### 复杂列表\n同时上述各个列表可以相互嵌套，如下即为在一个bulleted list下又嵌套了一个计数列表。\n```\n\\begin{itemize}\n    \\item 内容1\n    \\begin{enumerate}\n        \\item 内容1.1\n        \\item 内容1.2\n    \\end{enumerate}\n\\end{itemize}\n```\n\n## 插入图片\n在正文中插入图片很简单，如果你没有特殊的需求copy下面这段代码并且更改里面一些参数完全够用了，图片的资源文件和其他开发都是一样的，建议在根目录下建立一个img文件夹专门存放，同时记得将文件的命名与格式搞清楚。\n```\n%下行代码中[]内为可选项意义分别为\n%h 代表here,将表格排在当前文字位置\n%t 表示将表格放在下一页的 top (页首)\n%b 表示将表格放在当前页的 bottom (底部)\n%! 表示忽略美观因素，尽可能按照参数指定的方式来处理表格浮动位置\n\\begin{figure}[h]\n    \\centering      %使图片居中\n    %下面这行可以简单理解为载入图片的函数，width=0.6\\textwidth是将图片等比例设为宽度为0.6个间页长（排版的名词不大记得可以简单这么理解），你也可以使用px之类的将其设置为定宽。后面大括号内一定得是如image1.jpg这种格式，后缀不能漏\n    \\includegraphics[width=0.6\\textwidth]{加后缀的图片名}\n    \\caption{图片的名称}    %大括号内为页面显示的图片的名称\n    \\label{fig:1}          %设置图片的标签方便交叉引用\n\\end{figure}\n```\n\n## 插入表格\n表格是一切论文或其他议论文体中非常常见的数据表达形式，由于数据的不同各种类型多种多样，不想上节所述的图片那么一段代码打天下，所以表格内容较多，我尽量将我认为的常用的表格形式的通用代码附上，同时也列举一下表格的基本形式，方便读者进行变换。\n### 普通表格\n普通表格是指一个没有任何改动的最基本的表格（参考word你便知道样式），我也可以借由此说明一下表格中的一些常用参数\n同时，如\\centering；\\caption{};\\label{}等操作，与上一节所述关于图片相同\n```\n\\begin{table}[!htb] %[]内与上一节所述图片相同\n    \\begin{tabular}{|c|r|l|}    %后一个括号内c代表居中，r代表靠右，l代表靠左，|为表格竖线，可以舍去\n        \\hline  %为表格横线，可以舍去\n        内容1 & 内容2 & 内容3 \\\\    %每个单元格间由&分开，\\\\表示换行\n        \\hline\n        内容4 & 内容5 & 内容6 \\\\\n        \\hline\n    \\end{tabular}\n\\end{table}\n```\n### 表格其他的常用设置\n重新定义表格线的宽度代码如下，可随意更改使用相应代号的名称。使用时找到代码相应位置进行相应更改即可。\n注意：**以下内容要放在导言区**\n```\n%定义表格横线\\ttline的线宽为1.4pt，使用时用\\ttline代替上一节中的\\hline即可\n\\newcommand{\\ttline}{\n    \\noalign {\\ifnum 0=`}\\fi \\hrule height 1.4pt\n    \\futurelet \\reserved@a \\@xhline\n}\n%重定义表格竖线！的线宽为2pt，使用时用！代替上一节中的|即可\n\\newcolumntype{!}{@{\\hskip\\tabcolsep\\vrule width 2pt\\hskip\\tabcolsep}}\n\\makeatother\n```\n剩下的一些小功能如下：\n```\n%设置表格标题置于表格上面（默认置于下面）\n\\setlength{\\belowcaptionskip}{6pt}  %置于表格上面6pt\n\n%如果想单独使一个单元格居中，可以这么写\n\\multicolumn{1}{c}{content}\n\n%想调整表格上下间距，可以在\\begin{table}前加（同样适用于更改正文行距）\n\\linespread{倍数} %更改后值为 倍数*默认间距\n\n%合并单元格，合并行列可以使用以下公式进行嵌套\n\\multicolumn{项数}{新列格式}{单元格内容} %合并列\n\\multirow{项数}{新列格式}{单元格内容} %合并行\n\n\\cline{2-3} %表示画出一条位于第2列到第3列的横线段，其他列将不会有横线段\n```\n### 几种特殊表格代码\n下面是几种相对特殊的表格的代码，根据这些代码结合前两小节的内容更改相应部分即可完成自己的制定。\n```\n\\linespread{1.1}\n\\begin{table}[h]\n\\setlength{\\belowcaptionskip}{6pt}\\centering\\caption{dia test}\\label{tab:dia}\n\\begin{tabular}{ccc}\\ttline\n\\diagbox{test1}{test2} & altitude & vavlue \\\\ \\tline\ntesta & $22.2$ & $22.1$ \\\\ \ntestb & $1.22$ & $2.22$ \\\\\n\\end{tabular}\n\\end{table}\n```\n此种表格应记住在导言区加上 **\\usepackage{diagbox}**\n![示例1](/assets/BlogPic/2.1/t1.png)\n三线表是各种论文中较为常用的部分，代码与示例见下\n\n## 插入公式及其他数学式\n公式环境与图片和表格类似，也可以自动编号以及使用交叉引用，只需设置好\\label{}内容即可，具体如下：\n### 公式环境\n一般公式编辑：\n```\n\\begin{equation}\n    公式内容\n    \\label{eq:1}\n\\end{equation}\n```\n分段函数模板：\n```\n\\begin{equation}\np_{j}=\\begin{cases} \n    0,j=2\\\\\n    1,j=1\n\\end{cases}\n\\label{}\n\\end{equation}\n```\n### 常见数学公式的编辑","slug":"其他/工作效率/latex基本用法","published":1,"updated":"2020-07-16T15:57:52.892Z","_id":"ckcoz8rn7005z68js74zg71gb","comments":1,"layout":"post","photos":[],"link":"","content":"<p>谈到码字与排版大家首先想到的一定是word等办公软件，即一些“所见即所得”的排版与“码字”软件，这些软件功能强大足够应付日常的一切工作。<br>但当大家有英文论文的写作与排版需求时，尤其是面对美赛这种“英文写作比赛”时，输出的PDF文件的美观性就尤其重要了（本人也是因为美赛才接触了latex这个让人又爱又恨的软件）。出于实用与给自己进行用法记录的目的，我也就不拿软件的历史之类的凑字数了，直接上可以产生效果的东西。<br><strong>PS：</strong>我个人认为latex 与HTML之类的标签语言十分相似，学习成本低，易用难精（也没必要精），因此本文只针对相应排版的具体问题，不涉及任何latex的理论与底层问题，想精学的朋友建议移步刘海洋的《LaTeX入门》（可以联系本人电子版），同时有其他问题建议百度搜索或混混相应论坛，这儿给一个tackle problems的<a href=\"http://www.latexstudio.net/\" target=\"_blank\" rel=\"noopener\">传送门</a>,下载TEXLive请移步<a href=\"http://tug.org/texlive/\" target=\"_blank\" rel=\"noopener\">传送</a>,选择相应版本后耐心等待。<br><strong>以下未经说明使用TeXworks编辑器，编译方式选择XELaTeX</strong></p>\n<h2 id=\"目录及其相关设置\"><a href=\"#目录及其相关设置\" class=\"headerlink\" title=\"目录及其相关设置\"></a>目录及其相关设置</h2><pre><code>\\tableofcontents            %插入目录，由于latex的“交叉引用”，注意应编译两次\n\\thispagestyle{empty}       %设置目录页不计入页码，用于文章其他部位亦可\n\\clearpage                  %该语句使得文章后面内容另起一页显示，此处使得目录单独写在一页\n\\setcounter{page}{1}        %设置目录后正文第一页目录计数为1</code></pre><h2 id=\"正文文章结构的设置\"><a href=\"#正文文章结构的设置\" class=\"headerlink\" title=\"正文文章结构的设置\"></a>正文文章结构的设置</h2><pre><code>\\section{一级标题内容}\n正文\n\\subsection{二级标题内容}\n正文\n\\subsubsection{三级标题内容}\n正文</code></pre><p>以上模式相信用过word的朋友都很容易理解了，同时通过上一条所述的目录内容会根据正文中的\\section{}等标签自动生成文章目录，十分方便。</p>\n<h2 id=\"字体字号的常用设置\"><a href=\"#字体字号的常用设置\" class=\"headerlink\" title=\"字体字号的常用设置\"></a>字体字号的常用设置</h2><p>latex中包含了很多种字体，但如果没有特殊需求，我认为以下内容完全能够满足需要了</p>\n<pre><code>\\textbf{内容}       %将大括号内字体加粗\n\\textit{内容}       %将大括号内字体变为斜体\n\\emph{内容}         %强调括号内字体内容</code></pre><h2 id=\"列表环境\"><a href=\"#列表环境\" class=\"headerlink\" title=\"列表环境\"></a>列表环境</h2><h3 id=\"有计数的列表\"><a href=\"#有计数的列表\" class=\"headerlink\" title=\"有计数的列表\"></a>有计数的列表</h3><pre><code>\\begin{enumerate}\n    \\item 内容1\n    \\item 内容2\n\\end{enumerate}</code></pre><h3 id=\"无计数的列表（bulleted-list）\"><a href=\"#无计数的列表（bulleted-list）\" class=\"headerlink\" title=\"无计数的列表（bulleted list）\"></a>无计数的列表（bulleted list）</h3><pre><code>\\begin{itemize}\n    \\item 内容1\n    \\item 内容2\n\\end{itemize}</code></pre><h3 id=\"复杂列表\"><a href=\"#复杂列表\" class=\"headerlink\" title=\"复杂列表\"></a>复杂列表</h3><p>同时上述各个列表可以相互嵌套，如下即为在一个bulleted list下又嵌套了一个计数列表。</p>\n<pre><code>\\begin{itemize}\n    \\item 内容1\n    \\begin{enumerate}\n        \\item 内容1.1\n        \\item 内容1.2\n    \\end{enumerate}\n\\end{itemize}</code></pre><h2 id=\"插入图片\"><a href=\"#插入图片\" class=\"headerlink\" title=\"插入图片\"></a>插入图片</h2><p>在正文中插入图片很简单，如果你没有特殊的需求copy下面这段代码并且更改里面一些参数完全够用了，图片的资源文件和其他开发都是一样的，建议在根目录下建立一个img文件夹专门存放，同时记得将文件的命名与格式搞清楚。</p>\n<pre><code>%下行代码中[]内为可选项意义分别为\n%h 代表here,将表格排在当前文字位置\n%t 表示将表格放在下一页的 top (页首)\n%b 表示将表格放在当前页的 bottom (底部)\n%! 表示忽略美观因素，尽可能按照参数指定的方式来处理表格浮动位置\n\\begin{figure}[h]\n    \\centering      %使图片居中\n    %下面这行可以简单理解为载入图片的函数，width=0.6\\textwidth是将图片等比例设为宽度为0.6个间页长（排版的名词不大记得可以简单这么理解），你也可以使用px之类的将其设置为定宽。后面大括号内一定得是如image1.jpg这种格式，后缀不能漏\n    \\includegraphics[width=0.6\\textwidth]{加后缀的图片名}\n    \\caption{图片的名称}    %大括号内为页面显示的图片的名称\n    \\label{fig:1}          %设置图片的标签方便交叉引用\n\\end{figure}</code></pre><h2 id=\"插入表格\"><a href=\"#插入表格\" class=\"headerlink\" title=\"插入表格\"></a>插入表格</h2><p>表格是一切论文或其他议论文体中非常常见的数据表达形式，由于数据的不同各种类型多种多样，不想上节所述的图片那么一段代码打天下，所以表格内容较多，我尽量将我认为的常用的表格形式的通用代码附上，同时也列举一下表格的基本形式，方便读者进行变换。</p>\n<h3 id=\"普通表格\"><a href=\"#普通表格\" class=\"headerlink\" title=\"普通表格\"></a>普通表格</h3><p>普通表格是指一个没有任何改动的最基本的表格（参考word你便知道样式），我也可以借由此说明一下表格中的一些常用参数<br>同时，如\\centering；\\caption{};\\label{}等操作，与上一节所述关于图片相同</p>\n<pre><code>\\begin{table}[!htb] %[]内与上一节所述图片相同\n    \\begin{tabular}{|c|r|l|}    %后一个括号内c代表居中，r代表靠右，l代表靠左，|为表格竖线，可以舍去\n        \\hline  %为表格横线，可以舍去\n        内容1 &amp; 内容2 &amp; 内容3 \\\\    %每个单元格间由&amp;分开，\\\\表示换行\n        \\hline\n        内容4 &amp; 内容5 &amp; 内容6 \\\\\n        \\hline\n    \\end{tabular}\n\\end{table}</code></pre><h3 id=\"表格其他的常用设置\"><a href=\"#表格其他的常用设置\" class=\"headerlink\" title=\"表格其他的常用设置\"></a>表格其他的常用设置</h3><p>重新定义表格线的宽度代码如下，可随意更改使用相应代号的名称。使用时找到代码相应位置进行相应更改即可。<br>注意：<strong>以下内容要放在导言区</strong></p>\n<pre><code>%定义表格横线\\ttline的线宽为1.4pt，使用时用\\ttline代替上一节中的\\hline即可\n\\newcommand{\\ttline}{\n    \\noalign {\\ifnum 0=`}\\fi \\hrule height 1.4pt\n    \\futurelet \\reserved@a \\@xhline\n}\n%重定义表格竖线！的线宽为2pt，使用时用！代替上一节中的|即可\n\\newcolumntype{!}{@{\\hskip\\tabcolsep\\vrule width 2pt\\hskip\\tabcolsep}}\n\\makeatother</code></pre><p>剩下的一些小功能如下：</p>\n<pre><code>%设置表格标题置于表格上面（默认置于下面）\n\\setlength{\\belowcaptionskip}{6pt}  %置于表格上面6pt\n\n%如果想单独使一个单元格居中，可以这么写\n\\multicolumn{1}{c}{content}\n\n%想调整表格上下间距，可以在\\begin{table}前加（同样适用于更改正文行距）\n\\linespread{倍数} %更改后值为 倍数*默认间距\n\n%合并单元格，合并行列可以使用以下公式进行嵌套\n\\multicolumn{项数}{新列格式}{单元格内容} %合并列\n\\multirow{项数}{新列格式}{单元格内容} %合并行\n\n\\cline{2-3} %表示画出一条位于第2列到第3列的横线段，其他列将不会有横线段</code></pre><h3 id=\"几种特殊表格代码\"><a href=\"#几种特殊表格代码\" class=\"headerlink\" title=\"几种特殊表格代码\"></a>几种特殊表格代码</h3><p>下面是几种相对特殊的表格的代码，根据这些代码结合前两小节的内容更改相应部分即可完成自己的制定。</p>\n<pre><code>\\linespread{1.1}\n\\begin{table}[h]\n\\setlength{\\belowcaptionskip}{6pt}\\centering\\caption{dia test}\\label{tab:dia}\n\\begin{tabular}{ccc}\\ttline\n\\diagbox{test1}{test2} &amp; altitude &amp; vavlue \\\\ \\tline\ntesta &amp; $22.2$ &amp; $22.1$ \\\\ \ntestb &amp; $1.22$ &amp; $2.22$ \\\\\n\\end{tabular}\n\\end{table}</code></pre><p>此种表格应记住在导言区加上 <strong>\\usepackage{diagbox}</strong><br><img src=\"/page/latex1/BlogPic/2.1/t1.png\" alt=\"示例1\"><br>三线表是各种论文中较为常用的部分，代码与示例见下</p>\n<h2 id=\"插入公式及其他数学式\"><a href=\"#插入公式及其他数学式\" class=\"headerlink\" title=\"插入公式及其他数学式\"></a>插入公式及其他数学式</h2><p>公式环境与图片和表格类似，也可以自动编号以及使用交叉引用，只需设置好\\label{}内容即可，具体如下：</p>\n<h3 id=\"公式环境\"><a href=\"#公式环境\" class=\"headerlink\" title=\"公式环境\"></a>公式环境</h3><p>一般公式编辑：</p>\n<pre><code>\\begin{equation}\n    公式内容\n    \\label{eq:1}\n\\end{equation}</code></pre><p>分段函数模板：</p>\n<pre><code>\\begin{equation}\np_{j}=\\begin{cases} \n    0,j=2\\\\\n    1,j=1\n\\end{cases}\n\\label{}\n\\end{equation}</code></pre><h3 id=\"常见数学公式的编辑\"><a href=\"#常见数学公式的编辑\" class=\"headerlink\" title=\"常见数学公式的编辑\"></a>常见数学公式的编辑</h3>","site":{"data":{}},"excerpt":"","more":"<p>谈到码字与排版大家首先想到的一定是word等办公软件，即一些“所见即所得”的排版与“码字”软件，这些软件功能强大足够应付日常的一切工作。<br>但当大家有英文论文的写作与排版需求时，尤其是面对美赛这种“英文写作比赛”时，输出的PDF文件的美观性就尤其重要了（本人也是因为美赛才接触了latex这个让人又爱又恨的软件）。出于实用与给自己进行用法记录的目的，我也就不拿软件的历史之类的凑字数了，直接上可以产生效果的东西。<br><strong>PS：</strong>我个人认为latex 与HTML之类的标签语言十分相似，学习成本低，易用难精（也没必要精），因此本文只针对相应排版的具体问题，不涉及任何latex的理论与底层问题，想精学的朋友建议移步刘海洋的《LaTeX入门》（可以联系本人电子版），同时有其他问题建议百度搜索或混混相应论坛，这儿给一个tackle problems的<a href=\"http://www.latexstudio.net/\" target=\"_blank\" rel=\"noopener\">传送门</a>,下载TEXLive请移步<a href=\"http://tug.org/texlive/\" target=\"_blank\" rel=\"noopener\">传送</a>,选择相应版本后耐心等待。<br><strong>以下未经说明使用TeXworks编辑器，编译方式选择XELaTeX</strong></p>\n<h2 id=\"目录及其相关设置\"><a href=\"#目录及其相关设置\" class=\"headerlink\" title=\"目录及其相关设置\"></a>目录及其相关设置</h2><pre><code>\\tableofcontents            %插入目录，由于latex的“交叉引用”，注意应编译两次\n\\thispagestyle{empty}       %设置目录页不计入页码，用于文章其他部位亦可\n\\clearpage                  %该语句使得文章后面内容另起一页显示，此处使得目录单独写在一页\n\\setcounter{page}{1}        %设置目录后正文第一页目录计数为1</code></pre><h2 id=\"正文文章结构的设置\"><a href=\"#正文文章结构的设置\" class=\"headerlink\" title=\"正文文章结构的设置\"></a>正文文章结构的设置</h2><pre><code>\\section{一级标题内容}\n正文\n\\subsection{二级标题内容}\n正文\n\\subsubsection{三级标题内容}\n正文</code></pre><p>以上模式相信用过word的朋友都很容易理解了，同时通过上一条所述的目录内容会根据正文中的\\section{}等标签自动生成文章目录，十分方便。</p>\n<h2 id=\"字体字号的常用设置\"><a href=\"#字体字号的常用设置\" class=\"headerlink\" title=\"字体字号的常用设置\"></a>字体字号的常用设置</h2><p>latex中包含了很多种字体，但如果没有特殊需求，我认为以下内容完全能够满足需要了</p>\n<pre><code>\\textbf{内容}       %将大括号内字体加粗\n\\textit{内容}       %将大括号内字体变为斜体\n\\emph{内容}         %强调括号内字体内容</code></pre><h2 id=\"列表环境\"><a href=\"#列表环境\" class=\"headerlink\" title=\"列表环境\"></a>列表环境</h2><h3 id=\"有计数的列表\"><a href=\"#有计数的列表\" class=\"headerlink\" title=\"有计数的列表\"></a>有计数的列表</h3><pre><code>\\begin{enumerate}\n    \\item 内容1\n    \\item 内容2\n\\end{enumerate}</code></pre><h3 id=\"无计数的列表（bulleted-list）\"><a href=\"#无计数的列表（bulleted-list）\" class=\"headerlink\" title=\"无计数的列表（bulleted list）\"></a>无计数的列表（bulleted list）</h3><pre><code>\\begin{itemize}\n    \\item 内容1\n    \\item 内容2\n\\end{itemize}</code></pre><h3 id=\"复杂列表\"><a href=\"#复杂列表\" class=\"headerlink\" title=\"复杂列表\"></a>复杂列表</h3><p>同时上述各个列表可以相互嵌套，如下即为在一个bulleted list下又嵌套了一个计数列表。</p>\n<pre><code>\\begin{itemize}\n    \\item 内容1\n    \\begin{enumerate}\n        \\item 内容1.1\n        \\item 内容1.2\n    \\end{enumerate}\n\\end{itemize}</code></pre><h2 id=\"插入图片\"><a href=\"#插入图片\" class=\"headerlink\" title=\"插入图片\"></a>插入图片</h2><p>在正文中插入图片很简单，如果你没有特殊的需求copy下面这段代码并且更改里面一些参数完全够用了，图片的资源文件和其他开发都是一样的，建议在根目录下建立一个img文件夹专门存放，同时记得将文件的命名与格式搞清楚。</p>\n<pre><code>%下行代码中[]内为可选项意义分别为\n%h 代表here,将表格排在当前文字位置\n%t 表示将表格放在下一页的 top (页首)\n%b 表示将表格放在当前页的 bottom (底部)\n%! 表示忽略美观因素，尽可能按照参数指定的方式来处理表格浮动位置\n\\begin{figure}[h]\n    \\centering      %使图片居中\n    %下面这行可以简单理解为载入图片的函数，width=0.6\\textwidth是将图片等比例设为宽度为0.6个间页长（排版的名词不大记得可以简单这么理解），你也可以使用px之类的将其设置为定宽。后面大括号内一定得是如image1.jpg这种格式，后缀不能漏\n    \\includegraphics[width=0.6\\textwidth]{加后缀的图片名}\n    \\caption{图片的名称}    %大括号内为页面显示的图片的名称\n    \\label{fig:1}          %设置图片的标签方便交叉引用\n\\end{figure}</code></pre><h2 id=\"插入表格\"><a href=\"#插入表格\" class=\"headerlink\" title=\"插入表格\"></a>插入表格</h2><p>表格是一切论文或其他议论文体中非常常见的数据表达形式，由于数据的不同各种类型多种多样，不想上节所述的图片那么一段代码打天下，所以表格内容较多，我尽量将我认为的常用的表格形式的通用代码附上，同时也列举一下表格的基本形式，方便读者进行变换。</p>\n<h3 id=\"普通表格\"><a href=\"#普通表格\" class=\"headerlink\" title=\"普通表格\"></a>普通表格</h3><p>普通表格是指一个没有任何改动的最基本的表格（参考word你便知道样式），我也可以借由此说明一下表格中的一些常用参数<br>同时，如\\centering；\\caption{};\\label{}等操作，与上一节所述关于图片相同</p>\n<pre><code>\\begin{table}[!htb] %[]内与上一节所述图片相同\n    \\begin{tabular}{|c|r|l|}    %后一个括号内c代表居中，r代表靠右，l代表靠左，|为表格竖线，可以舍去\n        \\hline  %为表格横线，可以舍去\n        内容1 &amp; 内容2 &amp; 内容3 \\\\    %每个单元格间由&amp;分开，\\\\表示换行\n        \\hline\n        内容4 &amp; 内容5 &amp; 内容6 \\\\\n        \\hline\n    \\end{tabular}\n\\end{table}</code></pre><h3 id=\"表格其他的常用设置\"><a href=\"#表格其他的常用设置\" class=\"headerlink\" title=\"表格其他的常用设置\"></a>表格其他的常用设置</h3><p>重新定义表格线的宽度代码如下，可随意更改使用相应代号的名称。使用时找到代码相应位置进行相应更改即可。<br>注意：<strong>以下内容要放在导言区</strong></p>\n<pre><code>%定义表格横线\\ttline的线宽为1.4pt，使用时用\\ttline代替上一节中的\\hline即可\n\\newcommand{\\ttline}{\n    \\noalign {\\ifnum 0=`}\\fi \\hrule height 1.4pt\n    \\futurelet \\reserved@a \\@xhline\n}\n%重定义表格竖线！的线宽为2pt，使用时用！代替上一节中的|即可\n\\newcolumntype{!}{@{\\hskip\\tabcolsep\\vrule width 2pt\\hskip\\tabcolsep}}\n\\makeatother</code></pre><p>剩下的一些小功能如下：</p>\n<pre><code>%设置表格标题置于表格上面（默认置于下面）\n\\setlength{\\belowcaptionskip}{6pt}  %置于表格上面6pt\n\n%如果想单独使一个单元格居中，可以这么写\n\\multicolumn{1}{c}{content}\n\n%想调整表格上下间距，可以在\\begin{table}前加（同样适用于更改正文行距）\n\\linespread{倍数} %更改后值为 倍数*默认间距\n\n%合并单元格，合并行列可以使用以下公式进行嵌套\n\\multicolumn{项数}{新列格式}{单元格内容} %合并列\n\\multirow{项数}{新列格式}{单元格内容} %合并行\n\n\\cline{2-3} %表示画出一条位于第2列到第3列的横线段，其他列将不会有横线段</code></pre><h3 id=\"几种特殊表格代码\"><a href=\"#几种特殊表格代码\" class=\"headerlink\" title=\"几种特殊表格代码\"></a>几种特殊表格代码</h3><p>下面是几种相对特殊的表格的代码，根据这些代码结合前两小节的内容更改相应部分即可完成自己的制定。</p>\n<pre><code>\\linespread{1.1}\n\\begin{table}[h]\n\\setlength{\\belowcaptionskip}{6pt}\\centering\\caption{dia test}\\label{tab:dia}\n\\begin{tabular}{ccc}\\ttline\n\\diagbox{test1}{test2} &amp; altitude &amp; vavlue \\\\ \\tline\ntesta &amp; $22.2$ &amp; $22.1$ \\\\ \ntestb &amp; $1.22$ &amp; $2.22$ \\\\\n\\end{tabular}\n\\end{table}</code></pre><p>此种表格应记住在导言区加上 <strong>\\usepackage{diagbox}</strong><br><img src=\"/page/latex1/BlogPic/2.1/t1.png\" alt=\"示例1\"><br>三线表是各种论文中较为常用的部分，代码与示例见下</p>\n<h2 id=\"插入公式及其他数学式\"><a href=\"#插入公式及其他数学式\" class=\"headerlink\" title=\"插入公式及其他数学式\"></a>插入公式及其他数学式</h2><p>公式环境与图片和表格类似，也可以自动编号以及使用交叉引用，只需设置好\\label{}内容即可，具体如下：</p>\n<h3 id=\"公式环境\"><a href=\"#公式环境\" class=\"headerlink\" title=\"公式环境\"></a>公式环境</h3><p>一般公式编辑：</p>\n<pre><code>\\begin{equation}\n    公式内容\n    \\label{eq:1}\n\\end{equation}</code></pre><p>分段函数模板：</p>\n<pre><code>\\begin{equation}\np_{j}=\\begin{cases} \n    0,j=2\\\\\n    1,j=1\n\\end{cases}\n\\label{}\n\\end{equation}</code></pre><h3 id=\"常见数学公式的编辑\"><a href=\"#常见数学公式的编辑\" class=\"headerlink\" title=\"常见数学公式的编辑\"></a>常见数学公式的编辑</h3>"},{"title":"Java父类引用指向子类对象（向上转型）","date":"2020-07-12T07:44:11.000Z","fileName":"java_polymorphic","_content":"\n参考：https://www.cnblogs.com/ChrisMurphy/p/5054256.html\n\n父类的引用指向子类的对象是Java中多态的重要表现形式\n\n#### 表现形式\n\n父类为Animal，子类为Cat，如下即为父类引用指向子类对象的形式，**声明的是父类，实际指向的是子类的一个对象**。（其中Animal可以是类也可以是接口，Cat是继承或实现Animal的子类）\n\n```\nAnimal animal = new Cat()\n```\n\n这种情况也即为**向上转型**，父类引用指向子类实例。**可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法**。\n\n\n\n#### 意义\n\n子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特， 定义一个父类类型的引用指向一个子类的对象既可以**使用子类强大的功能**，又可以**抽取父类的共性**。 所以，父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，父类引用是无法调用的\n\n\n\n#### 示例\n\n父类\n\n```\npublic class Father {\n    // 父类中的func1方法\n    // 由于子类中对该方法只是进行了重载而没有进行重写\n    // 因此该方法仍然有效\n    public void func1() {\n        System.out.println(\"Father func1\");\n    }\n\n    // 父类中的func2方法\n    // 由于在子类中重写了该方法\n    // 所以在“向上转型”中，该方法不再有效\n    // 取而代之的是子类中的fun2方法\n    public void func2() {\n        System.out.println(\"Father func2\");\n    }\n}\n```\n\n子类\n\n```\npublic class Child extends Father {\n    // 对func1方法的一个重载\n    // 由于在父类中没有定义该方法，所以该方法不能被父类的引用调用\n    // 如果进行调用即会报错\n    public void func1(int i) {\n        System.out.println(\"Child func1\");\n    }\n\n    // 对父类方法的重写\n    // 能够起作用\n    public void func2() {\n        System.out.println(\"Child func2\");\n    }\n}\n```\n\n主函数\n\n```\npublic class Main {\n    public static void main(String[] args) {\n\t// write your code here\n        Father test = new Child();\n        test.func1();   // Father func1\n        test.func2();   // Child func2\n        test.func1(10); // 报错\n    }\n}\n```\n\n上述示例中，子类Child继承了父类Father，并重载了父类的func1()方法，重写了父类的func2()方法。重载后的func1(int i)和func1()不再是同一个方法，由于父类中没有func1(int i)，那么，父类类型的引用child就不能调用func1(int i)方法。而子类重写了func2()方法，那么父类类型的引用child在调用该方法时将会调用子类中重写的func2()。 \n\n\n\n#### 总结\n\n1、**使用父类类型的引用指向子类的对象；** \n\n2、**该引用只能调用父类中定义的方法和变量；** \n\n3、**如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）** \n\n4、**变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了父类中的变量，那么在编译时会报错。**\n\n\n\n\n\n","source":"_posts/Java/语言基础/Java父类引用指向子类对象.md","raw":"---\ntitle: Java父类引用指向子类对象（向上转型）\ndate: 2020-07-12 15:44:11\ntags:\n\t- Java\ncategories:\n\t- Java\n\t- 语言基础\nfileName: java_polymorphic\n---\n\n参考：https://www.cnblogs.com/ChrisMurphy/p/5054256.html\n\n父类的引用指向子类的对象是Java中多态的重要表现形式\n\n#### 表现形式\n\n父类为Animal，子类为Cat，如下即为父类引用指向子类对象的形式，**声明的是父类，实际指向的是子类的一个对象**。（其中Animal可以是类也可以是接口，Cat是继承或实现Animal的子类）\n\n```\nAnimal animal = new Cat()\n```\n\n这种情况也即为**向上转型**，父类引用指向子类实例。**可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法**。\n\n\n\n#### 意义\n\n子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特， 定义一个父类类型的引用指向一个子类的对象既可以**使用子类强大的功能**，又可以**抽取父类的共性**。 所以，父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，父类引用是无法调用的\n\n\n\n#### 示例\n\n父类\n\n```\npublic class Father {\n    // 父类中的func1方法\n    // 由于子类中对该方法只是进行了重载而没有进行重写\n    // 因此该方法仍然有效\n    public void func1() {\n        System.out.println(\"Father func1\");\n    }\n\n    // 父类中的func2方法\n    // 由于在子类中重写了该方法\n    // 所以在“向上转型”中，该方法不再有效\n    // 取而代之的是子类中的fun2方法\n    public void func2() {\n        System.out.println(\"Father func2\");\n    }\n}\n```\n\n子类\n\n```\npublic class Child extends Father {\n    // 对func1方法的一个重载\n    // 由于在父类中没有定义该方法，所以该方法不能被父类的引用调用\n    // 如果进行调用即会报错\n    public void func1(int i) {\n        System.out.println(\"Child func1\");\n    }\n\n    // 对父类方法的重写\n    // 能够起作用\n    public void func2() {\n        System.out.println(\"Child func2\");\n    }\n}\n```\n\n主函数\n\n```\npublic class Main {\n    public static void main(String[] args) {\n\t// write your code here\n        Father test = new Child();\n        test.func1();   // Father func1\n        test.func2();   // Child func2\n        test.func1(10); // 报错\n    }\n}\n```\n\n上述示例中，子类Child继承了父类Father，并重载了父类的func1()方法，重写了父类的func2()方法。重载后的func1(int i)和func1()不再是同一个方法，由于父类中没有func1(int i)，那么，父类类型的引用child就不能调用func1(int i)方法。而子类重写了func2()方法，那么父类类型的引用child在调用该方法时将会调用子类中重写的func2()。 \n\n\n\n#### 总结\n\n1、**使用父类类型的引用指向子类的对象；** \n\n2、**该引用只能调用父类中定义的方法和变量；** \n\n3、**如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）** \n\n4、**变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了父类中的变量，那么在编译时会报错。**\n\n\n\n\n\n","slug":"Java/语言基础/Java父类引用指向子类对象","published":1,"updated":"2020-07-16T16:06:58.026Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8rt0001l4jsaytbhcbk","content":"<p>参考：<a href=\"https://www.cnblogs.com/ChrisMurphy/p/5054256.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/ChrisMurphy/p/5054256.html</a></p>\n<p>父类的引用指向子类的对象是Java中多态的重要表现形式</p>\n<h4 id=\"表现形式\"><a href=\"#表现形式\" class=\"headerlink\" title=\"表现形式\"></a>表现形式</h4><p>父类为Animal，子类为Cat，如下即为父类引用指向子类对象的形式，<strong>声明的是父类，实际指向的是子类的一个对象</strong>。（其中Animal可以是类也可以是接口，Cat是继承或实现Animal的子类）</p>\n<pre><code>Animal animal = new Cat()</code></pre><p>这种情况也即为<strong>向上转型</strong>，父类引用指向子类实例。<strong>可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法</strong>。</p>\n<h4 id=\"意义\"><a href=\"#意义\" class=\"headerlink\" title=\"意义\"></a>意义</h4><p>子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特， 定义一个父类类型的引用指向一个子类的对象既可以<strong>使用子类强大的功能</strong>，又可以<strong>抽取父类的共性</strong>。 所以，父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，父类引用是无法调用的</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>父类</p>\n<pre><code>public class Father {\n    // 父类中的func1方法\n    // 由于子类中对该方法只是进行了重载而没有进行重写\n    // 因此该方法仍然有效\n    public void func1() {\n        System.out.println(&quot;Father func1&quot;);\n    }\n\n    // 父类中的func2方法\n    // 由于在子类中重写了该方法\n    // 所以在“向上转型”中，该方法不再有效\n    // 取而代之的是子类中的fun2方法\n    public void func2() {\n        System.out.println(&quot;Father func2&quot;);\n    }\n}</code></pre><p>子类</p>\n<pre><code>public class Child extends Father {\n    // 对func1方法的一个重载\n    // 由于在父类中没有定义该方法，所以该方法不能被父类的引用调用\n    // 如果进行调用即会报错\n    public void func1(int i) {\n        System.out.println(&quot;Child func1&quot;);\n    }\n\n    // 对父类方法的重写\n    // 能够起作用\n    public void func2() {\n        System.out.println(&quot;Child func2&quot;);\n    }\n}</code></pre><p>主函数</p>\n<pre><code>public class Main {\n    public static void main(String[] args) {\n    // write your code here\n        Father test = new Child();\n        test.func1();   // Father func1\n        test.func2();   // Child func2\n        test.func1(10); // 报错\n    }\n}</code></pre><p>上述示例中，子类Child继承了父类Father，并重载了父类的func1()方法，重写了父类的func2()方法。重载后的func1(int i)和func1()不再是同一个方法，由于父类中没有func1(int i)，那么，父类类型的引用child就不能调用func1(int i)方法。而子类重写了func2()方法，那么父类类型的引用child在调用该方法时将会调用子类中重写的func2()。 </p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>1、<strong>使用父类类型的引用指向子类的对象；</strong> </p>\n<p>2、<strong>该引用只能调用父类中定义的方法和变量；</strong> </p>\n<p>3、<strong>如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）</strong> </p>\n<p>4、<strong>变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了父类中的变量，那么在编译时会报错。</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考：<a href=\"https://www.cnblogs.com/ChrisMurphy/p/5054256.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/ChrisMurphy/p/5054256.html</a></p>\n<p>父类的引用指向子类的对象是Java中多态的重要表现形式</p>\n<h4 id=\"表现形式\"><a href=\"#表现形式\" class=\"headerlink\" title=\"表现形式\"></a>表现形式</h4><p>父类为Animal，子类为Cat，如下即为父类引用指向子类对象的形式，<strong>声明的是父类，实际指向的是子类的一个对象</strong>。（其中Animal可以是类也可以是接口，Cat是继承或实现Animal的子类）</p>\n<pre><code>Animal animal = new Cat()</code></pre><p>这种情况也即为<strong>向上转型</strong>，父类引用指向子类实例。<strong>可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法</strong>。</p>\n<h4 id=\"意义\"><a href=\"#意义\" class=\"headerlink\" title=\"意义\"></a>意义</h4><p>子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特， 定义一个父类类型的引用指向一个子类的对象既可以<strong>使用子类强大的功能</strong>，又可以<strong>抽取父类的共性</strong>。 所以，父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，父类引用是无法调用的</p>\n<h4 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h4><p>父类</p>\n<pre><code>public class Father {\n    // 父类中的func1方法\n    // 由于子类中对该方法只是进行了重载而没有进行重写\n    // 因此该方法仍然有效\n    public void func1() {\n        System.out.println(&quot;Father func1&quot;);\n    }\n\n    // 父类中的func2方法\n    // 由于在子类中重写了该方法\n    // 所以在“向上转型”中，该方法不再有效\n    // 取而代之的是子类中的fun2方法\n    public void func2() {\n        System.out.println(&quot;Father func2&quot;);\n    }\n}</code></pre><p>子类</p>\n<pre><code>public class Child extends Father {\n    // 对func1方法的一个重载\n    // 由于在父类中没有定义该方法，所以该方法不能被父类的引用调用\n    // 如果进行调用即会报错\n    public void func1(int i) {\n        System.out.println(&quot;Child func1&quot;);\n    }\n\n    // 对父类方法的重写\n    // 能够起作用\n    public void func2() {\n        System.out.println(&quot;Child func2&quot;);\n    }\n}</code></pre><p>主函数</p>\n<pre><code>public class Main {\n    public static void main(String[] args) {\n    // write your code here\n        Father test = new Child();\n        test.func1();   // Father func1\n        test.func2();   // Child func2\n        test.func1(10); // 报错\n    }\n}</code></pre><p>上述示例中，子类Child继承了父类Father，并重载了父类的func1()方法，重写了父类的func2()方法。重载后的func1(int i)和func1()不再是同一个方法，由于父类中没有func1(int i)，那么，父类类型的引用child就不能调用func1(int i)方法。而子类重写了func2()方法，那么父类类型的引用child在调用该方法时将会调用子类中重写的func2()。 </p>\n<h4 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h4><p>1、<strong>使用父类类型的引用指向子类的对象；</strong> </p>\n<p>2、<strong>该引用只能调用父类中定义的方法和变量；</strong> </p>\n<p>3、<strong>如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）</strong> </p>\n<p>4、<strong>变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了父类中的变量，那么在编译时会报错。</strong></p>\n"},{"title":"2、Java中的类与接口","date":"2020-07-04T02:43:51.000Z","fileName":"java2","_content":"\n主要参考：https://github.com/Snailclimb/JavaGuide\n\n### 面向对象三大特征\n\n#### 封装\n\n封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。\n\n#### 继承\n\n继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。同时，**Java语言中的继承是单继承**。\n\n1、子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。\n\n2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n\n3、子类可以用自己的方式实现父类的方法（方法重写）。\n\n#### 多态\n\n\n\n\n\n### Object类的常见方法总结\n\nObject类是所有类的父类，主要提供11个方法。\n\n```\n// 用于返回当前运行时对象的Class对象。\npublic final native Class<?> getClass()\n\n// 用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap\npublic native int hashCode()\n\n// 用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等\npublic boolean equals(Object obj)\n\n// 用于创建并返回当前对象的一份拷贝。\n// 一般情况下，对于任何对象 x\n// 表达式 x.clone() != x 为true\n// x.clone().getClass() == x.getClass() 为true\n// Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会产生异常。\nprotected native Object clone() throws CloneNotSupportedException\n\n// 返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。\npublic String toString()\n\n// 不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\npublic final native void notify()\n\n// 不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\npublic final native void notifyAll()\n\n// 不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。\npublic final native void wait(long timeout) throws InterruptedException\n\n// 多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\n// 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\npublic final void wait() throws InterruptedException\n\n// 实例被垃圾回收器回收的时候触发的操作\nprotected void finalize() throws Throwable\n\n```\n\n其中native方法即为调用非Java代码的接口，一个native方法是指该方法的实现由非Java语言实现。\n\n\n\n","source":"_posts/Java/语言基础/2、Java中的类与接口.md","raw":"---\ntitle: 2、Java中的类与接口\ndate: 2020-07-04 10:43:51\ntags:\n\t- Java\ncategories:\n\t- Java\n\t- 语言基础\nfileName: java2\n---\n\n主要参考：https://github.com/Snailclimb/JavaGuide\n\n### 面向对象三大特征\n\n#### 封装\n\n封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。\n\n#### 继承\n\n继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。同时，**Java语言中的继承是单继承**。\n\n1、子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。\n\n2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。\n\n3、子类可以用自己的方式实现父类的方法（方法重写）。\n\n#### 多态\n\n\n\n\n\n### Object类的常见方法总结\n\nObject类是所有类的父类，主要提供11个方法。\n\n```\n// 用于返回当前运行时对象的Class对象。\npublic final native Class<?> getClass()\n\n// 用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap\npublic native int hashCode()\n\n// 用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等\npublic boolean equals(Object obj)\n\n// 用于创建并返回当前对象的一份拷贝。\n// 一般情况下，对于任何对象 x\n// 表达式 x.clone() != x 为true\n// x.clone().getClass() == x.getClass() 为true\n// Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会产生异常。\nprotected native Object clone() throws CloneNotSupportedException\n\n// 返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。\npublic String toString()\n\n// 不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\npublic final native void notify()\n\n// 不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\npublic final native void notifyAll()\n\n// 不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。\npublic final native void wait(long timeout) throws InterruptedException\n\n// 多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\n// 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\npublic final void wait() throws InterruptedException\n\n// 实例被垃圾回收器回收的时候触发的操作\nprotected void finalize() throws Throwable\n\n```\n\n其中native方法即为调用非Java代码的接口，一个native方法是指该方法的实现由非Java语言实现。\n\n\n\n","slug":"Java/语言基础/2、Java中的类与接口","published":1,"updated":"2020-07-16T16:06:28.483Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8ru0002l4js646zbtrp","content":"<p>主要参考：<a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\" rel=\"noopener\">https://github.com/Snailclimb/JavaGuide</a></p>\n<h3 id=\"面向对象三大特征\"><a href=\"#面向对象三大特征\" class=\"headerlink\" title=\"面向对象三大特征\"></a>面向对象三大特征</h3><h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。同时，<strong>Java语言中的继承是单继承</strong>。</p>\n<p>1、子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</p>\n<p>2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>\n<p>3、子类可以用自己的方式实现父类的方法（方法重写）。</p>\n<h4 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h4><h3 id=\"Object类的常见方法总结\"><a href=\"#Object类的常见方法总结\" class=\"headerlink\" title=\"Object类的常见方法总结\"></a>Object类的常见方法总结</h3><p>Object类是所有类的父类，主要提供11个方法。</p>\n<pre><code>// 用于返回当前运行时对象的Class对象。\npublic final native Class&lt;?&gt; getClass()\n\n// 用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap\npublic native int hashCode()\n\n// 用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等\npublic boolean equals(Object obj)\n\n// 用于创建并返回当前对象的一份拷贝。\n// 一般情况下，对于任何对象 x\n// 表达式 x.clone() != x 为true\n// x.clone().getClass() == x.getClass() 为true\n// Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会产生异常。\nprotected native Object clone() throws CloneNotSupportedException\n\n// 返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。\npublic String toString()\n\n// 不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\npublic final native void notify()\n\n// 不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\npublic final native void notifyAll()\n\n// 不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。\npublic final native void wait(long timeout) throws InterruptedException\n\n// 多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\n// 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\npublic final void wait() throws InterruptedException\n\n// 实例被垃圾回收器回收的时候触发的操作\nprotected void finalize() throws Throwable\n</code></pre><p>其中native方法即为调用非Java代码的接口，一个native方法是指该方法的实现由非Java语言实现。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>主要参考：<a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\" rel=\"noopener\">https://github.com/Snailclimb/JavaGuide</a></p>\n<h3 id=\"面向对象三大特征\"><a href=\"#面向对象三大特征\" class=\"headerlink\" title=\"面向对象三大特征\"></a>面向对象三大特征</h3><h4 id=\"封装\"><a href=\"#封装\" class=\"headerlink\" title=\"封装\"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>\n<h4 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。同时，<strong>Java语言中的继承是单继承</strong>。</p>\n<p>1、子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</p>\n<p>2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>\n<p>3、子类可以用自己的方式实现父类的方法（方法重写）。</p>\n<h4 id=\"多态\"><a href=\"#多态\" class=\"headerlink\" title=\"多态\"></a>多态</h4><h3 id=\"Object类的常见方法总结\"><a href=\"#Object类的常见方法总结\" class=\"headerlink\" title=\"Object类的常见方法总结\"></a>Object类的常见方法总结</h3><p>Object类是所有类的父类，主要提供11个方法。</p>\n<pre><code>// 用于返回当前运行时对象的Class对象。\npublic final native Class&lt;?&gt; getClass()\n\n// 用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap\npublic native int hashCode()\n\n// 用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等\npublic boolean equals(Object obj)\n\n// 用于创建并返回当前对象的一份拷贝。\n// 一般情况下，对于任何对象 x\n// 表达式 x.clone() != x 为true\n// x.clone().getClass() == x.getClass() 为true\n// Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会产生异常。\nprotected native Object clone() throws CloneNotSupportedException\n\n// 返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。\npublic String toString()\n\n// 不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\npublic final native void notify()\n\n// 不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\npublic final native void notifyAll()\n\n// 不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。\npublic final native void wait(long timeout) throws InterruptedException\n\n// 多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。\npublic final void wait(long timeout, int nanos) throws InterruptedException\n\n// 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\npublic final void wait() throws InterruptedException\n\n// 实例被垃圾回收器回收的时候触发的操作\nprotected void finalize() throws Throwable\n</code></pre><p>其中native方法即为调用非Java代码的接口，一个native方法是指该方法的实现由非Java语言实现。</p>\n"},{"title":"4、Java多线程","date":"2020-07-12T10:47:21.000Z","fileName":"java4","_content":"\n### 线程的创建\n\n1、创建一个Thread类，或者一个Thread子类的对象\n\n2、创建一个实现Runnable接口的类的对象（解决Java只能单继承的限制，同时可以避免重写Thread类中的其他方法）\n\n```\nclass Test implements Runnable {\n\t@Override\n\tpublic void run() {\n\t\t// 添加你的代码\n\t}\n}\n```\n\n之后在主函数中输入\n\n```\nTest t = new Test();\nThread t1 = new Thread(pr);\t// 将创建好的通过参数传入Thread\nt1.start();\n```\n\n\n\n\n\nThread类的常用方法\n\n```\n# 线程相关的代码写入该方法，一般需要重写\npublic void run()\n\n# 启动线程\npublic void start()\n\n# 线程休眠m毫秒的方法\npublic static void sleep(long m)\n\n# 优先执行调用join()方法的线程\npublic void join()\n# 等待该线程终止的最长时间为millis毫秒\npublic final void join(long millis)\n```\n\n\n\nRunnable接口\n\nRunnable是Java中用以实现线程的接口，只有一个方法run()\n\n任何实现线程功能的类都必须实现该接口\n\n\n\n### 线程优先级\n\nJava为线程类提供了10个优先级，优先级可以用整数1-10表示，超过范围会抛出异常，主线程默认优先级为5\n\n优先级常量\n\n```\nMAX_PRIORITY：线程的最高优先级10\nMIN_PRIORITY：线程的最低优先级1\nNORM_PRIORITY：线程的默认优先级5\n```\n\n优先级相关方法：\n\n```;\n// 获取线程优先级\npublic int getPriority()\n\n// 设置线程优先级\npublic void setPriority(int newPriority)\n\n// 获取主线程优先级\nint mainpriority = Thread.currentThread().getPriority()\n```\n\n\n\n### 多线程\n\n各线程通过竞争CPU时间而获得运行机会，各线程什么时候得到CPU时间，占用多久，是不可预测的，一个正在运行着的线程在什么地方被暂停是不确定的\n\n\n\nsynchronized\n\n成员方法，静态方法、语句块\n\n```\npublic synchronized void func() {}\npublic static synchronized void func() {}\nsynchronized(obj) {}\n```\n\n\n\n线程间通信\n\n\n\n","source":"_posts/Java/语言基础/4、Java多线程.md","raw":"---\ntitle: 4、Java多线程\ndate: 2020-07-12 18:47:21\ntags:\n\t- Java\ncategories:\n\t- Java\n\t- 语言基础\nfileName: java4\n---\n\n### 线程的创建\n\n1、创建一个Thread类，或者一个Thread子类的对象\n\n2、创建一个实现Runnable接口的类的对象（解决Java只能单继承的限制，同时可以避免重写Thread类中的其他方法）\n\n```\nclass Test implements Runnable {\n\t@Override\n\tpublic void run() {\n\t\t// 添加你的代码\n\t}\n}\n```\n\n之后在主函数中输入\n\n```\nTest t = new Test();\nThread t1 = new Thread(pr);\t// 将创建好的通过参数传入Thread\nt1.start();\n```\n\n\n\n\n\nThread类的常用方法\n\n```\n# 线程相关的代码写入该方法，一般需要重写\npublic void run()\n\n# 启动线程\npublic void start()\n\n# 线程休眠m毫秒的方法\npublic static void sleep(long m)\n\n# 优先执行调用join()方法的线程\npublic void join()\n# 等待该线程终止的最长时间为millis毫秒\npublic final void join(long millis)\n```\n\n\n\nRunnable接口\n\nRunnable是Java中用以实现线程的接口，只有一个方法run()\n\n任何实现线程功能的类都必须实现该接口\n\n\n\n### 线程优先级\n\nJava为线程类提供了10个优先级，优先级可以用整数1-10表示，超过范围会抛出异常，主线程默认优先级为5\n\n优先级常量\n\n```\nMAX_PRIORITY：线程的最高优先级10\nMIN_PRIORITY：线程的最低优先级1\nNORM_PRIORITY：线程的默认优先级5\n```\n\n优先级相关方法：\n\n```;\n// 获取线程优先级\npublic int getPriority()\n\n// 设置线程优先级\npublic void setPriority(int newPriority)\n\n// 获取主线程优先级\nint mainpriority = Thread.currentThread().getPriority()\n```\n\n\n\n### 多线程\n\n各线程通过竞争CPU时间而获得运行机会，各线程什么时候得到CPU时间，占用多久，是不可预测的，一个正在运行着的线程在什么地方被暂停是不确定的\n\n\n\nsynchronized\n\n成员方法，静态方法、语句块\n\n```\npublic synchronized void func() {}\npublic static synchronized void func() {}\nsynchronized(obj) {}\n```\n\n\n\n线程间通信\n\n\n\n","slug":"Java/语言基础/4、Java多线程","published":1,"updated":"2020-07-16T16:06:49.158Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8rw0004l4js3fhz6j73","content":"<h3 id=\"线程的创建\"><a href=\"#线程的创建\" class=\"headerlink\" title=\"线程的创建\"></a>线程的创建</h3><p>1、创建一个Thread类，或者一个Thread子类的对象</p>\n<p>2、创建一个实现Runnable接口的类的对象（解决Java只能单继承的限制，同时可以避免重写Thread类中的其他方法）</p>\n<pre><code>class Test implements Runnable {\n    @Override\n    public void run() {\n        // 添加你的代码\n    }\n}</code></pre><p>之后在主函数中输入</p>\n<pre><code>Test t = new Test();\nThread t1 = new Thread(pr);    // 将创建好的通过参数传入Thread\nt1.start();</code></pre><p>Thread类的常用方法</p>\n<pre><code># 线程相关的代码写入该方法，一般需要重写\npublic void run()\n\n# 启动线程\npublic void start()\n\n# 线程休眠m毫秒的方法\npublic static void sleep(long m)\n\n# 优先执行调用join()方法的线程\npublic void join()\n# 等待该线程终止的最长时间为millis毫秒\npublic final void join(long millis)</code></pre><p>Runnable接口</p>\n<p>Runnable是Java中用以实现线程的接口，只有一个方法run()</p>\n<p>任何实现线程功能的类都必须实现该接口</p>\n<h3 id=\"线程优先级\"><a href=\"#线程优先级\" class=\"headerlink\" title=\"线程优先级\"></a>线程优先级</h3><p>Java为线程类提供了10个优先级，优先级可以用整数1-10表示，超过范围会抛出异常，主线程默认优先级为5</p>\n<p>优先级常量</p>\n<pre><code>MAX_PRIORITY：线程的最高优先级10\nMIN_PRIORITY：线程的最低优先级1\nNORM_PRIORITY：线程的默认优先级5</code></pre><p>优先级相关方法：</p>\n<pre><code class=\";\">// 获取线程优先级\npublic int getPriority()\n\n// 设置线程优先级\npublic void setPriority(int newPriority)\n\n// 获取主线程优先级\nint mainpriority = Thread.currentThread().getPriority()</code></pre>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><p>各线程通过竞争CPU时间而获得运行机会，各线程什么时候得到CPU时间，占用多久，是不可预测的，一个正在运行着的线程在什么地方被暂停是不确定的</p>\n<p>synchronized</p>\n<p>成员方法，静态方法、语句块</p>\n<pre><code>public synchronized void func() {}\npublic static synchronized void func() {}\nsynchronized(obj) {}</code></pre><p>线程间通信</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"线程的创建\"><a href=\"#线程的创建\" class=\"headerlink\" title=\"线程的创建\"></a>线程的创建</h3><p>1、创建一个Thread类，或者一个Thread子类的对象</p>\n<p>2、创建一个实现Runnable接口的类的对象（解决Java只能单继承的限制，同时可以避免重写Thread类中的其他方法）</p>\n<pre><code>class Test implements Runnable {\n    @Override\n    public void run() {\n        // 添加你的代码\n    }\n}</code></pre><p>之后在主函数中输入</p>\n<pre><code>Test t = new Test();\nThread t1 = new Thread(pr);    // 将创建好的通过参数传入Thread\nt1.start();</code></pre><p>Thread类的常用方法</p>\n<pre><code># 线程相关的代码写入该方法，一般需要重写\npublic void run()\n\n# 启动线程\npublic void start()\n\n# 线程休眠m毫秒的方法\npublic static void sleep(long m)\n\n# 优先执行调用join()方法的线程\npublic void join()\n# 等待该线程终止的最长时间为millis毫秒\npublic final void join(long millis)</code></pre><p>Runnable接口</p>\n<p>Runnable是Java中用以实现线程的接口，只有一个方法run()</p>\n<p>任何实现线程功能的类都必须实现该接口</p>\n<h3 id=\"线程优先级\"><a href=\"#线程优先级\" class=\"headerlink\" title=\"线程优先级\"></a>线程优先级</h3><p>Java为线程类提供了10个优先级，优先级可以用整数1-10表示，超过范围会抛出异常，主线程默认优先级为5</p>\n<p>优先级常量</p>\n<pre><code>MAX_PRIORITY：线程的最高优先级10\nMIN_PRIORITY：线程的最低优先级1\nNORM_PRIORITY：线程的默认优先级5</code></pre><p>优先级相关方法：</p>\n<pre><code class=\";\">// 获取线程优先级\npublic int getPriority()\n\n// 设置线程优先级\npublic void setPriority(int newPriority)\n\n// 获取主线程优先级\nint mainpriority = Thread.currentThread().getPriority()</code></pre>\n<h3 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h3><p>各线程通过竞争CPU时间而获得运行机会，各线程什么时候得到CPU时间，占用多久，是不可预测的，一个正在运行着的线程在什么地方被暂停是不确定的</p>\n<p>synchronized</p>\n<p>成员方法，静态方法、语句块</p>\n<pre><code>public synchronized void func() {}\npublic static synchronized void func() {}\nsynchronized(obj) {}</code></pre><p>线程间通信</p>\n"},{"title":"1、Django基础内容","date":"2020-06-19T02:46:18.000Z","fileName":"django1","_content":"\n模型（Model）\n\n\n\n视图（View）\n\n\n\n模板（Template）\n\n\n\n\n\n```\ndjango-admin startproject my_project\n```\n\n\n\n```\npython manage.py runserver\n```\n\n\n\nurl指定name，方便重定向\n\n```\nurl = reverse('index_two')\nreturn redirect(url)\n```\n\n\n\n\n\nurl的嵌套，使用include关键字\n\n```\nfrom django.conf.urls import include\n\nurl('', inclued('child.urls'))\n```\n\n\n\n视图\n\n一个视图函数，简称视图，是一个python函数\n\n接受一个请求，返回一个响应。响应可以是HTML内容、文本、图像，甚至是404、重定向等\n\n在urls.py文件中加上要响应的url\n\n```\nurlpatterns = [\n    url(r'^admin/', admin.site.urls),\n\n    # 展示当前时间\n    url(r'^time/$', views.now_time),\n]\n```\n\n在views.py中加入相应的视图函数\n\n```\n# 返回一个展示时间的html\ndef now_time(request):\n    \"\"\" 展示时间 \"\"\"\n    now = datetime.now()\n    html = \"\"\"\n    <html>\n        <head>\n            <style type=\"text/css\">\n                body {{color: blue}}\n            </style>\n        </head>\n        <body>\n            now: {0}\n        </body>\n    </html>\n    \"\"\".format(now)\n    return HttpResponse(html)\n```\n\n\n\n\n\n视图中获取URL参数\n\n视图中获取URL中的请求（GET/POST等）参数\n\n```\n# 输入URL\nhttp://index/?par=20\n# 视图编写，若找不到par参数则返回默认值10\ndef index(request):\n\tpar = request.GET.get('par', 10)\n\trequest.POST.get()\n```\n\n\n\n返回HTML信息\n\n通过文件读取方式返回\n\n```\ndef gg(request):\n    \"\"\" 从html文件读取内容，并响应 \"\"\"\n    html = ''\n    file_name = os.path.join(settings.BASE_DIR, 'templates', 'index.html')\n    with open(file_name) as f:\n        html = f.read()\n    return HttpResponse(html)\n```\n\n直接使用render_to_response函数\n\n```\nfrom django.shortcuts import render_to_response\n\ndef index(request):\n    return render_to_response('index.html')\n```\n\n\n\n内置错误处理视图\n\n400 Bad Request\n\n403 Forbidden\n\n404 Not Found\n\n500 Internal Server Error\n\n\n\n重写内置错误处理视图\n\n在urls.py中添加配置\n\n```\nhandler500 = 'django_app.views.page_500'\n```\n\n在views.py中添加\n\n```\ndef page_500(request):\n\tpass\n```\n\n\n\n请求对象Request\n\n请求方式method（POST/GET....）\n\n请求头信息META\n\nREMOTE_ADDR——请求的IP地址\n\nHTTP_USER_AGENT——用户请求终端信息\n\n获取请求传递参数\n\nGET、POST、COOKIES、FILES\n\n\n\n响应对象\n\nHttpResponse\n\nstatus：查看状态码\n\ncontent_type：设置响应类型\n\n\n\nFileResponse\n\n\n\n使用类重写视图\n\n1、继承视图。django.views.generic.TemplateView\n\n2、配置模板地址\n\n3、配置URL\n\n\n\nTemplateView原理\n\n1、从项目主目录寻找模板文件\n\n2、从app进行寻找\n\n```\nclass ShowClassView(TemplateView):\n    \"\"\" class视图 \"\"\"\n    template_name = 'class.html'\n    \nurl(r'^show/class/$', views.ShowClassView.as_view(), name\n```\n\n\n\n\n\n模板：\n\n模板具有一定的格式或骨架，可以动态的生成HTML\n\n\n\n模板引擎决定以何种方式组织代码\n\nDTL\n\nJinja2\n\n\n\n渲染机制\n\n1、从磁盘读取模板文件（get_template）\n\n2、选择合适模板引擎（select_template）\n\n3、将制定内容对模板进行渲染（render）\n\n4、发送给浏览器显示\n\n\n\n\n\n渲染python中的对象\n\n\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    我制定的值为: { { p1 } }\n</body>\n</html>\n```\n\n\n\n\n\n```\nurl(r'^text/$', views.text_show)\n\ndef text_show(request):\n    \"\"\" 变量在模板中的渲染 \"\"\"\n    p1 = 10\n    return render(request, 'index.html', {\n        'p1' : p1\n    })\n```\n\n\n\n```\n模板标签\n\n{% %}\n\n循环控制\n\n{% for item in list %}\n\n<li> </li>\n\n{% endfor %}\n```\n\n\n\n```\n条件控制\n\n{% if A %}\n\t满足A\n{% elif B %}\n\t满足B\n{% else %}\n\t都不满足\n{% endif %}\n```\n\n\n\n```\n注释\n\n{# 注释内容 #}\n```\n\n\n\n示例\n\n```\ndef text_show(request):\n    \"\"\" 变量在模板中的渲染 \"\"\"\n    list = ['北京', \"上海\", \"广州\", \"深圳\"]\n    return render(request, 'index.html', {\n        'list': list\n    })\n```\n\n\n\n```\n<ul>\n    {% for item in list  %}\n        <li>\n            {{ item }}\n        </li>\n    {% endfor %}\n</ul>\n```\n\n\n\n模板过滤器：对变量进行处理后再渲染\n\n```\n{{ value|filter_name:params }}\n```\n\n\n\n自定义过滤器\n\n1、在app目录下新建包templatetags，并新建filter.py\n\n2、定义过滤器\n\n```\nfrom django import template\n\nregister = template.Library()\n\ndef func(value):\n    pass\n\n# 注册过滤器\nregister.filter('func', func)\n```\n\n3、在模板中使用过滤器（）\n\n```\n{% load filter %}\n{{ value|func }}\n```\n\n\n\n模板的抽象和继承\n\n","source":"_posts/Python/Django/1、Django基础内容.md","raw":"---\ntitle: 1、Django基础内容\ndate: 2020-06-19 10:46:18\ntags:\n\t- Python\ncategories:\n\t- Python\n\t- Django\nfileName: django1\n---\n\n模型（Model）\n\n\n\n视图（View）\n\n\n\n模板（Template）\n\n\n\n\n\n```\ndjango-admin startproject my_project\n```\n\n\n\n```\npython manage.py runserver\n```\n\n\n\nurl指定name，方便重定向\n\n```\nurl = reverse('index_two')\nreturn redirect(url)\n```\n\n\n\n\n\nurl的嵌套，使用include关键字\n\n```\nfrom django.conf.urls import include\n\nurl('', inclued('child.urls'))\n```\n\n\n\n视图\n\n一个视图函数，简称视图，是一个python函数\n\n接受一个请求，返回一个响应。响应可以是HTML内容、文本、图像，甚至是404、重定向等\n\n在urls.py文件中加上要响应的url\n\n```\nurlpatterns = [\n    url(r'^admin/', admin.site.urls),\n\n    # 展示当前时间\n    url(r'^time/$', views.now_time),\n]\n```\n\n在views.py中加入相应的视图函数\n\n```\n# 返回一个展示时间的html\ndef now_time(request):\n    \"\"\" 展示时间 \"\"\"\n    now = datetime.now()\n    html = \"\"\"\n    <html>\n        <head>\n            <style type=\"text/css\">\n                body {{color: blue}}\n            </style>\n        </head>\n        <body>\n            now: {0}\n        </body>\n    </html>\n    \"\"\".format(now)\n    return HttpResponse(html)\n```\n\n\n\n\n\n视图中获取URL参数\n\n视图中获取URL中的请求（GET/POST等）参数\n\n```\n# 输入URL\nhttp://index/?par=20\n# 视图编写，若找不到par参数则返回默认值10\ndef index(request):\n\tpar = request.GET.get('par', 10)\n\trequest.POST.get()\n```\n\n\n\n返回HTML信息\n\n通过文件读取方式返回\n\n```\ndef gg(request):\n    \"\"\" 从html文件读取内容，并响应 \"\"\"\n    html = ''\n    file_name = os.path.join(settings.BASE_DIR, 'templates', 'index.html')\n    with open(file_name) as f:\n        html = f.read()\n    return HttpResponse(html)\n```\n\n直接使用render_to_response函数\n\n```\nfrom django.shortcuts import render_to_response\n\ndef index(request):\n    return render_to_response('index.html')\n```\n\n\n\n内置错误处理视图\n\n400 Bad Request\n\n403 Forbidden\n\n404 Not Found\n\n500 Internal Server Error\n\n\n\n重写内置错误处理视图\n\n在urls.py中添加配置\n\n```\nhandler500 = 'django_app.views.page_500'\n```\n\n在views.py中添加\n\n```\ndef page_500(request):\n\tpass\n```\n\n\n\n请求对象Request\n\n请求方式method（POST/GET....）\n\n请求头信息META\n\nREMOTE_ADDR——请求的IP地址\n\nHTTP_USER_AGENT——用户请求终端信息\n\n获取请求传递参数\n\nGET、POST、COOKIES、FILES\n\n\n\n响应对象\n\nHttpResponse\n\nstatus：查看状态码\n\ncontent_type：设置响应类型\n\n\n\nFileResponse\n\n\n\n使用类重写视图\n\n1、继承视图。django.views.generic.TemplateView\n\n2、配置模板地址\n\n3、配置URL\n\n\n\nTemplateView原理\n\n1、从项目主目录寻找模板文件\n\n2、从app进行寻找\n\n```\nclass ShowClassView(TemplateView):\n    \"\"\" class视图 \"\"\"\n    template_name = 'class.html'\n    \nurl(r'^show/class/$', views.ShowClassView.as_view(), name\n```\n\n\n\n\n\n模板：\n\n模板具有一定的格式或骨架，可以动态的生成HTML\n\n\n\n模板引擎决定以何种方式组织代码\n\nDTL\n\nJinja2\n\n\n\n渲染机制\n\n1、从磁盘读取模板文件（get_template）\n\n2、选择合适模板引擎（select_template）\n\n3、将制定内容对模板进行渲染（render）\n\n4、发送给浏览器显示\n\n\n\n\n\n渲染python中的对象\n\n\n\n```\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n    我制定的值为: { { p1 } }\n</body>\n</html>\n```\n\n\n\n\n\n```\nurl(r'^text/$', views.text_show)\n\ndef text_show(request):\n    \"\"\" 变量在模板中的渲染 \"\"\"\n    p1 = 10\n    return render(request, 'index.html', {\n        'p1' : p1\n    })\n```\n\n\n\n```\n模板标签\n\n{% %}\n\n循环控制\n\n{% for item in list %}\n\n<li> </li>\n\n{% endfor %}\n```\n\n\n\n```\n条件控制\n\n{% if A %}\n\t满足A\n{% elif B %}\n\t满足B\n{% else %}\n\t都不满足\n{% endif %}\n```\n\n\n\n```\n注释\n\n{# 注释内容 #}\n```\n\n\n\n示例\n\n```\ndef text_show(request):\n    \"\"\" 变量在模板中的渲染 \"\"\"\n    list = ['北京', \"上海\", \"广州\", \"深圳\"]\n    return render(request, 'index.html', {\n        'list': list\n    })\n```\n\n\n\n```\n<ul>\n    {% for item in list  %}\n        <li>\n            {{ item }}\n        </li>\n    {% endfor %}\n</ul>\n```\n\n\n\n模板过滤器：对变量进行处理后再渲染\n\n```\n{{ value|filter_name:params }}\n```\n\n\n\n自定义过滤器\n\n1、在app目录下新建包templatetags，并新建filter.py\n\n2、定义过滤器\n\n```\nfrom django import template\n\nregister = template.Library()\n\ndef func(value):\n    pass\n\n# 注册过滤器\nregister.filter('func', func)\n```\n\n3、在模板中使用过滤器（）\n\n```\n{% load filter %}\n{{ value|func }}\n```\n\n\n\n模板的抽象和继承\n\n","slug":"Python/Django/1、Django基础内容","published":1,"updated":"2020-07-16T09:30:16.026Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8s90007l4js3035evnp","content":"<p>模型（Model）</p>\n<p>视图（View）</p>\n<p>模板（Template）</p>\n<pre><code>django-admin startproject my_project</code></pre><pre><code>python manage.py runserver</code></pre><p>url指定name，方便重定向</p>\n<pre><code>url = reverse(&#39;index_two&#39;)\nreturn redirect(url)</code></pre><p>url的嵌套，使用include关键字</p>\n<pre><code>from django.conf.urls import include\n\nurl(&#39;&#39;, inclued(&#39;child.urls&#39;))</code></pre><p>视图</p>\n<p>一个视图函数，简称视图，是一个python函数</p>\n<p>接受一个请求，返回一个响应。响应可以是HTML内容、文本、图像，甚至是404、重定向等</p>\n<p>在urls.py文件中加上要响应的url</p>\n<pre><code>urlpatterns = [\n    url(r&#39;^admin/&#39;, admin.site.urls),\n\n    # 展示当前时间\n    url(r&#39;^time/$&#39;, views.now_time),\n]</code></pre><p>在views.py中加入相应的视图函数</p>\n<pre><code># 返回一个展示时间的html\ndef now_time(request):\n    &quot;&quot;&quot; 展示时间 &quot;&quot;&quot;\n    now = datetime.now()\n    html = &quot;&quot;&quot;\n    &lt;html&gt;\n        &lt;head&gt;\n            &lt;style type=&quot;text/css&quot;&gt;\n                body {{color: blue}}\n            &lt;/style&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n            now: {0}\n        &lt;/body&gt;\n    &lt;/html&gt;\n    &quot;&quot;&quot;.format(now)\n    return HttpResponse(html)</code></pre><p>视图中获取URL参数</p>\n<p>视图中获取URL中的请求（GET/POST等）参数</p>\n<pre><code># 输入URL\nhttp://index/?par=20\n# 视图编写，若找不到par参数则返回默认值10\ndef index(request):\n    par = request.GET.get(&#39;par&#39;, 10)\n    request.POST.get()</code></pre><p>返回HTML信息</p>\n<p>通过文件读取方式返回</p>\n<pre><code>def gg(request):\n    &quot;&quot;&quot; 从html文件读取内容，并响应 &quot;&quot;&quot;\n    html = &#39;&#39;\n    file_name = os.path.join(settings.BASE_DIR, &#39;templates&#39;, &#39;index.html&#39;)\n    with open(file_name) as f:\n        html = f.read()\n    return HttpResponse(html)</code></pre><p>直接使用render_to_response函数</p>\n<pre><code>from django.shortcuts import render_to_response\n\ndef index(request):\n    return render_to_response(&#39;index.html&#39;)</code></pre><p>内置错误处理视图</p>\n<p>400 Bad Request</p>\n<p>403 Forbidden</p>\n<p>404 Not Found</p>\n<p>500 Internal Server Error</p>\n<p>重写内置错误处理视图</p>\n<p>在urls.py中添加配置</p>\n<pre><code>handler500 = &#39;django_app.views.page_500&#39;</code></pre><p>在views.py中添加</p>\n<pre><code>def page_500(request):\n    pass</code></pre><p>请求对象Request</p>\n<p>请求方式method（POST/GET….）</p>\n<p>请求头信息META</p>\n<p>REMOTE_ADDR——请求的IP地址</p>\n<p>HTTP_USER_AGENT——用户请求终端信息</p>\n<p>获取请求传递参数</p>\n<p>GET、POST、COOKIES、FILES</p>\n<p>响应对象</p>\n<p>HttpResponse</p>\n<p>status：查看状态码</p>\n<p>content_type：设置响应类型</p>\n<p>FileResponse</p>\n<p>使用类重写视图</p>\n<p>1、继承视图。django.views.generic.TemplateView</p>\n<p>2、配置模板地址</p>\n<p>3、配置URL</p>\n<p>TemplateView原理</p>\n<p>1、从项目主目录寻找模板文件</p>\n<p>2、从app进行寻找</p>\n<pre><code>class ShowClassView(TemplateView):\n    &quot;&quot;&quot; class视图 &quot;&quot;&quot;\n    template_name = &#39;class.html&#39;\n\nurl(r&#39;^show/class/$&#39;, views.ShowClassView.as_view(), name</code></pre><p>模板：</p>\n<p>模板具有一定的格式或骨架，可以动态的生成HTML</p>\n<p>模板引擎决定以何种方式组织代码</p>\n<p>DTL</p>\n<p>Jinja2</p>\n<p>渲染机制</p>\n<p>1、从磁盘读取模板文件（get_template）</p>\n<p>2、选择合适模板引擎（select_template）</p>\n<p>3、将制定内容对模板进行渲染（render）</p>\n<p>4、发送给浏览器显示</p>\n<p>渲染python中的对象</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    我制定的值为: { { p1 } }\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><pre><code>url(r&#39;^text/$&#39;, views.text_show)\n\ndef text_show(request):\n    &quot;&quot;&quot; 变量在模板中的渲染 &quot;&quot;&quot;\n    p1 = 10\n    return render(request, &#39;index.html&#39;, {\n        &#39;p1&#39; : p1\n    })</code></pre><pre><code>模板标签\n\n{% %}\n\n循环控制\n\n{% for item in list %}\n\n<li> </li>\n\n{% endfor %}</code></pre><pre><code>条件控制\n\n{% if A %}\n\t满足A\n{% elif B %}\n\t满足B\n{% else %}\n\t都不满足\n{% endif %}</code></pre><pre><code>注释\n\n</code></pre><p>示例</p>\n<pre><code>def text_show(request):\n    &quot;&quot;&quot; 变量在模板中的渲染 &quot;&quot;&quot;\n    list = [&#39;北京&#39;, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;]\n    return render(request, &#39;index.html&#39;, {\n        &#39;list&#39;: list\n    })</code></pre><pre><code>&lt;ul&gt;\n    {% for item in list  %}\n        <li>\n            {{ item }}\n        </li>\n    {% endfor %}\n&lt;/ul&gt;</code></pre><p>模板过滤器：对变量进行处理后再渲染</p>\n<pre><code>{{ value|filter_name:params }}</code></pre><p>自定义过滤器</p>\n<p>1、在app目录下新建包templatetags，并新建filter.py</p>\n<p>2、定义过滤器</p>\n<pre><code>from django import template\n\nregister = template.Library()\n\ndef func(value):\n    pass\n\n# 注册过滤器\nregister.filter(&#39;func&#39;, func)</code></pre><p>3、在模板中使用过滤器（）</p>\n<pre><code>{% load filter %}\n{{ value|func }}</code></pre><p>模板的抽象和继承</p>\n","site":{"data":{}},"excerpt":"","more":"<p>模型（Model）</p>\n<p>视图（View）</p>\n<p>模板（Template）</p>\n<pre><code>django-admin startproject my_project</code></pre><pre><code>python manage.py runserver</code></pre><p>url指定name，方便重定向</p>\n<pre><code>url = reverse(&#39;index_two&#39;)\nreturn redirect(url)</code></pre><p>url的嵌套，使用include关键字</p>\n<pre><code>from django.conf.urls import include\n\nurl(&#39;&#39;, inclued(&#39;child.urls&#39;))</code></pre><p>视图</p>\n<p>一个视图函数，简称视图，是一个python函数</p>\n<p>接受一个请求，返回一个响应。响应可以是HTML内容、文本、图像，甚至是404、重定向等</p>\n<p>在urls.py文件中加上要响应的url</p>\n<pre><code>urlpatterns = [\n    url(r&#39;^admin/&#39;, admin.site.urls),\n\n    # 展示当前时间\n    url(r&#39;^time/$&#39;, views.now_time),\n]</code></pre><p>在views.py中加入相应的视图函数</p>\n<pre><code># 返回一个展示时间的html\ndef now_time(request):\n    &quot;&quot;&quot; 展示时间 &quot;&quot;&quot;\n    now = datetime.now()\n    html = &quot;&quot;&quot;\n    &lt;html&gt;\n        &lt;head&gt;\n            &lt;style type=&quot;text/css&quot;&gt;\n                body {{color: blue}}\n            &lt;/style&gt;\n        &lt;/head&gt;\n        &lt;body&gt;\n            now: {0}\n        &lt;/body&gt;\n    &lt;/html&gt;\n    &quot;&quot;&quot;.format(now)\n    return HttpResponse(html)</code></pre><p>视图中获取URL参数</p>\n<p>视图中获取URL中的请求（GET/POST等）参数</p>\n<pre><code># 输入URL\nhttp://index/?par=20\n# 视图编写，若找不到par参数则返回默认值10\ndef index(request):\n    par = request.GET.get(&#39;par&#39;, 10)\n    request.POST.get()</code></pre><p>返回HTML信息</p>\n<p>通过文件读取方式返回</p>\n<pre><code>def gg(request):\n    &quot;&quot;&quot; 从html文件读取内容，并响应 &quot;&quot;&quot;\n    html = &#39;&#39;\n    file_name = os.path.join(settings.BASE_DIR, &#39;templates&#39;, &#39;index.html&#39;)\n    with open(file_name) as f:\n        html = f.read()\n    return HttpResponse(html)</code></pre><p>直接使用render_to_response函数</p>\n<pre><code>from django.shortcuts import render_to_response\n\ndef index(request):\n    return render_to_response(&#39;index.html&#39;)</code></pre><p>内置错误处理视图</p>\n<p>400 Bad Request</p>\n<p>403 Forbidden</p>\n<p>404 Not Found</p>\n<p>500 Internal Server Error</p>\n<p>重写内置错误处理视图</p>\n<p>在urls.py中添加配置</p>\n<pre><code>handler500 = &#39;django_app.views.page_500&#39;</code></pre><p>在views.py中添加</p>\n<pre><code>def page_500(request):\n    pass</code></pre><p>请求对象Request</p>\n<p>请求方式method（POST/GET….）</p>\n<p>请求头信息META</p>\n<p>REMOTE_ADDR——请求的IP地址</p>\n<p>HTTP_USER_AGENT——用户请求终端信息</p>\n<p>获取请求传递参数</p>\n<p>GET、POST、COOKIES、FILES</p>\n<p>响应对象</p>\n<p>HttpResponse</p>\n<p>status：查看状态码</p>\n<p>content_type：设置响应类型</p>\n<p>FileResponse</p>\n<p>使用类重写视图</p>\n<p>1、继承视图。django.views.generic.TemplateView</p>\n<p>2、配置模板地址</p>\n<p>3、配置URL</p>\n<p>TemplateView原理</p>\n<p>1、从项目主目录寻找模板文件</p>\n<p>2、从app进行寻找</p>\n<pre><code>class ShowClassView(TemplateView):\n    &quot;&quot;&quot; class视图 &quot;&quot;&quot;\n    template_name = &#39;class.html&#39;\n\nurl(r&#39;^show/class/$&#39;, views.ShowClassView.as_view(), name</code></pre><p>模板：</p>\n<p>模板具有一定的格式或骨架，可以动态的生成HTML</p>\n<p>模板引擎决定以何种方式组织代码</p>\n<p>DTL</p>\n<p>Jinja2</p>\n<p>渲染机制</p>\n<p>1、从磁盘读取模板文件（get_template）</p>\n<p>2、选择合适模板引擎（select_template）</p>\n<p>3、将制定内容对模板进行渲染（render）</p>\n<p>4、发送给浏览器显示</p>\n<p>渲染python中的对象</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot;&gt;\n    &lt;title&gt;Title&lt;/title&gt;\n&lt;/head&gt;\n&lt;body&gt;\n    我制定的值为: { { p1 } }\n&lt;/body&gt;\n&lt;/html&gt;</code></pre><pre><code>url(r&#39;^text/$&#39;, views.text_show)\n\ndef text_show(request):\n    &quot;&quot;&quot; 变量在模板中的渲染 &quot;&quot;&quot;\n    p1 = 10\n    return render(request, &#39;index.html&#39;, {\n        &#39;p1&#39; : p1\n    })</code></pre><pre><code>模板标签\n\n{% %}\n\n循环控制\n\n{% for item in list %}\n\n<li> </li>\n\n{% endfor %}</code></pre><pre><code>条件控制\n\n{% if A %}\n\t满足A\n{% elif B %}\n\t满足B\n{% else %}\n\t都不满足\n{% endif %}</code></pre><pre><code>注释\n\n</code></pre><p>示例</p>\n<pre><code>def text_show(request):\n    &quot;&quot;&quot; 变量在模板中的渲染 &quot;&quot;&quot;\n    list = [&#39;北京&#39;, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;]\n    return render(request, &#39;index.html&#39;, {\n        &#39;list&#39;: list\n    })</code></pre><pre><code>&lt;ul&gt;\n    {% for item in list  %}\n        <li>\n            {{ item }}\n        </li>\n    {% endfor %}\n&lt;/ul&gt;</code></pre><p>模板过滤器：对变量进行处理后再渲染</p>\n<pre><code>{{ value|filter_name:params }}</code></pre><p>自定义过滤器</p>\n<p>1、在app目录下新建包templatetags，并新建filter.py</p>\n<p>2、定义过滤器</p>\n<pre><code>from django import template\n\nregister = template.Library()\n\ndef func(value):\n    pass\n\n# 注册过滤器\nregister.filter(&#39;func&#39;, func)</code></pre><p>3、在模板中使用过滤器（）</p>\n<pre><code>{% load filter %}\n{{ value|func }}</code></pre><p>模板的抽象和继承</p>\n"},{"title":"python常见问题","date":"2020-06-26T09:29:13.000Z","fileName":"python_method","_content":"\n### 生成requirements.txt\n\n使用`pipreqs`生成requirements\n\n```\n# 安装\npip install pipreqs\n# 在当前目录生成（若存在即覆盖）\npipreqs . --encoding=utf8 --force\n```\n\n使用requirement.txt安装依赖：\n\n```\\\npip install -r requirements.txt\n```\n\n","source":"_posts/Python/其他/python常见问题.md","raw":"---\ntitle: python常见问题\ndate: 2020-06-26 17:29:13\ntags:\ncategories:\n\t- Python\nfileName: python_method\n---\n\n### 生成requirements.txt\n\n使用`pipreqs`生成requirements\n\n```\n# 安装\npip install pipreqs\n# 在当前目录生成（若存在即覆盖）\npipreqs . --encoding=utf8 --force\n```\n\n使用requirement.txt安装依赖：\n\n```\\\npip install -r requirements.txt\n```\n\n","slug":"Python/其他/python常见问题","published":1,"updated":"2020-06-26T09:52:18.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8sc0009l4js1hdlfn2d","content":"<h3 id=\"生成requirements-txt\"><a href=\"#生成requirements-txt\" class=\"headerlink\" title=\"生成requirements.txt\"></a>生成requirements.txt</h3><p>使用<code>pipreqs</code>生成requirements</p>\n<pre><code># 安装\npip install pipreqs\n# 在当前目录生成（若存在即覆盖）\npipreqs . --encoding=utf8 --force</code></pre><p>使用requirement.txt安装依赖：</p>\n<pre><code class=\"\\\">pip install -r requirements.txt</code></pre>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"生成requirements-txt\"><a href=\"#生成requirements-txt\" class=\"headerlink\" title=\"生成requirements.txt\"></a>生成requirements.txt</h3><p>使用<code>pipreqs</code>生成requirements</p>\n<pre><code># 安装\npip install pipreqs\n# 在当前目录生成（若存在即覆盖）\npipreqs . --encoding=utf8 --force</code></pre><p>使用requirement.txt安装依赖：</p>\n<pre><code class=\"\\\">pip install -r requirements.txt</code></pre>\n"},{"title":"3、Java中的容器","date":"2020-07-10T06:34:11.000Z","fileName":"java3","_content":"\n\n\n\n\n\n\n### 异常\n\nThrowable根类\n\nError、Exception（程序本身可以处理的异常）\n\n\n\ntry块后可以接0或多个catch块，若没有catch块，则必须跟一个finally块\n\n```\ntry {\n\n} catch(Exception e) {\n\te.printStackTrace();\n} finally {\n\n}\n```\n\n\n\nthrows声明方法将要抛出何种异常的声明，通过throw将产生的异常抛出\n\n若一个方法可能出现异常，但没有能力处理异常，可以在方法声明处用throws子句来声明抛出异常\n\n```\npublic void method() throws Exception1, Exception2 {\n\t//可能产生异常的代码\n}\n```\n\n\n\n\n\n### 字符串\n\nequal方法指内容是否相同\n\n==指地址是否相同\n\n\n\nString的对象一旦被创建，则不能修改，是不可变的（即使用substr等函数时其本身是不会变的）\n\n\n\n当频繁操作字符串时，使用StringBuilder\n\n常用方法\n\n```\nStringBuilder str = new StringBuilder(\"hello\");\nstr.append(\" world\");\t// 向后添加字符串\nstr.delete(0,5);\t// 删除第0-4个字符\nstr.insert(4,\"gg\");\t// 在索引4向后插入gg\nstr.replace(4,6,\"aa\");\t// 在缩影4到5处替换为aa\n\n```\n\n\n\n### 集合\n\nCollection：List，Queue，Set\n\nList是元素有序并且可以重复的集合，称为序列\n\n两个主要实现类：ArrayList，LinkedList\n\n\n\nArrayList底层由数组实现，动态增长，其中元素可以为null\n\n```\nArrayList list = new ArrayList();\nlist.add(1);\t// 向后添加\nlist.size();\t// 获取元素数量\nlist.get(1);\t// 取出索引值为1的元素\nlist.remove(2);\t// 移除索引为2的元素\n\n```\n\n\n\nSet\n\n元素无序且不可以重复的集合。\n\nHashSet是Set的一个重要元素，称为哈希集，其中元素无序且不可以重复，只允许一个null元素。\n\n\n\n### 迭代器\n\nIterator接口可以以统一的方式对各种集合元素进行遍历，调用各种集合元素的iterator()方法得到迭代器。\n\nhasNext()方法检测集合中是否还有下一个元素\n\nnext()方法返回集合中的下一个元素\n\n```\nIterator it = set.iterator();\nwhile (it.hasNext()) {\n\tSystem.out.println(it.next());\n}\n```\n\n\n\nhashCode()和equals()，用于判断是否相同，选哟进行重写  \n\n\n\nMap。以键值对的形式存储\n\nHashMap：基于哈希表的Map接口的实现，允许使用null值和null键，无序排列。\n\n\n\n排序\n\n```\nCollections.sort(list);\n```\n\n使用Comparable或Comparator接口对自定义类进行排序\n\n\n\n\n\n### 泛型\n\n变量声明的类型必须匹配传递给实际对象的类型（即前后尖括号中的内容必须相同）\n\n\n\n<? extends 类名>   该类与其子类都可以\n\n<? super 类名> 该类与其父类都可以\n\n\n\n泛型方法不一定要写在泛型类当中\n\n```\n// 泛型方法\npublic class Generic {\n\tpublic <T> void func(T t) {\n\t\t\n\t}\n\t// 可以输入Number的子类\n\tpublic <T extents Number> void func1(T t) {\n\t\n\t}\n}\n```\n\n\n\n\n\n\n\n","source":"_posts/Java/语言基础/3、Java中的常用容器与方法.md","raw":"---\ntitle: 3、Java中的容器\ndate: 2020-07-10 14:34:11\ntags:\n\t- Java\ncategories:\n\t- Java\n\t- 语言基础\nfileName: java3\n---\n\n\n\n\n\n\n\n### 异常\n\nThrowable根类\n\nError、Exception（程序本身可以处理的异常）\n\n\n\ntry块后可以接0或多个catch块，若没有catch块，则必须跟一个finally块\n\n```\ntry {\n\n} catch(Exception e) {\n\te.printStackTrace();\n} finally {\n\n}\n```\n\n\n\nthrows声明方法将要抛出何种异常的声明，通过throw将产生的异常抛出\n\n若一个方法可能出现异常，但没有能力处理异常，可以在方法声明处用throws子句来声明抛出异常\n\n```\npublic void method() throws Exception1, Exception2 {\n\t//可能产生异常的代码\n}\n```\n\n\n\n\n\n### 字符串\n\nequal方法指内容是否相同\n\n==指地址是否相同\n\n\n\nString的对象一旦被创建，则不能修改，是不可变的（即使用substr等函数时其本身是不会变的）\n\n\n\n当频繁操作字符串时，使用StringBuilder\n\n常用方法\n\n```\nStringBuilder str = new StringBuilder(\"hello\");\nstr.append(\" world\");\t// 向后添加字符串\nstr.delete(0,5);\t// 删除第0-4个字符\nstr.insert(4,\"gg\");\t// 在索引4向后插入gg\nstr.replace(4,6,\"aa\");\t// 在缩影4到5处替换为aa\n\n```\n\n\n\n### 集合\n\nCollection：List，Queue，Set\n\nList是元素有序并且可以重复的集合，称为序列\n\n两个主要实现类：ArrayList，LinkedList\n\n\n\nArrayList底层由数组实现，动态增长，其中元素可以为null\n\n```\nArrayList list = new ArrayList();\nlist.add(1);\t// 向后添加\nlist.size();\t// 获取元素数量\nlist.get(1);\t// 取出索引值为1的元素\nlist.remove(2);\t// 移除索引为2的元素\n\n```\n\n\n\nSet\n\n元素无序且不可以重复的集合。\n\nHashSet是Set的一个重要元素，称为哈希集，其中元素无序且不可以重复，只允许一个null元素。\n\n\n\n### 迭代器\n\nIterator接口可以以统一的方式对各种集合元素进行遍历，调用各种集合元素的iterator()方法得到迭代器。\n\nhasNext()方法检测集合中是否还有下一个元素\n\nnext()方法返回集合中的下一个元素\n\n```\nIterator it = set.iterator();\nwhile (it.hasNext()) {\n\tSystem.out.println(it.next());\n}\n```\n\n\n\nhashCode()和equals()，用于判断是否相同，选哟进行重写  \n\n\n\nMap。以键值对的形式存储\n\nHashMap：基于哈希表的Map接口的实现，允许使用null值和null键，无序排列。\n\n\n\n排序\n\n```\nCollections.sort(list);\n```\n\n使用Comparable或Comparator接口对自定义类进行排序\n\n\n\n\n\n### 泛型\n\n变量声明的类型必须匹配传递给实际对象的类型（即前后尖括号中的内容必须相同）\n\n\n\n<? extends 类名>   该类与其子类都可以\n\n<? super 类名> 该类与其父类都可以\n\n\n\n泛型方法不一定要写在泛型类当中\n\n```\n// 泛型方法\npublic class Generic {\n\tpublic <T> void func(T t) {\n\t\t\n\t}\n\t// 可以输入Number的子类\n\tpublic <T extents Number> void func1(T t) {\n\t\n\t}\n}\n```\n\n\n\n\n\n\n\n","slug":"Java/语言基础/3、Java中的常用容器与方法","published":1,"updated":"2020-07-16T16:06:35.916Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8sj000cl4js9oevhe66","content":"<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><p>Throwable根类</p>\n<p>Error、Exception（程序本身可以处理的异常）</p>\n<p>try块后可以接0或多个catch块，若没有catch块，则必须跟一个finally块</p>\n<pre><code>try {\n\n} catch(Exception e) {\n    e.printStackTrace();\n} finally {\n\n}</code></pre><p>throws声明方法将要抛出何种异常的声明，通过throw将产生的异常抛出</p>\n<p>若一个方法可能出现异常，但没有能力处理异常，可以在方法声明处用throws子句来声明抛出异常</p>\n<pre><code>public void method() throws Exception1, Exception2 {\n    //可能产生异常的代码\n}</code></pre><h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>equal方法指内容是否相同</p>\n<p>==指地址是否相同</p>\n<p>String的对象一旦被创建，则不能修改，是不可变的（即使用substr等函数时其本身是不会变的）</p>\n<p>当频繁操作字符串时，使用StringBuilder</p>\n<p>常用方法</p>\n<pre><code>StringBuilder str = new StringBuilder(&quot;hello&quot;);\nstr.append(&quot; world&quot;);    // 向后添加字符串\nstr.delete(0,5);    // 删除第0-4个字符\nstr.insert(4,&quot;gg&quot;);    // 在索引4向后插入gg\nstr.replace(4,6,&quot;aa&quot;);    // 在缩影4到5处替换为aa\n</code></pre><h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>Collection：List，Queue，Set</p>\n<p>List是元素有序并且可以重复的集合，称为序列</p>\n<p>两个主要实现类：ArrayList，LinkedList</p>\n<p>ArrayList底层由数组实现，动态增长，其中元素可以为null</p>\n<pre><code>ArrayList list = new ArrayList();\nlist.add(1);    // 向后添加\nlist.size();    // 获取元素数量\nlist.get(1);    // 取出索引值为1的元素\nlist.remove(2);    // 移除索引为2的元素\n</code></pre><p>Set</p>\n<p>元素无序且不可以重复的集合。</p>\n<p>HashSet是Set的一个重要元素，称为哈希集，其中元素无序且不可以重复，只允许一个null元素。</p>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>Iterator接口可以以统一的方式对各种集合元素进行遍历，调用各种集合元素的iterator()方法得到迭代器。</p>\n<p>hasNext()方法检测集合中是否还有下一个元素</p>\n<p>next()方法返回集合中的下一个元素</p>\n<pre><code>Iterator it = set.iterator();\nwhile (it.hasNext()) {\n    System.out.println(it.next());\n}</code></pre><p>hashCode()和equals()，用于判断是否相同，选哟进行重写  </p>\n<p>Map。以键值对的形式存储</p>\n<p>HashMap：基于哈希表的Map接口的实现，允许使用null值和null键，无序排列。</p>\n<p>排序</p>\n<pre><code>Collections.sort(list);</code></pre><p>使用Comparable或Comparator接口对自定义类进行排序</p>\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><p>变量声明的类型必须匹配传递给实际对象的类型（即前后尖括号中的内容必须相同）</p>\n<p>&lt;? extends 类名&gt;   该类与其子类都可以</p>\n<p>&lt;? super 类名&gt; 该类与其父类都可以</p>\n<p>泛型方法不一定要写在泛型类当中</p>\n<pre><code>// 泛型方法\npublic class Generic {\n    public &lt;T&gt; void func(T t) {\n\n    }\n    // 可以输入Number的子类\n    public &lt;T extents Number&gt; void func1(T t) {\n\n    }\n}</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h3><p>Throwable根类</p>\n<p>Error、Exception（程序本身可以处理的异常）</p>\n<p>try块后可以接0或多个catch块，若没有catch块，则必须跟一个finally块</p>\n<pre><code>try {\n\n} catch(Exception e) {\n    e.printStackTrace();\n} finally {\n\n}</code></pre><p>throws声明方法将要抛出何种异常的声明，通过throw将产生的异常抛出</p>\n<p>若一个方法可能出现异常，但没有能力处理异常，可以在方法声明处用throws子句来声明抛出异常</p>\n<pre><code>public void method() throws Exception1, Exception2 {\n    //可能产生异常的代码\n}</code></pre><h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>equal方法指内容是否相同</p>\n<p>==指地址是否相同</p>\n<p>String的对象一旦被创建，则不能修改，是不可变的（即使用substr等函数时其本身是不会变的）</p>\n<p>当频繁操作字符串时，使用StringBuilder</p>\n<p>常用方法</p>\n<pre><code>StringBuilder str = new StringBuilder(&quot;hello&quot;);\nstr.append(&quot; world&quot;);    // 向后添加字符串\nstr.delete(0,5);    // 删除第0-4个字符\nstr.insert(4,&quot;gg&quot;);    // 在索引4向后插入gg\nstr.replace(4,6,&quot;aa&quot;);    // 在缩影4到5处替换为aa\n</code></pre><h3 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h3><p>Collection：List，Queue，Set</p>\n<p>List是元素有序并且可以重复的集合，称为序列</p>\n<p>两个主要实现类：ArrayList，LinkedList</p>\n<p>ArrayList底层由数组实现，动态增长，其中元素可以为null</p>\n<pre><code>ArrayList list = new ArrayList();\nlist.add(1);    // 向后添加\nlist.size();    // 获取元素数量\nlist.get(1);    // 取出索引值为1的元素\nlist.remove(2);    // 移除索引为2的元素\n</code></pre><p>Set</p>\n<p>元素无序且不可以重复的集合。</p>\n<p>HashSet是Set的一个重要元素，称为哈希集，其中元素无序且不可以重复，只允许一个null元素。</p>\n<h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>Iterator接口可以以统一的方式对各种集合元素进行遍历，调用各种集合元素的iterator()方法得到迭代器。</p>\n<p>hasNext()方法检测集合中是否还有下一个元素</p>\n<p>next()方法返回集合中的下一个元素</p>\n<pre><code>Iterator it = set.iterator();\nwhile (it.hasNext()) {\n    System.out.println(it.next());\n}</code></pre><p>hashCode()和equals()，用于判断是否相同，选哟进行重写  </p>\n<p>Map。以键值对的形式存储</p>\n<p>HashMap：基于哈希表的Map接口的实现，允许使用null值和null键，无序排列。</p>\n<p>排序</p>\n<pre><code>Collections.sort(list);</code></pre><p>使用Comparable或Comparator接口对自定义类进行排序</p>\n<h3 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h3><p>变量声明的类型必须匹配传递给实际对象的类型（即前后尖括号中的内容必须相同）</p>\n<p>&lt;? extends 类名&gt;   该类与其子类都可以</p>\n<p>&lt;? super 类名&gt; 该类与其父类都可以</p>\n<p>泛型方法不一定要写在泛型类当中</p>\n<pre><code>// 泛型方法\npublic class Generic {\n    public &lt;T&gt; void func(T t) {\n\n    }\n    // 可以输入Number的子类\n    public &lt;T extents Number&gt; void func1(T t) {\n\n    }\n}</code></pre>"},{"title":"Anaconda+PyCharm配置PyQt5全过程","date":"2020-04-09T14:44:55.000Z","fileName":"pyqt1","_content":"\n\n\n前段时间写了一个手写电话号码识别的小程序，GUI用的是Python自带的Tkinter，但这种GUI太简陋可视化效果不佳，因此打算使用别的更加强大的GUI重构一下，目光就瞄准了pyqt，因为用C++时接触过，知道这是个好用的GUI吧。\n\n## Anaconda下安装\n\n在Anaconda在GitHub上的issue下知道由于兼容Python2的原因没法用conda安装最新版PyQt5包，所以得使用pip命令进行安装。\n\n在Anaconda自带的prompt下输入以下命令即可完成安装。\n\n```\npip3 install PyQt5\n```\n\n但速度通常很慢，因此建议改为清华的镜像进行安装。\n\n```\npip install -i https://pypi.tuna.tsinghua.edu.cn/simple PyQt5\n```\n\n之后在命令行窗口输入`import PyQt5`，不报错，说明安装成功。\n\n## Pycharm下配置相关环境\n\n用过Qt的应该都知道Qt有QtDesigner这种优秀的可视化设计工具，可以简化编码，所以如果使用PyCharm作为IDE编写Python的话需要将QtDesigner作为拓展程序进行配置（这样可以在IDE中直接进行调用了，会很方便）。除此之外，还需要配置将QtDesigner生成的.ui文件转化为.py文件。\n\n### 配置QtDesigner\n\n在PyCharm中的`File->Settings`下，进行如下操作，即可配置完成QDesigner。\n\n![](Anaconda+PyCharm配置PyQt5全过程/1.png)\n\n### 配置PyUIC\n\n使用QDesigner生成的文件格式为.ui的格式，要将其转化为.py格式安装的pyqt包中也已经写好的相应的程序。在上图中的相同界面中输入以下信息。\n\n![](Anaconda+PyCharm配置PyQt5全过程/2.png)\n\nprogram中输入pyuic5.exe的路径。\n\n在参数栏中输入如下命令：(该命令就是将.ui转化为.py文件)\n\n```\n$FileName$ -o $FileNameWithoutExtension$.py\n```\n\n该步骤中也有直接输入pyuic.py文件的，但我试验了以下没有成功，所以使用.exe文件还是最靠谱的（Windows下）。\n\n## 使用实验\n\n在菜单栏“工具”中找到拓展工具，选择QDesigner即可。\n\n![](Anaconda+PyCharm配置PyQt5全过程/3.png)\n\n\n\n打开设计工具之后，即可创建相应的ui界面如下：\n\n![](Anaconda+PyCharm配置PyQt5全过程/4.png)\n\n这时候可以看到PyCharm界面中多了一个.ui文件，在该文件上右击，选择拓展工具中的PyUIC即可完成.ui到.py的转换。\n\n![](/Anaconda+PyCharm配置PyQt5全过程/5.png)\n\n此时可以发现多了一个同名的.py文件，打开文件里面包含的就是之前设计好的界面的python代码了，加入以下主函数运行：\n\n```\nimport sys\nfrom PyQt5.QtWidgets import QApplication, QMainWindow\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    MainWindow = QMainWindow()\n    ui = Ui_MainWindow()\n    ui.setupUi(MainWindow)\n    MainWindow.show()\n    sys.exit(app.exec_())\n```\n\n即可得到如下结果：\n\n![](/Anaconda+PyCharm配置PyQt5全过程/6.png)\n\nOK，那使用PyQt5构建python的GUI程序的流程总算整通了。\n\n#### 参考\n\nhttps://www.jianshu.com/p/094928ac0b73\n\n","source":"_posts/Python/GUI/Anaconda+PyCharm配置PyQt5全过程.md","raw":"---\ntitle: Anaconda+PyCharm配置PyQt5全过程\ndate: 2020-04-09 22:44:55\ntags:\n\t- python\n\t- GUI\ncategories:\n\t- Python\n\t- GUI\nfileName: pyqt1\n---\n\n\n\n前段时间写了一个手写电话号码识别的小程序，GUI用的是Python自带的Tkinter，但这种GUI太简陋可视化效果不佳，因此打算使用别的更加强大的GUI重构一下，目光就瞄准了pyqt，因为用C++时接触过，知道这是个好用的GUI吧。\n\n## Anaconda下安装\n\n在Anaconda在GitHub上的issue下知道由于兼容Python2的原因没法用conda安装最新版PyQt5包，所以得使用pip命令进行安装。\n\n在Anaconda自带的prompt下输入以下命令即可完成安装。\n\n```\npip3 install PyQt5\n```\n\n但速度通常很慢，因此建议改为清华的镜像进行安装。\n\n```\npip install -i https://pypi.tuna.tsinghua.edu.cn/simple PyQt5\n```\n\n之后在命令行窗口输入`import PyQt5`，不报错，说明安装成功。\n\n## Pycharm下配置相关环境\n\n用过Qt的应该都知道Qt有QtDesigner这种优秀的可视化设计工具，可以简化编码，所以如果使用PyCharm作为IDE编写Python的话需要将QtDesigner作为拓展程序进行配置（这样可以在IDE中直接进行调用了，会很方便）。除此之外，还需要配置将QtDesigner生成的.ui文件转化为.py文件。\n\n### 配置QtDesigner\n\n在PyCharm中的`File->Settings`下，进行如下操作，即可配置完成QDesigner。\n\n![](Anaconda+PyCharm配置PyQt5全过程/1.png)\n\n### 配置PyUIC\n\n使用QDesigner生成的文件格式为.ui的格式，要将其转化为.py格式安装的pyqt包中也已经写好的相应的程序。在上图中的相同界面中输入以下信息。\n\n![](Anaconda+PyCharm配置PyQt5全过程/2.png)\n\nprogram中输入pyuic5.exe的路径。\n\n在参数栏中输入如下命令：(该命令就是将.ui转化为.py文件)\n\n```\n$FileName$ -o $FileNameWithoutExtension$.py\n```\n\n该步骤中也有直接输入pyuic.py文件的，但我试验了以下没有成功，所以使用.exe文件还是最靠谱的（Windows下）。\n\n## 使用实验\n\n在菜单栏“工具”中找到拓展工具，选择QDesigner即可。\n\n![](Anaconda+PyCharm配置PyQt5全过程/3.png)\n\n\n\n打开设计工具之后，即可创建相应的ui界面如下：\n\n![](Anaconda+PyCharm配置PyQt5全过程/4.png)\n\n这时候可以看到PyCharm界面中多了一个.ui文件，在该文件上右击，选择拓展工具中的PyUIC即可完成.ui到.py的转换。\n\n![](/Anaconda+PyCharm配置PyQt5全过程/5.png)\n\n此时可以发现多了一个同名的.py文件，打开文件里面包含的就是之前设计好的界面的python代码了，加入以下主函数运行：\n\n```\nimport sys\nfrom PyQt5.QtWidgets import QApplication, QMainWindow\nif __name__ == '__main__':\n    app = QApplication(sys.argv)\n    MainWindow = QMainWindow()\n    ui = Ui_MainWindow()\n    ui.setupUi(MainWindow)\n    MainWindow.show()\n    sys.exit(app.exec_())\n```\n\n即可得到如下结果：\n\n![](/Anaconda+PyCharm配置PyQt5全过程/6.png)\n\nOK，那使用PyQt5构建python的GUI程序的流程总算整通了。\n\n#### 参考\n\nhttps://www.jianshu.com/p/094928ac0b73\n\n","slug":"Python/GUI/Anaconda+PyCharm配置PyQt5全过程","published":1,"updated":"2020-07-16T16:02:19.585Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8sm000dl4js3y0sd1r8","content":"<p>前段时间写了一个手写电话号码识别的小程序，GUI用的是Python自带的Tkinter，但这种GUI太简陋可视化效果不佳，因此打算使用别的更加强大的GUI重构一下，目光就瞄准了pyqt，因为用C++时接触过，知道这是个好用的GUI吧。</p>\n<h2 id=\"Anaconda下安装\"><a href=\"#Anaconda下安装\" class=\"headerlink\" title=\"Anaconda下安装\"></a>Anaconda下安装</h2><p>在Anaconda在GitHub上的issue下知道由于兼容Python2的原因没法用conda安装最新版PyQt5包，所以得使用pip命令进行安装。</p>\n<p>在Anaconda自带的prompt下输入以下命令即可完成安装。</p>\n<pre><code>pip3 install PyQt5</code></pre><p>但速度通常很慢，因此建议改为清华的镜像进行安装。</p>\n<pre><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple PyQt5</code></pre><p>之后在命令行窗口输入<code>import PyQt5</code>，不报错，说明安装成功。</p>\n<h2 id=\"Pycharm下配置相关环境\"><a href=\"#Pycharm下配置相关环境\" class=\"headerlink\" title=\"Pycharm下配置相关环境\"></a>Pycharm下配置相关环境</h2><p>用过Qt的应该都知道Qt有QtDesigner这种优秀的可视化设计工具，可以简化编码，所以如果使用PyCharm作为IDE编写Python的话需要将QtDesigner作为拓展程序进行配置（这样可以在IDE中直接进行调用了，会很方便）。除此之外，还需要配置将QtDesigner生成的.ui文件转化为.py文件。</p>\n<h3 id=\"配置QtDesigner\"><a href=\"#配置QtDesigner\" class=\"headerlink\" title=\"配置QtDesigner\"></a>配置QtDesigner</h3><p>在PyCharm中的<code>File-&gt;Settings</code>下，进行如下操作，即可配置完成QDesigner。</p>\n<p><img src=\"/page/pyqt1/1.png\" alt></p>\n<h3 id=\"配置PyUIC\"><a href=\"#配置PyUIC\" class=\"headerlink\" title=\"配置PyUIC\"></a>配置PyUIC</h3><p>使用QDesigner生成的文件格式为.ui的格式，要将其转化为.py格式安装的pyqt包中也已经写好的相应的程序。在上图中的相同界面中输入以下信息。</p>\n<p><img src=\"/page/pyqt1/2.png\" alt></p>\n<p>program中输入pyuic5.exe的路径。</p>\n<p>在参数栏中输入如下命令：(该命令就是将.ui转化为.py文件)</p>\n<pre><code>$FileName$ -o $FileNameWithoutExtension$.py</code></pre><p>该步骤中也有直接输入pyuic.py文件的，但我试验了以下没有成功，所以使用.exe文件还是最靠谱的（Windows下）。</p>\n<h2 id=\"使用实验\"><a href=\"#使用实验\" class=\"headerlink\" title=\"使用实验\"></a>使用实验</h2><p>在菜单栏“工具”中找到拓展工具，选择QDesigner即可。</p>\n<p><img src=\"/page/pyqt1/3.png\" alt></p>\n<p>打开设计工具之后，即可创建相应的ui界面如下：</p>\n<p><img src=\"/page/pyqt1/4.png\" alt></p>\n<p>这时候可以看到PyCharm界面中多了一个.ui文件，在该文件上右击，选择拓展工具中的PyUIC即可完成.ui到.py的转换。</p>\n<p><img src=\"/page/pyqt1/5.png\" alt></p>\n<p>此时可以发现多了一个同名的.py文件，打开文件里面包含的就是之前设计好的界面的python代码了，加入以下主函数运行：</p>\n<pre><code>import sys\nfrom PyQt5.QtWidgets import QApplication, QMainWindow\nif __name__ == &#39;__main__&#39;:\n    app = QApplication(sys.argv)\n    MainWindow = QMainWindow()\n    ui = Ui_MainWindow()\n    ui.setupUi(MainWindow)\n    MainWindow.show()\n    sys.exit(app.exec_())</code></pre><p>即可得到如下结果：</p>\n<p><img src=\"/page/pyqt1/6.png\" alt></p>\n<p>OK，那使用PyQt5构建python的GUI程序的流程总算整通了。</p>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://www.jianshu.com/p/094928ac0b73\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/094928ac0b73</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>前段时间写了一个手写电话号码识别的小程序，GUI用的是Python自带的Tkinter，但这种GUI太简陋可视化效果不佳，因此打算使用别的更加强大的GUI重构一下，目光就瞄准了pyqt，因为用C++时接触过，知道这是个好用的GUI吧。</p>\n<h2 id=\"Anaconda下安装\"><a href=\"#Anaconda下安装\" class=\"headerlink\" title=\"Anaconda下安装\"></a>Anaconda下安装</h2><p>在Anaconda在GitHub上的issue下知道由于兼容Python2的原因没法用conda安装最新版PyQt5包，所以得使用pip命令进行安装。</p>\n<p>在Anaconda自带的prompt下输入以下命令即可完成安装。</p>\n<pre><code>pip3 install PyQt5</code></pre><p>但速度通常很慢，因此建议改为清华的镜像进行安装。</p>\n<pre><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple PyQt5</code></pre><p>之后在命令行窗口输入<code>import PyQt5</code>，不报错，说明安装成功。</p>\n<h2 id=\"Pycharm下配置相关环境\"><a href=\"#Pycharm下配置相关环境\" class=\"headerlink\" title=\"Pycharm下配置相关环境\"></a>Pycharm下配置相关环境</h2><p>用过Qt的应该都知道Qt有QtDesigner这种优秀的可视化设计工具，可以简化编码，所以如果使用PyCharm作为IDE编写Python的话需要将QtDesigner作为拓展程序进行配置（这样可以在IDE中直接进行调用了，会很方便）。除此之外，还需要配置将QtDesigner生成的.ui文件转化为.py文件。</p>\n<h3 id=\"配置QtDesigner\"><a href=\"#配置QtDesigner\" class=\"headerlink\" title=\"配置QtDesigner\"></a>配置QtDesigner</h3><p>在PyCharm中的<code>File-&gt;Settings</code>下，进行如下操作，即可配置完成QDesigner。</p>\n<p><img src=\"/page/pyqt1/1.png\" alt></p>\n<h3 id=\"配置PyUIC\"><a href=\"#配置PyUIC\" class=\"headerlink\" title=\"配置PyUIC\"></a>配置PyUIC</h3><p>使用QDesigner生成的文件格式为.ui的格式，要将其转化为.py格式安装的pyqt包中也已经写好的相应的程序。在上图中的相同界面中输入以下信息。</p>\n<p><img src=\"/page/pyqt1/2.png\" alt></p>\n<p>program中输入pyuic5.exe的路径。</p>\n<p>在参数栏中输入如下命令：(该命令就是将.ui转化为.py文件)</p>\n<pre><code>$FileName$ -o $FileNameWithoutExtension$.py</code></pre><p>该步骤中也有直接输入pyuic.py文件的，但我试验了以下没有成功，所以使用.exe文件还是最靠谱的（Windows下）。</p>\n<h2 id=\"使用实验\"><a href=\"#使用实验\" class=\"headerlink\" title=\"使用实验\"></a>使用实验</h2><p>在菜单栏“工具”中找到拓展工具，选择QDesigner即可。</p>\n<p><img src=\"/page/pyqt1/3.png\" alt></p>\n<p>打开设计工具之后，即可创建相应的ui界面如下：</p>\n<p><img src=\"/page/pyqt1/4.png\" alt></p>\n<p>这时候可以看到PyCharm界面中多了一个.ui文件，在该文件上右击，选择拓展工具中的PyUIC即可完成.ui到.py的转换。</p>\n<p><img src=\"/page/pyqt1/5.png\" alt></p>\n<p>此时可以发现多了一个同名的.py文件，打开文件里面包含的就是之前设计好的界面的python代码了，加入以下主函数运行：</p>\n<pre><code>import sys\nfrom PyQt5.QtWidgets import QApplication, QMainWindow\nif __name__ == &#39;__main__&#39;:\n    app = QApplication(sys.argv)\n    MainWindow = QMainWindow()\n    ui = Ui_MainWindow()\n    ui.setupUi(MainWindow)\n    MainWindow.show()\n    sys.exit(app.exec_())</code></pre><p>即可得到如下结果：</p>\n<p><img src=\"/page/pyqt1/6.png\" alt></p>\n<p>OK，那使用PyQt5构建python的GUI程序的流程总算整通了。</p>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><p><a href=\"https://www.jianshu.com/p/094928ac0b73\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/094928ac0b73</a></p>\n"},{"title":"1、Java语言基础","date":"2020-06-27T09:25:12.000Z","fileName":"java1","_content":"\n参考：https://github.com/Snailclimb/JavaGuide\n\n### 基本概念\n\n1、**JVM**：Java虚拟机，用于运行Java字节码，其针对不同的操作系统有着特定的实现，使得相同的字节码运行会给出相同的结果。\n\n在Java中，JVM能够理解的代码就叫做**字节码**（.class文件）。其不面向任何特定的处理器，只面向虚拟机。\n\n2、**JDK**，即Java Development Kit，是功能齐全的Java软件开发包，拥有JRE所拥有的一切，有编译器（javac）和一些其他工具，能够创建和编译程序。\n\n3、**JRE**，即Java运行时环境。其为运行已编译Java程序所需要的所有内容的集合，包括Java虚拟机、Java类库、Java命令和其他一些基础的构建。但是，其不能用于创建新程序。\n\n\n\n**编译与解释并存**：Java程序要经过先编译、后解释两个步骤。（先经过编译生成字节码文件*.class，再经过解释进行执行）\n\n\n\n\n\n### 基本数据类型\n\nJava有8中基本数据类型，数字类型（byte<1>、short<2>、int<4>、long<8>、float<4>、double<8>）；字符类型（char<2>）；布尔型（boolean<依赖于JVM的具体实现>），其中<>内为其所对应的字节数，每个基本数据类型又有对应的默认值。\n\n#### 装箱与拆箱\n\n参考：https://www.cnblogs.com/dolphin0520/p/3780005.html\n\nJava为每种基本数据类型都提供了对应的包装器类型，将基本数据类型转换成包装类称为**装箱**，反之则称为**拆箱**。\n\n1、装箱：其中第一种方法不会触发自动装箱的机制，在执行效率和资源占用上，第二种方法通常要优于第一种情况。\n\n```\nInteger i = new Integer(10);\t// 手动装箱\nInteger i = 10;\t// 自动装箱\n```\n\n拆箱（直接进行赋值语句即可）：\n\n```\nint i2 = i;\n```\n\n**装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。**\n\n***\n\n**注意：**\n\n如下代码的输出不同，原因在于valueOf的实现方法，*可以简单总结为若数值在[-128,127]之间，便返回IntegerCache.cache中已存在的对象的引用，否则创建一个新的Integer对象*\n\n```\nInteger i1 = 100;\nInteger i2 = 100;\n\nInteger i3 = 200;\nInteger i4 = 200;\n\nSystem.out.println(i1==i2);\nSystem.out.println(i3==i4);\n\n####################################\ntrue\nfalse\n```\n\n同时，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的（**这些方法实现了常量池技术**），而Double、Float的valueOf方法的实现是类似的（**这些方法没有使用常量池技术**）。因此，上述代码若换成Double，会输出“false false”，换成Boolean会输出“true true”。\n\n除此之外，还应该注意的是，如果这些包装类使用了算数运算符，那么“==”比较的将会是数值（即触发了自动拆箱），如下：\n\n```\nInteger a = 1;\nInteger b = 2;\nInteger c = 3;\nSystem.out.println(c==(a+b));\n\n#########################################\ntrue\n```\n\n***\n\n对于包装器类型，equals方法并不会进行类型转换，如下：\n\n```\nInteger a = 1;\nInteger b = 2;\n\nLong c = 3L;\nLong d = 2L;\n\nSystem.out.println(c==a+b);\nSystem.out.println(c.equals(a+b));\nSystem.out.println(c.equals(a+d));\n\n###########################################\ntrue\nfalse\ntrue\n```\n\n\n\n\n\n### 方法（函数）\n\n#### 参数\n\n1、一个方法不能修改一个基本数据类型的参数。\n\n2、一个方法可以改变一个对象参数的状态。\n\n3、一个方法不能让对象参数引用一个新的对象。\n\n#### 方法的重载与重写\n\n**方法重载**：同样的方法根据输入数据的不同，做出不同处理（同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理）。满足如下要求：\n\na、同一个类中\n\nb、方法名相同，参数列表不同，方法返回值相同\n\nc、访问修饰符。\n\n\n\n**方法重写**：重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写（重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变）。满足以下条件：\n\na、发生有继承关系的子类中，且父类方法的访问修饰符为private/final/static则表示该方法不能重写，但是使用static修饰的方法能够被再次声明。同时构造方法不能被重写。\n\nb、方法名相同，参数列表相同（参数顺序、个数相同），返回值类型相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。\n\n\n\n\n\n\n\n\n\n构造函数需要一个有参构造和一个无参构造\n\n\n\ngetter/setter\n\n\n\n\n\n包：一个JAVA源文件中只能有一个package语句\n\n命名方法：域名倒序+模块+功能\n\n\n\nstatic：静态成员、类成员\n\n无论类实例化多少，值都相同 \n\n\n\n静态方法不能直接访问非静态成员\n\n \n\n使用{}形成代码块，每个代码块是一个独立的作用空间\n\n{}——在方法中，普通代码块。在类中，构造代码块\n\nstatic{}——静态代码块\n\n\n\n\n\n在方法中通过对象作为参数，传递的是他的引用\n\n\n\n\n\n\n\nJava只能是单继承\n\n子类可以访问父类非私有成员\n\n\n\n \n\n共有：public：任意位置\n\n私有：private：本类中访问\n\n保护：protected：当前类、同包子类/非子类、跨包子类（跨包子类不允许）\n\n默认：当前类、同包子类（跨包子类不允许调用）\n\n\n\nsuper：父类对象的引用\n\nsuper.print() 访问父类成员方法\n\nsuper.name 访问父类属性\n\nsuper() 访问父类构造方法，必须位于子类构造方法的第一行\n\n\n\n子类的构造过程必须调用其父类的构造方法，若子类构造方法中没有显式标注，则系统默认调用父类无参构造方法（若子类构造方法无显式标值且父类中没有无参构造方法，则编译出错）\n\n\n\nObject类是所有类的父类\n\n\n\n\n\nfinal\n\n1、在类前添加，标识该类不允许有子类（如System和String都有final关键字）\n\n2、在方法前添加，表明该方法不能被子类重写（子类能够调用）。不能修饰构造方法\n\n\n\n设计模式：软件开发人员在软件开发过程中面临的一般问题的解决方案。基于场景的解决方案\n\n单例模式：1、某个类有且只有一个实例；2、必须自行创建实例；3、自行向整个系统提供这个实例\n\n\n\n多态：不同类的对象对同一消息做出不同响应\n\n编译时多态：（方法重载）\n\n运行时多态：程序运行时动态决定调用哪个方法\n\n\n\n多态必要条件\n\n1、满足继承关系\n\n2、父类引用指向子类对象\n\n\n\n向上转型，父类引用指向子类实例。可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法\n\nAnimal two = new Cat()\n\n\n\n向下转型，子类引用指向父类实例，此处要求必须进行强转\n\ninstanceof 运算符，返回 true false\n\n```\nif(obj instanceof Cat) {\n\tCat temp = (Cat)obj\n}\n```\n\n\n\n```\nif() {\n\treturn new Dog();\n} else {\n\treturn new Cat();\n}\n```\n\n\n\n\n\nabstract关键字\n\n抽象类，无法进行实例化的类（可以通过向上转型指向子类实例 ）\n\n抽象方法：子类必须进行实现（或者子类也设置为抽象类），在父类定义时不能有方法体\n\n\n\n包含抽象方法的类是抽象类\n\n抽象类中可以没有抽象方法\n\nstatic/final/private不能与abstract共存\n\n\n\n接口：命名通常以“I”打头\n\n接口定义了某一批类所需要遵守的规范\n\n接口不关心这些类的内部数据，也不关心类中方法的实现细节，只规定这些类中必须提供某些方法\n\n\n\n\n\n接口访问修饰符：public 默认\n\n接口中抽象方法可以不写abstract关键字\n\n作为接口的实现类必须实现接口中定义的所有方法，否则需要将该类设置为抽象类\n\n接口中可以包含常量，默认public static final\n\n```\npublic interface ITest {\n    public void func();\n}\n```\n\n\n\n```\npublic class A implements ITest {\n\n    @java.lang.Override\n    public void func() {\n\n    }\n}\n```\n\n\n\n```\nINet net = new A();\n\n```\n\n\n\ndefault 关键字\n\n```\npublic interface ITest {\n\t// 默认方法\n\tdefault void func1() {\n\t\t\n\t}\n\t// 静态方法\n\tstatic void func2() {\n\t\n\t}\n}\n\n// 调用接口中的默认方法\nITest.super.func1();\n```\n\n接口的继承，可以一对多\n\n\n\n在Java中，可以将一个类定义在另一个类中或者一个方法中，这样的类称为内部类\n\n\n\n1、成员内部类\n\n获取内部类\n\n```\nA.a1 me = new A().new a1();\n```\n\n\n\n2、静态内部类\n\n3、方法内部类\n\n4、匿名内部类\n\n\n\n\n\n","source":"_posts/Java/语言基础/1、Java语言基础.md","raw":"---\ntitle: 1、Java语言基础\ndate: 2020-06-27 17:25:12\ntags:\n\t- Java\ncategories:\n\t- Java\n\t- 语言基础\nfileName: java1\n---\n\n参考：https://github.com/Snailclimb/JavaGuide\n\n### 基本概念\n\n1、**JVM**：Java虚拟机，用于运行Java字节码，其针对不同的操作系统有着特定的实现，使得相同的字节码运行会给出相同的结果。\n\n在Java中，JVM能够理解的代码就叫做**字节码**（.class文件）。其不面向任何特定的处理器，只面向虚拟机。\n\n2、**JDK**，即Java Development Kit，是功能齐全的Java软件开发包，拥有JRE所拥有的一切，有编译器（javac）和一些其他工具，能够创建和编译程序。\n\n3、**JRE**，即Java运行时环境。其为运行已编译Java程序所需要的所有内容的集合，包括Java虚拟机、Java类库、Java命令和其他一些基础的构建。但是，其不能用于创建新程序。\n\n\n\n**编译与解释并存**：Java程序要经过先编译、后解释两个步骤。（先经过编译生成字节码文件*.class，再经过解释进行执行）\n\n\n\n\n\n### 基本数据类型\n\nJava有8中基本数据类型，数字类型（byte<1>、short<2>、int<4>、long<8>、float<4>、double<8>）；字符类型（char<2>）；布尔型（boolean<依赖于JVM的具体实现>），其中<>内为其所对应的字节数，每个基本数据类型又有对应的默认值。\n\n#### 装箱与拆箱\n\n参考：https://www.cnblogs.com/dolphin0520/p/3780005.html\n\nJava为每种基本数据类型都提供了对应的包装器类型，将基本数据类型转换成包装类称为**装箱**，反之则称为**拆箱**。\n\n1、装箱：其中第一种方法不会触发自动装箱的机制，在执行效率和资源占用上，第二种方法通常要优于第一种情况。\n\n```\nInteger i = new Integer(10);\t// 手动装箱\nInteger i = 10;\t// 自动装箱\n```\n\n拆箱（直接进行赋值语句即可）：\n\n```\nint i2 = i;\n```\n\n**装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。**\n\n***\n\n**注意：**\n\n如下代码的输出不同，原因在于valueOf的实现方法，*可以简单总结为若数值在[-128,127]之间，便返回IntegerCache.cache中已存在的对象的引用，否则创建一个新的Integer对象*\n\n```\nInteger i1 = 100;\nInteger i2 = 100;\n\nInteger i3 = 200;\nInteger i4 = 200;\n\nSystem.out.println(i1==i2);\nSystem.out.println(i3==i4);\n\n####################################\ntrue\nfalse\n```\n\n同时，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的（**这些方法实现了常量池技术**），而Double、Float的valueOf方法的实现是类似的（**这些方法没有使用常量池技术**）。因此，上述代码若换成Double，会输出“false false”，换成Boolean会输出“true true”。\n\n除此之外，还应该注意的是，如果这些包装类使用了算数运算符，那么“==”比较的将会是数值（即触发了自动拆箱），如下：\n\n```\nInteger a = 1;\nInteger b = 2;\nInteger c = 3;\nSystem.out.println(c==(a+b));\n\n#########################################\ntrue\n```\n\n***\n\n对于包装器类型，equals方法并不会进行类型转换，如下：\n\n```\nInteger a = 1;\nInteger b = 2;\n\nLong c = 3L;\nLong d = 2L;\n\nSystem.out.println(c==a+b);\nSystem.out.println(c.equals(a+b));\nSystem.out.println(c.equals(a+d));\n\n###########################################\ntrue\nfalse\ntrue\n```\n\n\n\n\n\n### 方法（函数）\n\n#### 参数\n\n1、一个方法不能修改一个基本数据类型的参数。\n\n2、一个方法可以改变一个对象参数的状态。\n\n3、一个方法不能让对象参数引用一个新的对象。\n\n#### 方法的重载与重写\n\n**方法重载**：同样的方法根据输入数据的不同，做出不同处理（同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理）。满足如下要求：\n\na、同一个类中\n\nb、方法名相同，参数列表不同，方法返回值相同\n\nc、访问修饰符。\n\n\n\n**方法重写**：重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写（重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变）。满足以下条件：\n\na、发生有继承关系的子类中，且父类方法的访问修饰符为private/final/static则表示该方法不能重写，但是使用static修饰的方法能够被再次声明。同时构造方法不能被重写。\n\nb、方法名相同，参数列表相同（参数顺序、个数相同），返回值类型相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。\n\n\n\n\n\n\n\n\n\n构造函数需要一个有参构造和一个无参构造\n\n\n\ngetter/setter\n\n\n\n\n\n包：一个JAVA源文件中只能有一个package语句\n\n命名方法：域名倒序+模块+功能\n\n\n\nstatic：静态成员、类成员\n\n无论类实例化多少，值都相同 \n\n\n\n静态方法不能直接访问非静态成员\n\n \n\n使用{}形成代码块，每个代码块是一个独立的作用空间\n\n{}——在方法中，普通代码块。在类中，构造代码块\n\nstatic{}——静态代码块\n\n\n\n\n\n在方法中通过对象作为参数，传递的是他的引用\n\n\n\n\n\n\n\nJava只能是单继承\n\n子类可以访问父类非私有成员\n\n\n\n \n\n共有：public：任意位置\n\n私有：private：本类中访问\n\n保护：protected：当前类、同包子类/非子类、跨包子类（跨包子类不允许）\n\n默认：当前类、同包子类（跨包子类不允许调用）\n\n\n\nsuper：父类对象的引用\n\nsuper.print() 访问父类成员方法\n\nsuper.name 访问父类属性\n\nsuper() 访问父类构造方法，必须位于子类构造方法的第一行\n\n\n\n子类的构造过程必须调用其父类的构造方法，若子类构造方法中没有显式标注，则系统默认调用父类无参构造方法（若子类构造方法无显式标值且父类中没有无参构造方法，则编译出错）\n\n\n\nObject类是所有类的父类\n\n\n\n\n\nfinal\n\n1、在类前添加，标识该类不允许有子类（如System和String都有final关键字）\n\n2、在方法前添加，表明该方法不能被子类重写（子类能够调用）。不能修饰构造方法\n\n\n\n设计模式：软件开发人员在软件开发过程中面临的一般问题的解决方案。基于场景的解决方案\n\n单例模式：1、某个类有且只有一个实例；2、必须自行创建实例；3、自行向整个系统提供这个实例\n\n\n\n多态：不同类的对象对同一消息做出不同响应\n\n编译时多态：（方法重载）\n\n运行时多态：程序运行时动态决定调用哪个方法\n\n\n\n多态必要条件\n\n1、满足继承关系\n\n2、父类引用指向子类对象\n\n\n\n向上转型，父类引用指向子类实例。可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法\n\nAnimal two = new Cat()\n\n\n\n向下转型，子类引用指向父类实例，此处要求必须进行强转\n\ninstanceof 运算符，返回 true false\n\n```\nif(obj instanceof Cat) {\n\tCat temp = (Cat)obj\n}\n```\n\n\n\n```\nif() {\n\treturn new Dog();\n} else {\n\treturn new Cat();\n}\n```\n\n\n\n\n\nabstract关键字\n\n抽象类，无法进行实例化的类（可以通过向上转型指向子类实例 ）\n\n抽象方法：子类必须进行实现（或者子类也设置为抽象类），在父类定义时不能有方法体\n\n\n\n包含抽象方法的类是抽象类\n\n抽象类中可以没有抽象方法\n\nstatic/final/private不能与abstract共存\n\n\n\n接口：命名通常以“I”打头\n\n接口定义了某一批类所需要遵守的规范\n\n接口不关心这些类的内部数据，也不关心类中方法的实现细节，只规定这些类中必须提供某些方法\n\n\n\n\n\n接口访问修饰符：public 默认\n\n接口中抽象方法可以不写abstract关键字\n\n作为接口的实现类必须实现接口中定义的所有方法，否则需要将该类设置为抽象类\n\n接口中可以包含常量，默认public static final\n\n```\npublic interface ITest {\n    public void func();\n}\n```\n\n\n\n```\npublic class A implements ITest {\n\n    @java.lang.Override\n    public void func() {\n\n    }\n}\n```\n\n\n\n```\nINet net = new A();\n\n```\n\n\n\ndefault 关键字\n\n```\npublic interface ITest {\n\t// 默认方法\n\tdefault void func1() {\n\t\t\n\t}\n\t// 静态方法\n\tstatic void func2() {\n\t\n\t}\n}\n\n// 调用接口中的默认方法\nITest.super.func1();\n```\n\n接口的继承，可以一对多\n\n\n\n在Java中，可以将一个类定义在另一个类中或者一个方法中，这样的类称为内部类\n\n\n\n1、成员内部类\n\n获取内部类\n\n```\nA.a1 me = new A().new a1();\n```\n\n\n\n2、静态内部类\n\n3、方法内部类\n\n4、匿名内部类\n\n\n\n\n\n","slug":"Java/语言基础/1、Java语言基础","published":1,"updated":"2020-07-16T16:06:19.597Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8sp000hl4js4kk84nf9","content":"<p>参考：<a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\" rel=\"noopener\">https://github.com/Snailclimb/JavaGuide</a></p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>1、<strong>JVM</strong>：Java虚拟机，用于运行Java字节码，其针对不同的操作系统有着特定的实现，使得相同的字节码运行会给出相同的结果。</p>\n<p>在Java中，JVM能够理解的代码就叫做<strong>字节码</strong>（.class文件）。其不面向任何特定的处理器，只面向虚拟机。</p>\n<p>2、<strong>JDK</strong>，即Java Development Kit，是功能齐全的Java软件开发包，拥有JRE所拥有的一切，有编译器（javac）和一些其他工具，能够创建和编译程序。</p>\n<p>3、<strong>JRE</strong>，即Java运行时环境。其为运行已编译Java程序所需要的所有内容的集合，包括Java虚拟机、Java类库、Java命令和其他一些基础的构建。但是，其不能用于创建新程序。</p>\n<p><strong>编译与解释并存</strong>：Java程序要经过先编译、后解释两个步骤。（先经过编译生成字节码文件*.class，再经过解释进行执行）</p>\n<h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><p>Java有8中基本数据类型，数字类型（byte&lt;1&gt;、short&lt;2&gt;、int&lt;4&gt;、long&lt;8&gt;、float&lt;4&gt;、double&lt;8&gt;）；字符类型（char&lt;2&gt;）；布尔型（boolean&lt;依赖于JVM的具体实现&gt;），其中&lt;&gt;内为其所对应的字节数，每个基本数据类型又有对应的默认值。</p>\n<h4 id=\"装箱与拆箱\"><a href=\"#装箱与拆箱\" class=\"headerlink\" title=\"装箱与拆箱\"></a>装箱与拆箱</h4><p>参考：<a href=\"https://www.cnblogs.com/dolphin0520/p/3780005.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dolphin0520/p/3780005.html</a></p>\n<p>Java为每种基本数据类型都提供了对应的包装器类型，将基本数据类型转换成包装类称为<strong>装箱</strong>，反之则称为<strong>拆箱</strong>。</p>\n<p>1、装箱：其中第一种方法不会触发自动装箱的机制，在执行效率和资源占用上，第二种方法通常要优于第一种情况。</p>\n<pre><code>Integer i = new Integer(10);    // 手动装箱\nInteger i = 10;    // 自动装箱</code></pre><p>拆箱（直接进行赋值语句即可）：</p>\n<pre><code>int i2 = i;</code></pre><p><strong>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。</strong></p>\n<hr>\n<p><strong>注意：</strong></p>\n<p>如下代码的输出不同，原因在于valueOf的实现方法，<em>可以简单总结为若数值在[-128,127]之间，便返回IntegerCache.cache中已存在的对象的引用，否则创建一个新的Integer对象</em></p>\n<pre><code>Integer i1 = 100;\nInteger i2 = 100;\n\nInteger i3 = 200;\nInteger i4 = 200;\n\nSystem.out.println(i1==i2);\nSystem.out.println(i3==i4);\n\n####################################\ntrue\nfalse</code></pre><p>同时，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的（<strong>这些方法实现了常量池技术</strong>），而Double、Float的valueOf方法的实现是类似的（<strong>这些方法没有使用常量池技术</strong>）。因此，上述代码若换成Double，会输出“false false”，换成Boolean会输出“true true”。</p>\n<p>除此之外，还应该注意的是，如果这些包装类使用了算数运算符，那么“==”比较的将会是数值（即触发了自动拆箱），如下：</p>\n<pre><code>Integer a = 1;\nInteger b = 2;\nInteger c = 3;\nSystem.out.println(c==(a+b));\n\n#########################################\ntrue</code></pre><hr>\n<p>对于包装器类型，equals方法并不会进行类型转换，如下：</p>\n<pre><code>Integer a = 1;\nInteger b = 2;\n\nLong c = 3L;\nLong d = 2L;\n\nSystem.out.println(c==a+b);\nSystem.out.println(c.equals(a+b));\nSystem.out.println(c.equals(a+d));\n\n###########################################\ntrue\nfalse\ntrue</code></pre><h3 id=\"方法（函数）\"><a href=\"#方法（函数）\" class=\"headerlink\" title=\"方法（函数）\"></a>方法（函数）</h3><h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>1、一个方法不能修改一个基本数据类型的参数。</p>\n<p>2、一个方法可以改变一个对象参数的状态。</p>\n<p>3、一个方法不能让对象参数引用一个新的对象。</p>\n<h4 id=\"方法的重载与重写\"><a href=\"#方法的重载与重写\" class=\"headerlink\" title=\"方法的重载与重写\"></a>方法的重载与重写</h4><p><strong>方法重载</strong>：同样的方法根据输入数据的不同，做出不同处理（同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理）。满足如下要求：</p>\n<p>a、同一个类中</p>\n<p>b、方法名相同，参数列表不同，方法返回值相同</p>\n<p>c、访问修饰符。</p>\n<p><strong>方法重写</strong>：重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写（重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变）。满足以下条件：</p>\n<p>a、发生有继承关系的子类中，且父类方法的访问修饰符为private/final/static则表示该方法不能重写，但是使用static修饰的方法能够被再次声明。同时构造方法不能被重写。</p>\n<p>b、方法名相同，参数列表相同（参数顺序、个数相同），返回值类型相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</p>\n<p>构造函数需要一个有参构造和一个无参构造</p>\n<p>getter/setter</p>\n<p>包：一个JAVA源文件中只能有一个package语句</p>\n<p>命名方法：域名倒序+模块+功能</p>\n<p>static：静态成员、类成员</p>\n<p>无论类实例化多少，值都相同 </p>\n<p>静态方法不能直接访问非静态成员</p>\n<p>使用{}形成代码块，每个代码块是一个独立的作用空间</p>\n<p>{}——在方法中，普通代码块。在类中，构造代码块</p>\n<p>static{}——静态代码块</p>\n<p>在方法中通过对象作为参数，传递的是他的引用</p>\n<p>Java只能是单继承</p>\n<p>子类可以访问父类非私有成员</p>\n<p>共有：public：任意位置</p>\n<p>私有：private：本类中访问</p>\n<p>保护：protected：当前类、同包子类/非子类、跨包子类（跨包子类不允许）</p>\n<p>默认：当前类、同包子类（跨包子类不允许调用）</p>\n<p>super：父类对象的引用</p>\n<p>super.print() 访问父类成员方法</p>\n<p>super.name 访问父类属性</p>\n<p>super() 访问父类构造方法，必须位于子类构造方法的第一行</p>\n<p>子类的构造过程必须调用其父类的构造方法，若子类构造方法中没有显式标注，则系统默认调用父类无参构造方法（若子类构造方法无显式标值且父类中没有无参构造方法，则编译出错）</p>\n<p>Object类是所有类的父类</p>\n<p>final</p>\n<p>1、在类前添加，标识该类不允许有子类（如System和String都有final关键字）</p>\n<p>2、在方法前添加，表明该方法不能被子类重写（子类能够调用）。不能修饰构造方法</p>\n<p>设计模式：软件开发人员在软件开发过程中面临的一般问题的解决方案。基于场景的解决方案</p>\n<p>单例模式：1、某个类有且只有一个实例；2、必须自行创建实例；3、自行向整个系统提供这个实例</p>\n<p>多态：不同类的对象对同一消息做出不同响应</p>\n<p>编译时多态：（方法重载）</p>\n<p>运行时多态：程序运行时动态决定调用哪个方法</p>\n<p>多态必要条件</p>\n<p>1、满足继承关系</p>\n<p>2、父类引用指向子类对象</p>\n<p>向上转型，父类引用指向子类实例。可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法</p>\n<p>Animal two = new Cat()</p>\n<p>向下转型，子类引用指向父类实例，此处要求必须进行强转</p>\n<p>instanceof 运算符，返回 true false</p>\n<pre><code>if(obj instanceof Cat) {\n    Cat temp = (Cat)obj\n}</code></pre><pre><code>if() {\n    return new Dog();\n} else {\n    return new Cat();\n}</code></pre><p>abstract关键字</p>\n<p>抽象类，无法进行实例化的类（可以通过向上转型指向子类实例 ）</p>\n<p>抽象方法：子类必须进行实现（或者子类也设置为抽象类），在父类定义时不能有方法体</p>\n<p>包含抽象方法的类是抽象类</p>\n<p>抽象类中可以没有抽象方法</p>\n<p>static/final/private不能与abstract共存</p>\n<p>接口：命名通常以“I”打头</p>\n<p>接口定义了某一批类所需要遵守的规范</p>\n<p>接口不关心这些类的内部数据，也不关心类中方法的实现细节，只规定这些类中必须提供某些方法</p>\n<p>接口访问修饰符：public 默认</p>\n<p>接口中抽象方法可以不写abstract关键字</p>\n<p>作为接口的实现类必须实现接口中定义的所有方法，否则需要将该类设置为抽象类</p>\n<p>接口中可以包含常量，默认public static final</p>\n<pre><code>public interface ITest {\n    public void func();\n}</code></pre><pre><code>public class A implements ITest {\n\n    @java.lang.Override\n    public void func() {\n\n    }\n}</code></pre><pre><code>INet net = new A();\n</code></pre><p>default 关键字</p>\n<pre><code>public interface ITest {\n    // 默认方法\n    default void func1() {\n\n    }\n    // 静态方法\n    static void func2() {\n\n    }\n}\n\n// 调用接口中的默认方法\nITest.super.func1();</code></pre><p>接口的继承，可以一对多</p>\n<p>在Java中，可以将一个类定义在另一个类中或者一个方法中，这样的类称为内部类</p>\n<p>1、成员内部类</p>\n<p>获取内部类</p>\n<pre><code>A.a1 me = new A().new a1();</code></pre><p>2、静态内部类</p>\n<p>3、方法内部类</p>\n<p>4、匿名内部类</p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考：<a href=\"https://github.com/Snailclimb/JavaGuide\" target=\"_blank\" rel=\"noopener\">https://github.com/Snailclimb/JavaGuide</a></p>\n<h3 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h3><p>1、<strong>JVM</strong>：Java虚拟机，用于运行Java字节码，其针对不同的操作系统有着特定的实现，使得相同的字节码运行会给出相同的结果。</p>\n<p>在Java中，JVM能够理解的代码就叫做<strong>字节码</strong>（.class文件）。其不面向任何特定的处理器，只面向虚拟机。</p>\n<p>2、<strong>JDK</strong>，即Java Development Kit，是功能齐全的Java软件开发包，拥有JRE所拥有的一切，有编译器（javac）和一些其他工具，能够创建和编译程序。</p>\n<p>3、<strong>JRE</strong>，即Java运行时环境。其为运行已编译Java程序所需要的所有内容的集合，包括Java虚拟机、Java类库、Java命令和其他一些基础的构建。但是，其不能用于创建新程序。</p>\n<p><strong>编译与解释并存</strong>：Java程序要经过先编译、后解释两个步骤。（先经过编译生成字节码文件*.class，再经过解释进行执行）</p>\n<h3 id=\"基本数据类型\"><a href=\"#基本数据类型\" class=\"headerlink\" title=\"基本数据类型\"></a>基本数据类型</h3><p>Java有8中基本数据类型，数字类型（byte&lt;1&gt;、short&lt;2&gt;、int&lt;4&gt;、long&lt;8&gt;、float&lt;4&gt;、double&lt;8&gt;）；字符类型（char&lt;2&gt;）；布尔型（boolean&lt;依赖于JVM的具体实现&gt;），其中&lt;&gt;内为其所对应的字节数，每个基本数据类型又有对应的默认值。</p>\n<h4 id=\"装箱与拆箱\"><a href=\"#装箱与拆箱\" class=\"headerlink\" title=\"装箱与拆箱\"></a>装箱与拆箱</h4><p>参考：<a href=\"https://www.cnblogs.com/dolphin0520/p/3780005.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dolphin0520/p/3780005.html</a></p>\n<p>Java为每种基本数据类型都提供了对应的包装器类型，将基本数据类型转换成包装类称为<strong>装箱</strong>，反之则称为<strong>拆箱</strong>。</p>\n<p>1、装箱：其中第一种方法不会触发自动装箱的机制，在执行效率和资源占用上，第二种方法通常要优于第一种情况。</p>\n<pre><code>Integer i = new Integer(10);    // 手动装箱\nInteger i = 10;    // 自动装箱</code></pre><p>拆箱（直接进行赋值语句即可）：</p>\n<pre><code>int i2 = i;</code></pre><p><strong>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。</strong></p>\n<hr>\n<p><strong>注意：</strong></p>\n<p>如下代码的输出不同，原因在于valueOf的实现方法，<em>可以简单总结为若数值在[-128,127]之间，便返回IntegerCache.cache中已存在的对象的引用，否则创建一个新的Integer对象</em></p>\n<pre><code>Integer i1 = 100;\nInteger i2 = 100;\n\nInteger i3 = 200;\nInteger i4 = 200;\n\nSystem.out.println(i1==i2);\nSystem.out.println(i3==i4);\n\n####################################\ntrue\nfalse</code></pre><p>同时，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的（<strong>这些方法实现了常量池技术</strong>），而Double、Float的valueOf方法的实现是类似的（<strong>这些方法没有使用常量池技术</strong>）。因此，上述代码若换成Double，会输出“false false”，换成Boolean会输出“true true”。</p>\n<p>除此之外，还应该注意的是，如果这些包装类使用了算数运算符，那么“==”比较的将会是数值（即触发了自动拆箱），如下：</p>\n<pre><code>Integer a = 1;\nInteger b = 2;\nInteger c = 3;\nSystem.out.println(c==(a+b));\n\n#########################################\ntrue</code></pre><hr>\n<p>对于包装器类型，equals方法并不会进行类型转换，如下：</p>\n<pre><code>Integer a = 1;\nInteger b = 2;\n\nLong c = 3L;\nLong d = 2L;\n\nSystem.out.println(c==a+b);\nSystem.out.println(c.equals(a+b));\nSystem.out.println(c.equals(a+d));\n\n###########################################\ntrue\nfalse\ntrue</code></pre><h3 id=\"方法（函数）\"><a href=\"#方法（函数）\" class=\"headerlink\" title=\"方法（函数）\"></a>方法（函数）</h3><h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><p>1、一个方法不能修改一个基本数据类型的参数。</p>\n<p>2、一个方法可以改变一个对象参数的状态。</p>\n<p>3、一个方法不能让对象参数引用一个新的对象。</p>\n<h4 id=\"方法的重载与重写\"><a href=\"#方法的重载与重写\" class=\"headerlink\" title=\"方法的重载与重写\"></a>方法的重载与重写</h4><p><strong>方法重载</strong>：同样的方法根据输入数据的不同，做出不同处理（同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理）。满足如下要求：</p>\n<p>a、同一个类中</p>\n<p>b、方法名相同，参数列表不同，方法返回值相同</p>\n<p>c、访问修饰符。</p>\n<p><strong>方法重写</strong>：重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写（重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变）。满足以下条件：</p>\n<p>a、发生有继承关系的子类中，且父类方法的访问修饰符为private/final/static则表示该方法不能重写，但是使用static修饰的方法能够被再次声明。同时构造方法不能被重写。</p>\n<p>b、方法名相同，参数列表相同（参数顺序、个数相同），返回值类型相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</p>\n<p>构造函数需要一个有参构造和一个无参构造</p>\n<p>getter/setter</p>\n<p>包：一个JAVA源文件中只能有一个package语句</p>\n<p>命名方法：域名倒序+模块+功能</p>\n<p>static：静态成员、类成员</p>\n<p>无论类实例化多少，值都相同 </p>\n<p>静态方法不能直接访问非静态成员</p>\n<p>使用{}形成代码块，每个代码块是一个独立的作用空间</p>\n<p>{}——在方法中，普通代码块。在类中，构造代码块</p>\n<p>static{}——静态代码块</p>\n<p>在方法中通过对象作为参数，传递的是他的引用</p>\n<p>Java只能是单继承</p>\n<p>子类可以访问父类非私有成员</p>\n<p>共有：public：任意位置</p>\n<p>私有：private：本类中访问</p>\n<p>保护：protected：当前类、同包子类/非子类、跨包子类（跨包子类不允许）</p>\n<p>默认：当前类、同包子类（跨包子类不允许调用）</p>\n<p>super：父类对象的引用</p>\n<p>super.print() 访问父类成员方法</p>\n<p>super.name 访问父类属性</p>\n<p>super() 访问父类构造方法，必须位于子类构造方法的第一行</p>\n<p>子类的构造过程必须调用其父类的构造方法，若子类构造方法中没有显式标注，则系统默认调用父类无参构造方法（若子类构造方法无显式标值且父类中没有无参构造方法，则编译出错）</p>\n<p>Object类是所有类的父类</p>\n<p>final</p>\n<p>1、在类前添加，标识该类不允许有子类（如System和String都有final关键字）</p>\n<p>2、在方法前添加，表明该方法不能被子类重写（子类能够调用）。不能修饰构造方法</p>\n<p>设计模式：软件开发人员在软件开发过程中面临的一般问题的解决方案。基于场景的解决方案</p>\n<p>单例模式：1、某个类有且只有一个实例；2、必须自行创建实例；3、自行向整个系统提供这个实例</p>\n<p>多态：不同类的对象对同一消息做出不同响应</p>\n<p>编译时多态：（方法重载）</p>\n<p>运行时多态：程序运行时动态决定调用哪个方法</p>\n<p>多态必要条件</p>\n<p>1、满足继承关系</p>\n<p>2、父类引用指向子类对象</p>\n<p>向上转型，父类引用指向子类实例。可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法</p>\n<p>Animal two = new Cat()</p>\n<p>向下转型，子类引用指向父类实例，此处要求必须进行强转</p>\n<p>instanceof 运算符，返回 true false</p>\n<pre><code>if(obj instanceof Cat) {\n    Cat temp = (Cat)obj\n}</code></pre><pre><code>if() {\n    return new Dog();\n} else {\n    return new Cat();\n}</code></pre><p>abstract关键字</p>\n<p>抽象类，无法进行实例化的类（可以通过向上转型指向子类实例 ）</p>\n<p>抽象方法：子类必须进行实现（或者子类也设置为抽象类），在父类定义时不能有方法体</p>\n<p>包含抽象方法的类是抽象类</p>\n<p>抽象类中可以没有抽象方法</p>\n<p>static/final/private不能与abstract共存</p>\n<p>接口：命名通常以“I”打头</p>\n<p>接口定义了某一批类所需要遵守的规范</p>\n<p>接口不关心这些类的内部数据，也不关心类中方法的实现细节，只规定这些类中必须提供某些方法</p>\n<p>接口访问修饰符：public 默认</p>\n<p>接口中抽象方法可以不写abstract关键字</p>\n<p>作为接口的实现类必须实现接口中定义的所有方法，否则需要将该类设置为抽象类</p>\n<p>接口中可以包含常量，默认public static final</p>\n<pre><code>public interface ITest {\n    public void func();\n}</code></pre><pre><code>public class A implements ITest {\n\n    @java.lang.Override\n    public void func() {\n\n    }\n}</code></pre><pre><code>INet net = new A();\n</code></pre><p>default 关键字</p>\n<pre><code>public interface ITest {\n    // 默认方法\n    default void func1() {\n\n    }\n    // 静态方法\n    static void func2() {\n\n    }\n}\n\n// 调用接口中的默认方法\nITest.super.func1();</code></pre><p>接口的继承，可以一对多</p>\n<p>在Java中，可以将一个类定义在另一个类中或者一个方法中，这样的类称为内部类</p>\n<p>1、成员内部类</p>\n<p>获取内部类</p>\n<pre><code>A.a1 me = new A().new a1();</code></pre><p>2、静态内部类</p>\n<p>3、方法内部类</p>\n<p>4、匿名内部类</p>\n"},{"title":"pygame基础","date":"2020-05-15T08:11:20.000Z","fileName":"pygame1","_content":"\n官方文档：https://www.pygame.org/docs/\n\n### 基本流程\n\n1. 引入相关的包\n2. 初始化，pygame.init()\n3. 得到屏幕对象，`screen = pygame.display.set_mode((320, 240))`\n4. 游戏主循环\n   * 处理游戏事件\n   * 更新游戏状态\n   * 屏幕重新绘制\n\n基本代码框架\n\n```\nimport pygame\n# 初始化\npygame.init()\n# 获取屏幕对象\nscreen = pygame.display.set_mode((width, height))\n# 游戏主循环\nwhile True:\n\t# 处理游戏事件\n\tfor event in pygame.event.get():\n\t\tpass\n\t# 更新游戏状态（游戏逻辑）\n\t\n\t# 重新绘制屏幕\n```\n\n\n\n### 绘制图片\n\n基本流程如下\n\n```\n# 加载图片\nball = pygame.image.load('assets/images/background.png')\n\n# 图片绘制\n    screen.blit(ball, ball.get_rect)\n    pygame.display.flip()\n```\n\n其中`get_rect`返回值为（left, top, width, height）。前者为图片显示的左上角坐标，后者为图片的长与宽。\n\n绘制其他模块自带的图形\n\n```\nred = pygame.Color(255, 0, 0)\n# 画线\npygame.draw.line(screen, red, (10,10), (200, 200),10)\n# 画矩形\npygame.draw.rect(screen,red,(10,20,200,300),10)\n# 画圆\npygame.draw.circle(screen, red, (100, 100),50,5)\n```\n\n\n\n### 绘制文字\n\n可以使用系统默认的字体进行加载，也可以在项目中使用ttf文件作为资源进行加载。\n\n```\n# 加载字体（使用系统默认字体进行加载）\nred = pygame.Color(255, 0, 0)\nfonts = pygame.font.SysFont('宋体', 40)\ntext = fonts.render('Scores:', True, red)\n\n# 写于游戏主循环\nscreen.blit(text, (20, 20))\npygame.display.flip()\n```\n\n加载项目中所带的ttf文件\n\n```\nfonts = pygame.font.Font('*.ttf', 40)\n```\n\n\n\n### 游戏音效\n\n```\n# 加载音乐\nbgm = pygame.mixer_music.load('assets/sounds/game_bg_music.mp3')\n# 循环播放\npygame.mixer_music.play(-1)\n```\n\n设置音量大小\n\n```\npygame.mixer_music.set_volume(0.1) 输入值为（0，1）\n```\n\n\n\n### 动画切换\n\n两张图片的切换（pygame貌似不支持使用gif之类的动图）\n\n思路：通过设置帧率进行切换，`pygame.time.Clock`\n\n```\nimport sys, pygame\n# 初始化\npygame.init()\n# 屏幕对象\nscreen = pygame.display.set_mode((320, 800))\n\nimage1 = pygame.image.load('assets/images/hero1.png')\nimage2 = pygame.image.load('assets/images/hero2.png')\ncount = 0\nclock = pygame.time.Clock()\n\n# 游戏主循环\nwhile True:\n\n    count += 1\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n    screen.fill(pygame.Color(255, 255, 255))\n    # 每秒60次\n    clock.tick(60)\n    if count % 5 == 0:\n        screen.blit(image1, (20, 20))\n    else:\n        screen.blit(image2, (20, 20))\n\n    pygame.display.update()\n```\n\n\n\n### 精灵及精灵组\n\n**精灵**：可以理解为需要操纵的图片（飞机大战中的飞机），一种可以在屏幕上移动的图形对象，并且可以和其他图形对象交互。可以使用pygame绘制，也可以是资源图片。\n\n**精灵组**：是一个容器，用于管理组内精灵的绘制与更新，精灵加入精灵组，精灵组会自动调用每一个精灵的方法。\n\n基本使用方法就是，对自己的精灵类继承自`pygame.sprite.Sprite`，然后填补update之类的方法即可。\n\n**碰撞检测**：检测两个精灵有没有重叠的部分\n\n```\n# 输入两个精灵，输出为布尔值\nres = pygame.sprite.collide_rect(sprite1, sprite2)\n# 指定碰撞精度\nres = pygame.sprite.collide_rect_ratio(0.5)(sprite1, sprite2)\n```\n","source":"_posts/Python/游戏/pygame基础.md","raw":"---\ntitle: pygame基础\ndate: 2020-05-15 16:11:20\ntags:\n\t- pygame\ncategories:\n\t- Python\n\t- 游戏\nfileName: pygame1\n---\n\n官方文档：https://www.pygame.org/docs/\n\n### 基本流程\n\n1. 引入相关的包\n2. 初始化，pygame.init()\n3. 得到屏幕对象，`screen = pygame.display.set_mode((320, 240))`\n4. 游戏主循环\n   * 处理游戏事件\n   * 更新游戏状态\n   * 屏幕重新绘制\n\n基本代码框架\n\n```\nimport pygame\n# 初始化\npygame.init()\n# 获取屏幕对象\nscreen = pygame.display.set_mode((width, height))\n# 游戏主循环\nwhile True:\n\t# 处理游戏事件\n\tfor event in pygame.event.get():\n\t\tpass\n\t# 更新游戏状态（游戏逻辑）\n\t\n\t# 重新绘制屏幕\n```\n\n\n\n### 绘制图片\n\n基本流程如下\n\n```\n# 加载图片\nball = pygame.image.load('assets/images/background.png')\n\n# 图片绘制\n    screen.blit(ball, ball.get_rect)\n    pygame.display.flip()\n```\n\n其中`get_rect`返回值为（left, top, width, height）。前者为图片显示的左上角坐标，后者为图片的长与宽。\n\n绘制其他模块自带的图形\n\n```\nred = pygame.Color(255, 0, 0)\n# 画线\npygame.draw.line(screen, red, (10,10), (200, 200),10)\n# 画矩形\npygame.draw.rect(screen,red,(10,20,200,300),10)\n# 画圆\npygame.draw.circle(screen, red, (100, 100),50,5)\n```\n\n\n\n### 绘制文字\n\n可以使用系统默认的字体进行加载，也可以在项目中使用ttf文件作为资源进行加载。\n\n```\n# 加载字体（使用系统默认字体进行加载）\nred = pygame.Color(255, 0, 0)\nfonts = pygame.font.SysFont('宋体', 40)\ntext = fonts.render('Scores:', True, red)\n\n# 写于游戏主循环\nscreen.blit(text, (20, 20))\npygame.display.flip()\n```\n\n加载项目中所带的ttf文件\n\n```\nfonts = pygame.font.Font('*.ttf', 40)\n```\n\n\n\n### 游戏音效\n\n```\n# 加载音乐\nbgm = pygame.mixer_music.load('assets/sounds/game_bg_music.mp3')\n# 循环播放\npygame.mixer_music.play(-1)\n```\n\n设置音量大小\n\n```\npygame.mixer_music.set_volume(0.1) 输入值为（0，1）\n```\n\n\n\n### 动画切换\n\n两张图片的切换（pygame貌似不支持使用gif之类的动图）\n\n思路：通过设置帧率进行切换，`pygame.time.Clock`\n\n```\nimport sys, pygame\n# 初始化\npygame.init()\n# 屏幕对象\nscreen = pygame.display.set_mode((320, 800))\n\nimage1 = pygame.image.load('assets/images/hero1.png')\nimage2 = pygame.image.load('assets/images/hero2.png')\ncount = 0\nclock = pygame.time.Clock()\n\n# 游戏主循环\nwhile True:\n\n    count += 1\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n    screen.fill(pygame.Color(255, 255, 255))\n    # 每秒60次\n    clock.tick(60)\n    if count % 5 == 0:\n        screen.blit(image1, (20, 20))\n    else:\n        screen.blit(image2, (20, 20))\n\n    pygame.display.update()\n```\n\n\n\n### 精灵及精灵组\n\n**精灵**：可以理解为需要操纵的图片（飞机大战中的飞机），一种可以在屏幕上移动的图形对象，并且可以和其他图形对象交互。可以使用pygame绘制，也可以是资源图片。\n\n**精灵组**：是一个容器，用于管理组内精灵的绘制与更新，精灵加入精灵组，精灵组会自动调用每一个精灵的方法。\n\n基本使用方法就是，对自己的精灵类继承自`pygame.sprite.Sprite`，然后填补update之类的方法即可。\n\n**碰撞检测**：检测两个精灵有没有重叠的部分\n\n```\n# 输入两个精灵，输出为布尔值\nres = pygame.sprite.collide_rect(sprite1, sprite2)\n# 指定碰撞精度\nres = pygame.sprite.collide_rect_ratio(0.5)(sprite1, sprite2)\n```\n","slug":"Python/游戏/pygame基础","published":1,"updated":"2020-07-16T16:03:14.499Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8sv000kl4jsfcfm81n3","content":"<p>官方文档：<a href=\"https://www.pygame.org/docs/\" target=\"_blank\" rel=\"noopener\">https://www.pygame.org/docs/</a></p>\n<h3 id=\"基本流程\"><a href=\"#基本流程\" class=\"headerlink\" title=\"基本流程\"></a>基本流程</h3><ol>\n<li>引入相关的包</li>\n<li>初始化，pygame.init()</li>\n<li>得到屏幕对象，<code>screen = pygame.display.set_mode((320, 240))</code></li>\n<li>游戏主循环<ul>\n<li>处理游戏事件</li>\n<li>更新游戏状态</li>\n<li>屏幕重新绘制</li>\n</ul>\n</li>\n</ol>\n<p>基本代码框架</p>\n<pre><code>import pygame\n# 初始化\npygame.init()\n# 获取屏幕对象\nscreen = pygame.display.set_mode((width, height))\n# 游戏主循环\nwhile True:\n    # 处理游戏事件\n    for event in pygame.event.get():\n        pass\n    # 更新游戏状态（游戏逻辑）\n\n    # 重新绘制屏幕</code></pre><h3 id=\"绘制图片\"><a href=\"#绘制图片\" class=\"headerlink\" title=\"绘制图片\"></a>绘制图片</h3><p>基本流程如下</p>\n<pre><code># 加载图片\nball = pygame.image.load(&#39;assets/images/background.png&#39;)\n\n# 图片绘制\n    screen.blit(ball, ball.get_rect)\n    pygame.display.flip()</code></pre><p>其中<code>get_rect</code>返回值为（left, top, width, height）。前者为图片显示的左上角坐标，后者为图片的长与宽。</p>\n<p>绘制其他模块自带的图形</p>\n<pre><code>red = pygame.Color(255, 0, 0)\n# 画线\npygame.draw.line(screen, red, (10,10), (200, 200),10)\n# 画矩形\npygame.draw.rect(screen,red,(10,20,200,300),10)\n# 画圆\npygame.draw.circle(screen, red, (100, 100),50,5)</code></pre><h3 id=\"绘制文字\"><a href=\"#绘制文字\" class=\"headerlink\" title=\"绘制文字\"></a>绘制文字</h3><p>可以使用系统默认的字体进行加载，也可以在项目中使用ttf文件作为资源进行加载。</p>\n<pre><code># 加载字体（使用系统默认字体进行加载）\nred = pygame.Color(255, 0, 0)\nfonts = pygame.font.SysFont(&#39;宋体&#39;, 40)\ntext = fonts.render(&#39;Scores:&#39;, True, red)\n\n# 写于游戏主循环\nscreen.blit(text, (20, 20))\npygame.display.flip()</code></pre><p>加载项目中所带的ttf文件</p>\n<pre><code>fonts = pygame.font.Font(&#39;*.ttf&#39;, 40)</code></pre><h3 id=\"游戏音效\"><a href=\"#游戏音效\" class=\"headerlink\" title=\"游戏音效\"></a>游戏音效</h3><pre><code># 加载音乐\nbgm = pygame.mixer_music.load(&#39;assets/sounds/game_bg_music.mp3&#39;)\n# 循环播放\npygame.mixer_music.play(-1)</code></pre><p>设置音量大小</p>\n<pre><code>pygame.mixer_music.set_volume(0.1) 输入值为（0，1）</code></pre><h3 id=\"动画切换\"><a href=\"#动画切换\" class=\"headerlink\" title=\"动画切换\"></a>动画切换</h3><p>两张图片的切换（pygame貌似不支持使用gif之类的动图）</p>\n<p>思路：通过设置帧率进行切换，<code>pygame.time.Clock</code></p>\n<pre><code>import sys, pygame\n# 初始化\npygame.init()\n# 屏幕对象\nscreen = pygame.display.set_mode((320, 800))\n\nimage1 = pygame.image.load(&#39;assets/images/hero1.png&#39;)\nimage2 = pygame.image.load(&#39;assets/images/hero2.png&#39;)\ncount = 0\nclock = pygame.time.Clock()\n\n# 游戏主循环\nwhile True:\n\n    count += 1\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n    screen.fill(pygame.Color(255, 255, 255))\n    # 每秒60次\n    clock.tick(60)\n    if count % 5 == 0:\n        screen.blit(image1, (20, 20))\n    else:\n        screen.blit(image2, (20, 20))\n\n    pygame.display.update()</code></pre><h3 id=\"精灵及精灵组\"><a href=\"#精灵及精灵组\" class=\"headerlink\" title=\"精灵及精灵组\"></a>精灵及精灵组</h3><p><strong>精灵</strong>：可以理解为需要操纵的图片（飞机大战中的飞机），一种可以在屏幕上移动的图形对象，并且可以和其他图形对象交互。可以使用pygame绘制，也可以是资源图片。</p>\n<p><strong>精灵组</strong>：是一个容器，用于管理组内精灵的绘制与更新，精灵加入精灵组，精灵组会自动调用每一个精灵的方法。</p>\n<p>基本使用方法就是，对自己的精灵类继承自<code>pygame.sprite.Sprite</code>，然后填补update之类的方法即可。</p>\n<p><strong>碰撞检测</strong>：检测两个精灵有没有重叠的部分</p>\n<pre><code># 输入两个精灵，输出为布尔值\nres = pygame.sprite.collide_rect(sprite1, sprite2)\n# 指定碰撞精度\nres = pygame.sprite.collide_rect_ratio(0.5)(sprite1, sprite2)</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>官方文档：<a href=\"https://www.pygame.org/docs/\" target=\"_blank\" rel=\"noopener\">https://www.pygame.org/docs/</a></p>\n<h3 id=\"基本流程\"><a href=\"#基本流程\" class=\"headerlink\" title=\"基本流程\"></a>基本流程</h3><ol>\n<li>引入相关的包</li>\n<li>初始化，pygame.init()</li>\n<li>得到屏幕对象，<code>screen = pygame.display.set_mode((320, 240))</code></li>\n<li>游戏主循环<ul>\n<li>处理游戏事件</li>\n<li>更新游戏状态</li>\n<li>屏幕重新绘制</li>\n</ul>\n</li>\n</ol>\n<p>基本代码框架</p>\n<pre><code>import pygame\n# 初始化\npygame.init()\n# 获取屏幕对象\nscreen = pygame.display.set_mode((width, height))\n# 游戏主循环\nwhile True:\n    # 处理游戏事件\n    for event in pygame.event.get():\n        pass\n    # 更新游戏状态（游戏逻辑）\n\n    # 重新绘制屏幕</code></pre><h3 id=\"绘制图片\"><a href=\"#绘制图片\" class=\"headerlink\" title=\"绘制图片\"></a>绘制图片</h3><p>基本流程如下</p>\n<pre><code># 加载图片\nball = pygame.image.load(&#39;assets/images/background.png&#39;)\n\n# 图片绘制\n    screen.blit(ball, ball.get_rect)\n    pygame.display.flip()</code></pre><p>其中<code>get_rect</code>返回值为（left, top, width, height）。前者为图片显示的左上角坐标，后者为图片的长与宽。</p>\n<p>绘制其他模块自带的图形</p>\n<pre><code>red = pygame.Color(255, 0, 0)\n# 画线\npygame.draw.line(screen, red, (10,10), (200, 200),10)\n# 画矩形\npygame.draw.rect(screen,red,(10,20,200,300),10)\n# 画圆\npygame.draw.circle(screen, red, (100, 100),50,5)</code></pre><h3 id=\"绘制文字\"><a href=\"#绘制文字\" class=\"headerlink\" title=\"绘制文字\"></a>绘制文字</h3><p>可以使用系统默认的字体进行加载，也可以在项目中使用ttf文件作为资源进行加载。</p>\n<pre><code># 加载字体（使用系统默认字体进行加载）\nred = pygame.Color(255, 0, 0)\nfonts = pygame.font.SysFont(&#39;宋体&#39;, 40)\ntext = fonts.render(&#39;Scores:&#39;, True, red)\n\n# 写于游戏主循环\nscreen.blit(text, (20, 20))\npygame.display.flip()</code></pre><p>加载项目中所带的ttf文件</p>\n<pre><code>fonts = pygame.font.Font(&#39;*.ttf&#39;, 40)</code></pre><h3 id=\"游戏音效\"><a href=\"#游戏音效\" class=\"headerlink\" title=\"游戏音效\"></a>游戏音效</h3><pre><code># 加载音乐\nbgm = pygame.mixer_music.load(&#39;assets/sounds/game_bg_music.mp3&#39;)\n# 循环播放\npygame.mixer_music.play(-1)</code></pre><p>设置音量大小</p>\n<pre><code>pygame.mixer_music.set_volume(0.1) 输入值为（0，1）</code></pre><h3 id=\"动画切换\"><a href=\"#动画切换\" class=\"headerlink\" title=\"动画切换\"></a>动画切换</h3><p>两张图片的切换（pygame貌似不支持使用gif之类的动图）</p>\n<p>思路：通过设置帧率进行切换，<code>pygame.time.Clock</code></p>\n<pre><code>import sys, pygame\n# 初始化\npygame.init()\n# 屏幕对象\nscreen = pygame.display.set_mode((320, 800))\n\nimage1 = pygame.image.load(&#39;assets/images/hero1.png&#39;)\nimage2 = pygame.image.load(&#39;assets/images/hero2.png&#39;)\ncount = 0\nclock = pygame.time.Clock()\n\n# 游戏主循环\nwhile True:\n\n    count += 1\n    for event in pygame.event.get():\n        if event.type == pygame.QUIT:\n            pygame.quit()\n            sys.exit()\n    screen.fill(pygame.Color(255, 255, 255))\n    # 每秒60次\n    clock.tick(60)\n    if count % 5 == 0:\n        screen.blit(image1, (20, 20))\n    else:\n        screen.blit(image2, (20, 20))\n\n    pygame.display.update()</code></pre><h3 id=\"精灵及精灵组\"><a href=\"#精灵及精灵组\" class=\"headerlink\" title=\"精灵及精灵组\"></a>精灵及精灵组</h3><p><strong>精灵</strong>：可以理解为需要操纵的图片（飞机大战中的飞机），一种可以在屏幕上移动的图形对象，并且可以和其他图形对象交互。可以使用pygame绘制，也可以是资源图片。</p>\n<p><strong>精灵组</strong>：是一个容器，用于管理组内精灵的绘制与更新，精灵加入精灵组，精灵组会自动调用每一个精灵的方法。</p>\n<p>基本使用方法就是，对自己的精灵类继承自<code>pygame.sprite.Sprite</code>，然后填补update之类的方法即可。</p>\n<p><strong>碰撞检测</strong>：检测两个精灵有没有重叠的部分</p>\n<pre><code># 输入两个精灵，输出为布尔值\nres = pygame.sprite.collide_rect(sprite1, sprite2)\n# 指定碰撞精度\nres = pygame.sprite.collide_rect_ratio(0.5)(sprite1, sprite2)</code></pre>"},{"title":"1、Python基本数据类型","date":"2020-05-08T04:46:26.000Z","fileName":"python1","_content":"\n### 字符串\n\n1、 单双引号的应用，即字符串中包含单引号时可以使用双引号进行包含，包含双引号时使用单引号进行包含，如下：\n```\n\"a's hhh\"\n'a\"s hhh'\n```\n\n2、 字符串的一些基本操作（拼接、搜索、替换），其中**替换操作必须要将str赋给一个新的变量**\n```\nstr = str1 + str2\t# 拼接字符串（直接使用 + 进行操作）\nlen(str) # 获取长度\nstr.find(string) # 返回搜索到的第一个index，没搜索到则返回-1\nstr = str.replace('A', 'B') # A替换B\n```\n\n3、 格式化字符串（使用.format语句），使用{}占位符进行\n```\n\"{} {} gg\".format(\"huangkai\",\"is\")\n# huangkai is gg\n\n# 带索引的格式化字符串\n\"{1} {0} gg\".format(\"huangkai\",\"is\")\nis huangkai gg\n\n# f形式的格式化字符串\nstr1 = 'Curry'\nstr2 = 'James'\ncombi = f'{str1} and {str2}, NBA stars'\n\n# 使用别名\nstr3 = “gg {s1}， {s2}”。format(s1=str1, s2 str2)\n```\n\n### 列表（list）\n\n列表在内存中按照顺序存储\n\n1、 列表反转与排序\n\n```\nlist.reverse()\t# 列表反转\nlist.sort() # 升序排列\nlist.sort(reverse=True) # 降序排列\n```\n\n2、 列表常用操作\n\n```\nlist.append(new_element) # 在列表末尾添加元素\nlist.insert(index, new_element) # 在指定的index处加入一个元素，其后元素全部后移\nlist.remove(element) # 删除值为element的元素\nlist.pop(index) # 删除索引值为index的元素，无index则删除最后一个元素\nlist.clear() # 清空列表\n```\n\n4、 列表其他操作（区别于append）\n\n```\nlist.extend([e1, e2]) # 将列表追加进list（区别于append）\n```\n\n5、 **列表的复制**，想将一个列表赋值给另一个列表必须要使用.copy方法，否则修改其中一个表另一个也会变，如下：\n```\nl1 = [1,2,3,4]\nl2 = l1\nprint(id(l1))\nprint(id(l2))\n```\n运行结果可以发现l1与l2指向了同一块内存，因此改变l1，l2也会相应改变。而copy()方法会重新创建一个空列表再将原列表的元素放进去。\n```\nl2 = list.copy()\n```\n\n6、列表元素直接的对应操作，以相加为例，使用列表生成器如下。其中zip函数为将a、b两个列表中的元素一一组合。\n\n```\na = [1,2,3,4]\nb = [1,2,3,4]\nc = [i+j for i, j in zip(a,b)]\n########################################\n[2, 4, 6, 8]\n```\n\n\n\n### 字典（dict）\n\n键值对（key-value），可修改。Python中的散列值函数`hash(data)`，字典存储根据其哈希值存储。\n\n1、 创建\n```\ndic = dict.fromkeys(['school number', 'bala1', 'bala2'])\nprint(dic)\n\n# 输出\n{'school number': None, 'bala1': None, 'bala2': None}\n```\n\n2、 取值\n```\n# 直接使用key获取value\ndic[key]\n# 使用get方法（可以为不存在的key赋默认值）\ndic.get(key)\n```\n\n3、 遍历字典\n```\n# 方案1\nfor key in dic:\n\tv = dic[key]\n\t\n# 方案2（返回每一个键值对）\nfor key,value in dic.items():\n\t\n```\n\n4、 字典常用操作\n```\ndic.update(k1 = new_value1, k2 = new_value2) # 对多个键值进行更新或新增\ndic,pop(key) # 删除键值为key\ndic.popitem() # 删除最后一个键值对，并返回该键值对的tuple\ndic.clear() # 清空字典\ndic.setdefault('key', 'value') # 设置默认值（如果没有该键值的话）\n\n# 修改字典时下面三个值都会变\ndic.keys()\t# 返回所有键\ndic.values() # 返回所有值\ndic.items() # 返回所有键值对\n\n# 格式化字符串，使用format_map\ndic = {'name':'Curry','gg':'no'}\ns = \"姓名:{name},瞎写:{gg}\".format_map(dic)\nprint(s)\n# 输出\n姓名:Curry,瞎写:no\n```\n\n### 元组（tuple）\n\n创建后不允许修改，当列表等可变对象为元组元素时，可以修改该元素的值。\n\n\n### 集合（Set）\n\n元素是无序的、可变的、元素不能重复，在内存中是分散保存的（存储方式与字典相似），缺点，浪费内存空间\n\n1、 初始化\n```\n# 空集合的创建\n# 不能使用s = {}，这样默认创建的是字典\nset1 = set()\n```\n2、 集合的常用运算\n```\nset1 = {1,2,3,4,5}\nset2 = {4,5,6,7,8}\n\n# 交集运算\nset3 = set1.intersection(set2)\t# 产生新集合\n# intersection_update为更新原有集合\nprint(set3)\n# 输出\n{4, 5}\n\n# 并集运算\nset3 = set1.union(set2)\nprint(set3)\n# 输出\n{1, 2, 3, 4, 5, 6, 7, 8}\n\n# 差集运算\nset3 = set1.difference(set2) # 得到set1中有，set2中没有的元素 \nprint(set3)\n# 输出\n{1, 2, 3}\n\n# 双向差集\nset3 = set1.symmetric_difference(set2)\nprint(set3)\n# 输出\n{1, 2, 3, 6, 7, 8}\n```\n\n3、 集合间的关系操作\n```\n# 判断两个集合的元素是否完全相同\ns1 = {1,2,3,4,5}\ns2 = {5,4,3,2,1}\nprint(s1 == s2)\n# 输出\nTrue\n```\n\n```\n# 子集判断\n# 父集判断，同理。 .issuperset()\ns1 = {1,2,3,4,5}\ns2 = {5,4,3,2}\nprint(s2.issubset(s1))\n# 输出\nTrue\n```\n\n```\n# 判断两个集合是否存在重复元素\n# 返回False代表存在重复元素\ns1 = {1,2,3,4,5}\ns2 = {5,4,3,2}\nprint(s1.isdisjoint(s2))\n# 输出\nFalse\n```\n\n```\n# 新增数据\nset.add(element) # 一次添加一个元素\nset.update(列表或元组) # 一次添加多个元素\n# 删除元素\nset.remove(element) # 删除不存在的元素会报错\nset.discard(element) # 删除不存在的元素会直接忽略\n```\n\n### 常用的转换函数\n\n```\nlist() # 转换为列表\ntuple() # 转换为元组\njoin(), str() # 转换为字符串\n```\n\n### 生成器\n\n1、 **列表生成器**，常用形式如下\n\n[数据 循环语句 循环或判断语句]\n\n```\nl = [i**2 for i in range(10)]\n# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\nl = [i**2 for i in range(10) if i%2 ==0]\n# [0, 4, 16, 36, 64]\n```\n\n2、 字典生成器\n\n```\nlist1 = ['A', 'B', 'C']\ndic = {i:list1[i] for i in range(len(list1))}\n# {0: 'A', 1: 'B', 2: 'C'}\n```\n\n3、 集合生成器（跟列表生成式类似）\n```\nset1 = {i for i in range(10)}\n```","source":"_posts/Python/语言基础/1、Python基本数据类型.md","raw":"---\ntitle: 1、Python基本数据类型\ndate: 2020-05-08 12:46:26\ntags:\n\t- python\ncategories:\n\t- Python\n\t- 语言基础\nfileName: python1\n---\n\n### 字符串\n\n1、 单双引号的应用，即字符串中包含单引号时可以使用双引号进行包含，包含双引号时使用单引号进行包含，如下：\n```\n\"a's hhh\"\n'a\"s hhh'\n```\n\n2、 字符串的一些基本操作（拼接、搜索、替换），其中**替换操作必须要将str赋给一个新的变量**\n```\nstr = str1 + str2\t# 拼接字符串（直接使用 + 进行操作）\nlen(str) # 获取长度\nstr.find(string) # 返回搜索到的第一个index，没搜索到则返回-1\nstr = str.replace('A', 'B') # A替换B\n```\n\n3、 格式化字符串（使用.format语句），使用{}占位符进行\n```\n\"{} {} gg\".format(\"huangkai\",\"is\")\n# huangkai is gg\n\n# 带索引的格式化字符串\n\"{1} {0} gg\".format(\"huangkai\",\"is\")\nis huangkai gg\n\n# f形式的格式化字符串\nstr1 = 'Curry'\nstr2 = 'James'\ncombi = f'{str1} and {str2}, NBA stars'\n\n# 使用别名\nstr3 = “gg {s1}， {s2}”。format(s1=str1, s2 str2)\n```\n\n### 列表（list）\n\n列表在内存中按照顺序存储\n\n1、 列表反转与排序\n\n```\nlist.reverse()\t# 列表反转\nlist.sort() # 升序排列\nlist.sort(reverse=True) # 降序排列\n```\n\n2、 列表常用操作\n\n```\nlist.append(new_element) # 在列表末尾添加元素\nlist.insert(index, new_element) # 在指定的index处加入一个元素，其后元素全部后移\nlist.remove(element) # 删除值为element的元素\nlist.pop(index) # 删除索引值为index的元素，无index则删除最后一个元素\nlist.clear() # 清空列表\n```\n\n4、 列表其他操作（区别于append）\n\n```\nlist.extend([e1, e2]) # 将列表追加进list（区别于append）\n```\n\n5、 **列表的复制**，想将一个列表赋值给另一个列表必须要使用.copy方法，否则修改其中一个表另一个也会变，如下：\n```\nl1 = [1,2,3,4]\nl2 = l1\nprint(id(l1))\nprint(id(l2))\n```\n运行结果可以发现l1与l2指向了同一块内存，因此改变l1，l2也会相应改变。而copy()方法会重新创建一个空列表再将原列表的元素放进去。\n```\nl2 = list.copy()\n```\n\n6、列表元素直接的对应操作，以相加为例，使用列表生成器如下。其中zip函数为将a、b两个列表中的元素一一组合。\n\n```\na = [1,2,3,4]\nb = [1,2,3,4]\nc = [i+j for i, j in zip(a,b)]\n########################################\n[2, 4, 6, 8]\n```\n\n\n\n### 字典（dict）\n\n键值对（key-value），可修改。Python中的散列值函数`hash(data)`，字典存储根据其哈希值存储。\n\n1、 创建\n```\ndic = dict.fromkeys(['school number', 'bala1', 'bala2'])\nprint(dic)\n\n# 输出\n{'school number': None, 'bala1': None, 'bala2': None}\n```\n\n2、 取值\n```\n# 直接使用key获取value\ndic[key]\n# 使用get方法（可以为不存在的key赋默认值）\ndic.get(key)\n```\n\n3、 遍历字典\n```\n# 方案1\nfor key in dic:\n\tv = dic[key]\n\t\n# 方案2（返回每一个键值对）\nfor key,value in dic.items():\n\t\n```\n\n4、 字典常用操作\n```\ndic.update(k1 = new_value1, k2 = new_value2) # 对多个键值进行更新或新增\ndic,pop(key) # 删除键值为key\ndic.popitem() # 删除最后一个键值对，并返回该键值对的tuple\ndic.clear() # 清空字典\ndic.setdefault('key', 'value') # 设置默认值（如果没有该键值的话）\n\n# 修改字典时下面三个值都会变\ndic.keys()\t# 返回所有键\ndic.values() # 返回所有值\ndic.items() # 返回所有键值对\n\n# 格式化字符串，使用format_map\ndic = {'name':'Curry','gg':'no'}\ns = \"姓名:{name},瞎写:{gg}\".format_map(dic)\nprint(s)\n# 输出\n姓名:Curry,瞎写:no\n```\n\n### 元组（tuple）\n\n创建后不允许修改，当列表等可变对象为元组元素时，可以修改该元素的值。\n\n\n### 集合（Set）\n\n元素是无序的、可变的、元素不能重复，在内存中是分散保存的（存储方式与字典相似），缺点，浪费内存空间\n\n1、 初始化\n```\n# 空集合的创建\n# 不能使用s = {}，这样默认创建的是字典\nset1 = set()\n```\n2、 集合的常用运算\n```\nset1 = {1,2,3,4,5}\nset2 = {4,5,6,7,8}\n\n# 交集运算\nset3 = set1.intersection(set2)\t# 产生新集合\n# intersection_update为更新原有集合\nprint(set3)\n# 输出\n{4, 5}\n\n# 并集运算\nset3 = set1.union(set2)\nprint(set3)\n# 输出\n{1, 2, 3, 4, 5, 6, 7, 8}\n\n# 差集运算\nset3 = set1.difference(set2) # 得到set1中有，set2中没有的元素 \nprint(set3)\n# 输出\n{1, 2, 3}\n\n# 双向差集\nset3 = set1.symmetric_difference(set2)\nprint(set3)\n# 输出\n{1, 2, 3, 6, 7, 8}\n```\n\n3、 集合间的关系操作\n```\n# 判断两个集合的元素是否完全相同\ns1 = {1,2,3,4,5}\ns2 = {5,4,3,2,1}\nprint(s1 == s2)\n# 输出\nTrue\n```\n\n```\n# 子集判断\n# 父集判断，同理。 .issuperset()\ns1 = {1,2,3,4,5}\ns2 = {5,4,3,2}\nprint(s2.issubset(s1))\n# 输出\nTrue\n```\n\n```\n# 判断两个集合是否存在重复元素\n# 返回False代表存在重复元素\ns1 = {1,2,3,4,5}\ns2 = {5,4,3,2}\nprint(s1.isdisjoint(s2))\n# 输出\nFalse\n```\n\n```\n# 新增数据\nset.add(element) # 一次添加一个元素\nset.update(列表或元组) # 一次添加多个元素\n# 删除元素\nset.remove(element) # 删除不存在的元素会报错\nset.discard(element) # 删除不存在的元素会直接忽略\n```\n\n### 常用的转换函数\n\n```\nlist() # 转换为列表\ntuple() # 转换为元组\njoin(), str() # 转换为字符串\n```\n\n### 生成器\n\n1、 **列表生成器**，常用形式如下\n\n[数据 循环语句 循环或判断语句]\n\n```\nl = [i**2 for i in range(10)]\n# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\nl = [i**2 for i in range(10) if i%2 ==0]\n# [0, 4, 16, 36, 64]\n```\n\n2、 字典生成器\n\n```\nlist1 = ['A', 'B', 'C']\ndic = {i:list1[i] for i in range(len(list1))}\n# {0: 'A', 1: 'B', 2: 'C'}\n```\n\n3、 集合生成器（跟列表生成式类似）\n```\nset1 = {i for i in range(10)}\n```","slug":"Python/语言基础/1、Python基本数据类型","published":1,"updated":"2020-07-16T16:03:47.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8sz000ol4js2obc4x3i","content":"<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>1、 单双引号的应用，即字符串中包含单引号时可以使用双引号进行包含，包含双引号时使用单引号进行包含，如下：</p>\n<pre><code>&quot;a&#39;s hhh&quot;\n&#39;a&quot;s hhh&#39;</code></pre><p>2、 字符串的一些基本操作（拼接、搜索、替换），其中<strong>替换操作必须要将str赋给一个新的变量</strong></p>\n<pre><code>str = str1 + str2    # 拼接字符串（直接使用 + 进行操作）\nlen(str) # 获取长度\nstr.find(string) # 返回搜索到的第一个index，没搜索到则返回-1\nstr = str.replace(&#39;A&#39;, &#39;B&#39;) # A替换B</code></pre><p>3、 格式化字符串（使用.format语句），使用{}占位符进行</p>\n<pre><code>&quot;{} {} gg&quot;.format(&quot;huangkai&quot;,&quot;is&quot;)\n# huangkai is gg\n\n# 带索引的格式化字符串\n&quot;{1} {0} gg&quot;.format(&quot;huangkai&quot;,&quot;is&quot;)\nis huangkai gg\n\n# f形式的格式化字符串\nstr1 = &#39;Curry&#39;\nstr2 = &#39;James&#39;\ncombi = f&#39;{str1} and {str2}, NBA stars&#39;\n\n# 使用别名\nstr3 = “gg {s1}， {s2}”。format(s1=str1, s2 str2)</code></pre><h3 id=\"列表（list）\"><a href=\"#列表（list）\" class=\"headerlink\" title=\"列表（list）\"></a>列表（list）</h3><p>列表在内存中按照顺序存储</p>\n<p>1、 列表反转与排序</p>\n<pre><code>list.reverse()    # 列表反转\nlist.sort() # 升序排列\nlist.sort(reverse=True) # 降序排列</code></pre><p>2、 列表常用操作</p>\n<pre><code>list.append(new_element) # 在列表末尾添加元素\nlist.insert(index, new_element) # 在指定的index处加入一个元素，其后元素全部后移\nlist.remove(element) # 删除值为element的元素\nlist.pop(index) # 删除索引值为index的元素，无index则删除最后一个元素\nlist.clear() # 清空列表</code></pre><p>4、 列表其他操作（区别于append）</p>\n<pre><code>list.extend([e1, e2]) # 将列表追加进list（区别于append）</code></pre><p>5、 <strong>列表的复制</strong>，想将一个列表赋值给另一个列表必须要使用.copy方法，否则修改其中一个表另一个也会变，如下：</p>\n<pre><code>l1 = [1,2,3,4]\nl2 = l1\nprint(id(l1))\nprint(id(l2))</code></pre><p>运行结果可以发现l1与l2指向了同一块内存，因此改变l1，l2也会相应改变。而copy()方法会重新创建一个空列表再将原列表的元素放进去。</p>\n<pre><code>l2 = list.copy()</code></pre><p>6、列表元素直接的对应操作，以相加为例，使用列表生成器如下。其中zip函数为将a、b两个列表中的元素一一组合。</p>\n<pre><code>a = [1,2,3,4]\nb = [1,2,3,4]\nc = [i+j for i, j in zip(a,b)]\n########################################\n[2, 4, 6, 8]</code></pre><h3 id=\"字典（dict）\"><a href=\"#字典（dict）\" class=\"headerlink\" title=\"字典（dict）\"></a>字典（dict）</h3><p>键值对（key-value），可修改。Python中的散列值函数<code>hash(data)</code>，字典存储根据其哈希值存储。</p>\n<p>1、 创建</p>\n<pre><code>dic = dict.fromkeys([&#39;school number&#39;, &#39;bala1&#39;, &#39;bala2&#39;])\nprint(dic)\n\n# 输出\n{&#39;school number&#39;: None, &#39;bala1&#39;: None, &#39;bala2&#39;: None}</code></pre><p>2、 取值</p>\n<pre><code># 直接使用key获取value\ndic[key]\n# 使用get方法（可以为不存在的key赋默认值）\ndic.get(key)</code></pre><p>3、 遍历字典</p>\n<pre><code># 方案1\nfor key in dic:\n    v = dic[key]\n\n# 方案2（返回每一个键值对）\nfor key,value in dic.items():\n</code></pre><p>4、 字典常用操作</p>\n<pre><code>dic.update(k1 = new_value1, k2 = new_value2) # 对多个键值进行更新或新增\ndic,pop(key) # 删除键值为key\ndic.popitem() # 删除最后一个键值对，并返回该键值对的tuple\ndic.clear() # 清空字典\ndic.setdefault(&#39;key&#39;, &#39;value&#39;) # 设置默认值（如果没有该键值的话）\n\n# 修改字典时下面三个值都会变\ndic.keys()    # 返回所有键\ndic.values() # 返回所有值\ndic.items() # 返回所有键值对\n\n# 格式化字符串，使用format_map\ndic = {&#39;name&#39;:&#39;Curry&#39;,&#39;gg&#39;:&#39;no&#39;}\ns = &quot;姓名:{name},瞎写:{gg}&quot;.format_map(dic)\nprint(s)\n# 输出\n姓名:Curry,瞎写:no</code></pre><h3 id=\"元组（tuple）\"><a href=\"#元组（tuple）\" class=\"headerlink\" title=\"元组（tuple）\"></a>元组（tuple）</h3><p>创建后不允许修改，当列表等可变对象为元组元素时，可以修改该元素的值。</p>\n<h3 id=\"集合（Set）\"><a href=\"#集合（Set）\" class=\"headerlink\" title=\"集合（Set）\"></a>集合（Set）</h3><p>元素是无序的、可变的、元素不能重复，在内存中是分散保存的（存储方式与字典相似），缺点，浪费内存空间</p>\n<p>1、 初始化</p>\n<pre><code># 空集合的创建\n# 不能使用s = {}，这样默认创建的是字典\nset1 = set()</code></pre><p>2、 集合的常用运算</p>\n<pre><code>set1 = {1,2,3,4,5}\nset2 = {4,5,6,7,8}\n\n# 交集运算\nset3 = set1.intersection(set2)    # 产生新集合\n# intersection_update为更新原有集合\nprint(set3)\n# 输出\n{4, 5}\n\n# 并集运算\nset3 = set1.union(set2)\nprint(set3)\n# 输出\n{1, 2, 3, 4, 5, 6, 7, 8}\n\n# 差集运算\nset3 = set1.difference(set2) # 得到set1中有，set2中没有的元素 \nprint(set3)\n# 输出\n{1, 2, 3}\n\n# 双向差集\nset3 = set1.symmetric_difference(set2)\nprint(set3)\n# 输出\n{1, 2, 3, 6, 7, 8}</code></pre><p>3、 集合间的关系操作</p>\n<pre><code># 判断两个集合的元素是否完全相同\ns1 = {1,2,3,4,5}\ns2 = {5,4,3,2,1}\nprint(s1 == s2)\n# 输出\nTrue</code></pre><pre><code># 子集判断\n# 父集判断，同理。 .issuperset()\ns1 = {1,2,3,4,5}\ns2 = {5,4,3,2}\nprint(s2.issubset(s1))\n# 输出\nTrue</code></pre><pre><code># 判断两个集合是否存在重复元素\n# 返回False代表存在重复元素\ns1 = {1,2,3,4,5}\ns2 = {5,4,3,2}\nprint(s1.isdisjoint(s2))\n# 输出\nFalse</code></pre><pre><code># 新增数据\nset.add(element) # 一次添加一个元素\nset.update(列表或元组) # 一次添加多个元素\n# 删除元素\nset.remove(element) # 删除不存在的元素会报错\nset.discard(element) # 删除不存在的元素会直接忽略</code></pre><h3 id=\"常用的转换函数\"><a href=\"#常用的转换函数\" class=\"headerlink\" title=\"常用的转换函数\"></a>常用的转换函数</h3><pre><code>list() # 转换为列表\ntuple() # 转换为元组\njoin(), str() # 转换为字符串</code></pre><h3 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h3><p>1、 <strong>列表生成器</strong>，常用形式如下</p>\n<p>[数据 循环语句 循环或判断语句]</p>\n<pre><code>l = [i**2 for i in range(10)]\n# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\nl = [i**2 for i in range(10) if i%2 ==0]\n# [0, 4, 16, 36, 64]</code></pre><p>2、 字典生成器</p>\n<pre><code>list1 = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]\ndic = {i:list1[i] for i in range(len(list1))}\n# {0: &#39;A&#39;, 1: &#39;B&#39;, 2: &#39;C&#39;}</code></pre><p>3、 集合生成器（跟列表生成式类似）</p>\n<pre><code>set1 = {i for i in range(10)}</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>1、 单双引号的应用，即字符串中包含单引号时可以使用双引号进行包含，包含双引号时使用单引号进行包含，如下：</p>\n<pre><code>&quot;a&#39;s hhh&quot;\n&#39;a&quot;s hhh&#39;</code></pre><p>2、 字符串的一些基本操作（拼接、搜索、替换），其中<strong>替换操作必须要将str赋给一个新的变量</strong></p>\n<pre><code>str = str1 + str2    # 拼接字符串（直接使用 + 进行操作）\nlen(str) # 获取长度\nstr.find(string) # 返回搜索到的第一个index，没搜索到则返回-1\nstr = str.replace(&#39;A&#39;, &#39;B&#39;) # A替换B</code></pre><p>3、 格式化字符串（使用.format语句），使用{}占位符进行</p>\n<pre><code>&quot;{} {} gg&quot;.format(&quot;huangkai&quot;,&quot;is&quot;)\n# huangkai is gg\n\n# 带索引的格式化字符串\n&quot;{1} {0} gg&quot;.format(&quot;huangkai&quot;,&quot;is&quot;)\nis huangkai gg\n\n# f形式的格式化字符串\nstr1 = &#39;Curry&#39;\nstr2 = &#39;James&#39;\ncombi = f&#39;{str1} and {str2}, NBA stars&#39;\n\n# 使用别名\nstr3 = “gg {s1}， {s2}”。format(s1=str1, s2 str2)</code></pre><h3 id=\"列表（list）\"><a href=\"#列表（list）\" class=\"headerlink\" title=\"列表（list）\"></a>列表（list）</h3><p>列表在内存中按照顺序存储</p>\n<p>1、 列表反转与排序</p>\n<pre><code>list.reverse()    # 列表反转\nlist.sort() # 升序排列\nlist.sort(reverse=True) # 降序排列</code></pre><p>2、 列表常用操作</p>\n<pre><code>list.append(new_element) # 在列表末尾添加元素\nlist.insert(index, new_element) # 在指定的index处加入一个元素，其后元素全部后移\nlist.remove(element) # 删除值为element的元素\nlist.pop(index) # 删除索引值为index的元素，无index则删除最后一个元素\nlist.clear() # 清空列表</code></pre><p>4、 列表其他操作（区别于append）</p>\n<pre><code>list.extend([e1, e2]) # 将列表追加进list（区别于append）</code></pre><p>5、 <strong>列表的复制</strong>，想将一个列表赋值给另一个列表必须要使用.copy方法，否则修改其中一个表另一个也会变，如下：</p>\n<pre><code>l1 = [1,2,3,4]\nl2 = l1\nprint(id(l1))\nprint(id(l2))</code></pre><p>运行结果可以发现l1与l2指向了同一块内存，因此改变l1，l2也会相应改变。而copy()方法会重新创建一个空列表再将原列表的元素放进去。</p>\n<pre><code>l2 = list.copy()</code></pre><p>6、列表元素直接的对应操作，以相加为例，使用列表生成器如下。其中zip函数为将a、b两个列表中的元素一一组合。</p>\n<pre><code>a = [1,2,3,4]\nb = [1,2,3,4]\nc = [i+j for i, j in zip(a,b)]\n########################################\n[2, 4, 6, 8]</code></pre><h3 id=\"字典（dict）\"><a href=\"#字典（dict）\" class=\"headerlink\" title=\"字典（dict）\"></a>字典（dict）</h3><p>键值对（key-value），可修改。Python中的散列值函数<code>hash(data)</code>，字典存储根据其哈希值存储。</p>\n<p>1、 创建</p>\n<pre><code>dic = dict.fromkeys([&#39;school number&#39;, &#39;bala1&#39;, &#39;bala2&#39;])\nprint(dic)\n\n# 输出\n{&#39;school number&#39;: None, &#39;bala1&#39;: None, &#39;bala2&#39;: None}</code></pre><p>2、 取值</p>\n<pre><code># 直接使用key获取value\ndic[key]\n# 使用get方法（可以为不存在的key赋默认值）\ndic.get(key)</code></pre><p>3、 遍历字典</p>\n<pre><code># 方案1\nfor key in dic:\n    v = dic[key]\n\n# 方案2（返回每一个键值对）\nfor key,value in dic.items():\n</code></pre><p>4、 字典常用操作</p>\n<pre><code>dic.update(k1 = new_value1, k2 = new_value2) # 对多个键值进行更新或新增\ndic,pop(key) # 删除键值为key\ndic.popitem() # 删除最后一个键值对，并返回该键值对的tuple\ndic.clear() # 清空字典\ndic.setdefault(&#39;key&#39;, &#39;value&#39;) # 设置默认值（如果没有该键值的话）\n\n# 修改字典时下面三个值都会变\ndic.keys()    # 返回所有键\ndic.values() # 返回所有值\ndic.items() # 返回所有键值对\n\n# 格式化字符串，使用format_map\ndic = {&#39;name&#39;:&#39;Curry&#39;,&#39;gg&#39;:&#39;no&#39;}\ns = &quot;姓名:{name},瞎写:{gg}&quot;.format_map(dic)\nprint(s)\n# 输出\n姓名:Curry,瞎写:no</code></pre><h3 id=\"元组（tuple）\"><a href=\"#元组（tuple）\" class=\"headerlink\" title=\"元组（tuple）\"></a>元组（tuple）</h3><p>创建后不允许修改，当列表等可变对象为元组元素时，可以修改该元素的值。</p>\n<h3 id=\"集合（Set）\"><a href=\"#集合（Set）\" class=\"headerlink\" title=\"集合（Set）\"></a>集合（Set）</h3><p>元素是无序的、可变的、元素不能重复，在内存中是分散保存的（存储方式与字典相似），缺点，浪费内存空间</p>\n<p>1、 初始化</p>\n<pre><code># 空集合的创建\n# 不能使用s = {}，这样默认创建的是字典\nset1 = set()</code></pre><p>2、 集合的常用运算</p>\n<pre><code>set1 = {1,2,3,4,5}\nset2 = {4,5,6,7,8}\n\n# 交集运算\nset3 = set1.intersection(set2)    # 产生新集合\n# intersection_update为更新原有集合\nprint(set3)\n# 输出\n{4, 5}\n\n# 并集运算\nset3 = set1.union(set2)\nprint(set3)\n# 输出\n{1, 2, 3, 4, 5, 6, 7, 8}\n\n# 差集运算\nset3 = set1.difference(set2) # 得到set1中有，set2中没有的元素 \nprint(set3)\n# 输出\n{1, 2, 3}\n\n# 双向差集\nset3 = set1.symmetric_difference(set2)\nprint(set3)\n# 输出\n{1, 2, 3, 6, 7, 8}</code></pre><p>3、 集合间的关系操作</p>\n<pre><code># 判断两个集合的元素是否完全相同\ns1 = {1,2,3,4,5}\ns2 = {5,4,3,2,1}\nprint(s1 == s2)\n# 输出\nTrue</code></pre><pre><code># 子集判断\n# 父集判断，同理。 .issuperset()\ns1 = {1,2,3,4,5}\ns2 = {5,4,3,2}\nprint(s2.issubset(s1))\n# 输出\nTrue</code></pre><pre><code># 判断两个集合是否存在重复元素\n# 返回False代表存在重复元素\ns1 = {1,2,3,4,5}\ns2 = {5,4,3,2}\nprint(s1.isdisjoint(s2))\n# 输出\nFalse</code></pre><pre><code># 新增数据\nset.add(element) # 一次添加一个元素\nset.update(列表或元组) # 一次添加多个元素\n# 删除元素\nset.remove(element) # 删除不存在的元素会报错\nset.discard(element) # 删除不存在的元素会直接忽略</code></pre><h3 id=\"常用的转换函数\"><a href=\"#常用的转换函数\" class=\"headerlink\" title=\"常用的转换函数\"></a>常用的转换函数</h3><pre><code>list() # 转换为列表\ntuple() # 转换为元组\njoin(), str() # 转换为字符串</code></pre><h3 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h3><p>1、 <strong>列表生成器</strong>，常用形式如下</p>\n<p>[数据 循环语句 循环或判断语句]</p>\n<pre><code>l = [i**2 for i in range(10)]\n# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\nl = [i**2 for i in range(10) if i%2 ==0]\n# [0, 4, 16, 36, 64]</code></pre><p>2、 字典生成器</p>\n<pre><code>list1 = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]\ndic = {i:list1[i] for i in range(len(list1))}\n# {0: &#39;A&#39;, 1: &#39;B&#39;, 2: &#39;C&#39;}</code></pre><p>3、 集合生成器（跟列表生成式类似）</p>\n<pre><code>set1 = {i for i in range(10)}</code></pre>"},{"title":"2、Python函数相关内容","date":"2020-05-08T07:20:53.000Z","fileName":"python2","_content":"\n### Python函数的基本特性\n\n#### Python函数为对象\n\nPython中的函数都是对象，这也使得其具备了一些对象的通用特性。\n\n* 可作为**值传递**，赋值给另一个对象；\n\n* 可以作为元素添加到集合对象中；\n\n* 可以作为参数传递给其他函数；\n\n* 可以作为函数的返回值。\n\n1、函数赋值给变量，通过变量可以调用。且传递方法为**值传递**，这也就意味着即使删除函数f1，temp仍然能够正常运行。\n\n```\ndef f1(str):\n  return len(str)\ntemp=f1\t# 函数赋值给对象\ndel f1\t# 删除函数\nprint temp('hello')\t# 仍然正常调用\n```\n\n2、作为元素添加进入容器。\n\n```\ndef f2(str1,str2):\n   return str1+str2\na=[]\na.append(f1)\na.append(f2)\nprint a[0]('hello')\nprint a[1]('hello','world')\n```\n\n3、作为函数参数\n\n```\ndef func(f,str):\n  return f(str)\nprint func(f1,'hello')\n```\n\n4、作为函数返回值\n\n```\ndef mutiply(x,y):\n  reutrn x*y\ndef sub(x,y):return x-y\ndef func2(i):if i==1: return mutiplyelse:return sub\ntemp=func2(2)\nprint temp(2,4)\n```\n\n**Python函数是最高级别的对象，而不仅仅为一小段代码**。一个函数是一个被其自己定义和执行的对象，参数是一种“成员数据”，所以它们的状态和其他对象一样，会随着每一次调用而改变。\n\n#### 嵌套与闭包\n\n1、函数的嵌套\n\n```\ndef fun1():\n    def fun2():\n        def fun3():\n            print(\"Hello world!\")\n        return fun3\n    return fun2\nfun1()()()\n##########################################\nHello world!\n```\n\n2、函数的闭包\n\n**闭包函数就是函数可以读取到与自己不是一个作用域的局部变量**\n\n1. 必须有一个内嵌函数\n2. 内嵌函数必须引用外部函数中的变量\n3. 外部函数的返回值必须是内嵌函数\n\n```\ndef fun1(x):\n    def fun2(y):\n        print(x+y)\n    return fun2\nfun1(2)(3)\n#############################\n5\n```\n\n**装饰器，匿名函数，map函数等都是函数的变体，都是通过这些基本特性来实现的**\n\n**装饰器**：使用函数的嵌套，外层函数传进来的参数为一个函数对象，里层函数对传进来的函数进行加工处理后再返回处理的函数\n\n\n\n### 函数的一些传参方法\n\n#### 关键字传参\n\n可以增强代码可读性，每次传参都需要指定形参名，以下就是关键字传参。\n\n```\ndef func(a,b):\n\tpass\nfunc(a=1,b=2)\n```\n\n\n\n**Tip：** * 代表之后所有参数传参时必须使用关键字传参（混合形式传参）\n\n```\ndef func(p1,*,p2,p3):\n    print(p2+p3)\nfunc(1,p2=2,p3=3)\n\n# 输出\n5\n```\n\n以下代码中p2、p3不使用关键字传参即会报错。\n\n```\ndef func(p1,*,p2,p3):\n    print(p2+p3)\nfunc(1,2,3)\n\n# 输出（报错）\nTypeError                                 Traceback (most recent call last)\n<ipython-input-17-83e9b0e5315e> in <module>\n      1 def func(p1,*,p2,p3):\n      2     print(p2+p3)\n----> 3 func(1,2,3)\n\nTypeError: func() takes 1 positional argument but 3 were given\n```\n\n#### 列表传参\n\n将列表传入函数，只要在列表名前面加上*即可传入\n\n```\ndef func(a, b):\n    print(a+b)\nl = [1, 2]\nfunc(*l)\n\n# 输出\n3\n```\n\n#### 字典传参\n\n将字典你传入函数，只需要在字典名前面加上**即可，这种方法可以先将参数写为json格式之后进行传入。\n\n```\ndef func(a,b,c):\n    print(a+b+c)\nparam = {\"a\":1,\"b\":2,\"c\":3}\nfunc(**param)\n\n# 输出\n6\n```\n\n#### 默认参数\n\n很好理解，在定义函数时指定该参数的值即可。\n\n```\n# 参数a默认为1\ndef func(a=1):\n\tpass\n```\n\n### 可变参数（重要特性）\n\n在定义函数时，不限定参数的个数，而使用*args和**kwargs表示。*args为元组，**kwargs为字典。\n\n*args将参数打包为tuple给函数体使用，实例如下：\n\n```\ndef func(a, *args):\n    print(a)\n    print(type(a))\n    print(args)\n    print(type(args))\nfunc('gg', 1, 2, 'gg3')\n\n######################################\ngg\n<class 'str'>\n(1, 2, 'gg3')\n<class 'tuple'>\n```\n\n**kwargs将参数打包为dict给函数使用，调用时实参为key=value的形式。\n\n```\ndef func(a, **kwargs):\n    print(a)\n    print(type(a))\n    print(kwargs)\n    print(type(kwargs))\nfunc('gg', b=1, c=1)\n\n############################################\ngg\n<class 'str'>\n{'b': 1, 'c': 1}\n<class 'dict'>\n```\n\n#### 参数组合\n\n当多种参数组合使用时，参数定义顺序为必选参数、默认参数、可变参数。\n\n\n\n### 高阶函数\n\n可以简单理解为调用函数的函数。\n\n#### `lambda`表达式\n\nlambda是python中的一种表达式，创建内嵌的简单**匿名函数**。可以避免取函数名\n\n```\nf = lambda i:i**2\nf(2)\n# 4\n```\n\n\n\n#### filter函数\n\nfilter(func, seq) \t返回seq中所有满足func结果为真的对象，可以简单理解为一个过滤器。\n\n```\n# 找到所有奇数\nl = range(10)\na = filter(lambda n: n%2!=0, l)\nprint(list(a))\n# [1, 3, 5, 7, 9]\n```\n\n\n\n#### map函数\n\nmap (func, seq) 返回对seq执行func后的值，可以简单理解为一个映射。\n\n```\n# 找到数的所有平方\nl = range(5)\na = map(lambda n: n**2, l)\nprint(list(a))\n# [0, 1, 4, 9, 16]\n```","source":"_posts/Python/语言基础/2、Python函数相关内容.md","raw":"---\ntitle: 2、Python函数相关内容\ndate: 2020-05-08 15:20:53\ntags:\n\t- python\ncategories:\n\t- Python\n\t- 语言基础\nfileName: python2\n---\n\n### Python函数的基本特性\n\n#### Python函数为对象\n\nPython中的函数都是对象，这也使得其具备了一些对象的通用特性。\n\n* 可作为**值传递**，赋值给另一个对象；\n\n* 可以作为元素添加到集合对象中；\n\n* 可以作为参数传递给其他函数；\n\n* 可以作为函数的返回值。\n\n1、函数赋值给变量，通过变量可以调用。且传递方法为**值传递**，这也就意味着即使删除函数f1，temp仍然能够正常运行。\n\n```\ndef f1(str):\n  return len(str)\ntemp=f1\t# 函数赋值给对象\ndel f1\t# 删除函数\nprint temp('hello')\t# 仍然正常调用\n```\n\n2、作为元素添加进入容器。\n\n```\ndef f2(str1,str2):\n   return str1+str2\na=[]\na.append(f1)\na.append(f2)\nprint a[0]('hello')\nprint a[1]('hello','world')\n```\n\n3、作为函数参数\n\n```\ndef func(f,str):\n  return f(str)\nprint func(f1,'hello')\n```\n\n4、作为函数返回值\n\n```\ndef mutiply(x,y):\n  reutrn x*y\ndef sub(x,y):return x-y\ndef func2(i):if i==1: return mutiplyelse:return sub\ntemp=func2(2)\nprint temp(2,4)\n```\n\n**Python函数是最高级别的对象，而不仅仅为一小段代码**。一个函数是一个被其自己定义和执行的对象，参数是一种“成员数据”，所以它们的状态和其他对象一样，会随着每一次调用而改变。\n\n#### 嵌套与闭包\n\n1、函数的嵌套\n\n```\ndef fun1():\n    def fun2():\n        def fun3():\n            print(\"Hello world!\")\n        return fun3\n    return fun2\nfun1()()()\n##########################################\nHello world!\n```\n\n2、函数的闭包\n\n**闭包函数就是函数可以读取到与自己不是一个作用域的局部变量**\n\n1. 必须有一个内嵌函数\n2. 内嵌函数必须引用外部函数中的变量\n3. 外部函数的返回值必须是内嵌函数\n\n```\ndef fun1(x):\n    def fun2(y):\n        print(x+y)\n    return fun2\nfun1(2)(3)\n#############################\n5\n```\n\n**装饰器，匿名函数，map函数等都是函数的变体，都是通过这些基本特性来实现的**\n\n**装饰器**：使用函数的嵌套，外层函数传进来的参数为一个函数对象，里层函数对传进来的函数进行加工处理后再返回处理的函数\n\n\n\n### 函数的一些传参方法\n\n#### 关键字传参\n\n可以增强代码可读性，每次传参都需要指定形参名，以下就是关键字传参。\n\n```\ndef func(a,b):\n\tpass\nfunc(a=1,b=2)\n```\n\n\n\n**Tip：** * 代表之后所有参数传参时必须使用关键字传参（混合形式传参）\n\n```\ndef func(p1,*,p2,p3):\n    print(p2+p3)\nfunc(1,p2=2,p3=3)\n\n# 输出\n5\n```\n\n以下代码中p2、p3不使用关键字传参即会报错。\n\n```\ndef func(p1,*,p2,p3):\n    print(p2+p3)\nfunc(1,2,3)\n\n# 输出（报错）\nTypeError                                 Traceback (most recent call last)\n<ipython-input-17-83e9b0e5315e> in <module>\n      1 def func(p1,*,p2,p3):\n      2     print(p2+p3)\n----> 3 func(1,2,3)\n\nTypeError: func() takes 1 positional argument but 3 were given\n```\n\n#### 列表传参\n\n将列表传入函数，只要在列表名前面加上*即可传入\n\n```\ndef func(a, b):\n    print(a+b)\nl = [1, 2]\nfunc(*l)\n\n# 输出\n3\n```\n\n#### 字典传参\n\n将字典你传入函数，只需要在字典名前面加上**即可，这种方法可以先将参数写为json格式之后进行传入。\n\n```\ndef func(a,b,c):\n    print(a+b+c)\nparam = {\"a\":1,\"b\":2,\"c\":3}\nfunc(**param)\n\n# 输出\n6\n```\n\n#### 默认参数\n\n很好理解，在定义函数时指定该参数的值即可。\n\n```\n# 参数a默认为1\ndef func(a=1):\n\tpass\n```\n\n### 可变参数（重要特性）\n\n在定义函数时，不限定参数的个数，而使用*args和**kwargs表示。*args为元组，**kwargs为字典。\n\n*args将参数打包为tuple给函数体使用，实例如下：\n\n```\ndef func(a, *args):\n    print(a)\n    print(type(a))\n    print(args)\n    print(type(args))\nfunc('gg', 1, 2, 'gg3')\n\n######################################\ngg\n<class 'str'>\n(1, 2, 'gg3')\n<class 'tuple'>\n```\n\n**kwargs将参数打包为dict给函数使用，调用时实参为key=value的形式。\n\n```\ndef func(a, **kwargs):\n    print(a)\n    print(type(a))\n    print(kwargs)\n    print(type(kwargs))\nfunc('gg', b=1, c=1)\n\n############################################\ngg\n<class 'str'>\n{'b': 1, 'c': 1}\n<class 'dict'>\n```\n\n#### 参数组合\n\n当多种参数组合使用时，参数定义顺序为必选参数、默认参数、可变参数。\n\n\n\n### 高阶函数\n\n可以简单理解为调用函数的函数。\n\n#### `lambda`表达式\n\nlambda是python中的一种表达式，创建内嵌的简单**匿名函数**。可以避免取函数名\n\n```\nf = lambda i:i**2\nf(2)\n# 4\n```\n\n\n\n#### filter函数\n\nfilter(func, seq) \t返回seq中所有满足func结果为真的对象，可以简单理解为一个过滤器。\n\n```\n# 找到所有奇数\nl = range(10)\na = filter(lambda n: n%2!=0, l)\nprint(list(a))\n# [1, 3, 5, 7, 9]\n```\n\n\n\n#### map函数\n\nmap (func, seq) 返回对seq执行func后的值，可以简单理解为一个映射。\n\n```\n# 找到数的所有平方\nl = range(5)\na = map(lambda n: n**2, l)\nprint(list(a))\n# [0, 1, 4, 9, 16]\n```","slug":"Python/语言基础/2、Python函数相关内容","published":1,"updated":"2020-07-16T16:03:57.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8t1000rl4jscw0v11l0","content":"<h3 id=\"Python函数的基本特性\"><a href=\"#Python函数的基本特性\" class=\"headerlink\" title=\"Python函数的基本特性\"></a>Python函数的基本特性</h3><h4 id=\"Python函数为对象\"><a href=\"#Python函数为对象\" class=\"headerlink\" title=\"Python函数为对象\"></a>Python函数为对象</h4><p>Python中的函数都是对象，这也使得其具备了一些对象的通用特性。</p>\n<ul>\n<li><p>可作为<strong>值传递</strong>，赋值给另一个对象；</p>\n</li>\n<li><p>可以作为元素添加到集合对象中；</p>\n</li>\n<li><p>可以作为参数传递给其他函数；</p>\n</li>\n<li><p>可以作为函数的返回值。</p>\n</li>\n</ul>\n<p>1、函数赋值给变量，通过变量可以调用。且传递方法为<strong>值传递</strong>，这也就意味着即使删除函数f1，temp仍然能够正常运行。</p>\n<pre><code>def f1(str):\n  return len(str)\ntemp=f1    # 函数赋值给对象\ndel f1    # 删除函数\nprint temp(&#39;hello&#39;)    # 仍然正常调用</code></pre><p>2、作为元素添加进入容器。</p>\n<pre><code>def f2(str1,str2):\n   return str1+str2\na=[]\na.append(f1)\na.append(f2)\nprint a[0](&#39;hello&#39;)\nprint a[1](&#39;hello&#39;,&#39;world&#39;)</code></pre><p>3、作为函数参数</p>\n<pre><code>def func(f,str):\n  return f(str)\nprint func(f1,&#39;hello&#39;)</code></pre><p>4、作为函数返回值</p>\n<pre><code>def mutiply(x,y):\n  reutrn x*y\ndef sub(x,y):return x-y\ndef func2(i):if i==1: return mutiplyelse:return sub\ntemp=func2(2)\nprint temp(2,4)</code></pre><p><strong>Python函数是最高级别的对象，而不仅仅为一小段代码</strong>。一个函数是一个被其自己定义和执行的对象，参数是一种“成员数据”，所以它们的状态和其他对象一样，会随着每一次调用而改变。</p>\n<h4 id=\"嵌套与闭包\"><a href=\"#嵌套与闭包\" class=\"headerlink\" title=\"嵌套与闭包\"></a>嵌套与闭包</h4><p>1、函数的嵌套</p>\n<pre><code>def fun1():\n    def fun2():\n        def fun3():\n            print(&quot;Hello world!&quot;)\n        return fun3\n    return fun2\nfun1()()()\n##########################################\nHello world!</code></pre><p>2、函数的闭包</p>\n<p><strong>闭包函数就是函数可以读取到与自己不是一个作用域的局部变量</strong></p>\n<ol>\n<li>必须有一个内嵌函数</li>\n<li>内嵌函数必须引用外部函数中的变量</li>\n<li>外部函数的返回值必须是内嵌函数</li>\n</ol>\n<pre><code>def fun1(x):\n    def fun2(y):\n        print(x+y)\n    return fun2\nfun1(2)(3)\n#############################\n5</code></pre><p><strong>装饰器，匿名函数，map函数等都是函数的变体，都是通过这些基本特性来实现的</strong></p>\n<p><strong>装饰器</strong>：使用函数的嵌套，外层函数传进来的参数为一个函数对象，里层函数对传进来的函数进行加工处理后再返回处理的函数</p>\n<h3 id=\"函数的一些传参方法\"><a href=\"#函数的一些传参方法\" class=\"headerlink\" title=\"函数的一些传参方法\"></a>函数的一些传参方法</h3><h4 id=\"关键字传参\"><a href=\"#关键字传参\" class=\"headerlink\" title=\"关键字传参\"></a>关键字传参</h4><p>可以增强代码可读性，每次传参都需要指定形参名，以下就是关键字传参。</p>\n<pre><code>def func(a,b):\n    pass\nfunc(a=1,b=2)</code></pre><p><strong>Tip：</strong> * 代表之后所有参数传参时必须使用关键字传参（混合形式传参）</p>\n<pre><code>def func(p1,*,p2,p3):\n    print(p2+p3)\nfunc(1,p2=2,p3=3)\n\n# 输出\n5</code></pre><p>以下代码中p2、p3不使用关键字传参即会报错。</p>\n<pre><code>def func(p1,*,p2,p3):\n    print(p2+p3)\nfunc(1,2,3)\n\n# 输出（报错）\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-17-83e9b0e5315e&gt; in &lt;module&gt;\n      1 def func(p1,*,p2,p3):\n      2     print(p2+p3)\n----&gt; 3 func(1,2,3)\n\nTypeError: func() takes 1 positional argument but 3 were given</code></pre><h4 id=\"列表传参\"><a href=\"#列表传参\" class=\"headerlink\" title=\"列表传参\"></a>列表传参</h4><p>将列表传入函数，只要在列表名前面加上*即可传入</p>\n<pre><code>def func(a, b):\n    print(a+b)\nl = [1, 2]\nfunc(*l)\n\n# 输出\n3</code></pre><h4 id=\"字典传参\"><a href=\"#字典传参\" class=\"headerlink\" title=\"字典传参\"></a>字典传参</h4><p>将字典你传入函数，只需要在字典名前面加上**即可，这种方法可以先将参数写为json格式之后进行传入。</p>\n<pre><code>def func(a,b,c):\n    print(a+b+c)\nparam = {&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3}\nfunc(**param)\n\n# 输出\n6</code></pre><h4 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h4><p>很好理解，在定义函数时指定该参数的值即可。</p>\n<pre><code># 参数a默认为1\ndef func(a=1):\n    pass</code></pre><h3 id=\"可变参数（重要特性）\"><a href=\"#可变参数（重要特性）\" class=\"headerlink\" title=\"可变参数（重要特性）\"></a>可变参数（重要特性）</h3><p>在定义函数时，不限定参数的个数，而使用<em>args和*</em>kwargs表示。<em>args为元组，*</em>kwargs为字典。</p>\n<p>*args将参数打包为tuple给函数体使用，实例如下：</p>\n<pre><code>def func(a, *args):\n    print(a)\n    print(type(a))\n    print(args)\n    print(type(args))\nfunc(&#39;gg&#39;, 1, 2, &#39;gg3&#39;)\n\n######################################\ngg\n&lt;class &#39;str&#39;&gt;\n(1, 2, &#39;gg3&#39;)\n&lt;class &#39;tuple&#39;&gt;</code></pre><p>**kwargs将参数打包为dict给函数使用，调用时实参为key=value的形式。</p>\n<pre><code>def func(a, **kwargs):\n    print(a)\n    print(type(a))\n    print(kwargs)\n    print(type(kwargs))\nfunc(&#39;gg&#39;, b=1, c=1)\n\n############################################\ngg\n&lt;class &#39;str&#39;&gt;\n{&#39;b&#39;: 1, &#39;c&#39;: 1}\n&lt;class &#39;dict&#39;&gt;</code></pre><h4 id=\"参数组合\"><a href=\"#参数组合\" class=\"headerlink\" title=\"参数组合\"></a>参数组合</h4><p>当多种参数组合使用时，参数定义顺序为必选参数、默认参数、可变参数。</p>\n<h3 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h3><p>可以简单理解为调用函数的函数。</p>\n<h4 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a><code>lambda</code>表达式</h4><p>lambda是python中的一种表达式，创建内嵌的简单<strong>匿名函数</strong>。可以避免取函数名</p>\n<pre><code>f = lambda i:i**2\nf(2)\n# 4</code></pre><h4 id=\"filter函数\"><a href=\"#filter函数\" class=\"headerlink\" title=\"filter函数\"></a>filter函数</h4><p>filter(func, seq)     返回seq中所有满足func结果为真的对象，可以简单理解为一个过滤器。</p>\n<pre><code># 找到所有奇数\nl = range(10)\na = filter(lambda n: n%2!=0, l)\nprint(list(a))\n# [1, 3, 5, 7, 9]</code></pre><h4 id=\"map函数\"><a href=\"#map函数\" class=\"headerlink\" title=\"map函数\"></a>map函数</h4><p>map (func, seq) 返回对seq执行func后的值，可以简单理解为一个映射。</p>\n<pre><code># 找到数的所有平方\nl = range(5)\na = map(lambda n: n**2, l)\nprint(list(a))\n# [0, 1, 4, 9, 16]</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Python函数的基本特性\"><a href=\"#Python函数的基本特性\" class=\"headerlink\" title=\"Python函数的基本特性\"></a>Python函数的基本特性</h3><h4 id=\"Python函数为对象\"><a href=\"#Python函数为对象\" class=\"headerlink\" title=\"Python函数为对象\"></a>Python函数为对象</h4><p>Python中的函数都是对象，这也使得其具备了一些对象的通用特性。</p>\n<ul>\n<li><p>可作为<strong>值传递</strong>，赋值给另一个对象；</p>\n</li>\n<li><p>可以作为元素添加到集合对象中；</p>\n</li>\n<li><p>可以作为参数传递给其他函数；</p>\n</li>\n<li><p>可以作为函数的返回值。</p>\n</li>\n</ul>\n<p>1、函数赋值给变量，通过变量可以调用。且传递方法为<strong>值传递</strong>，这也就意味着即使删除函数f1，temp仍然能够正常运行。</p>\n<pre><code>def f1(str):\n  return len(str)\ntemp=f1    # 函数赋值给对象\ndel f1    # 删除函数\nprint temp(&#39;hello&#39;)    # 仍然正常调用</code></pre><p>2、作为元素添加进入容器。</p>\n<pre><code>def f2(str1,str2):\n   return str1+str2\na=[]\na.append(f1)\na.append(f2)\nprint a[0](&#39;hello&#39;)\nprint a[1](&#39;hello&#39;,&#39;world&#39;)</code></pre><p>3、作为函数参数</p>\n<pre><code>def func(f,str):\n  return f(str)\nprint func(f1,&#39;hello&#39;)</code></pre><p>4、作为函数返回值</p>\n<pre><code>def mutiply(x,y):\n  reutrn x*y\ndef sub(x,y):return x-y\ndef func2(i):if i==1: return mutiplyelse:return sub\ntemp=func2(2)\nprint temp(2,4)</code></pre><p><strong>Python函数是最高级别的对象，而不仅仅为一小段代码</strong>。一个函数是一个被其自己定义和执行的对象，参数是一种“成员数据”，所以它们的状态和其他对象一样，会随着每一次调用而改变。</p>\n<h4 id=\"嵌套与闭包\"><a href=\"#嵌套与闭包\" class=\"headerlink\" title=\"嵌套与闭包\"></a>嵌套与闭包</h4><p>1、函数的嵌套</p>\n<pre><code>def fun1():\n    def fun2():\n        def fun3():\n            print(&quot;Hello world!&quot;)\n        return fun3\n    return fun2\nfun1()()()\n##########################################\nHello world!</code></pre><p>2、函数的闭包</p>\n<p><strong>闭包函数就是函数可以读取到与自己不是一个作用域的局部变量</strong></p>\n<ol>\n<li>必须有一个内嵌函数</li>\n<li>内嵌函数必须引用外部函数中的变量</li>\n<li>外部函数的返回值必须是内嵌函数</li>\n</ol>\n<pre><code>def fun1(x):\n    def fun2(y):\n        print(x+y)\n    return fun2\nfun1(2)(3)\n#############################\n5</code></pre><p><strong>装饰器，匿名函数，map函数等都是函数的变体，都是通过这些基本特性来实现的</strong></p>\n<p><strong>装饰器</strong>：使用函数的嵌套，外层函数传进来的参数为一个函数对象，里层函数对传进来的函数进行加工处理后再返回处理的函数</p>\n<h3 id=\"函数的一些传参方法\"><a href=\"#函数的一些传参方法\" class=\"headerlink\" title=\"函数的一些传参方法\"></a>函数的一些传参方法</h3><h4 id=\"关键字传参\"><a href=\"#关键字传参\" class=\"headerlink\" title=\"关键字传参\"></a>关键字传参</h4><p>可以增强代码可读性，每次传参都需要指定形参名，以下就是关键字传参。</p>\n<pre><code>def func(a,b):\n    pass\nfunc(a=1,b=2)</code></pre><p><strong>Tip：</strong> * 代表之后所有参数传参时必须使用关键字传参（混合形式传参）</p>\n<pre><code>def func(p1,*,p2,p3):\n    print(p2+p3)\nfunc(1,p2=2,p3=3)\n\n# 输出\n5</code></pre><p>以下代码中p2、p3不使用关键字传参即会报错。</p>\n<pre><code>def func(p1,*,p2,p3):\n    print(p2+p3)\nfunc(1,2,3)\n\n# 输出（报错）\nTypeError                                 Traceback (most recent call last)\n&lt;ipython-input-17-83e9b0e5315e&gt; in &lt;module&gt;\n      1 def func(p1,*,p2,p3):\n      2     print(p2+p3)\n----&gt; 3 func(1,2,3)\n\nTypeError: func() takes 1 positional argument but 3 were given</code></pre><h4 id=\"列表传参\"><a href=\"#列表传参\" class=\"headerlink\" title=\"列表传参\"></a>列表传参</h4><p>将列表传入函数，只要在列表名前面加上*即可传入</p>\n<pre><code>def func(a, b):\n    print(a+b)\nl = [1, 2]\nfunc(*l)\n\n# 输出\n3</code></pre><h4 id=\"字典传参\"><a href=\"#字典传参\" class=\"headerlink\" title=\"字典传参\"></a>字典传参</h4><p>将字典你传入函数，只需要在字典名前面加上**即可，这种方法可以先将参数写为json格式之后进行传入。</p>\n<pre><code>def func(a,b,c):\n    print(a+b+c)\nparam = {&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3}\nfunc(**param)\n\n# 输出\n6</code></pre><h4 id=\"默认参数\"><a href=\"#默认参数\" class=\"headerlink\" title=\"默认参数\"></a>默认参数</h4><p>很好理解，在定义函数时指定该参数的值即可。</p>\n<pre><code># 参数a默认为1\ndef func(a=1):\n    pass</code></pre><h3 id=\"可变参数（重要特性）\"><a href=\"#可变参数（重要特性）\" class=\"headerlink\" title=\"可变参数（重要特性）\"></a>可变参数（重要特性）</h3><p>在定义函数时，不限定参数的个数，而使用<em>args和*</em>kwargs表示。<em>args为元组，*</em>kwargs为字典。</p>\n<p>*args将参数打包为tuple给函数体使用，实例如下：</p>\n<pre><code>def func(a, *args):\n    print(a)\n    print(type(a))\n    print(args)\n    print(type(args))\nfunc(&#39;gg&#39;, 1, 2, &#39;gg3&#39;)\n\n######################################\ngg\n&lt;class &#39;str&#39;&gt;\n(1, 2, &#39;gg3&#39;)\n&lt;class &#39;tuple&#39;&gt;</code></pre><p>**kwargs将参数打包为dict给函数使用，调用时实参为key=value的形式。</p>\n<pre><code>def func(a, **kwargs):\n    print(a)\n    print(type(a))\n    print(kwargs)\n    print(type(kwargs))\nfunc(&#39;gg&#39;, b=1, c=1)\n\n############################################\ngg\n&lt;class &#39;str&#39;&gt;\n{&#39;b&#39;: 1, &#39;c&#39;: 1}\n&lt;class &#39;dict&#39;&gt;</code></pre><h4 id=\"参数组合\"><a href=\"#参数组合\" class=\"headerlink\" title=\"参数组合\"></a>参数组合</h4><p>当多种参数组合使用时，参数定义顺序为必选参数、默认参数、可变参数。</p>\n<h3 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h3><p>可以简单理解为调用函数的函数。</p>\n<h4 id=\"lambda表达式\"><a href=\"#lambda表达式\" class=\"headerlink\" title=\"lambda表达式\"></a><code>lambda</code>表达式</h4><p>lambda是python中的一种表达式，创建内嵌的简单<strong>匿名函数</strong>。可以避免取函数名</p>\n<pre><code>f = lambda i:i**2\nf(2)\n# 4</code></pre><h4 id=\"filter函数\"><a href=\"#filter函数\" class=\"headerlink\" title=\"filter函数\"></a>filter函数</h4><p>filter(func, seq)     返回seq中所有满足func结果为真的对象，可以简单理解为一个过滤器。</p>\n<pre><code># 找到所有奇数\nl = range(10)\na = filter(lambda n: n%2!=0, l)\nprint(list(a))\n# [1, 3, 5, 7, 9]</code></pre><h4 id=\"map函数\"><a href=\"#map函数\" class=\"headerlink\" title=\"map函数\"></a>map函数</h4><p>map (func, seq) 返回对seq执行func后的值，可以简单理解为一个映射。</p>\n<pre><code># 找到数的所有平方\nl = range(5)\na = map(lambda n: n**2, l)\nprint(list(a))\n# [0, 1, 4, 9, 16]</code></pre>"},{"title":"4、Python模块与文件读写","date":"2020-05-10T13:03:43.000Z","fileName":"python4","_content":"\n## 模块与包\n\n### 导入模块时Python的操作\n\n当程序导入一个模块时，Python解析器对模块位置的搜索顺序为：\n\n1. 当前目录\n2. 若当前目录搜索不到，Python则搜索在shell变量PYTHONPATH下的每个目录。\n3. 若都找不到，Python会察看默认路径。UNIX下，默认路径一为/usr/local/lib/python/。\n\n模块搜索路径存储在 system 模块的**sys.path** 变量中。变量里包含当前目录、PYTHONPATH和由安装过程决定的默认目录。\n\n\n\n### 模块常用函数\n\n1、**dir()——列出对象的所有属性和方法**。dir() 函数返回一个排好序的字符串列表，内容是一个模块里定义过的名字。返回的列表容纳了在一个模块里定义的所有**模块**，**变量**和**函数**。\n\n2、**help()——查看类、方法的帮助信息**\n\n3、**\\__name__ ——模块的名称**\n\n4、\\__file__ ——文件全路径\n\n\n\n## 文件读写\n\n### open函数及其他基本操作\n\nPython使用**open()**打开文件，并返回文件的一个句柄。具体的参数为**文件句柄 = open('文件路径',打开模式, 编码方式)**。其中编码方式encoding如果没有指定，将采用系统自带的编码方式。\n\n```\nf = open('aa.txt')\nprint(f)\nf.close()\n####################################################\n<_io.TextIOWrapper name='aa.txt' mode='r' encoding='cp936'>\n```\n\n由以上输出可以看到，没指定打开模式时文件默认为只读模式（r），这时使用写入操作就会出错，常用的文件打开方式主要有以下几个。\n\n1、**r**，只读的方式打开（文件必须存在，若文件不存在会抛出异常）。文件以什么编码写就以什么编码打开。\n\n2、**w**，只写模式（文件不可读，若文件不存在，则创建一个新的文件，如果文件存在，则会清空里面的内容）\n\n3、**a**，只追加写的模式 （文件不可读，不存在则创建新的文件，文件存在的话，可在后面追加内容）\n\n4、**b**，对于非文本的文件，使用b的模式。'b'表示以字节的方式进行操作 如：rb,wb,ab 分别对应以上内容，如果以b的方式打开，读取到的内容是字节类型\n\n```\n# aa.txt文件中为一行字符串“hello world!”\nf = open('aa.txt', mode='rb')\nprint(f.read())\nf.close()\n####################################\nb'hello world!'\n```\n\n5、**’+‘模式**，r+: 读写模式  w+:写读模式  a+：写读模式。在 **r+** 模式下，应该先读，后写，如果先写，后读，同样的道理，光标移动到了文件末尾，将读取不到内容。\n\n同时使用**open**打开了一个文件操作完成后必须进行关闭，关闭文件使用**close()**。由于文件操作的这一性质，可以使用**with**关键字进行操作，如下：\n\n**with 上下文管理器（到达语句末尾，将自动关闭文件）**\n\n```\nwith open(\"*.txt\") as f\n\tpass\n```\n\n\n\n### 与文件读写相关的一些功能函数\n\n1、读取文件的操作\n\n```\n# 读取文件，可以输入读取几个字符\nread()\n# 读取一行数据，也可以读取参数\nreadline()\n# 读取所有行，并返回列表，之后可以通过对列表进行遍历得到数据\nreadlines()\n```\n\n2、写入文件的操作\n\n```\n# 向文件中写入内容\nwrite()\n# 输入一个列表，将列表内容分别写入\nwirtelines([])\n```\n\n3、其他操作（文件定位操作）\n\n**tell()**方法告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。\n\n**seek(offset [,from])**方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。","source":"_posts/Python/语言基础/4、Python模块与文件读写.md","raw":"---\ntitle: 4、Python模块与文件读写\ndate: 2020-05-10 21:03:43\ntags:\ncategories:\n\t- Python\n\t- 语言基础\nfileName: python4\n---\n\n## 模块与包\n\n### 导入模块时Python的操作\n\n当程序导入一个模块时，Python解析器对模块位置的搜索顺序为：\n\n1. 当前目录\n2. 若当前目录搜索不到，Python则搜索在shell变量PYTHONPATH下的每个目录。\n3. 若都找不到，Python会察看默认路径。UNIX下，默认路径一为/usr/local/lib/python/。\n\n模块搜索路径存储在 system 模块的**sys.path** 变量中。变量里包含当前目录、PYTHONPATH和由安装过程决定的默认目录。\n\n\n\n### 模块常用函数\n\n1、**dir()——列出对象的所有属性和方法**。dir() 函数返回一个排好序的字符串列表，内容是一个模块里定义过的名字。返回的列表容纳了在一个模块里定义的所有**模块**，**变量**和**函数**。\n\n2、**help()——查看类、方法的帮助信息**\n\n3、**\\__name__ ——模块的名称**\n\n4、\\__file__ ——文件全路径\n\n\n\n## 文件读写\n\n### open函数及其他基本操作\n\nPython使用**open()**打开文件，并返回文件的一个句柄。具体的参数为**文件句柄 = open('文件路径',打开模式, 编码方式)**。其中编码方式encoding如果没有指定，将采用系统自带的编码方式。\n\n```\nf = open('aa.txt')\nprint(f)\nf.close()\n####################################################\n<_io.TextIOWrapper name='aa.txt' mode='r' encoding='cp936'>\n```\n\n由以上输出可以看到，没指定打开模式时文件默认为只读模式（r），这时使用写入操作就会出错，常用的文件打开方式主要有以下几个。\n\n1、**r**，只读的方式打开（文件必须存在，若文件不存在会抛出异常）。文件以什么编码写就以什么编码打开。\n\n2、**w**，只写模式（文件不可读，若文件不存在，则创建一个新的文件，如果文件存在，则会清空里面的内容）\n\n3、**a**，只追加写的模式 （文件不可读，不存在则创建新的文件，文件存在的话，可在后面追加内容）\n\n4、**b**，对于非文本的文件，使用b的模式。'b'表示以字节的方式进行操作 如：rb,wb,ab 分别对应以上内容，如果以b的方式打开，读取到的内容是字节类型\n\n```\n# aa.txt文件中为一行字符串“hello world!”\nf = open('aa.txt', mode='rb')\nprint(f.read())\nf.close()\n####################################\nb'hello world!'\n```\n\n5、**’+‘模式**，r+: 读写模式  w+:写读模式  a+：写读模式。在 **r+** 模式下，应该先读，后写，如果先写，后读，同样的道理，光标移动到了文件末尾，将读取不到内容。\n\n同时使用**open**打开了一个文件操作完成后必须进行关闭，关闭文件使用**close()**。由于文件操作的这一性质，可以使用**with**关键字进行操作，如下：\n\n**with 上下文管理器（到达语句末尾，将自动关闭文件）**\n\n```\nwith open(\"*.txt\") as f\n\tpass\n```\n\n\n\n### 与文件读写相关的一些功能函数\n\n1、读取文件的操作\n\n```\n# 读取文件，可以输入读取几个字符\nread()\n# 读取一行数据，也可以读取参数\nreadline()\n# 读取所有行，并返回列表，之后可以通过对列表进行遍历得到数据\nreadlines()\n```\n\n2、写入文件的操作\n\n```\n# 向文件中写入内容\nwrite()\n# 输入一个列表，将列表内容分别写入\nwirtelines([])\n```\n\n3、其他操作（文件定位操作）\n\n**tell()**方法告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。\n\n**seek(offset [,from])**方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。","slug":"Python/语言基础/4、Python模块与文件读写","published":1,"updated":"2020-07-16T16:04:09.790Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8t5000vl4jsflq20cno","content":"<h2 id=\"模块与包\"><a href=\"#模块与包\" class=\"headerlink\" title=\"模块与包\"></a>模块与包</h2><h3 id=\"导入模块时Python的操作\"><a href=\"#导入模块时Python的操作\" class=\"headerlink\" title=\"导入模块时Python的操作\"></a>导入模块时Python的操作</h3><p>当程序导入一个模块时，Python解析器对模块位置的搜索顺序为：</p>\n<ol>\n<li>当前目录</li>\n<li>若当前目录搜索不到，Python则搜索在shell变量PYTHONPATH下的每个目录。</li>\n<li>若都找不到，Python会察看默认路径。UNIX下，默认路径一为/usr/local/lib/python/。</li>\n</ol>\n<p>模块搜索路径存储在 system 模块的<strong>sys.path</strong> 变量中。变量里包含当前目录、PYTHONPATH和由安装过程决定的默认目录。</p>\n<h3 id=\"模块常用函数\"><a href=\"#模块常用函数\" class=\"headerlink\" title=\"模块常用函数\"></a>模块常用函数</h3><p>1、<strong>dir()——列出对象的所有属性和方法</strong>。dir() 函数返回一个排好序的字符串列表，内容是一个模块里定义过的名字。返回的列表容纳了在一个模块里定义的所有<strong>模块</strong>，<strong>变量</strong>和<strong>函数</strong>。</p>\n<p>2、<strong>help()——查看类、方法的帮助信息</strong></p>\n<p>3、<strong>_<em>name_</em> ——模块的名称</strong></p>\n<p>4、_<em>file_</em> ——文件全路径</p>\n<h2 id=\"文件读写\"><a href=\"#文件读写\" class=\"headerlink\" title=\"文件读写\"></a>文件读写</h2><h3 id=\"open函数及其他基本操作\"><a href=\"#open函数及其他基本操作\" class=\"headerlink\" title=\"open函数及其他基本操作\"></a>open函数及其他基本操作</h3><p>Python使用<strong>open()</strong>打开文件，并返回文件的一个句柄。具体的参数为<strong>文件句柄 = open(‘文件路径’,打开模式, 编码方式)</strong>。其中编码方式encoding如果没有指定，将采用系统自带的编码方式。</p>\n<pre><code>f = open(&#39;aa.txt&#39;)\nprint(f)\nf.close()\n####################################################\n&lt;_io.TextIOWrapper name=&#39;aa.txt&#39; mode=&#39;r&#39; encoding=&#39;cp936&#39;&gt;</code></pre><p>由以上输出可以看到，没指定打开模式时文件默认为只读模式（r），这时使用写入操作就会出错，常用的文件打开方式主要有以下几个。</p>\n<p>1、<strong>r</strong>，只读的方式打开（文件必须存在，若文件不存在会抛出异常）。文件以什么编码写就以什么编码打开。</p>\n<p>2、<strong>w</strong>，只写模式（文件不可读，若文件不存在，则创建一个新的文件，如果文件存在，则会清空里面的内容）</p>\n<p>3、<strong>a</strong>，只追加写的模式 （文件不可读，不存在则创建新的文件，文件存在的话，可在后面追加内容）</p>\n<p>4、<strong>b</strong>，对于非文本的文件，使用b的模式。’b’表示以字节的方式进行操作 如：rb,wb,ab 分别对应以上内容，如果以b的方式打开，读取到的内容是字节类型</p>\n<pre><code># aa.txt文件中为一行字符串“hello world!”\nf = open(&#39;aa.txt&#39;, mode=&#39;rb&#39;)\nprint(f.read())\nf.close()\n####################################\nb&#39;hello world!&#39;</code></pre><p>5、<strong>’+‘模式</strong>，r+: 读写模式  w+:写读模式  a+：写读模式。在 <strong>r+</strong> 模式下，应该先读，后写，如果先写，后读，同样的道理，光标移动到了文件末尾，将读取不到内容。</p>\n<p>同时使用<strong>open</strong>打开了一个文件操作完成后必须进行关闭，关闭文件使用<strong>close()</strong>。由于文件操作的这一性质，可以使用<strong>with</strong>关键字进行操作，如下：</p>\n<p><strong>with 上下文管理器（到达语句末尾，将自动关闭文件）</strong></p>\n<pre><code>with open(&quot;*.txt&quot;) as f\n    pass</code></pre><h3 id=\"与文件读写相关的一些功能函数\"><a href=\"#与文件读写相关的一些功能函数\" class=\"headerlink\" title=\"与文件读写相关的一些功能函数\"></a>与文件读写相关的一些功能函数</h3><p>1、读取文件的操作</p>\n<pre><code># 读取文件，可以输入读取几个字符\nread()\n# 读取一行数据，也可以读取参数\nreadline()\n# 读取所有行，并返回列表，之后可以通过对列表进行遍历得到数据\nreadlines()</code></pre><p>2、写入文件的操作</p>\n<pre><code># 向文件中写入内容\nwrite()\n# 输入一个列表，将列表内容分别写入\nwirtelines([])</code></pre><p>3、其他操作（文件定位操作）</p>\n<p><strong>tell()</strong>方法告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。</p>\n<p><strong>seek(offset [,from])</strong>方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"模块与包\"><a href=\"#模块与包\" class=\"headerlink\" title=\"模块与包\"></a>模块与包</h2><h3 id=\"导入模块时Python的操作\"><a href=\"#导入模块时Python的操作\" class=\"headerlink\" title=\"导入模块时Python的操作\"></a>导入模块时Python的操作</h3><p>当程序导入一个模块时，Python解析器对模块位置的搜索顺序为：</p>\n<ol>\n<li>当前目录</li>\n<li>若当前目录搜索不到，Python则搜索在shell变量PYTHONPATH下的每个目录。</li>\n<li>若都找不到，Python会察看默认路径。UNIX下，默认路径一为/usr/local/lib/python/。</li>\n</ol>\n<p>模块搜索路径存储在 system 模块的<strong>sys.path</strong> 变量中。变量里包含当前目录、PYTHONPATH和由安装过程决定的默认目录。</p>\n<h3 id=\"模块常用函数\"><a href=\"#模块常用函数\" class=\"headerlink\" title=\"模块常用函数\"></a>模块常用函数</h3><p>1、<strong>dir()——列出对象的所有属性和方法</strong>。dir() 函数返回一个排好序的字符串列表，内容是一个模块里定义过的名字。返回的列表容纳了在一个模块里定义的所有<strong>模块</strong>，<strong>变量</strong>和<strong>函数</strong>。</p>\n<p>2、<strong>help()——查看类、方法的帮助信息</strong></p>\n<p>3、<strong>_<em>name_</em> ——模块的名称</strong></p>\n<p>4、_<em>file_</em> ——文件全路径</p>\n<h2 id=\"文件读写\"><a href=\"#文件读写\" class=\"headerlink\" title=\"文件读写\"></a>文件读写</h2><h3 id=\"open函数及其他基本操作\"><a href=\"#open函数及其他基本操作\" class=\"headerlink\" title=\"open函数及其他基本操作\"></a>open函数及其他基本操作</h3><p>Python使用<strong>open()</strong>打开文件，并返回文件的一个句柄。具体的参数为<strong>文件句柄 = open(‘文件路径’,打开模式, 编码方式)</strong>。其中编码方式encoding如果没有指定，将采用系统自带的编码方式。</p>\n<pre><code>f = open(&#39;aa.txt&#39;)\nprint(f)\nf.close()\n####################################################\n&lt;_io.TextIOWrapper name=&#39;aa.txt&#39; mode=&#39;r&#39; encoding=&#39;cp936&#39;&gt;</code></pre><p>由以上输出可以看到，没指定打开模式时文件默认为只读模式（r），这时使用写入操作就会出错，常用的文件打开方式主要有以下几个。</p>\n<p>1、<strong>r</strong>，只读的方式打开（文件必须存在，若文件不存在会抛出异常）。文件以什么编码写就以什么编码打开。</p>\n<p>2、<strong>w</strong>，只写模式（文件不可读，若文件不存在，则创建一个新的文件，如果文件存在，则会清空里面的内容）</p>\n<p>3、<strong>a</strong>，只追加写的模式 （文件不可读，不存在则创建新的文件，文件存在的话，可在后面追加内容）</p>\n<p>4、<strong>b</strong>，对于非文本的文件，使用b的模式。’b’表示以字节的方式进行操作 如：rb,wb,ab 分别对应以上内容，如果以b的方式打开，读取到的内容是字节类型</p>\n<pre><code># aa.txt文件中为一行字符串“hello world!”\nf = open(&#39;aa.txt&#39;, mode=&#39;rb&#39;)\nprint(f.read())\nf.close()\n####################################\nb&#39;hello world!&#39;</code></pre><p>5、<strong>’+‘模式</strong>，r+: 读写模式  w+:写读模式  a+：写读模式。在 <strong>r+</strong> 模式下，应该先读，后写，如果先写，后读，同样的道理，光标移动到了文件末尾，将读取不到内容。</p>\n<p>同时使用<strong>open</strong>打开了一个文件操作完成后必须进行关闭，关闭文件使用<strong>close()</strong>。由于文件操作的这一性质，可以使用<strong>with</strong>关键字进行操作，如下：</p>\n<p><strong>with 上下文管理器（到达语句末尾，将自动关闭文件）</strong></p>\n<pre><code>with open(&quot;*.txt&quot;) as f\n    pass</code></pre><h3 id=\"与文件读写相关的一些功能函数\"><a href=\"#与文件读写相关的一些功能函数\" class=\"headerlink\" title=\"与文件读写相关的一些功能函数\"></a>与文件读写相关的一些功能函数</h3><p>1、读取文件的操作</p>\n<pre><code># 读取文件，可以输入读取几个字符\nread()\n# 读取一行数据，也可以读取参数\nreadline()\n# 读取所有行，并返回列表，之后可以通过对列表进行遍历得到数据\nreadlines()</code></pre><p>2、写入文件的操作</p>\n<pre><code># 向文件中写入内容\nwrite()\n# 输入一个列表，将列表内容分别写入\nwirtelines([])</code></pre><p>3、其他操作（文件定位操作）</p>\n<p><strong>tell()</strong>方法告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。</p>\n<p><strong>seek(offset [,from])</strong>方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。</p>\n"},{"title":"3、Python类的使用","date":"2020-05-08T07:40:45.000Z","fileName":"python3","_content":"\n### 一些基本内容\n\n_name：单前置下划线，私有化属性或方法，类对象和子类可以访问，from somemodule import *禁止导入\n\n__name：双前置下划线，私有化属性或方法，无法在外部直接访问（名字重整所以访问不到）\n\n\\__name__：系统定义的名字，自己不要创建\n\n\n\nPython的析构函数`__del__(self)`。默认会直接进行操作。\n\n```\n# 判断是否为子类\nissubclass(cat, animal)\n```\n\n\n\n### 调用父类方法\n`super()`方法\n\n若方法重名，先继承的优先调用\n\n```\nclass A():\n    def test(self):\n        print(\"我是爸爸\")\n\nclass B(A):\n    def test(self):\n        super().test()\n        print(\"我是儿子\")\n        \nif __name__ == '__main__':\n    b = B()\n    b.test()\n    \n#############################################\n我是爸爸\n我是儿子\n```\n\n\n\n### @property\n\n@property：将类的方法当做属性来使用（可以简单理解为调用时可以将函数的括号去掉）\n\n一般用来获取某些数据（如获取私有变量），不会向函数中传递参数\n\n```\nclass pig():\n    def __init__(self, name):\n        self.__name = name\n\n    @property\n    def name(self):\n        return self.__name\n        \np = pig(\"猪\")\nprint(p.name) # 等价于不加@property时的，p.name()\n\n# 猪\n```\n\n\n\n@*.setter 表示可读可写，可以向该函数中传递参数，使用方法为`对象.函数名 = 参数值`。一般用来设置某些数据。\n\n```\nclass Pig():\n    def __init__(self, name):\n        self.__name = name\n\n    @property\n    def name(self):\n        return self.__name\n\n    @name.setter\n    def name(self, name):\n        # 在这即可对需要设置的值进行类型判断等操作\n        self.__name = name\n        \nif __name__ == '__main__':\n    p = Pig('pig1')\n    print(p.name)\n    p.name = 'pig2' # 可进行更改\n    print(p.name)\n  \n​```\npig1\npig2\n​```\n```\n\n\n\n### \\__slots__<限制类中的属性>\n\n为指定的类设置一个静态属性列表，为属性很少的类节约内存空间，同时提供更快的属性访问速度\n\n使用`__slots__`后**不允许给类添加新的属性与方法**（对其子类也适用，子类新加的会拼接到后面）。示例如下：\n\n```\n# 不加__slots__\nclass B():\n    pass\n    \nb = B()\nb.gg = 1\nprint(b.gg)\n\n###############################\n1\n```\n\n```\n# 加上__slots__\nclass A():\n    __slots__ = ('name')\n    def __init__(self, name):\n        self.name = name\n        \nif __name__ == '__main__':\n    a = A('aa')\n    a.gg = 1\n    print(a.gg)\n    \n###############################################\nTraceback (most recent call last):\n  File \"C:/Users/lenovo/Desktop/python学习/decorate.py\", line 13, in <module>\n    a.gg = 1\nAttributeError: 'A' object has no attribute 'gg'\n```\n\n可见，使用\\__slots__指定了类的属性后就无法对实例添加属性了\n\n\n\n### Python类中的方法\n\nPython类中的方法主要可以分为以下三种：\n\n* 实例方法：需要绑定要一个对象上，第一个参数默认使用self，会把对象作为第一个参数传递进来\n* 静态方法：使用装饰器@staticmethod进行定义，类和对象都可以调用，不需要默认参数\n* 类方法：使用装饰器@classmethod进行定义，类和对象都可以调用，第一个参数默认使用cls，会把类作为第一个参数传递进来\n\n\n\n#### @staticmethod，静态方法\n\n静态方法，可以直接通过类名对其进行调用（类的实例也可以调用 ）。相当于变为了\"类的方法\"。<类和对象都可以调用，不需要默认参数（如self等）>\n\n```\nclass Pig():\n    @staticmethod\n    def func():\n        print(\"聪明的猪\")\n        \nPig()\n\n#############################################\n聪明的猪\n```\n\n\n\n#### @classmethod，类方法\n\n用于表示类的方法，可以**不实例化调用类的属性和方法**。有一个`cls`参数用于表示类本身。<类和对象都可以调用，第一个参数默认使用cls，会把类作为第一个参数传递进来>\n\n```\nclass A():\n    def test(self):\n        print(\"test\")\n\n    @classmethod\n    def gg(cls):\n        cls().test()\n        \nA.gg()\n\n############################################\ntest\n```\n\n\n\n#### 动态添加实例方法\n\n```\nclass A():\n\tpass\n\t\ndef func(self):\n\tpass\n\t\na = A()\na.func = types.MethodType(func, a)\t# 给实例添加方法\n```\n\n如上，可以使用types.MethodType的方式给类的实例添加其实例方法，但该对象的另一个实例则不具备该方法。\n\n","source":"_posts/Python/语言基础/3、Python类的使用.md","raw":"---\ntitle: 3、Python类的使用\ndate: 2020-05-08 15:40:45\ntags:\ncategories:\n\t- Python\n\t- 语言基础\nfileName: python3\n---\n\n### 一些基本内容\n\n_name：单前置下划线，私有化属性或方法，类对象和子类可以访问，from somemodule import *禁止导入\n\n__name：双前置下划线，私有化属性或方法，无法在外部直接访问（名字重整所以访问不到）\n\n\\__name__：系统定义的名字，自己不要创建\n\n\n\nPython的析构函数`__del__(self)`。默认会直接进行操作。\n\n```\n# 判断是否为子类\nissubclass(cat, animal)\n```\n\n\n\n### 调用父类方法\n`super()`方法\n\n若方法重名，先继承的优先调用\n\n```\nclass A():\n    def test(self):\n        print(\"我是爸爸\")\n\nclass B(A):\n    def test(self):\n        super().test()\n        print(\"我是儿子\")\n        \nif __name__ == '__main__':\n    b = B()\n    b.test()\n    \n#############################################\n我是爸爸\n我是儿子\n```\n\n\n\n### @property\n\n@property：将类的方法当做属性来使用（可以简单理解为调用时可以将函数的括号去掉）\n\n一般用来获取某些数据（如获取私有变量），不会向函数中传递参数\n\n```\nclass pig():\n    def __init__(self, name):\n        self.__name = name\n\n    @property\n    def name(self):\n        return self.__name\n        \np = pig(\"猪\")\nprint(p.name) # 等价于不加@property时的，p.name()\n\n# 猪\n```\n\n\n\n@*.setter 表示可读可写，可以向该函数中传递参数，使用方法为`对象.函数名 = 参数值`。一般用来设置某些数据。\n\n```\nclass Pig():\n    def __init__(self, name):\n        self.__name = name\n\n    @property\n    def name(self):\n        return self.__name\n\n    @name.setter\n    def name(self, name):\n        # 在这即可对需要设置的值进行类型判断等操作\n        self.__name = name\n        \nif __name__ == '__main__':\n    p = Pig('pig1')\n    print(p.name)\n    p.name = 'pig2' # 可进行更改\n    print(p.name)\n  \n​```\npig1\npig2\n​```\n```\n\n\n\n### \\__slots__<限制类中的属性>\n\n为指定的类设置一个静态属性列表，为属性很少的类节约内存空间，同时提供更快的属性访问速度\n\n使用`__slots__`后**不允许给类添加新的属性与方法**（对其子类也适用，子类新加的会拼接到后面）。示例如下：\n\n```\n# 不加__slots__\nclass B():\n    pass\n    \nb = B()\nb.gg = 1\nprint(b.gg)\n\n###############################\n1\n```\n\n```\n# 加上__slots__\nclass A():\n    __slots__ = ('name')\n    def __init__(self, name):\n        self.name = name\n        \nif __name__ == '__main__':\n    a = A('aa')\n    a.gg = 1\n    print(a.gg)\n    \n###############################################\nTraceback (most recent call last):\n  File \"C:/Users/lenovo/Desktop/python学习/decorate.py\", line 13, in <module>\n    a.gg = 1\nAttributeError: 'A' object has no attribute 'gg'\n```\n\n可见，使用\\__slots__指定了类的属性后就无法对实例添加属性了\n\n\n\n### Python类中的方法\n\nPython类中的方法主要可以分为以下三种：\n\n* 实例方法：需要绑定要一个对象上，第一个参数默认使用self，会把对象作为第一个参数传递进来\n* 静态方法：使用装饰器@staticmethod进行定义，类和对象都可以调用，不需要默认参数\n* 类方法：使用装饰器@classmethod进行定义，类和对象都可以调用，第一个参数默认使用cls，会把类作为第一个参数传递进来\n\n\n\n#### @staticmethod，静态方法\n\n静态方法，可以直接通过类名对其进行调用（类的实例也可以调用 ）。相当于变为了\"类的方法\"。<类和对象都可以调用，不需要默认参数（如self等）>\n\n```\nclass Pig():\n    @staticmethod\n    def func():\n        print(\"聪明的猪\")\n        \nPig()\n\n#############################################\n聪明的猪\n```\n\n\n\n#### @classmethod，类方法\n\n用于表示类的方法，可以**不实例化调用类的属性和方法**。有一个`cls`参数用于表示类本身。<类和对象都可以调用，第一个参数默认使用cls，会把类作为第一个参数传递进来>\n\n```\nclass A():\n    def test(self):\n        print(\"test\")\n\n    @classmethod\n    def gg(cls):\n        cls().test()\n        \nA.gg()\n\n############################################\ntest\n```\n\n\n\n#### 动态添加实例方法\n\n```\nclass A():\n\tpass\n\t\ndef func(self):\n\tpass\n\t\na = A()\na.func = types.MethodType(func, a)\t# 给实例添加方法\n```\n\n如上，可以使用types.MethodType的方式给类的实例添加其实例方法，但该对象的另一个实例则不具备该方法。\n\n","slug":"Python/语言基础/3、Python类的使用","published":1,"updated":"2020-07-16T16:04:03.669Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8t8000yl4jsdn9k6k6u","content":"<h3 id=\"一些基本内容\"><a href=\"#一些基本内容\" class=\"headerlink\" title=\"一些基本内容\"></a>一些基本内容</h3><p>_name：单前置下划线，私有化属性或方法，类对象和子类可以访问，from somemodule import *禁止导入</p>\n<p>__name：双前置下划线，私有化属性或方法，无法在外部直接访问（名字重整所以访问不到）</p>\n<p>__name__：系统定义的名字，自己不要创建</p>\n<p>Python的析构函数<code>__del__(self)</code>。默认会直接进行操作。</p>\n<pre><code># 判断是否为子类\nissubclass(cat, animal)</code></pre><h3 id=\"调用父类方法\"><a href=\"#调用父类方法\" class=\"headerlink\" title=\"调用父类方法\"></a>调用父类方法</h3><p><code>super()</code>方法</p>\n<p>若方法重名，先继承的优先调用</p>\n<pre><code>class A():\n    def test(self):\n        print(&quot;我是爸爸&quot;)\n\nclass B(A):\n    def test(self):\n        super().test()\n        print(&quot;我是儿子&quot;)\n\nif __name__ == &#39;__main__&#39;:\n    b = B()\n    b.test()\n\n#############################################\n我是爸爸\n我是儿子</code></pre><h3 id=\"property\"><a href=\"#property\" class=\"headerlink\" title=\"@property\"></a>@property</h3><p>@property：将类的方法当做属性来使用（可以简单理解为调用时可以将函数的括号去掉）</p>\n<p>一般用来获取某些数据（如获取私有变量），不会向函数中传递参数</p>\n<pre><code>class pig():\n    def __init__(self, name):\n        self.__name = name\n\n    @property\n    def name(self):\n        return self.__name\n\np = pig(&quot;猪&quot;)\nprint(p.name) # 等价于不加@property时的，p.name()\n\n# 猪</code></pre><p>@*.setter 表示可读可写，可以向该函数中传递参数，使用方法为<code>对象.函数名 = 参数值</code>。一般用来设置某些数据。</p>\n<pre><code>class Pig():\n    def __init__(self, name):\n        self.__name = name\n\n    @property\n    def name(self):\n        return self.__name\n\n    @name.setter\n    def name(self, name):\n        # 在这即可对需要设置的值进行类型判断等操作\n        self.__name = name\n\nif __name__ == &#39;__main__&#39;:\n    p = Pig(&#39;pig1&#39;)\n    print(p.name)\n    p.name = &#39;pig2&#39; # 可进行更改\n    print(p.name)\n\n​```\npig1\npig2\n​```</code></pre><h3 id=\"slots-lt-限制类中的属性-gt\"><a href=\"#slots-lt-限制类中的属性-gt\" class=\"headerlink\" title=\"_slots_&lt;限制类中的属性&gt;\"></a>_<em>slots_</em>&lt;限制类中的属性&gt;</h3><p>为指定的类设置一个静态属性列表，为属性很少的类节约内存空间，同时提供更快的属性访问速度</p>\n<p>使用<code>__slots__</code>后<strong>不允许给类添加新的属性与方法</strong>（对其子类也适用，子类新加的会拼接到后面）。示例如下：</p>\n<pre><code># 不加__slots__\nclass B():\n    pass\n\nb = B()\nb.gg = 1\nprint(b.gg)\n\n###############################\n1</code></pre><pre><code># 加上__slots__\nclass A():\n    __slots__ = (&#39;name&#39;)\n    def __init__(self, name):\n        self.name = name\n\nif __name__ == &#39;__main__&#39;:\n    a = A(&#39;aa&#39;)\n    a.gg = 1\n    print(a.gg)\n\n###############################################\nTraceback (most recent call last):\n  File &quot;C:/Users/lenovo/Desktop/python学习/decorate.py&quot;, line 13, in &lt;module&gt;\n    a.gg = 1\nAttributeError: &#39;A&#39; object has no attribute &#39;gg&#39;</code></pre><p>可见，使用__slots__指定了类的属性后就无法对实例添加属性了</p>\n<h3 id=\"Python类中的方法\"><a href=\"#Python类中的方法\" class=\"headerlink\" title=\"Python类中的方法\"></a>Python类中的方法</h3><p>Python类中的方法主要可以分为以下三种：</p>\n<ul>\n<li>实例方法：需要绑定要一个对象上，第一个参数默认使用self，会把对象作为第一个参数传递进来</li>\n<li>静态方法：使用装饰器@staticmethod进行定义，类和对象都可以调用，不需要默认参数</li>\n<li>类方法：使用装饰器@classmethod进行定义，类和对象都可以调用，第一个参数默认使用cls，会把类作为第一个参数传递进来</li>\n</ul>\n<h4 id=\"staticmethod，静态方法\"><a href=\"#staticmethod，静态方法\" class=\"headerlink\" title=\"@staticmethod，静态方法\"></a>@staticmethod，静态方法</h4><p>静态方法，可以直接通过类名对其进行调用（类的实例也可以调用 ）。相当于变为了”类的方法”。&lt;类和对象都可以调用，不需要默认参数（如self等）&gt;</p>\n<pre><code>class Pig():\n    @staticmethod\n    def func():\n        print(&quot;聪明的猪&quot;)\n\nPig()\n\n#############################################\n聪明的猪</code></pre><h4 id=\"classmethod，类方法\"><a href=\"#classmethod，类方法\" class=\"headerlink\" title=\"@classmethod，类方法\"></a>@classmethod，类方法</h4><p>用于表示类的方法，可以<strong>不实例化调用类的属性和方法</strong>。有一个<code>cls</code>参数用于表示类本身。&lt;类和对象都可以调用，第一个参数默认使用cls，会把类作为第一个参数传递进来&gt;</p>\n<pre><code>class A():\n    def test(self):\n        print(&quot;test&quot;)\n\n    @classmethod\n    def gg(cls):\n        cls().test()\n\nA.gg()\n\n############################################\ntest</code></pre><h4 id=\"动态添加实例方法\"><a href=\"#动态添加实例方法\" class=\"headerlink\" title=\"动态添加实例方法\"></a>动态添加实例方法</h4><pre><code>class A():\n    pass\n\ndef func(self):\n    pass\n\na = A()\na.func = types.MethodType(func, a)    # 给实例添加方法</code></pre><p>如上，可以使用types.MethodType的方式给类的实例添加其实例方法，但该对象的另一个实例则不具备该方法。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"一些基本内容\"><a href=\"#一些基本内容\" class=\"headerlink\" title=\"一些基本内容\"></a>一些基本内容</h3><p>_name：单前置下划线，私有化属性或方法，类对象和子类可以访问，from somemodule import *禁止导入</p>\n<p>__name：双前置下划线，私有化属性或方法，无法在外部直接访问（名字重整所以访问不到）</p>\n<p>__name__：系统定义的名字，自己不要创建</p>\n<p>Python的析构函数<code>__del__(self)</code>。默认会直接进行操作。</p>\n<pre><code># 判断是否为子类\nissubclass(cat, animal)</code></pre><h3 id=\"调用父类方法\"><a href=\"#调用父类方法\" class=\"headerlink\" title=\"调用父类方法\"></a>调用父类方法</h3><p><code>super()</code>方法</p>\n<p>若方法重名，先继承的优先调用</p>\n<pre><code>class A():\n    def test(self):\n        print(&quot;我是爸爸&quot;)\n\nclass B(A):\n    def test(self):\n        super().test()\n        print(&quot;我是儿子&quot;)\n\nif __name__ == &#39;__main__&#39;:\n    b = B()\n    b.test()\n\n#############################################\n我是爸爸\n我是儿子</code></pre><h3 id=\"property\"><a href=\"#property\" class=\"headerlink\" title=\"@property\"></a>@property</h3><p>@property：将类的方法当做属性来使用（可以简单理解为调用时可以将函数的括号去掉）</p>\n<p>一般用来获取某些数据（如获取私有变量），不会向函数中传递参数</p>\n<pre><code>class pig():\n    def __init__(self, name):\n        self.__name = name\n\n    @property\n    def name(self):\n        return self.__name\n\np = pig(&quot;猪&quot;)\nprint(p.name) # 等价于不加@property时的，p.name()\n\n# 猪</code></pre><p>@*.setter 表示可读可写，可以向该函数中传递参数，使用方法为<code>对象.函数名 = 参数值</code>。一般用来设置某些数据。</p>\n<pre><code>class Pig():\n    def __init__(self, name):\n        self.__name = name\n\n    @property\n    def name(self):\n        return self.__name\n\n    @name.setter\n    def name(self, name):\n        # 在这即可对需要设置的值进行类型判断等操作\n        self.__name = name\n\nif __name__ == &#39;__main__&#39;:\n    p = Pig(&#39;pig1&#39;)\n    print(p.name)\n    p.name = &#39;pig2&#39; # 可进行更改\n    print(p.name)\n\n​```\npig1\npig2\n​```</code></pre><h3 id=\"slots-lt-限制类中的属性-gt\"><a href=\"#slots-lt-限制类中的属性-gt\" class=\"headerlink\" title=\"_slots_&lt;限制类中的属性&gt;\"></a>_<em>slots_</em>&lt;限制类中的属性&gt;</h3><p>为指定的类设置一个静态属性列表，为属性很少的类节约内存空间，同时提供更快的属性访问速度</p>\n<p>使用<code>__slots__</code>后<strong>不允许给类添加新的属性与方法</strong>（对其子类也适用，子类新加的会拼接到后面）。示例如下：</p>\n<pre><code># 不加__slots__\nclass B():\n    pass\n\nb = B()\nb.gg = 1\nprint(b.gg)\n\n###############################\n1</code></pre><pre><code># 加上__slots__\nclass A():\n    __slots__ = (&#39;name&#39;)\n    def __init__(self, name):\n        self.name = name\n\nif __name__ == &#39;__main__&#39;:\n    a = A(&#39;aa&#39;)\n    a.gg = 1\n    print(a.gg)\n\n###############################################\nTraceback (most recent call last):\n  File &quot;C:/Users/lenovo/Desktop/python学习/decorate.py&quot;, line 13, in &lt;module&gt;\n    a.gg = 1\nAttributeError: &#39;A&#39; object has no attribute &#39;gg&#39;</code></pre><p>可见，使用__slots__指定了类的属性后就无法对实例添加属性了</p>\n<h3 id=\"Python类中的方法\"><a href=\"#Python类中的方法\" class=\"headerlink\" title=\"Python类中的方法\"></a>Python类中的方法</h3><p>Python类中的方法主要可以分为以下三种：</p>\n<ul>\n<li>实例方法：需要绑定要一个对象上，第一个参数默认使用self，会把对象作为第一个参数传递进来</li>\n<li>静态方法：使用装饰器@staticmethod进行定义，类和对象都可以调用，不需要默认参数</li>\n<li>类方法：使用装饰器@classmethod进行定义，类和对象都可以调用，第一个参数默认使用cls，会把类作为第一个参数传递进来</li>\n</ul>\n<h4 id=\"staticmethod，静态方法\"><a href=\"#staticmethod，静态方法\" class=\"headerlink\" title=\"@staticmethod，静态方法\"></a>@staticmethod，静态方法</h4><p>静态方法，可以直接通过类名对其进行调用（类的实例也可以调用 ）。相当于变为了”类的方法”。&lt;类和对象都可以调用，不需要默认参数（如self等）&gt;</p>\n<pre><code>class Pig():\n    @staticmethod\n    def func():\n        print(&quot;聪明的猪&quot;)\n\nPig()\n\n#############################################\n聪明的猪</code></pre><h4 id=\"classmethod，类方法\"><a href=\"#classmethod，类方法\" class=\"headerlink\" title=\"@classmethod，类方法\"></a>@classmethod，类方法</h4><p>用于表示类的方法，可以<strong>不实例化调用类的属性和方法</strong>。有一个<code>cls</code>参数用于表示类本身。&lt;类和对象都可以调用，第一个参数默认使用cls，会把类作为第一个参数传递进来&gt;</p>\n<pre><code>class A():\n    def test(self):\n        print(&quot;test&quot;)\n\n    @classmethod\n    def gg(cls):\n        cls().test()\n\nA.gg()\n\n############################################\ntest</code></pre><h4 id=\"动态添加实例方法\"><a href=\"#动态添加实例方法\" class=\"headerlink\" title=\"动态添加实例方法\"></a>动态添加实例方法</h4><pre><code>class A():\n    pass\n\ndef func(self):\n    pass\n\na = A()\na.func = types.MethodType(func, a)    # 给实例添加方法</code></pre><p>如上，可以使用types.MethodType的方式给类的实例添加其实例方法，但该对象的另一个实例则不具备该方法。</p>\n"},{"title":"5、Python装饰器、迭代器、生成器","date":"2020-05-13T06:25:10.000Z","fileName":"python5","_content":"\n### 装饰器\n\n用于拓展原来函数功能的一种函数，返回函数的函数，在不更改原函数代码的前提下给函数增加新的功能（易于代码重用）\n\n```\n# 装饰器的常用写法\n# 输入函数，在函数内部定义返回函数\ndef decoratre(func):\n    def wrapper():\n        print('start')\n        func()\n        print(('end'))\n    return wrapper\n\n@decoratre\ndef func():\n    print(\"原函数执行\")\n\n\nif __name__ == '__main__':\n    func()\n    \n##########################################\nstart\n原函数执行\nend\n```\n\n\n\n### 带参数的装饰器\n\n#### 装饰器参数的传入\n\n```\ndef gg(name):\n    def decoratre(func):\n        def wrapper():\n            print('{}:start'.format(name))\n            func()\n            print('{}:end'.format(name))\n        return wrapper\n    return decoratre\n\n@gg('func')\ndef func():\n    print(\"原函数执行\")\n\n\nif __name__ == '__main__':\n    func()\n    \n#########################################\nfunc:start\n原函数执行\nfunc:end\n```\n\n\n\n#### 函数参数的传入\n\n使用`*args, **kwargs`\n\n```\ndef gg(name):\n    def decoratre(func):\n        def wrapper(*args, **kwargs):\n            print('{}:start'.format(name))\n            res = func(*args, **kwargs)\n            print(res)\n            print('{}:end'.format(name))\n            return res\n        return wrapper\n    return decoratre\n    \n@gg('sum')\ndef sum(a, b):\n    return a+b\n    \nif __name__ == '__main__':\n    sum(1, 2)\n    \n#############################################    \nsum:start\n3\nsum:end\n```\n\n\n\n\n\n\n\n装饰器对函数进行封装时改变了原函数的名称与说明文档等信息，如下：\n\n```\ndef gg(name):\n    def decoratre(func):\n        def wrapper():\n            print('{}:start'.format(name))\n            func()\n            print('{}:end'.format(name))\n        return wrapper\n    return decoratre\n\n@gg('func')\ndef func():\n    print(\"原函数执行\")\n\nif __name__ == '__main__':\n    print(func.__name__)\n    \n###################################################\nwrapper\n```\n\n\n\n为解决这个问题，可使用`@wraps(func)`方法，具体如下。\n\n```\nfrom functools import wraps\n\ndef gg(name):\n    def decoratre(func):\n        @wraps(func)\n        def wrapper():\n            print('{}:start'.format(name))\n            func()\n            print('{}:end'.format(name))\n        return wrapper\n    return decoratre\n\n@gg('func')\ndef func():\n    print(\"原函数执行\")\n\nif __name__ == '__main__':\n    print(func.__name__)\n    \n####################################################\nfunc\n```\n\n\n\n### 类的装饰器\n\n对一些类都需要添加一些共有的方法，可以用类的装饰器实现\n\n基本使用方法如下：\n\n```\ndef decorate(cls):\n    cls.func = lambda self: print(\"新方法\")\n    return cls\n\n@decorate\nclass Pig():\n    pass\n\nif __name__ == '__main__':\n    pig = Pig()\n    pig.func()\n    \n##########################################\n新方法\n```\n\n\n\n### 迭代器\n\n迭代器是一个可以**记住遍历的位置的对象**。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。字符串，列表或元组对象都可用于创建迭代器。同时，迭代器有两个基本的方法：**iter()** 和 **next()**。\n\n\n\n把一个类作为一个迭代器使用需要在类中实现两个方法`__iter__`和`__next__`。`__iter__()`方法返回一个特殊的迭代器对象。`__next__()` 方法会返回下一个迭代器对象。\n\n以下代码实现了一个计算平方的迭代器。\n\n```\nclass Square():\n    value = 0\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        self.value += 1\n        return self.value ** 2\n\nif __name__ == '__main__':\n    test = Square()\n    print(test.__next__())\n    print(test.__next__())\n    print(next(test))\n```\n\n\n\n### 生成器\n\n在 Python 中，使用了` yield` 的函数被称为生成器（generator）。在调用生成器运行的过程中，每次遇到` yield` 时函数会暂停并保存当前所有的运行信息，返回 `yield `的值, 并在下一次执行` next() `方法时从当前位置继续运行。\n\n```\ndef square():\n    for i in range(5):\n        yield i ** 2\n```\n","source":"_posts/Python/语言基础/5、Python装饰器、迭代器、生成器.md","raw":"---\ntitle: 5、Python装饰器、迭代器、生成器\ndate: 2020-05-13 14:25:10\ntags:\ncategories:\n\t- Python\n\t- 语言基础\nfileName: python5\n---\n\n### 装饰器\n\n用于拓展原来函数功能的一种函数，返回函数的函数，在不更改原函数代码的前提下给函数增加新的功能（易于代码重用）\n\n```\n# 装饰器的常用写法\n# 输入函数，在函数内部定义返回函数\ndef decoratre(func):\n    def wrapper():\n        print('start')\n        func()\n        print(('end'))\n    return wrapper\n\n@decoratre\ndef func():\n    print(\"原函数执行\")\n\n\nif __name__ == '__main__':\n    func()\n    \n##########################################\nstart\n原函数执行\nend\n```\n\n\n\n### 带参数的装饰器\n\n#### 装饰器参数的传入\n\n```\ndef gg(name):\n    def decoratre(func):\n        def wrapper():\n            print('{}:start'.format(name))\n            func()\n            print('{}:end'.format(name))\n        return wrapper\n    return decoratre\n\n@gg('func')\ndef func():\n    print(\"原函数执行\")\n\n\nif __name__ == '__main__':\n    func()\n    \n#########################################\nfunc:start\n原函数执行\nfunc:end\n```\n\n\n\n#### 函数参数的传入\n\n使用`*args, **kwargs`\n\n```\ndef gg(name):\n    def decoratre(func):\n        def wrapper(*args, **kwargs):\n            print('{}:start'.format(name))\n            res = func(*args, **kwargs)\n            print(res)\n            print('{}:end'.format(name))\n            return res\n        return wrapper\n    return decoratre\n    \n@gg('sum')\ndef sum(a, b):\n    return a+b\n    \nif __name__ == '__main__':\n    sum(1, 2)\n    \n#############################################    \nsum:start\n3\nsum:end\n```\n\n\n\n\n\n\n\n装饰器对函数进行封装时改变了原函数的名称与说明文档等信息，如下：\n\n```\ndef gg(name):\n    def decoratre(func):\n        def wrapper():\n            print('{}:start'.format(name))\n            func()\n            print('{}:end'.format(name))\n        return wrapper\n    return decoratre\n\n@gg('func')\ndef func():\n    print(\"原函数执行\")\n\nif __name__ == '__main__':\n    print(func.__name__)\n    \n###################################################\nwrapper\n```\n\n\n\n为解决这个问题，可使用`@wraps(func)`方法，具体如下。\n\n```\nfrom functools import wraps\n\ndef gg(name):\n    def decoratre(func):\n        @wraps(func)\n        def wrapper():\n            print('{}:start'.format(name))\n            func()\n            print('{}:end'.format(name))\n        return wrapper\n    return decoratre\n\n@gg('func')\ndef func():\n    print(\"原函数执行\")\n\nif __name__ == '__main__':\n    print(func.__name__)\n    \n####################################################\nfunc\n```\n\n\n\n### 类的装饰器\n\n对一些类都需要添加一些共有的方法，可以用类的装饰器实现\n\n基本使用方法如下：\n\n```\ndef decorate(cls):\n    cls.func = lambda self: print(\"新方法\")\n    return cls\n\n@decorate\nclass Pig():\n    pass\n\nif __name__ == '__main__':\n    pig = Pig()\n    pig.func()\n    \n##########################################\n新方法\n```\n\n\n\n### 迭代器\n\n迭代器是一个可以**记住遍历的位置的对象**。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。字符串，列表或元组对象都可用于创建迭代器。同时，迭代器有两个基本的方法：**iter()** 和 **next()**。\n\n\n\n把一个类作为一个迭代器使用需要在类中实现两个方法`__iter__`和`__next__`。`__iter__()`方法返回一个特殊的迭代器对象。`__next__()` 方法会返回下一个迭代器对象。\n\n以下代码实现了一个计算平方的迭代器。\n\n```\nclass Square():\n    value = 0\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        self.value += 1\n        return self.value ** 2\n\nif __name__ == '__main__':\n    test = Square()\n    print(test.__next__())\n    print(test.__next__())\n    print(next(test))\n```\n\n\n\n### 生成器\n\n在 Python 中，使用了` yield` 的函数被称为生成器（generator）。在调用生成器运行的过程中，每次遇到` yield` 时函数会暂停并保存当前所有的运行信息，返回 `yield `的值, 并在下一次执行` next() `方法时从当前位置继续运行。\n\n```\ndef square():\n    for i in range(5):\n        yield i ** 2\n```\n","slug":"Python/语言基础/5、Python装饰器、迭代器、生成器","published":1,"updated":"2020-07-16T16:04:18.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8tb0012l4jsgyoy4adr","content":"<h3 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3><p>用于拓展原来函数功能的一种函数，返回函数的函数，在不更改原函数代码的前提下给函数增加新的功能（易于代码重用）</p>\n<pre><code># 装饰器的常用写法\n# 输入函数，在函数内部定义返回函数\ndef decoratre(func):\n    def wrapper():\n        print(&#39;start&#39;)\n        func()\n        print((&#39;end&#39;))\n    return wrapper\n\n@decoratre\ndef func():\n    print(&quot;原函数执行&quot;)\n\n\nif __name__ == &#39;__main__&#39;:\n    func()\n\n##########################################\nstart\n原函数执行\nend</code></pre><h3 id=\"带参数的装饰器\"><a href=\"#带参数的装饰器\" class=\"headerlink\" title=\"带参数的装饰器\"></a>带参数的装饰器</h3><h4 id=\"装饰器参数的传入\"><a href=\"#装饰器参数的传入\" class=\"headerlink\" title=\"装饰器参数的传入\"></a>装饰器参数的传入</h4><pre><code>def gg(name):\n    def decoratre(func):\n        def wrapper():\n            print(&#39;{}:start&#39;.format(name))\n            func()\n            print(&#39;{}:end&#39;.format(name))\n        return wrapper\n    return decoratre\n\n@gg(&#39;func&#39;)\ndef func():\n    print(&quot;原函数执行&quot;)\n\n\nif __name__ == &#39;__main__&#39;:\n    func()\n\n#########################################\nfunc:start\n原函数执行\nfunc:end</code></pre><h4 id=\"函数参数的传入\"><a href=\"#函数参数的传入\" class=\"headerlink\" title=\"函数参数的传入\"></a>函数参数的传入</h4><p>使用<code>*args, **kwargs</code></p>\n<pre><code>def gg(name):\n    def decoratre(func):\n        def wrapper(*args, **kwargs):\n            print(&#39;{}:start&#39;.format(name))\n            res = func(*args, **kwargs)\n            print(res)\n            print(&#39;{}:end&#39;.format(name))\n            return res\n        return wrapper\n    return decoratre\n\n@gg(&#39;sum&#39;)\ndef sum(a, b):\n    return a+b\n\nif __name__ == &#39;__main__&#39;:\n    sum(1, 2)\n\n#############################################    \nsum:start\n3\nsum:end</code></pre><p>装饰器对函数进行封装时改变了原函数的名称与说明文档等信息，如下：</p>\n<pre><code>def gg(name):\n    def decoratre(func):\n        def wrapper():\n            print(&#39;{}:start&#39;.format(name))\n            func()\n            print(&#39;{}:end&#39;.format(name))\n        return wrapper\n    return decoratre\n\n@gg(&#39;func&#39;)\ndef func():\n    print(&quot;原函数执行&quot;)\n\nif __name__ == &#39;__main__&#39;:\n    print(func.__name__)\n\n###################################################\nwrapper</code></pre><p>为解决这个问题，可使用<code>@wraps(func)</code>方法，具体如下。</p>\n<pre><code>from functools import wraps\n\ndef gg(name):\n    def decoratre(func):\n        @wraps(func)\n        def wrapper():\n            print(&#39;{}:start&#39;.format(name))\n            func()\n            print(&#39;{}:end&#39;.format(name))\n        return wrapper\n    return decoratre\n\n@gg(&#39;func&#39;)\ndef func():\n    print(&quot;原函数执行&quot;)\n\nif __name__ == &#39;__main__&#39;:\n    print(func.__name__)\n\n####################################################\nfunc</code></pre><h3 id=\"类的装饰器\"><a href=\"#类的装饰器\" class=\"headerlink\" title=\"类的装饰器\"></a>类的装饰器</h3><p>对一些类都需要添加一些共有的方法，可以用类的装饰器实现</p>\n<p>基本使用方法如下：</p>\n<pre><code>def decorate(cls):\n    cls.func = lambda self: print(&quot;新方法&quot;)\n    return cls\n\n@decorate\nclass Pig():\n    pass\n\nif __name__ == &#39;__main__&#39;:\n    pig = Pig()\n    pig.func()\n\n##########################################\n新方法</code></pre><h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>迭代器是一个可以<strong>记住遍历的位置的对象</strong>。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。字符串，列表或元组对象都可用于创建迭代器。同时，迭代器有两个基本的方法：<strong>iter()</strong> 和 <strong>next()</strong>。</p>\n<p>把一个类作为一个迭代器使用需要在类中实现两个方法<code>__iter__</code>和<code>__next__</code>。<code>__iter__()</code>方法返回一个特殊的迭代器对象。<code>__next__()</code> 方法会返回下一个迭代器对象。</p>\n<p>以下代码实现了一个计算平方的迭代器。</p>\n<pre><code>class Square():\n    value = 0\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        self.value += 1\n        return self.value ** 2\n\nif __name__ == &#39;__main__&#39;:\n    test = Square()\n    print(test.__next__())\n    print(test.__next__())\n    print(next(test))</code></pre><h3 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h3><p>在 Python 中，使用了<code>yield</code> 的函数被称为生成器（generator）。在调用生成器运行的过程中，每次遇到<code>yield</code> 时函数会暂停并保存当前所有的运行信息，返回 <code>yield</code>的值, 并在下一次执行<code>next()</code>方法时从当前位置继续运行。</p>\n<pre><code>def square():\n    for i in range(5):\n        yield i ** 2</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h3><p>用于拓展原来函数功能的一种函数，返回函数的函数，在不更改原函数代码的前提下给函数增加新的功能（易于代码重用）</p>\n<pre><code># 装饰器的常用写法\n# 输入函数，在函数内部定义返回函数\ndef decoratre(func):\n    def wrapper():\n        print(&#39;start&#39;)\n        func()\n        print((&#39;end&#39;))\n    return wrapper\n\n@decoratre\ndef func():\n    print(&quot;原函数执行&quot;)\n\n\nif __name__ == &#39;__main__&#39;:\n    func()\n\n##########################################\nstart\n原函数执行\nend</code></pre><h3 id=\"带参数的装饰器\"><a href=\"#带参数的装饰器\" class=\"headerlink\" title=\"带参数的装饰器\"></a>带参数的装饰器</h3><h4 id=\"装饰器参数的传入\"><a href=\"#装饰器参数的传入\" class=\"headerlink\" title=\"装饰器参数的传入\"></a>装饰器参数的传入</h4><pre><code>def gg(name):\n    def decoratre(func):\n        def wrapper():\n            print(&#39;{}:start&#39;.format(name))\n            func()\n            print(&#39;{}:end&#39;.format(name))\n        return wrapper\n    return decoratre\n\n@gg(&#39;func&#39;)\ndef func():\n    print(&quot;原函数执行&quot;)\n\n\nif __name__ == &#39;__main__&#39;:\n    func()\n\n#########################################\nfunc:start\n原函数执行\nfunc:end</code></pre><h4 id=\"函数参数的传入\"><a href=\"#函数参数的传入\" class=\"headerlink\" title=\"函数参数的传入\"></a>函数参数的传入</h4><p>使用<code>*args, **kwargs</code></p>\n<pre><code>def gg(name):\n    def decoratre(func):\n        def wrapper(*args, **kwargs):\n            print(&#39;{}:start&#39;.format(name))\n            res = func(*args, **kwargs)\n            print(res)\n            print(&#39;{}:end&#39;.format(name))\n            return res\n        return wrapper\n    return decoratre\n\n@gg(&#39;sum&#39;)\ndef sum(a, b):\n    return a+b\n\nif __name__ == &#39;__main__&#39;:\n    sum(1, 2)\n\n#############################################    \nsum:start\n3\nsum:end</code></pre><p>装饰器对函数进行封装时改变了原函数的名称与说明文档等信息，如下：</p>\n<pre><code>def gg(name):\n    def decoratre(func):\n        def wrapper():\n            print(&#39;{}:start&#39;.format(name))\n            func()\n            print(&#39;{}:end&#39;.format(name))\n        return wrapper\n    return decoratre\n\n@gg(&#39;func&#39;)\ndef func():\n    print(&quot;原函数执行&quot;)\n\nif __name__ == &#39;__main__&#39;:\n    print(func.__name__)\n\n###################################################\nwrapper</code></pre><p>为解决这个问题，可使用<code>@wraps(func)</code>方法，具体如下。</p>\n<pre><code>from functools import wraps\n\ndef gg(name):\n    def decoratre(func):\n        @wraps(func)\n        def wrapper():\n            print(&#39;{}:start&#39;.format(name))\n            func()\n            print(&#39;{}:end&#39;.format(name))\n        return wrapper\n    return decoratre\n\n@gg(&#39;func&#39;)\ndef func():\n    print(&quot;原函数执行&quot;)\n\nif __name__ == &#39;__main__&#39;:\n    print(func.__name__)\n\n####################################################\nfunc</code></pre><h3 id=\"类的装饰器\"><a href=\"#类的装饰器\" class=\"headerlink\" title=\"类的装饰器\"></a>类的装饰器</h3><p>对一些类都需要添加一些共有的方法，可以用类的装饰器实现</p>\n<p>基本使用方法如下：</p>\n<pre><code>def decorate(cls):\n    cls.func = lambda self: print(&quot;新方法&quot;)\n    return cls\n\n@decorate\nclass Pig():\n    pass\n\nif __name__ == &#39;__main__&#39;:\n    pig = Pig()\n    pig.func()\n\n##########################################\n新方法</code></pre><h3 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h3><p>迭代器是一个可以<strong>记住遍历的位置的对象</strong>。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。字符串，列表或元组对象都可用于创建迭代器。同时，迭代器有两个基本的方法：<strong>iter()</strong> 和 <strong>next()</strong>。</p>\n<p>把一个类作为一个迭代器使用需要在类中实现两个方法<code>__iter__</code>和<code>__next__</code>。<code>__iter__()</code>方法返回一个特殊的迭代器对象。<code>__next__()</code> 方法会返回下一个迭代器对象。</p>\n<p>以下代码实现了一个计算平方的迭代器。</p>\n<pre><code>class Square():\n    value = 0\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        self.value += 1\n        return self.value ** 2\n\nif __name__ == &#39;__main__&#39;:\n    test = Square()\n    print(test.__next__())\n    print(test.__next__())\n    print(next(test))</code></pre><h3 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h3><p>在 Python 中，使用了<code>yield</code> 的函数被称为生成器（generator）。在调用生成器运行的过程中，每次遇到<code>yield</code> 时函数会暂停并保存当前所有的运行信息，返回 <code>yield</code>的值, 并在下一次执行<code>next()</code>方法时从当前位置继续运行。</p>\n<pre><code>def square():\n    for i in range(5):\n        yield i ** 2</code></pre>"},{"title":"6、Python异常处理","date":"2020-05-15T07:15:49.000Z","fileName":"python6","_content":"\n### 异常基本概述\n\n1. 每个异常都是某个类的实例\n2. 发生了异常如果不捕获，程序将终止执行\n3. 有一些内置的异常类（Exception等）\n\n\n\n### 捕获异常\n\n `try except`句式\n\n```\ndef test(a, b):\n    return a/b\n\nif __name__ == '__main__':\n    try:\n        print(test(2, 0))\n    except:\n        print(\"出错了\")\n        \n#############################\n出错了\n```\n\n检测出错类型的方法\n\n```\ndef test(a, b):\n    return a/b\n\nif __name__ == '__main__':\n    try:\n        print(test(2, 'a'))\n    except ZeroDivisionError:\n        print(\"除数为0\")\n    except TypeError:\n        print(\"类型出错\")\n        \n#######################################\n类型出错\n```\n\n\n\n获取出错信息\n\n```\ndef test(a, b):\n    return a/b\n\nif __name__ == '__main__':\n    try:\n        print(test(2, 'a'))\n    except (ZeroDivisionError, TypeError) as e:\n        print(e)\n        \n############################################\nunsupported operand type(s) for /: 'int' and 'str'\n```\n\n\n\n处理必须处理的语句（finally中的语句不管有没有问题都会执行）\n\n`try except finally`语句\n\n```\ndef test(a, b):\n    return a/b\n\nif __name__ == '__main__':\n    try:\n        print(test(2, 'a'))\n    except (ZeroDivisionError, TypeError) as e:\n        print(e)\n    finally:\n        print(\"我必须处理\")\n        \n#################################################\nunsupported operand type(s) for /: 'int' and 'str'\n我必须处理\n```\n\n\n\n### 自定义异常和抛出异常\n\n通过继承**Exception类**来定义异常，通过使用**raise**关键字来抛出异常。\n\n1、**自定义异常**。通过创建一个继承自Exception类的新的异常类来记录自己的异常\n\n```\nclass test(Exception):\n    pass\n\nif __name__ == '__main__':\n    if True:\n        raise test('出现了自定义的测试错误')\n        \n######################################################\nTraceback (most recent call last):\n  File \"C:/Users/lenovo/Desktop/python学习/decorate.py\", line 7, in <module>\n    raise test('出现了自定义的测试错误')\n__main__.test: 出现了自定义的测试错误\n```\n\n","source":"_posts/Python/语言基础/6、Python异常处理.md","raw":"---\ntitle: 6、Python异常处理\ndate: 2020-05-15 15:15:49\ntags:\ncategories:\n\t- Python\n\t- 语言基础\nfileName: python6\n---\n\n### 异常基本概述\n\n1. 每个异常都是某个类的实例\n2. 发生了异常如果不捕获，程序将终止执行\n3. 有一些内置的异常类（Exception等）\n\n\n\n### 捕获异常\n\n `try except`句式\n\n```\ndef test(a, b):\n    return a/b\n\nif __name__ == '__main__':\n    try:\n        print(test(2, 0))\n    except:\n        print(\"出错了\")\n        \n#############################\n出错了\n```\n\n检测出错类型的方法\n\n```\ndef test(a, b):\n    return a/b\n\nif __name__ == '__main__':\n    try:\n        print(test(2, 'a'))\n    except ZeroDivisionError:\n        print(\"除数为0\")\n    except TypeError:\n        print(\"类型出错\")\n        \n#######################################\n类型出错\n```\n\n\n\n获取出错信息\n\n```\ndef test(a, b):\n    return a/b\n\nif __name__ == '__main__':\n    try:\n        print(test(2, 'a'))\n    except (ZeroDivisionError, TypeError) as e:\n        print(e)\n        \n############################################\nunsupported operand type(s) for /: 'int' and 'str'\n```\n\n\n\n处理必须处理的语句（finally中的语句不管有没有问题都会执行）\n\n`try except finally`语句\n\n```\ndef test(a, b):\n    return a/b\n\nif __name__ == '__main__':\n    try:\n        print(test(2, 'a'))\n    except (ZeroDivisionError, TypeError) as e:\n        print(e)\n    finally:\n        print(\"我必须处理\")\n        \n#################################################\nunsupported operand type(s) for /: 'int' and 'str'\n我必须处理\n```\n\n\n\n### 自定义异常和抛出异常\n\n通过继承**Exception类**来定义异常，通过使用**raise**关键字来抛出异常。\n\n1、**自定义异常**。通过创建一个继承自Exception类的新的异常类来记录自己的异常\n\n```\nclass test(Exception):\n    pass\n\nif __name__ == '__main__':\n    if True:\n        raise test('出现了自定义的测试错误')\n        \n######################################################\nTraceback (most recent call last):\n  File \"C:/Users/lenovo/Desktop/python学习/decorate.py\", line 7, in <module>\n    raise test('出现了自定义的测试错误')\n__main__.test: 出现了自定义的测试错误\n```\n\n","slug":"Python/语言基础/6、Python异常处理","published":1,"updated":"2020-07-16T16:04:25.054Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8td0014l4jsfzo92e1s","content":"<h3 id=\"异常基本概述\"><a href=\"#异常基本概述\" class=\"headerlink\" title=\"异常基本概述\"></a>异常基本概述</h3><ol>\n<li>每个异常都是某个类的实例</li>\n<li>发生了异常如果不捕获，程序将终止执行</li>\n<li>有一些内置的异常类（Exception等）</li>\n</ol>\n<h3 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h3><p> <code>try except</code>句式</p>\n<pre><code>def test(a, b):\n    return a/b\n\nif __name__ == &#39;__main__&#39;:\n    try:\n        print(test(2, 0))\n    except:\n        print(&quot;出错了&quot;)\n\n#############################\n出错了</code></pre><p>检测出错类型的方法</p>\n<pre><code>def test(a, b):\n    return a/b\n\nif __name__ == &#39;__main__&#39;:\n    try:\n        print(test(2, &#39;a&#39;))\n    except ZeroDivisionError:\n        print(&quot;除数为0&quot;)\n    except TypeError:\n        print(&quot;类型出错&quot;)\n\n#######################################\n类型出错</code></pre><p>获取出错信息</p>\n<pre><code>def test(a, b):\n    return a/b\n\nif __name__ == &#39;__main__&#39;:\n    try:\n        print(test(2, &#39;a&#39;))\n    except (ZeroDivisionError, TypeError) as e:\n        print(e)\n\n############################################\nunsupported operand type(s) for /: &#39;int&#39; and &#39;str&#39;</code></pre><p>处理必须处理的语句（finally中的语句不管有没有问题都会执行）</p>\n<p><code>try except finally</code>语句</p>\n<pre><code>def test(a, b):\n    return a/b\n\nif __name__ == &#39;__main__&#39;:\n    try:\n        print(test(2, &#39;a&#39;))\n    except (ZeroDivisionError, TypeError) as e:\n        print(e)\n    finally:\n        print(&quot;我必须处理&quot;)\n\n#################################################\nunsupported operand type(s) for /: &#39;int&#39; and &#39;str&#39;\n我必须处理</code></pre><h3 id=\"自定义异常和抛出异常\"><a href=\"#自定义异常和抛出异常\" class=\"headerlink\" title=\"自定义异常和抛出异常\"></a>自定义异常和抛出异常</h3><p>通过继承<strong>Exception类</strong>来定义异常，通过使用<strong>raise</strong>关键字来抛出异常。</p>\n<p>1、<strong>自定义异常</strong>。通过创建一个继承自Exception类的新的异常类来记录自己的异常</p>\n<pre><code>class test(Exception):\n    pass\n\nif __name__ == &#39;__main__&#39;:\n    if True:\n        raise test(&#39;出现了自定义的测试错误&#39;)\n\n######################################################\nTraceback (most recent call last):\n  File &quot;C:/Users/lenovo/Desktop/python学习/decorate.py&quot;, line 7, in &lt;module&gt;\n    raise test(&#39;出现了自定义的测试错误&#39;)\n__main__.test: 出现了自定义的测试错误</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"异常基本概述\"><a href=\"#异常基本概述\" class=\"headerlink\" title=\"异常基本概述\"></a>异常基本概述</h3><ol>\n<li>每个异常都是某个类的实例</li>\n<li>发生了异常如果不捕获，程序将终止执行</li>\n<li>有一些内置的异常类（Exception等）</li>\n</ol>\n<h3 id=\"捕获异常\"><a href=\"#捕获异常\" class=\"headerlink\" title=\"捕获异常\"></a>捕获异常</h3><p> <code>try except</code>句式</p>\n<pre><code>def test(a, b):\n    return a/b\n\nif __name__ == &#39;__main__&#39;:\n    try:\n        print(test(2, 0))\n    except:\n        print(&quot;出错了&quot;)\n\n#############################\n出错了</code></pre><p>检测出错类型的方法</p>\n<pre><code>def test(a, b):\n    return a/b\n\nif __name__ == &#39;__main__&#39;:\n    try:\n        print(test(2, &#39;a&#39;))\n    except ZeroDivisionError:\n        print(&quot;除数为0&quot;)\n    except TypeError:\n        print(&quot;类型出错&quot;)\n\n#######################################\n类型出错</code></pre><p>获取出错信息</p>\n<pre><code>def test(a, b):\n    return a/b\n\nif __name__ == &#39;__main__&#39;:\n    try:\n        print(test(2, &#39;a&#39;))\n    except (ZeroDivisionError, TypeError) as e:\n        print(e)\n\n############################################\nunsupported operand type(s) for /: &#39;int&#39; and &#39;str&#39;</code></pre><p>处理必须处理的语句（finally中的语句不管有没有问题都会执行）</p>\n<p><code>try except finally</code>语句</p>\n<pre><code>def test(a, b):\n    return a/b\n\nif __name__ == &#39;__main__&#39;:\n    try:\n        print(test(2, &#39;a&#39;))\n    except (ZeroDivisionError, TypeError) as e:\n        print(e)\n    finally:\n        print(&quot;我必须处理&quot;)\n\n#################################################\nunsupported operand type(s) for /: &#39;int&#39; and &#39;str&#39;\n我必须处理</code></pre><h3 id=\"自定义异常和抛出异常\"><a href=\"#自定义异常和抛出异常\" class=\"headerlink\" title=\"自定义异常和抛出异常\"></a>自定义异常和抛出异常</h3><p>通过继承<strong>Exception类</strong>来定义异常，通过使用<strong>raise</strong>关键字来抛出异常。</p>\n<p>1、<strong>自定义异常</strong>。通过创建一个继承自Exception类的新的异常类来记录自己的异常</p>\n<pre><code>class test(Exception):\n    pass\n\nif __name__ == &#39;__main__&#39;:\n    if True:\n        raise test(&#39;出现了自定义的测试错误&#39;)\n\n######################################################\nTraceback (most recent call last):\n  File &quot;C:/Users/lenovo/Desktop/python学习/decorate.py&quot;, line 7, in &lt;module&gt;\n    raise test(&#39;出现了自定义的测试错误&#39;)\n__main__.test: 出现了自定义的测试错误</code></pre>"},{"title":"Python操作MySQL数据库","date":"2020-06-15T07:37:28.000Z","fileName":"python_mysql","_content":"\n123\n\n创建连接\n\n```\nimport mysql.connector\n\nconfig = {\n    \"host\": \"localhost\",\n    \"port\": \"3306\",\n    \"user\": \"root\",\n    \"password\": \"password\",\n    \"database\": \"demo\"\n}\n\ncon = mysql.connector.connect(**config)\n\ncon.close()\n```\n\n\n\n\n\n游标（Cursor）\n\n执行SQL语句\n\n```\ncurser = con.cursor()\ncurser.execute()\n```\n\n示例\n\n```\ncurser = con.cursor()\nsql = \"SELECT ename FROM t_emp;\"\ncurser.execute(sql)\nfor one in curser:\n    print(one[0])\n```\n\n\n\n事务控制\n\n```\ncon.start_transaction()\ncon.commit()\ncon.rollback()\n```\n\n异常处理\n\n```\ntry:\n    con = mysql.connector.connect(**config)\n    con.start_transaction()\n    con.commit()\nexcept Exception as e:\n    con.rollback()\nfinally:\n    if \"con\" in dir():\n        con.close()\n```\n\n\n\n数据库连接池\n\n```\npool = mysql.connector.pooling.MySQLConnectionPool(\n    **config,\n    pool_size=10\n)\ncon = pool.get_connection()\n```\n\n\n\n","source":"_posts/Python/数据库/Python操作MySQL数据库.md","raw":"---\ntitle: Python操作MySQL数据库\ndate: 2020-06-15 15:37:28\ntags:\ncategories:\n\t- Python\n\t- 数据库\nfileName: python_mysql\n---\n\n123\n\n创建连接\n\n```\nimport mysql.connector\n\nconfig = {\n    \"host\": \"localhost\",\n    \"port\": \"3306\",\n    \"user\": \"root\",\n    \"password\": \"password\",\n    \"database\": \"demo\"\n}\n\ncon = mysql.connector.connect(**config)\n\ncon.close()\n```\n\n\n\n\n\n游标（Cursor）\n\n执行SQL语句\n\n```\ncurser = con.cursor()\ncurser.execute()\n```\n\n示例\n\n```\ncurser = con.cursor()\nsql = \"SELECT ename FROM t_emp;\"\ncurser.execute(sql)\nfor one in curser:\n    print(one[0])\n```\n\n\n\n事务控制\n\n```\ncon.start_transaction()\ncon.commit()\ncon.rollback()\n```\n\n异常处理\n\n```\ntry:\n    con = mysql.connector.connect(**config)\n    con.start_transaction()\n    con.commit()\nexcept Exception as e:\n    con.rollback()\nfinally:\n    if \"con\" in dir():\n        con.close()\n```\n\n\n\n数据库连接池\n\n```\npool = mysql.connector.pooling.MySQLConnectionPool(\n    **config,\n    pool_size=10\n)\ncon = pool.get_connection()\n```\n\n\n\n","slug":"Python/数据库/Python操作MySQL数据库","published":1,"updated":"2020-07-16T16:02:38.453Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8tf0016l4jsd8eq1asi","content":"<p>123</p>\n<p>创建连接</p>\n<pre><code>import mysql.connector\n\nconfig = {\n    &quot;host&quot;: &quot;localhost&quot;,\n    &quot;port&quot;: &quot;3306&quot;,\n    &quot;user&quot;: &quot;root&quot;,\n    &quot;password&quot;: &quot;password&quot;,\n    &quot;database&quot;: &quot;demo&quot;\n}\n\ncon = mysql.connector.connect(**config)\n\ncon.close()</code></pre><p>游标（Cursor）</p>\n<p>执行SQL语句</p>\n<pre><code>curser = con.cursor()\ncurser.execute()</code></pre><p>示例</p>\n<pre><code>curser = con.cursor()\nsql = &quot;SELECT ename FROM t_emp;&quot;\ncurser.execute(sql)\nfor one in curser:\n    print(one[0])</code></pre><p>事务控制</p>\n<pre><code>con.start_transaction()\ncon.commit()\ncon.rollback()</code></pre><p>异常处理</p>\n<pre><code>try:\n    con = mysql.connector.connect(**config)\n    con.start_transaction()\n    con.commit()\nexcept Exception as e:\n    con.rollback()\nfinally:\n    if &quot;con&quot; in dir():\n        con.close()</code></pre><p>数据库连接池</p>\n<pre><code>pool = mysql.connector.pooling.MySQLConnectionPool(\n    **config,\n    pool_size=10\n)\ncon = pool.get_connection()</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>123</p>\n<p>创建连接</p>\n<pre><code>import mysql.connector\n\nconfig = {\n    &quot;host&quot;: &quot;localhost&quot;,\n    &quot;port&quot;: &quot;3306&quot;,\n    &quot;user&quot;: &quot;root&quot;,\n    &quot;password&quot;: &quot;password&quot;,\n    &quot;database&quot;: &quot;demo&quot;\n}\n\ncon = mysql.connector.connect(**config)\n\ncon.close()</code></pre><p>游标（Cursor）</p>\n<p>执行SQL语句</p>\n<pre><code>curser = con.cursor()\ncurser.execute()</code></pre><p>示例</p>\n<pre><code>curser = con.cursor()\nsql = &quot;SELECT ename FROM t_emp;&quot;\ncurser.execute(sql)\nfor one in curser:\n    print(one[0])</code></pre><p>事务控制</p>\n<pre><code>con.start_transaction()\ncon.commit()\ncon.rollback()</code></pre><p>异常处理</p>\n<pre><code>try:\n    con = mysql.connector.connect(**config)\n    con.start_transaction()\n    con.commit()\nexcept Exception as e:\n    con.rollback()\nfinally:\n    if &quot;con&quot; in dir():\n        con.close()</code></pre><p>数据库连接池</p>\n<pre><code>pool = mysql.connector.pooling.MySQLConnectionPool(\n    **config,\n    pool_size=10\n)\ncon = pool.get_connection()</code></pre>"},{"title":"8、Python的一些语言特性与机制","date":"2020-06-19T07:01:02.000Z","fileName":"python8","_content":"\n代码高效、程序健壮\n\n\n\n值的类型，引用类型\n\n\n\n内存共享机制\n\n\n\n垃圾回收机制\n\n以引用计数为主，分代收集为辅\n\n每个对象都有指向该对象的引用总数\n\n```\nsys.getrefcount()\n```\n\n满足特定条件，自动启动垃圾回收\n\nPython运行时，会记录分配对象与取消分配对象的次数。当两者差值高过阈值时。\n\n\n\n```\n# 查看阈值\ngc.get_threshold()\n```\n\n所有新建对象都是0代对象。所有对象分为0，1，2代。当某一代对象经历过垃圾回收，依然存活，则被归入下一代\n\n\n\n若一个对象的引用数为0，Python虚拟机就会回收这个对象的内存\n\n引用计数的缺陷是循环引用的问题\n\n\n\n\n\n递归运行时报错“RecursionError”。这是python默认的递归深度是很有限的（默认是1000），因此当递归深度超过999的样子，就会引发这样的一个异常。\n\n解决方法：首先考虑对代码进行优化，其次也可以考虑将递归深度的数值调大一些。\n\n```\nimport sys\nsys.setrecursionlimit(100000) #你想设置的递归深度（可为任意值）\n```\n\n\n\n","source":"_posts/Python/语言基础/8、Python的一些语言特性与机制.md","raw":"---\ntitle: 8、Python的一些语言特性与机制\ndate: 2020-06-19 15:01:02\ntags:\ncategories:\n\t- Python\n\t- 语言基础\nfileName: python8\n---\n\n代码高效、程序健壮\n\n\n\n值的类型，引用类型\n\n\n\n内存共享机制\n\n\n\n垃圾回收机制\n\n以引用计数为主，分代收集为辅\n\n每个对象都有指向该对象的引用总数\n\n```\nsys.getrefcount()\n```\n\n满足特定条件，自动启动垃圾回收\n\nPython运行时，会记录分配对象与取消分配对象的次数。当两者差值高过阈值时。\n\n\n\n```\n# 查看阈值\ngc.get_threshold()\n```\n\n所有新建对象都是0代对象。所有对象分为0，1，2代。当某一代对象经历过垃圾回收，依然存活，则被归入下一代\n\n\n\n若一个对象的引用数为0，Python虚拟机就会回收这个对象的内存\n\n引用计数的缺陷是循环引用的问题\n\n\n\n\n\n递归运行时报错“RecursionError”。这是python默认的递归深度是很有限的（默认是1000），因此当递归深度超过999的样子，就会引发这样的一个异常。\n\n解决方法：首先考虑对代码进行优化，其次也可以考虑将递归深度的数值调大一些。\n\n```\nimport sys\nsys.setrecursionlimit(100000) #你想设置的递归深度（可为任意值）\n```\n\n\n\n","slug":"Python/语言基础/8、Python的一些语言特性与机制","published":1,"updated":"2020-07-16T16:05:16.616Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8tl0019l4js3dyy0gj8","content":"<p>代码高效、程序健壮</p>\n<p>值的类型，引用类型</p>\n<p>内存共享机制</p>\n<p>垃圾回收机制</p>\n<p>以引用计数为主，分代收集为辅</p>\n<p>每个对象都有指向该对象的引用总数</p>\n<pre><code>sys.getrefcount()</code></pre><p>满足特定条件，自动启动垃圾回收</p>\n<p>Python运行时，会记录分配对象与取消分配对象的次数。当两者差值高过阈值时。</p>\n<pre><code># 查看阈值\ngc.get_threshold()</code></pre><p>所有新建对象都是0代对象。所有对象分为0，1，2代。当某一代对象经历过垃圾回收，依然存活，则被归入下一代</p>\n<p>若一个对象的引用数为0，Python虚拟机就会回收这个对象的内存</p>\n<p>引用计数的缺陷是循环引用的问题</p>\n<p>递归运行时报错“RecursionError”。这是python默认的递归深度是很有限的（默认是1000），因此当递归深度超过999的样子，就会引发这样的一个异常。</p>\n<p>解决方法：首先考虑对代码进行优化，其次也可以考虑将递归深度的数值调大一些。</p>\n<pre><code>import sys\nsys.setrecursionlimit(100000) #你想设置的递归深度（可为任意值）</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>代码高效、程序健壮</p>\n<p>值的类型，引用类型</p>\n<p>内存共享机制</p>\n<p>垃圾回收机制</p>\n<p>以引用计数为主，分代收集为辅</p>\n<p>每个对象都有指向该对象的引用总数</p>\n<pre><code>sys.getrefcount()</code></pre><p>满足特定条件，自动启动垃圾回收</p>\n<p>Python运行时，会记录分配对象与取消分配对象的次数。当两者差值高过阈值时。</p>\n<pre><code># 查看阈值\ngc.get_threshold()</code></pre><p>所有新建对象都是0代对象。所有对象分为0，1，2代。当某一代对象经历过垃圾回收，依然存活，则被归入下一代</p>\n<p>若一个对象的引用数为0，Python虚拟机就会回收这个对象的内存</p>\n<p>引用计数的缺陷是循环引用的问题</p>\n<p>递归运行时报错“RecursionError”。这是python默认的递归深度是很有限的（默认是1000），因此当递归深度超过999的样子，就会引发这样的一个异常。</p>\n<p>解决方法：首先考虑对代码进行优化，其次也可以考虑将递归深度的数值调大一些。</p>\n<pre><code>import sys\nsys.setrecursionlimit(100000) #你想设置的递归深度（可为任意值）</code></pre>"},{"title":"Python中os模块的常用操作","date":"2020-06-20T01:41:07.000Z","fileName":"Python_os1","_content":"\n### 模块简介\n\nos模块是Python标准库中的一个用于**访问操作系统功能**的模块。使用os模块中提供的接口可以实现跨平台访问。\n\n\n\n### 系统操作\n\nos.sep：用于系统路径的分隔符。Windows为“\\\\\\”，Linux为“/”。\n\nos.name：指示正在使用的工作平台。Windows为‘nt’，Linux为‘posix’。\n\nos.getenv('path')：读取环境变量名称\n\nos.getcwd()：获取当前路径\n\nos.getpid()：获取当前进程ID\n\n\n\n### 目录操作\n\n**os.listdir(path)**：列出指定目录下的所有文件和子目录，包括隐藏文件；参数为空，为当前目录，返回一个列表。\n\nos.mkdir()：创建一个目录。\n\nos.rmdir()：删除一个空目录，如果该目录中有文件则删除不了。\n\n\n\n**os.rename(src, dst) **：用于重命名文件或目录，从src改为dst。若运行出错会抛出OSError。\n\n\n\n### Path模块\n\nos.path.exists(path)：判断文件或者目录是否存在。存在返回True，不存在返回False。\n\nos.path.isfile(path)：判断是否为文件。是返回True，不是返回False。\n\nos.path.isdir(path)：判断是否为目录。是返回True，不是返回False。\n\n\n\nos.path.abspath()：返回绝对路径\n\nos.path.realpath(\\__file__)：获取当前.py文件的目录\n\nos.path.dirname()：返回文件路径\n\nos.path.basename(path) ：返回文件名\n\n\n\nos.path.split(path) ：拆分路径dirname和basename，返回为元组\n\n**os.path.splitext('')**：将文件名与后缀名分开\n\n\n\n**os.path.join(path, name)**：连接目录与文件名或目录\n\n示例：\n\n```\nimport os\n\nfile_path = os.path.realpath(__file__)  # 该py文件目录\nprint(file_path)\nprint(os.path.dirname(file_path))   # 上级目录\nprint(os.path.basename(file_path))  # py文件名称\nprint(os.path.split(file_path)) # 分割目录与名称\n\n##############################################\nC:\\Users\\lenovo\\Desktop\\vega\\gg.py\nC:\\Users\\lenovo\\Desktop\\vega\ngg.py\n('C:\\\\Users\\\\lenovo\\\\Desktop\\\\vega', 'gg.py')\n```\n\n\n\n### 操作实例\n\n1、将某一路径下的文件名称中的广告部分去除并填上文件后缀名\n\n```\ndef rename():\n    path = '你的路径'\n    file_list = os.listdir(path)\t# 得到文件名列表\n    for file in file_list:\n        old_dir = os.path.join(path, file)\t#得到初始路径\n        # 若该文件名为路径，则继续遍历\n        if os.path.isdir(old_dir):\n            continue\n        file_name = os.path.splitext(file)[0]\n        # 在该处进行文件名的字符串更改操作\n        file_type = os.path.splitext(file)[1]\n        # 在该处变更文件的后缀\n        file_name = file_name+file_type\n        new_dir = os.path.join(path, file_name)\t# 新的路径\n        os.rename(old_dir, new_dir)\t# 完成文件的重命名\n```\n\n","source":"_posts/Python/语言基础/Python中os模块的常用操作.md","raw":"---\ntitle: Python中os模块的常用操作\ndate: 2020-06-20 09:41:07\ntags:\ncategories:\n\t- Python\n\t- 语言基础\nfileName: Python_os1\n---\n\n### 模块简介\n\nos模块是Python标准库中的一个用于**访问操作系统功能**的模块。使用os模块中提供的接口可以实现跨平台访问。\n\n\n\n### 系统操作\n\nos.sep：用于系统路径的分隔符。Windows为“\\\\\\”，Linux为“/”。\n\nos.name：指示正在使用的工作平台。Windows为‘nt’，Linux为‘posix’。\n\nos.getenv('path')：读取环境变量名称\n\nos.getcwd()：获取当前路径\n\nos.getpid()：获取当前进程ID\n\n\n\n### 目录操作\n\n**os.listdir(path)**：列出指定目录下的所有文件和子目录，包括隐藏文件；参数为空，为当前目录，返回一个列表。\n\nos.mkdir()：创建一个目录。\n\nos.rmdir()：删除一个空目录，如果该目录中有文件则删除不了。\n\n\n\n**os.rename(src, dst) **：用于重命名文件或目录，从src改为dst。若运行出错会抛出OSError。\n\n\n\n### Path模块\n\nos.path.exists(path)：判断文件或者目录是否存在。存在返回True，不存在返回False。\n\nos.path.isfile(path)：判断是否为文件。是返回True，不是返回False。\n\nos.path.isdir(path)：判断是否为目录。是返回True，不是返回False。\n\n\n\nos.path.abspath()：返回绝对路径\n\nos.path.realpath(\\__file__)：获取当前.py文件的目录\n\nos.path.dirname()：返回文件路径\n\nos.path.basename(path) ：返回文件名\n\n\n\nos.path.split(path) ：拆分路径dirname和basename，返回为元组\n\n**os.path.splitext('')**：将文件名与后缀名分开\n\n\n\n**os.path.join(path, name)**：连接目录与文件名或目录\n\n示例：\n\n```\nimport os\n\nfile_path = os.path.realpath(__file__)  # 该py文件目录\nprint(file_path)\nprint(os.path.dirname(file_path))   # 上级目录\nprint(os.path.basename(file_path))  # py文件名称\nprint(os.path.split(file_path)) # 分割目录与名称\n\n##############################################\nC:\\Users\\lenovo\\Desktop\\vega\\gg.py\nC:\\Users\\lenovo\\Desktop\\vega\ngg.py\n('C:\\\\Users\\\\lenovo\\\\Desktop\\\\vega', 'gg.py')\n```\n\n\n\n### 操作实例\n\n1、将某一路径下的文件名称中的广告部分去除并填上文件后缀名\n\n```\ndef rename():\n    path = '你的路径'\n    file_list = os.listdir(path)\t# 得到文件名列表\n    for file in file_list:\n        old_dir = os.path.join(path, file)\t#得到初始路径\n        # 若该文件名为路径，则继续遍历\n        if os.path.isdir(old_dir):\n            continue\n        file_name = os.path.splitext(file)[0]\n        # 在该处进行文件名的字符串更改操作\n        file_type = os.path.splitext(file)[1]\n        # 在该处变更文件的后缀\n        file_name = file_name+file_type\n        new_dir = os.path.join(path, file_name)\t# 新的路径\n        os.rename(old_dir, new_dir)\t# 完成文件的重命名\n```\n\n","slug":"Python/语言基础/Python中os模块的常用操作","published":1,"updated":"2020-07-16T16:05:45.601Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8to001bl4jsct5q07vg","content":"<h3 id=\"模块简介\"><a href=\"#模块简介\" class=\"headerlink\" title=\"模块简介\"></a>模块简介</h3><p>os模块是Python标准库中的一个用于<strong>访问操作系统功能</strong>的模块。使用os模块中提供的接口可以实现跨平台访问。</p>\n<h3 id=\"系统操作\"><a href=\"#系统操作\" class=\"headerlink\" title=\"系统操作\"></a>系统操作</h3><p>os.sep：用于系统路径的分隔符。Windows为“\\\\”，Linux为“/”。</p>\n<p>os.name：指示正在使用的工作平台。Windows为‘nt’，Linux为‘posix’。</p>\n<p>os.getenv(‘path’)：读取环境变量名称</p>\n<p>os.getcwd()：获取当前路径</p>\n<p>os.getpid()：获取当前进程ID</p>\n<h3 id=\"目录操作\"><a href=\"#目录操作\" class=\"headerlink\" title=\"目录操作\"></a>目录操作</h3><p><strong>os.listdir(path)</strong>：列出指定目录下的所有文件和子目录，包括隐藏文件；参数为空，为当前目录，返回一个列表。</p>\n<p>os.mkdir()：创建一个目录。</p>\n<p>os.rmdir()：删除一个空目录，如果该目录中有文件则删除不了。</p>\n<p>*<em>os.rename(src, dst) *</em>：用于重命名文件或目录，从src改为dst。若运行出错会抛出OSError。</p>\n<h3 id=\"Path模块\"><a href=\"#Path模块\" class=\"headerlink\" title=\"Path模块\"></a>Path模块</h3><p>os.path.exists(path)：判断文件或者目录是否存在。存在返回True，不存在返回False。</p>\n<p>os.path.isfile(path)：判断是否为文件。是返回True，不是返回False。</p>\n<p>os.path.isdir(path)：判断是否为目录。是返回True，不是返回False。</p>\n<p>os.path.abspath()：返回绝对路径</p>\n<p>os.path.realpath(_<em>file_</em>)：获取当前.py文件的目录</p>\n<p>os.path.dirname()：返回文件路径</p>\n<p>os.path.basename(path) ：返回文件名</p>\n<p>os.path.split(path) ：拆分路径dirname和basename，返回为元组</p>\n<p><strong>os.path.splitext(‘’)</strong>：将文件名与后缀名分开</p>\n<p><strong>os.path.join(path, name)</strong>：连接目录与文件名或目录</p>\n<p>示例：</p>\n<pre><code>import os\n\nfile_path = os.path.realpath(__file__)  # 该py文件目录\nprint(file_path)\nprint(os.path.dirname(file_path))   # 上级目录\nprint(os.path.basename(file_path))  # py文件名称\nprint(os.path.split(file_path)) # 分割目录与名称\n\n##############################################\nC:\\Users\\lenovo\\Desktop\\vega\\gg.py\nC:\\Users\\lenovo\\Desktop\\vega\ngg.py\n(&#39;C:\\\\Users\\\\lenovo\\\\Desktop\\\\vega&#39;, &#39;gg.py&#39;)</code></pre><h3 id=\"操作实例\"><a href=\"#操作实例\" class=\"headerlink\" title=\"操作实例\"></a>操作实例</h3><p>1、将某一路径下的文件名称中的广告部分去除并填上文件后缀名</p>\n<pre><code>def rename():\n    path = &#39;你的路径&#39;\n    file_list = os.listdir(path)    # 得到文件名列表\n    for file in file_list:\n        old_dir = os.path.join(path, file)    #得到初始路径\n        # 若该文件名为路径，则继续遍历\n        if os.path.isdir(old_dir):\n            continue\n        file_name = os.path.splitext(file)[0]\n        # 在该处进行文件名的字符串更改操作\n        file_type = os.path.splitext(file)[1]\n        # 在该处变更文件的后缀\n        file_name = file_name+file_type\n        new_dir = os.path.join(path, file_name)    # 新的路径\n        os.rename(old_dir, new_dir)    # 完成文件的重命名</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"模块简介\"><a href=\"#模块简介\" class=\"headerlink\" title=\"模块简介\"></a>模块简介</h3><p>os模块是Python标准库中的一个用于<strong>访问操作系统功能</strong>的模块。使用os模块中提供的接口可以实现跨平台访问。</p>\n<h3 id=\"系统操作\"><a href=\"#系统操作\" class=\"headerlink\" title=\"系统操作\"></a>系统操作</h3><p>os.sep：用于系统路径的分隔符。Windows为“\\\\”，Linux为“/”。</p>\n<p>os.name：指示正在使用的工作平台。Windows为‘nt’，Linux为‘posix’。</p>\n<p>os.getenv(‘path’)：读取环境变量名称</p>\n<p>os.getcwd()：获取当前路径</p>\n<p>os.getpid()：获取当前进程ID</p>\n<h3 id=\"目录操作\"><a href=\"#目录操作\" class=\"headerlink\" title=\"目录操作\"></a>目录操作</h3><p><strong>os.listdir(path)</strong>：列出指定目录下的所有文件和子目录，包括隐藏文件；参数为空，为当前目录，返回一个列表。</p>\n<p>os.mkdir()：创建一个目录。</p>\n<p>os.rmdir()：删除一个空目录，如果该目录中有文件则删除不了。</p>\n<p>*<em>os.rename(src, dst) *</em>：用于重命名文件或目录，从src改为dst。若运行出错会抛出OSError。</p>\n<h3 id=\"Path模块\"><a href=\"#Path模块\" class=\"headerlink\" title=\"Path模块\"></a>Path模块</h3><p>os.path.exists(path)：判断文件或者目录是否存在。存在返回True，不存在返回False。</p>\n<p>os.path.isfile(path)：判断是否为文件。是返回True，不是返回False。</p>\n<p>os.path.isdir(path)：判断是否为目录。是返回True，不是返回False。</p>\n<p>os.path.abspath()：返回绝对路径</p>\n<p>os.path.realpath(_<em>file_</em>)：获取当前.py文件的目录</p>\n<p>os.path.dirname()：返回文件路径</p>\n<p>os.path.basename(path) ：返回文件名</p>\n<p>os.path.split(path) ：拆分路径dirname和basename，返回为元组</p>\n<p><strong>os.path.splitext(‘’)</strong>：将文件名与后缀名分开</p>\n<p><strong>os.path.join(path, name)</strong>：连接目录与文件名或目录</p>\n<p>示例：</p>\n<pre><code>import os\n\nfile_path = os.path.realpath(__file__)  # 该py文件目录\nprint(file_path)\nprint(os.path.dirname(file_path))   # 上级目录\nprint(os.path.basename(file_path))  # py文件名称\nprint(os.path.split(file_path)) # 分割目录与名称\n\n##############################################\nC:\\Users\\lenovo\\Desktop\\vega\\gg.py\nC:\\Users\\lenovo\\Desktop\\vega\ngg.py\n(&#39;C:\\\\Users\\\\lenovo\\\\Desktop\\\\vega&#39;, &#39;gg.py&#39;)</code></pre><h3 id=\"操作实例\"><a href=\"#操作实例\" class=\"headerlink\" title=\"操作实例\"></a>操作实例</h3><p>1、将某一路径下的文件名称中的广告部分去除并填上文件后缀名</p>\n<pre><code>def rename():\n    path = &#39;你的路径&#39;\n    file_list = os.listdir(path)    # 得到文件名列表\n    for file in file_list:\n        old_dir = os.path.join(path, file)    #得到初始路径\n        # 若该文件名为路径，则继续遍历\n        if os.path.isdir(old_dir):\n            continue\n        file_name = os.path.splitext(file)[0]\n        # 在该处进行文件名的字符串更改操作\n        file_type = os.path.splitext(file)[1]\n        # 在该处变更文件的后缀\n        file_name = file_name+file_type\n        new_dir = os.path.join(path, file_name)    # 新的路径\n        os.rename(old_dir, new_dir)    # 完成文件的重命名</code></pre>"},{"title":"7、Python的线程与进程","date":"2020-05-18T01:59:00.000Z","fileName":"python7","_content":"\n\n\n\n\n\n\n\n\n内存池机制：当创建大量消耗小内存的对象时，频繁调用new/malloc会导致大量的内存碎片，使效率降低。\n\n内存池就是预先在内存中申请一定数量的、大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了再申请新的内存，这样做最显著的优势就是能够减小内存碎片，提升效率\n\n\n\npymalloc\n\n针对小对象，pymalloc会在内存池中申请内存空间\n\n大对象，申请新的内存空间\n\n\n\n\n\n### Python多线程\n\n进程：一个执行中的程序，每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据。操作系统管理其上所有进程，并为这些进程合理分配时间。\n\n\n\nthreading模块\n\n线程：在同一个进程下执行，并共享相同的上下文。一个进程中的各个线程与主线程共享同一片数据空间。\n\n线程包括开始、执行顺序、结束三部分\n\n可以被抢占（中断）和临时挂起（睡眠）\n\n一般以并发方式执行（是一种属性，并行只是并发问题的可能方法之一，若两个事件互不影响，则两个事件是并发的）\n\n\n\n对多核CPU的应用\n\nGIL——全局解释器锁（强制在任何时候只有一个线程可以执行python代码）\n\nI/O密集型应用（如网页之类），CPU密集型应用（数据分析，可借助C或CPP的拓展）\n\n\n\nGIL执行顺序\n\n\n\n实现一个线程\n\n```\nimport threading\nimport time\n\nclass LoopThread(threading.Thread):\n    n = 0\n    def run(self) -> None:\n        while self.n < 5:\n            now_thread = threading.current_thread()\n            print('loop now: {0}'.format(now_thread.name))\n            print(self.n)\n            time.sleep(1)\n            self.n += 1\n\nif __name__ == '__main__':\n    now_thread = threading.current_thread()\n    print('now: {0}'.format(now_thread.name))\n\n    t = LoopThread(name='loop_thread')\n    t.start()\n    t.join()\n    \n############################################\nnow: MainThread\nloop now: loop_thread\n0\nloop now: loop_thread\n1\nloop now: loop_thread\n2\nloop now: loop_thread\n3\nloop now: loop_thread\n4\n```\n\n\n\n多线程并发\n\n```\nimport threading\nimport time\n\nnum = 0\n\ndef test(n):\n    global num\n    num += n\n    time.sleep(2)\n    num -= n\n    time.sleep(1)\n    print('----------------{0}'.format(num))\n\nclass testThread(threading.Thread):\n    def __init__(self, n, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.n = n\n\n    def run(self) -> None:\n        for i in range(1000):\n            test(self.n)\n\nif __name__ == '__main__':\n    t1 = testThread(1)\n    t2 = testThread(2)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n    \n############################################\n----------------0\n----------------2\n----------------0\n----------------2\n----------------0\n----------------1\n----------------0\n----------------1\n```\n\n\n\n多线程中的锁\n\n`RLock`在一个线程中锁住了还能够再锁\n\n不能重复锁，否则资源被死锁\n\n```\nimport threading\nimport time\n\nnum = 0\nlock = threading.Lock()\n\ndef test(n):\n    global num\n    num += n\n    time.sleep(2)\n    num -= n\n    time.sleep(1)\n    print('----------------{0}'.format(num))\n\nclass testThread(threading.Thread):\n    def __init__(self, n, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.n = n\n\n    def run(self) -> None:\n        for i in range(1000):\n            lock.acquire()\n            try:\n                test(self.n)\n            finally:\n                lock.release()\n\nif __name__ == '__main__':\n    t1 = testThread(1)\n    t2 = testThread(2)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n    \n###########################################\n----------------0\n----------------0\n----------------0\n----------------0\n----------------0\n----------------0\n```\n\n\n\n产生死锁\n\n```\ndef run(self) -> None:\n    for i in range(1000):\n        print('start lock')\n        lock.acquire()\n        print('lock again')\n        lock.acquire()\n        print('lock end')\n        try:\n            test(self.n)\n        finally:\n            lock.release()\n            \n###########################################\nstart lock\nlock again\nstart lock\n```\n\n\n\n\n\n线程的调度与优化\n\n```\nimport threading, time\nfrom multiprocessing.dummy import Pool as ThreadPool\n\ndef run(n):\n    time.sleep(1)\n    print(threading.current_thread().name, n)\n\ndef test():\n    t1 = time.time()\n    for n in range(10):\n        run(n)\n    print(time.time() - t1)\n\n\nif __name__ == '__main__':\n    test()\n    \n########################################\nMainThread 0\nMainThread 1\nMainThread 2\nMainThread 3\nMainThread 4\nMainThread 5\nMainThread 6\nMainThread 7\nMainThread 8\nMainThread 9\n10.0053870677948\n```\n\n\n\n快了很多\n\n```\nimport threading, time\nfrom multiprocessing.dummy import Pool as ThreadPool\n\ndef run(n):\n    time.sleep(1)\n    print(threading.current_thread().name, n)\n\ndef test_use_thread():\n    t1 = time.time()\n    ls = []\n    for i in range(10):\n        t = threading.Thread(target=run, args=(i,))\n        ls.append(t)\n        t.start()\n\n    for l in ls:\n        l.join()\n    print(time.time() - t1)\n\ndef test():\n    t1 = time.time()\n    for n in range(10):\n        run(n)\n    print(time.time() - t1)\n\n\nif __name__ == '__main__':\n    test_use_thread()\n    \n###############################################\nThread-2 1\nThread-3 2\nThread-1 0\nThread-5 4\nThread-4 3\nThread-6 5\nThread-10 9\nThread-8 7\nThread-9 8\nThread-7 6\n1.0038871765136719\n```\n\n\n\n```\ndef test_use_pool():\n    t1 = time.time()\n    n_list = range(100)\n    pool = Pool(10)\n    pool.map(run, n_list)\n    pool.close()\n    pool.join()\n    print(time.time() - t1)\n```\n\n\n\n达到了线程的复用\n\n\n\n\n\n### Python进程\n\n进程的实现\n\n```\nimport time\nfrom multiprocessing import Process\n\ndef run(name):\n    \"\"\"\n    name: 进程名称\n    \"\"\"\n    print(\"进程名称：{}\".format(name))\n    time.sleep(5)\n    print(\"进程完成\")\n\nif __name__ == '__main__':\n    p = Process(target=run, args=('my process',))\n    p.start()\n    p.join()\n    \n##############################################\n进程名称：my process\n进程完成\n```\n\n使用过os模块下的`os.getpid()`可以得到当前进程的ID\n\n\n\n进程间的通信\n\n\n\n多进程中的锁：","source":"_posts/Python/语言基础/7、Python的线程与进程.md","raw":"---\ntitle: 7、Python的线程与进程\ndate: 2020-05-18 09:59:00\ntags:\ncategories:\n\t- Python\n\t- 语言基础\nfileName: python7\n---\n\n\n\n\n\n\n\n\n\n内存池机制：当创建大量消耗小内存的对象时，频繁调用new/malloc会导致大量的内存碎片，使效率降低。\n\n内存池就是预先在内存中申请一定数量的、大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了再申请新的内存，这样做最显著的优势就是能够减小内存碎片，提升效率\n\n\n\npymalloc\n\n针对小对象，pymalloc会在内存池中申请内存空间\n\n大对象，申请新的内存空间\n\n\n\n\n\n### Python多线程\n\n进程：一个执行中的程序，每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据。操作系统管理其上所有进程，并为这些进程合理分配时间。\n\n\n\nthreading模块\n\n线程：在同一个进程下执行，并共享相同的上下文。一个进程中的各个线程与主线程共享同一片数据空间。\n\n线程包括开始、执行顺序、结束三部分\n\n可以被抢占（中断）和临时挂起（睡眠）\n\n一般以并发方式执行（是一种属性，并行只是并发问题的可能方法之一，若两个事件互不影响，则两个事件是并发的）\n\n\n\n对多核CPU的应用\n\nGIL——全局解释器锁（强制在任何时候只有一个线程可以执行python代码）\n\nI/O密集型应用（如网页之类），CPU密集型应用（数据分析，可借助C或CPP的拓展）\n\n\n\nGIL执行顺序\n\n\n\n实现一个线程\n\n```\nimport threading\nimport time\n\nclass LoopThread(threading.Thread):\n    n = 0\n    def run(self) -> None:\n        while self.n < 5:\n            now_thread = threading.current_thread()\n            print('loop now: {0}'.format(now_thread.name))\n            print(self.n)\n            time.sleep(1)\n            self.n += 1\n\nif __name__ == '__main__':\n    now_thread = threading.current_thread()\n    print('now: {0}'.format(now_thread.name))\n\n    t = LoopThread(name='loop_thread')\n    t.start()\n    t.join()\n    \n############################################\nnow: MainThread\nloop now: loop_thread\n0\nloop now: loop_thread\n1\nloop now: loop_thread\n2\nloop now: loop_thread\n3\nloop now: loop_thread\n4\n```\n\n\n\n多线程并发\n\n```\nimport threading\nimport time\n\nnum = 0\n\ndef test(n):\n    global num\n    num += n\n    time.sleep(2)\n    num -= n\n    time.sleep(1)\n    print('----------------{0}'.format(num))\n\nclass testThread(threading.Thread):\n    def __init__(self, n, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.n = n\n\n    def run(self) -> None:\n        for i in range(1000):\n            test(self.n)\n\nif __name__ == '__main__':\n    t1 = testThread(1)\n    t2 = testThread(2)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n    \n############################################\n----------------0\n----------------2\n----------------0\n----------------2\n----------------0\n----------------1\n----------------0\n----------------1\n```\n\n\n\n多线程中的锁\n\n`RLock`在一个线程中锁住了还能够再锁\n\n不能重复锁，否则资源被死锁\n\n```\nimport threading\nimport time\n\nnum = 0\nlock = threading.Lock()\n\ndef test(n):\n    global num\n    num += n\n    time.sleep(2)\n    num -= n\n    time.sleep(1)\n    print('----------------{0}'.format(num))\n\nclass testThread(threading.Thread):\n    def __init__(self, n, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.n = n\n\n    def run(self) -> None:\n        for i in range(1000):\n            lock.acquire()\n            try:\n                test(self.n)\n            finally:\n                lock.release()\n\nif __name__ == '__main__':\n    t1 = testThread(1)\n    t2 = testThread(2)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n    \n###########################################\n----------------0\n----------------0\n----------------0\n----------------0\n----------------0\n----------------0\n```\n\n\n\n产生死锁\n\n```\ndef run(self) -> None:\n    for i in range(1000):\n        print('start lock')\n        lock.acquire()\n        print('lock again')\n        lock.acquire()\n        print('lock end')\n        try:\n            test(self.n)\n        finally:\n            lock.release()\n            \n###########################################\nstart lock\nlock again\nstart lock\n```\n\n\n\n\n\n线程的调度与优化\n\n```\nimport threading, time\nfrom multiprocessing.dummy import Pool as ThreadPool\n\ndef run(n):\n    time.sleep(1)\n    print(threading.current_thread().name, n)\n\ndef test():\n    t1 = time.time()\n    for n in range(10):\n        run(n)\n    print(time.time() - t1)\n\n\nif __name__ == '__main__':\n    test()\n    \n########################################\nMainThread 0\nMainThread 1\nMainThread 2\nMainThread 3\nMainThread 4\nMainThread 5\nMainThread 6\nMainThread 7\nMainThread 8\nMainThread 9\n10.0053870677948\n```\n\n\n\n快了很多\n\n```\nimport threading, time\nfrom multiprocessing.dummy import Pool as ThreadPool\n\ndef run(n):\n    time.sleep(1)\n    print(threading.current_thread().name, n)\n\ndef test_use_thread():\n    t1 = time.time()\n    ls = []\n    for i in range(10):\n        t = threading.Thread(target=run, args=(i,))\n        ls.append(t)\n        t.start()\n\n    for l in ls:\n        l.join()\n    print(time.time() - t1)\n\ndef test():\n    t1 = time.time()\n    for n in range(10):\n        run(n)\n    print(time.time() - t1)\n\n\nif __name__ == '__main__':\n    test_use_thread()\n    \n###############################################\nThread-2 1\nThread-3 2\nThread-1 0\nThread-5 4\nThread-4 3\nThread-6 5\nThread-10 9\nThread-8 7\nThread-9 8\nThread-7 6\n1.0038871765136719\n```\n\n\n\n```\ndef test_use_pool():\n    t1 = time.time()\n    n_list = range(100)\n    pool = Pool(10)\n    pool.map(run, n_list)\n    pool.close()\n    pool.join()\n    print(time.time() - t1)\n```\n\n\n\n达到了线程的复用\n\n\n\n\n\n### Python进程\n\n进程的实现\n\n```\nimport time\nfrom multiprocessing import Process\n\ndef run(name):\n    \"\"\"\n    name: 进程名称\n    \"\"\"\n    print(\"进程名称：{}\".format(name))\n    time.sleep(5)\n    print(\"进程完成\")\n\nif __name__ == '__main__':\n    p = Process(target=run, args=('my process',))\n    p.start()\n    p.join()\n    \n##############################################\n进程名称：my process\n进程完成\n```\n\n使用过os模块下的`os.getpid()`可以得到当前进程的ID\n\n\n\n进程间的通信\n\n\n\n多进程中的锁：","slug":"Python/语言基础/7、Python的线程与进程","published":1,"updated":"2020-07-16T16:05:05.555Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8tr001el4jsgba4dwnh","content":"<p>内存池机制：当创建大量消耗小内存的对象时，频繁调用new/malloc会导致大量的内存碎片，使效率降低。</p>\n<p>内存池就是预先在内存中申请一定数量的、大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了再申请新的内存，这样做最显著的优势就是能够减小内存碎片，提升效率</p>\n<p>pymalloc</p>\n<p>针对小对象，pymalloc会在内存池中申请内存空间</p>\n<p>大对象，申请新的内存空间</p>\n<h3 id=\"Python多线程\"><a href=\"#Python多线程\" class=\"headerlink\" title=\"Python多线程\"></a>Python多线程</h3><p>进程：一个执行中的程序，每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据。操作系统管理其上所有进程，并为这些进程合理分配时间。</p>\n<p>threading模块</p>\n<p>线程：在同一个进程下执行，并共享相同的上下文。一个进程中的各个线程与主线程共享同一片数据空间。</p>\n<p>线程包括开始、执行顺序、结束三部分</p>\n<p>可以被抢占（中断）和临时挂起（睡眠）</p>\n<p>一般以并发方式执行（是一种属性，并行只是并发问题的可能方法之一，若两个事件互不影响，则两个事件是并发的）</p>\n<p>对多核CPU的应用</p>\n<p>GIL——全局解释器锁（强制在任何时候只有一个线程可以执行python代码）</p>\n<p>I/O密集型应用（如网页之类），CPU密集型应用（数据分析，可借助C或CPP的拓展）</p>\n<p>GIL执行顺序</p>\n<p>实现一个线程</p>\n<pre><code>import threading\nimport time\n\nclass LoopThread(threading.Thread):\n    n = 0\n    def run(self) -&gt; None:\n        while self.n &lt; 5:\n            now_thread = threading.current_thread()\n            print(&#39;loop now: {0}&#39;.format(now_thread.name))\n            print(self.n)\n            time.sleep(1)\n            self.n += 1\n\nif __name__ == &#39;__main__&#39;:\n    now_thread = threading.current_thread()\n    print(&#39;now: {0}&#39;.format(now_thread.name))\n\n    t = LoopThread(name=&#39;loop_thread&#39;)\n    t.start()\n    t.join()\n\n############################################\nnow: MainThread\nloop now: loop_thread\n0\nloop now: loop_thread\n1\nloop now: loop_thread\n2\nloop now: loop_thread\n3\nloop now: loop_thread\n4</code></pre><p>多线程并发</p>\n<pre><code>import threading\nimport time\n\nnum = 0\n\ndef test(n):\n    global num\n    num += n\n    time.sleep(2)\n    num -= n\n    time.sleep(1)\n    print(&#39;----------------{0}&#39;.format(num))\n\nclass testThread(threading.Thread):\n    def __init__(self, n, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.n = n\n\n    def run(self) -&gt; None:\n        for i in range(1000):\n            test(self.n)\n\nif __name__ == &#39;__main__&#39;:\n    t1 = testThread(1)\n    t2 = testThread(2)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n\n############################################\n----------------0\n----------------2\n----------------0\n----------------2\n----------------0\n----------------1\n----------------0\n----------------1</code></pre><p>多线程中的锁</p>\n<p><code>RLock</code>在一个线程中锁住了还能够再锁</p>\n<p>不能重复锁，否则资源被死锁</p>\n<pre><code>import threading\nimport time\n\nnum = 0\nlock = threading.Lock()\n\ndef test(n):\n    global num\n    num += n\n    time.sleep(2)\n    num -= n\n    time.sleep(1)\n    print(&#39;----------------{0}&#39;.format(num))\n\nclass testThread(threading.Thread):\n    def __init__(self, n, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.n = n\n\n    def run(self) -&gt; None:\n        for i in range(1000):\n            lock.acquire()\n            try:\n                test(self.n)\n            finally:\n                lock.release()\n\nif __name__ == &#39;__main__&#39;:\n    t1 = testThread(1)\n    t2 = testThread(2)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n\n###########################################\n----------------0\n----------------0\n----------------0\n----------------0\n----------------0\n----------------0</code></pre><p>产生死锁</p>\n<pre><code>def run(self) -&gt; None:\n    for i in range(1000):\n        print(&#39;start lock&#39;)\n        lock.acquire()\n        print(&#39;lock again&#39;)\n        lock.acquire()\n        print(&#39;lock end&#39;)\n        try:\n            test(self.n)\n        finally:\n            lock.release()\n\n###########################################\nstart lock\nlock again\nstart lock</code></pre><p>线程的调度与优化</p>\n<pre><code>import threading, time\nfrom multiprocessing.dummy import Pool as ThreadPool\n\ndef run(n):\n    time.sleep(1)\n    print(threading.current_thread().name, n)\n\ndef test():\n    t1 = time.time()\n    for n in range(10):\n        run(n)\n    print(time.time() - t1)\n\n\nif __name__ == &#39;__main__&#39;:\n    test()\n\n########################################\nMainThread 0\nMainThread 1\nMainThread 2\nMainThread 3\nMainThread 4\nMainThread 5\nMainThread 6\nMainThread 7\nMainThread 8\nMainThread 9\n10.0053870677948</code></pre><p>快了很多</p>\n<pre><code>import threading, time\nfrom multiprocessing.dummy import Pool as ThreadPool\n\ndef run(n):\n    time.sleep(1)\n    print(threading.current_thread().name, n)\n\ndef test_use_thread():\n    t1 = time.time()\n    ls = []\n    for i in range(10):\n        t = threading.Thread(target=run, args=(i,))\n        ls.append(t)\n        t.start()\n\n    for l in ls:\n        l.join()\n    print(time.time() - t1)\n\ndef test():\n    t1 = time.time()\n    for n in range(10):\n        run(n)\n    print(time.time() - t1)\n\n\nif __name__ == &#39;__main__&#39;:\n    test_use_thread()\n\n###############################################\nThread-2 1\nThread-3 2\nThread-1 0\nThread-5 4\nThread-4 3\nThread-6 5\nThread-10 9\nThread-8 7\nThread-9 8\nThread-7 6\n1.0038871765136719</code></pre><pre><code>def test_use_pool():\n    t1 = time.time()\n    n_list = range(100)\n    pool = Pool(10)\n    pool.map(run, n_list)\n    pool.close()\n    pool.join()\n    print(time.time() - t1)</code></pre><p>达到了线程的复用</p>\n<h3 id=\"Python进程\"><a href=\"#Python进程\" class=\"headerlink\" title=\"Python进程\"></a>Python进程</h3><p>进程的实现</p>\n<pre><code>import time\nfrom multiprocessing import Process\n\ndef run(name):\n    &quot;&quot;&quot;\n    name: 进程名称\n    &quot;&quot;&quot;\n    print(&quot;进程名称：{}&quot;.format(name))\n    time.sleep(5)\n    print(&quot;进程完成&quot;)\n\nif __name__ == &#39;__main__&#39;:\n    p = Process(target=run, args=(&#39;my process&#39;,))\n    p.start()\n    p.join()\n\n##############################################\n进程名称：my process\n进程完成</code></pre><p>使用过os模块下的<code>os.getpid()</code>可以得到当前进程的ID</p>\n<p>进程间的通信</p>\n<p>多进程中的锁：</p>\n","site":{"data":{}},"excerpt":"","more":"<p>内存池机制：当创建大量消耗小内存的对象时，频繁调用new/malloc会导致大量的内存碎片，使效率降低。</p>\n<p>内存池就是预先在内存中申请一定数量的、大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了再申请新的内存，这样做最显著的优势就是能够减小内存碎片，提升效率</p>\n<p>pymalloc</p>\n<p>针对小对象，pymalloc会在内存池中申请内存空间</p>\n<p>大对象，申请新的内存空间</p>\n<h3 id=\"Python多线程\"><a href=\"#Python多线程\" class=\"headerlink\" title=\"Python多线程\"></a>Python多线程</h3><p>进程：一个执行中的程序，每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据。操作系统管理其上所有进程，并为这些进程合理分配时间。</p>\n<p>threading模块</p>\n<p>线程：在同一个进程下执行，并共享相同的上下文。一个进程中的各个线程与主线程共享同一片数据空间。</p>\n<p>线程包括开始、执行顺序、结束三部分</p>\n<p>可以被抢占（中断）和临时挂起（睡眠）</p>\n<p>一般以并发方式执行（是一种属性，并行只是并发问题的可能方法之一，若两个事件互不影响，则两个事件是并发的）</p>\n<p>对多核CPU的应用</p>\n<p>GIL——全局解释器锁（强制在任何时候只有一个线程可以执行python代码）</p>\n<p>I/O密集型应用（如网页之类），CPU密集型应用（数据分析，可借助C或CPP的拓展）</p>\n<p>GIL执行顺序</p>\n<p>实现一个线程</p>\n<pre><code>import threading\nimport time\n\nclass LoopThread(threading.Thread):\n    n = 0\n    def run(self) -&gt; None:\n        while self.n &lt; 5:\n            now_thread = threading.current_thread()\n            print(&#39;loop now: {0}&#39;.format(now_thread.name))\n            print(self.n)\n            time.sleep(1)\n            self.n += 1\n\nif __name__ == &#39;__main__&#39;:\n    now_thread = threading.current_thread()\n    print(&#39;now: {0}&#39;.format(now_thread.name))\n\n    t = LoopThread(name=&#39;loop_thread&#39;)\n    t.start()\n    t.join()\n\n############################################\nnow: MainThread\nloop now: loop_thread\n0\nloop now: loop_thread\n1\nloop now: loop_thread\n2\nloop now: loop_thread\n3\nloop now: loop_thread\n4</code></pre><p>多线程并发</p>\n<pre><code>import threading\nimport time\n\nnum = 0\n\ndef test(n):\n    global num\n    num += n\n    time.sleep(2)\n    num -= n\n    time.sleep(1)\n    print(&#39;----------------{0}&#39;.format(num))\n\nclass testThread(threading.Thread):\n    def __init__(self, n, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.n = n\n\n    def run(self) -&gt; None:\n        for i in range(1000):\n            test(self.n)\n\nif __name__ == &#39;__main__&#39;:\n    t1 = testThread(1)\n    t2 = testThread(2)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n\n############################################\n----------------0\n----------------2\n----------------0\n----------------2\n----------------0\n----------------1\n----------------0\n----------------1</code></pre><p>多线程中的锁</p>\n<p><code>RLock</code>在一个线程中锁住了还能够再锁</p>\n<p>不能重复锁，否则资源被死锁</p>\n<pre><code>import threading\nimport time\n\nnum = 0\nlock = threading.Lock()\n\ndef test(n):\n    global num\n    num += n\n    time.sleep(2)\n    num -= n\n    time.sleep(1)\n    print(&#39;----------------{0}&#39;.format(num))\n\nclass testThread(threading.Thread):\n    def __init__(self, n, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.n = n\n\n    def run(self) -&gt; None:\n        for i in range(1000):\n            lock.acquire()\n            try:\n                test(self.n)\n            finally:\n                lock.release()\n\nif __name__ == &#39;__main__&#39;:\n    t1 = testThread(1)\n    t2 = testThread(2)\n    t1.start()\n    t2.start()\n    t1.join()\n    t2.join()\n\n###########################################\n----------------0\n----------------0\n----------------0\n----------------0\n----------------0\n----------------0</code></pre><p>产生死锁</p>\n<pre><code>def run(self) -&gt; None:\n    for i in range(1000):\n        print(&#39;start lock&#39;)\n        lock.acquire()\n        print(&#39;lock again&#39;)\n        lock.acquire()\n        print(&#39;lock end&#39;)\n        try:\n            test(self.n)\n        finally:\n            lock.release()\n\n###########################################\nstart lock\nlock again\nstart lock</code></pre><p>线程的调度与优化</p>\n<pre><code>import threading, time\nfrom multiprocessing.dummy import Pool as ThreadPool\n\ndef run(n):\n    time.sleep(1)\n    print(threading.current_thread().name, n)\n\ndef test():\n    t1 = time.time()\n    for n in range(10):\n        run(n)\n    print(time.time() - t1)\n\n\nif __name__ == &#39;__main__&#39;:\n    test()\n\n########################################\nMainThread 0\nMainThread 1\nMainThread 2\nMainThread 3\nMainThread 4\nMainThread 5\nMainThread 6\nMainThread 7\nMainThread 8\nMainThread 9\n10.0053870677948</code></pre><p>快了很多</p>\n<pre><code>import threading, time\nfrom multiprocessing.dummy import Pool as ThreadPool\n\ndef run(n):\n    time.sleep(1)\n    print(threading.current_thread().name, n)\n\ndef test_use_thread():\n    t1 = time.time()\n    ls = []\n    for i in range(10):\n        t = threading.Thread(target=run, args=(i,))\n        ls.append(t)\n        t.start()\n\n    for l in ls:\n        l.join()\n    print(time.time() - t1)\n\ndef test():\n    t1 = time.time()\n    for n in range(10):\n        run(n)\n    print(time.time() - t1)\n\n\nif __name__ == &#39;__main__&#39;:\n    test_use_thread()\n\n###############################################\nThread-2 1\nThread-3 2\nThread-1 0\nThread-5 4\nThread-4 3\nThread-6 5\nThread-10 9\nThread-8 7\nThread-9 8\nThread-7 6\n1.0038871765136719</code></pre><pre><code>def test_use_pool():\n    t1 = time.time()\n    n_list = range(100)\n    pool = Pool(10)\n    pool.map(run, n_list)\n    pool.close()\n    pool.join()\n    print(time.time() - t1)</code></pre><p>达到了线程的复用</p>\n<h3 id=\"Python进程\"><a href=\"#Python进程\" class=\"headerlink\" title=\"Python进程\"></a>Python进程</h3><p>进程的实现</p>\n<pre><code>import time\nfrom multiprocessing import Process\n\ndef run(name):\n    &quot;&quot;&quot;\n    name: 进程名称\n    &quot;&quot;&quot;\n    print(&quot;进程名称：{}&quot;.format(name))\n    time.sleep(5)\n    print(&quot;进程完成&quot;)\n\nif __name__ == &#39;__main__&#39;:\n    p = Process(target=run, args=(&#39;my process&#39;,))\n    p.start()\n    p.join()\n\n##############################################\n进程名称：my process\n进程完成</code></pre><p>使用过os模块下的<code>os.getpid()</code>可以得到当前进程的ID</p>\n<p>进程间的通信</p>\n<p>多进程中的锁：</p>\n"},{"title":"pythonic的编码方式","date":"2020-06-30T02:23:28.000Z","fileName":"pythonic","_content":"\n### 变量的交换\n\n```\na, b = b, a\n```\n\n### 利用百分号语法进行字符串格式化\n\n\n\n```\na = Curry\nb = Player\nprint(\"%s is the best %s\" % (a,b))\n```\n\n\n\nenumerate() 提供列表的索引值和数值\n\n\n\n将两个字典合并\n\n```\na = {}\nb = {}\nc = {**a, **b}\t# 解包\n```\n\n","source":"_posts/Python/语言基础/pythonic的编码方式.md","raw":"---\ntitle: pythonic的编码方式\ndate: 2020-06-30 10:23:28\ntags:\ncategories:\n\t- Python\n\t- 语言基础\nfileName: pythonic\n---\n\n### 变量的交换\n\n```\na, b = b, a\n```\n\n### 利用百分号语法进行字符串格式化\n\n\n\n```\na = Curry\nb = Player\nprint(\"%s is the best %s\" % (a,b))\n```\n\n\n\nenumerate() 提供列表的索引值和数值\n\n\n\n将两个字典合并\n\n```\na = {}\nb = {}\nc = {**a, **b}\t# 解包\n```\n\n","slug":"Python/语言基础/pythonic的编码方式","published":1,"updated":"2020-07-16T16:05:34.593Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8tt001gl4jsh9x9bte9","content":"<h3 id=\"变量的交换\"><a href=\"#变量的交换\" class=\"headerlink\" title=\"变量的交换\"></a>变量的交换</h3><pre><code>a, b = b, a</code></pre><h3 id=\"利用百分号语法进行字符串格式化\"><a href=\"#利用百分号语法进行字符串格式化\" class=\"headerlink\" title=\"利用百分号语法进行字符串格式化\"></a>利用百分号语法进行字符串格式化</h3><pre><code>a = Curry\nb = Player\nprint(&quot;%s is the best %s&quot; % (a,b))</code></pre><p>enumerate() 提供列表的索引值和数值</p>\n<p>将两个字典合并</p>\n<pre><code>a = {}\nb = {}\nc = {**a, **b}    # 解包</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"变量的交换\"><a href=\"#变量的交换\" class=\"headerlink\" title=\"变量的交换\"></a>变量的交换</h3><pre><code>a, b = b, a</code></pre><h3 id=\"利用百分号语法进行字符串格式化\"><a href=\"#利用百分号语法进行字符串格式化\" class=\"headerlink\" title=\"利用百分号语法进行字符串格式化\"></a>利用百分号语法进行字符串格式化</h3><pre><code>a = Curry\nb = Player\nprint(&quot;%s is the best %s&quot; % (a,b))</code></pre><p>enumerate() 提供列表的索引值和数值</p>\n<p>将两个字典合并</p>\n<pre><code>a = {}\nb = {}\nc = {**a, **b}    # 解包</code></pre>"},{"title":"全卷积神经网络（FCN）","date":"2020-03-23T03:50:01.000Z","fileName":"FCN","_content":"\nFully Convolutional Networks for Semantic Segmentation\t（2015 CVPR）\n\n### 核心思想\n\n建立全卷积神经网络，将经典的分类网络如AlexNet、VGG、GoogLeNet中网络结构最后的全连接层用上采样替换\n\npixelwise prediction\n\n\n\n\n\n### 主要内容\n\n1. **全卷积化**\n\n* 将经典CNN网络结构最后的全连接层替换为卷积层（即对最后一个特征图（feature）进行反卷积操作），使得输出图像与输入图像的尺寸完全一致。\n* 经典CNN网络全连接层后对图像进行分类改为了对所有像素都进行softmax分类计算。可以理解为传统分类网络将一幅图像作为一个分类样本，而FCN则将图像中的每一个像素作为分类样本。这样其实就解决了图像语义分割的问题，即进行了密集预测（dense prediction）\n\n\n\n2. 进行了对特征图的**上采样**\n\n文中主要提出了三种上采样方法\n\n1. Shift-and-Stitch\n2. decreasing subsampling\n3. Deconvolution\n\n\n\n3. 使用了**跳跃结构**（ skip architecture）\n\n> We address this by **adding skips** that combine the final prediction layer with lower layers with finer strides\n\n使用跳跃结构融合多层输出，使得网络能够预测更多的位置信息。因为在浅层网络位置信息等保留的比较好，将他们加入到深层输出中，就可以预测到更精细的信息。\n\n本文的做法为将对应的两个位置的网络进行逐元素相加的处理。","source":"_posts/学习笔记/论文/全卷积神经网络（FCN）.md","raw":"---\ntitle: 全卷积神经网络（FCN）\ndate: 2020-03-23 11:50:01\ntags:\n\t- CNN\n\t- 语义分割\ncategories:\n\t- 学习笔记\n\t- 论文\nfileName: FCN\n---\n\nFully Convolutional Networks for Semantic Segmentation\t（2015 CVPR）\n\n### 核心思想\n\n建立全卷积神经网络，将经典的分类网络如AlexNet、VGG、GoogLeNet中网络结构最后的全连接层用上采样替换\n\npixelwise prediction\n\n\n\n\n\n### 主要内容\n\n1. **全卷积化**\n\n* 将经典CNN网络结构最后的全连接层替换为卷积层（即对最后一个特征图（feature）进行反卷积操作），使得输出图像与输入图像的尺寸完全一致。\n* 经典CNN网络全连接层后对图像进行分类改为了对所有像素都进行softmax分类计算。可以理解为传统分类网络将一幅图像作为一个分类样本，而FCN则将图像中的每一个像素作为分类样本。这样其实就解决了图像语义分割的问题，即进行了密集预测（dense prediction）\n\n\n\n2. 进行了对特征图的**上采样**\n\n文中主要提出了三种上采样方法\n\n1. Shift-and-Stitch\n2. decreasing subsampling\n3. Deconvolution\n\n\n\n3. 使用了**跳跃结构**（ skip architecture）\n\n> We address this by **adding skips** that combine the final prediction layer with lower layers with finer strides\n\n使用跳跃结构融合多层输出，使得网络能够预测更多的位置信息。因为在浅层网络位置信息等保留的比较好，将他们加入到深层输出中，就可以预测到更精细的信息。\n\n本文的做法为将对应的两个位置的网络进行逐元素相加的处理。","slug":"学习笔记/论文/全卷积神经网络（FCN）","published":1,"updated":"2020-07-16T15:58:47.901Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8ub001tl4jsae811ozx","content":"<p>Fully Convolutional Networks for Semantic Segmentation    （2015 CVPR）</p>\n<h3 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h3><p>建立全卷积神经网络，将经典的分类网络如AlexNet、VGG、GoogLeNet中网络结构最后的全连接层用上采样替换</p>\n<p>pixelwise prediction</p>\n<h3 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h3><ol>\n<li><strong>全卷积化</strong></li>\n</ol>\n<ul>\n<li>将经典CNN网络结构最后的全连接层替换为卷积层（即对最后一个特征图（feature）进行反卷积操作），使得输出图像与输入图像的尺寸完全一致。</li>\n<li>经典CNN网络全连接层后对图像进行分类改为了对所有像素都进行softmax分类计算。可以理解为传统分类网络将一幅图像作为一个分类样本，而FCN则将图像中的每一个像素作为分类样本。这样其实就解决了图像语义分割的问题，即进行了密集预测（dense prediction）</li>\n</ul>\n<ol start=\"2\">\n<li>进行了对特征图的<strong>上采样</strong></li>\n</ol>\n<p>文中主要提出了三种上采样方法</p>\n<ol>\n<li>Shift-and-Stitch</li>\n<li>decreasing subsampling</li>\n<li>Deconvolution</li>\n</ol>\n<ol start=\"3\">\n<li>使用了<strong>跳跃结构</strong>（ skip architecture）</li>\n</ol>\n<blockquote>\n<p>We address this by <strong>adding skips</strong> that combine the final prediction layer with lower layers with finer strides</p>\n</blockquote>\n<p>使用跳跃结构融合多层输出，使得网络能够预测更多的位置信息。因为在浅层网络位置信息等保留的比较好，将他们加入到深层输出中，就可以预测到更精细的信息。</p>\n<p>本文的做法为将对应的两个位置的网络进行逐元素相加的处理。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Fully Convolutional Networks for Semantic Segmentation    （2015 CVPR）</p>\n<h3 id=\"核心思想\"><a href=\"#核心思想\" class=\"headerlink\" title=\"核心思想\"></a>核心思想</h3><p>建立全卷积神经网络，将经典的分类网络如AlexNet、VGG、GoogLeNet中网络结构最后的全连接层用上采样替换</p>\n<p>pixelwise prediction</p>\n<h3 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h3><ol>\n<li><strong>全卷积化</strong></li>\n</ol>\n<ul>\n<li>将经典CNN网络结构最后的全连接层替换为卷积层（即对最后一个特征图（feature）进行反卷积操作），使得输出图像与输入图像的尺寸完全一致。</li>\n<li>经典CNN网络全连接层后对图像进行分类改为了对所有像素都进行softmax分类计算。可以理解为传统分类网络将一幅图像作为一个分类样本，而FCN则将图像中的每一个像素作为分类样本。这样其实就解决了图像语义分割的问题，即进行了密集预测（dense prediction）</li>\n</ul>\n<ol start=\"2\">\n<li>进行了对特征图的<strong>上采样</strong></li>\n</ol>\n<p>文中主要提出了三种上采样方法</p>\n<ol>\n<li>Shift-and-Stitch</li>\n<li>decreasing subsampling</li>\n<li>Deconvolution</li>\n</ol>\n<ol start=\"3\">\n<li>使用了<strong>跳跃结构</strong>（ skip architecture）</li>\n</ol>\n<blockquote>\n<p>We address this by <strong>adding skips</strong> that combine the final prediction layer with lower layers with finer strides</p>\n</blockquote>\n<p>使用跳跃结构融合多层输出，使得网络能够预测更多的位置信息。因为在浅层网络位置信息等保留的比较好，将他们加入到深层输出中，就可以预测到更精细的信息。</p>\n<p>本文的做法为将对应的两个位置的网络进行逐元素相加的处理。</p>\n"},{"title":"SQL语句——查","date":"2020-06-10T09:30:10.000Z","fileName":"mysql2","_content":"\n### SELECT语句\n\n1、基本使用框架\n\n```\nSELECT * FROM 数据表\n[WHERE]\n[LIMIT]\n[OFFSET]\n```\n\n2、使用别名\n\n```\nSELECT\n\t字段名 AS 别名\nFROM 数据表\n```\n\n3、查询语句的执行顺序：\n\n先进行语法分析和优化，找到关键字优先级，先执行FROM，再执行SELECT\n\n\n\n\n\n### 查询相关功能\n\n1、**ORDER BY**子句功能，对查询的结果进行**排序**，示例如下\n\n```\n// 按照相关信息进行排序\nSELECT * FROM * ORDER BY 列名 [ASC|DESC]\n// 多个排序信息\nSELECT * FROM * ORDER BY 列名 [ASC|DESC],列名 [ASC|DESC]\n```\n\n\n\n2、去除结果中的**重复记录**，在字段名称前加上**DISTINCT**字段，只支持一个字段名。\n\n```\nSELECT DISTINCT 字段名 FROM *;\n```\n\n\n\n3、**条件查询**，使用**WHERE**语句指定查询的条件逻辑，中间使用AND|OR等逻辑连接符连接，同时注意判断相等的条件是“=”而不是“==”。\n\n```\nSELECT * FROM * WHERE 条件1 [AND|OR] 条件2 ......;\n```\n\n\n\n4、使用**聚合函数**。所谓聚合函数，也就是平均值、最大值等函数，以下为求该字段名下的平均值函数（AVG），其他函数使用方法与此类似。该类方法在实际使用时可以将统计结果作为一个子表进行查询。\n\n```\nSELECT AVG(字段名) FROM 表名\n```\n\n**COUNT(*)**用于获得包含空值的记录数，**COUNT(字段名)**用于获取包含非空值的记录数。\n\n\n\n5、**分组查询**，使用**GROUP BY**字句。即通过一定规则将数据集分为若干个部分进行查询处理。以下即为使用字段1进行分组统计每一组中字段2的平均值。\n\n```\nSELECT 字段1,AVG(字段2) FROM 表名 GROUP BY 字段1;\n```\n\n使用分组查询SELECT语句中只能出现用以分组的字段以及其他字段的聚合函数，否则会报错（由于产生了**一对多**的关系）。为解决这个问题，可以使用`GROUP_CONCAT`函数，这个函数可以将符合条件的值连接起来进行输出，可以理解为将“多”的部分进行了字符串拼接。\n\n```\nSELECT 字段1,GROUP_CONCAT(字段2) FROM 表名 GROUP BY 字段1;\n```\n\n同时可以加上`WITH ROLLUP`再进行一次汇总运算（即在返回的查询结果之下再加上一条汇总记录）。\n\n```\nSELECT 字段1,AVG(字段2) FROM 表名 GROUP BY 字段1 WITH ROLLUP;\n```\n\n\n\n6、**HAVING**子句，以及为何要使用HAVING子句\n\n由于WHERE子句执行在GROUP BY子句之前，因此如果WHERE子句中出现了如平均值等信息时SQL会不知道在哪个范围内进行平均，因此会出错，如以下代码即为错误的（聚合函数作为判断条件）。所以需要使用`HAVING`子句。\n\n```\n# 使用错误\nSELECT f1\nFROM table\nWHERE AVG(f2) > 10\nGROUP BY f1;\n```\n\n```\n# 使用正确\nSELECT f1\nFROM table\nGROUP BY f1 HAVING AVG(f2) > 10;\n```\n\n\n\n\n\n### 表的连接\n\n表的连接很重要，具体有内外两种连接构成。\n\n1、**内连接**：结果集中只保留符合连接条件的记录\n\n```\nSELECT * FROM 表1 [INNER] JOIN 表2 ON 连接条件;\n\nSELECT * FROM 表1 [INNER] JOIN 表2 WHERE 连接条件;\n\nSELECT * FROM 表1, 表2 WHERE 连接条件;\n```\n\n\n\n2、**外连接**：不管是否符合连接条件，记录都要保留在结果集里\n\n```\n// 右表出NULL值和左表连接\nLEFT JOIN \n```\n\n\n\n3、**内外连接的区别**。具体如图所示（图片摘自LeetCode）\n\n1）左联结（left join），联结结果保留左表的全部数据\n2）右联结（right join），联结结果保留右表的全部数据\n3）内联结（inner join），取两表的公共数据\n\n![](\\SQL语句——查\\sql连接.png)\n\n应用在[175.组合两个表中](https://leetcode-cn.com/problems/combine-two-tables/)。该题需要满足“无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息”，所以当person表在左时采用左连接。\n\n\n\n### 一些注意事项\n\n1、**表连接时on和where的区别**\n\n\n\n\n\n以下不推荐，因为查询速度会很慢，每一次都会执行WHERE语句中的内容。\n\n```\nSELECT ename \nFROM t_emp\nWHERE deptno = (SELECT deptno FROM t_emp WHERE ename=\"SCOTT\")\n```\n\n\n\n```\nSELECT e2.ename\nFROM t_emp e1 JOIN t_emp e2 ON e1.deptno=e2.deptno\nWHERE e1.ename = \"SCOTT\"\n```\n\n\n\n将AVG的结果视为一个表，与原表进行连接。\n\n错误\n\n```\nSELECT e2.ename\nFROM t_emp e1 JOIN t_emp e2 ON e2.sal >= AVG(e1.sal)\n```\n\n正确\n\n```\nSELECT e.ename\nFROM t_emp e \nJOIN (SELECT AVG(sal) avg FROM t_emp) t\nON e.sal >= t.avg;\n```\n\n","source":"_posts/数据库/MySQL/SQL语句——查.md","raw":"---\ntitle: SQL语句——查\ndate: 2020-06-10 17:30:10\ntags:\n\t- 数据库\ncategories:\n\t- 数据库\n\t- MySQL\nfileName: mysql2\n---\n\n### SELECT语句\n\n1、基本使用框架\n\n```\nSELECT * FROM 数据表\n[WHERE]\n[LIMIT]\n[OFFSET]\n```\n\n2、使用别名\n\n```\nSELECT\n\t字段名 AS 别名\nFROM 数据表\n```\n\n3、查询语句的执行顺序：\n\n先进行语法分析和优化，找到关键字优先级，先执行FROM，再执行SELECT\n\n\n\n\n\n### 查询相关功能\n\n1、**ORDER BY**子句功能，对查询的结果进行**排序**，示例如下\n\n```\n// 按照相关信息进行排序\nSELECT * FROM * ORDER BY 列名 [ASC|DESC]\n// 多个排序信息\nSELECT * FROM * ORDER BY 列名 [ASC|DESC],列名 [ASC|DESC]\n```\n\n\n\n2、去除结果中的**重复记录**，在字段名称前加上**DISTINCT**字段，只支持一个字段名。\n\n```\nSELECT DISTINCT 字段名 FROM *;\n```\n\n\n\n3、**条件查询**，使用**WHERE**语句指定查询的条件逻辑，中间使用AND|OR等逻辑连接符连接，同时注意判断相等的条件是“=”而不是“==”。\n\n```\nSELECT * FROM * WHERE 条件1 [AND|OR] 条件2 ......;\n```\n\n\n\n4、使用**聚合函数**。所谓聚合函数，也就是平均值、最大值等函数，以下为求该字段名下的平均值函数（AVG），其他函数使用方法与此类似。该类方法在实际使用时可以将统计结果作为一个子表进行查询。\n\n```\nSELECT AVG(字段名) FROM 表名\n```\n\n**COUNT(*)**用于获得包含空值的记录数，**COUNT(字段名)**用于获取包含非空值的记录数。\n\n\n\n5、**分组查询**，使用**GROUP BY**字句。即通过一定规则将数据集分为若干个部分进行查询处理。以下即为使用字段1进行分组统计每一组中字段2的平均值。\n\n```\nSELECT 字段1,AVG(字段2) FROM 表名 GROUP BY 字段1;\n```\n\n使用分组查询SELECT语句中只能出现用以分组的字段以及其他字段的聚合函数，否则会报错（由于产生了**一对多**的关系）。为解决这个问题，可以使用`GROUP_CONCAT`函数，这个函数可以将符合条件的值连接起来进行输出，可以理解为将“多”的部分进行了字符串拼接。\n\n```\nSELECT 字段1,GROUP_CONCAT(字段2) FROM 表名 GROUP BY 字段1;\n```\n\n同时可以加上`WITH ROLLUP`再进行一次汇总运算（即在返回的查询结果之下再加上一条汇总记录）。\n\n```\nSELECT 字段1,AVG(字段2) FROM 表名 GROUP BY 字段1 WITH ROLLUP;\n```\n\n\n\n6、**HAVING**子句，以及为何要使用HAVING子句\n\n由于WHERE子句执行在GROUP BY子句之前，因此如果WHERE子句中出现了如平均值等信息时SQL会不知道在哪个范围内进行平均，因此会出错，如以下代码即为错误的（聚合函数作为判断条件）。所以需要使用`HAVING`子句。\n\n```\n# 使用错误\nSELECT f1\nFROM table\nWHERE AVG(f2) > 10\nGROUP BY f1;\n```\n\n```\n# 使用正确\nSELECT f1\nFROM table\nGROUP BY f1 HAVING AVG(f2) > 10;\n```\n\n\n\n\n\n### 表的连接\n\n表的连接很重要，具体有内外两种连接构成。\n\n1、**内连接**：结果集中只保留符合连接条件的记录\n\n```\nSELECT * FROM 表1 [INNER] JOIN 表2 ON 连接条件;\n\nSELECT * FROM 表1 [INNER] JOIN 表2 WHERE 连接条件;\n\nSELECT * FROM 表1, 表2 WHERE 连接条件;\n```\n\n\n\n2、**外连接**：不管是否符合连接条件，记录都要保留在结果集里\n\n```\n// 右表出NULL值和左表连接\nLEFT JOIN \n```\n\n\n\n3、**内外连接的区别**。具体如图所示（图片摘自LeetCode）\n\n1）左联结（left join），联结结果保留左表的全部数据\n2）右联结（right join），联结结果保留右表的全部数据\n3）内联结（inner join），取两表的公共数据\n\n![](\\SQL语句——查\\sql连接.png)\n\n应用在[175.组合两个表中](https://leetcode-cn.com/problems/combine-two-tables/)。该题需要满足“无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息”，所以当person表在左时采用左连接。\n\n\n\n### 一些注意事项\n\n1、**表连接时on和where的区别**\n\n\n\n\n\n以下不推荐，因为查询速度会很慢，每一次都会执行WHERE语句中的内容。\n\n```\nSELECT ename \nFROM t_emp\nWHERE deptno = (SELECT deptno FROM t_emp WHERE ename=\"SCOTT\")\n```\n\n\n\n```\nSELECT e2.ename\nFROM t_emp e1 JOIN t_emp e2 ON e1.deptno=e2.deptno\nWHERE e1.ename = \"SCOTT\"\n```\n\n\n\n将AVG的结果视为一个表，与原表进行连接。\n\n错误\n\n```\nSELECT e2.ename\nFROM t_emp e1 JOIN t_emp e2 ON e2.sal >= AVG(e1.sal)\n```\n\n正确\n\n```\nSELECT e.ename\nFROM t_emp e \nJOIN (SELECT AVG(sal) avg FROM t_emp) t\nON e.sal >= t.avg;\n```\n\n","slug":"数据库/MySQL/SQL语句——查","published":1,"updated":"2020-06-29T07:10:29.612Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8uc001vl4js3skp5h9k","content":"<h3 id=\"SELECT语句\"><a href=\"#SELECT语句\" class=\"headerlink\" title=\"SELECT语句\"></a>SELECT语句</h3><p>1、基本使用框架</p>\n<pre><code>SELECT * FROM 数据表\n[WHERE]\n[LIMIT]\n[OFFSET]</code></pre><p>2、使用别名</p>\n<pre><code>SELECT\n    字段名 AS 别名\nFROM 数据表</code></pre><p>3、查询语句的执行顺序：</p>\n<p>先进行语法分析和优化，找到关键字优先级，先执行FROM，再执行SELECT</p>\n<h3 id=\"查询相关功能\"><a href=\"#查询相关功能\" class=\"headerlink\" title=\"查询相关功能\"></a>查询相关功能</h3><p>1、<strong>ORDER BY</strong>子句功能，对查询的结果进行<strong>排序</strong>，示例如下</p>\n<pre><code>// 按照相关信息进行排序\nSELECT * FROM * ORDER BY 列名 [ASC|DESC]\n// 多个排序信息\nSELECT * FROM * ORDER BY 列名 [ASC|DESC],列名 [ASC|DESC]</code></pre><p>2、去除结果中的<strong>重复记录</strong>，在字段名称前加上<strong>DISTINCT</strong>字段，只支持一个字段名。</p>\n<pre><code>SELECT DISTINCT 字段名 FROM *;</code></pre><p>3、<strong>条件查询</strong>，使用<strong>WHERE</strong>语句指定查询的条件逻辑，中间使用AND|OR等逻辑连接符连接，同时注意判断相等的条件是“=”而不是“==”。</p>\n<pre><code>SELECT * FROM * WHERE 条件1 [AND|OR] 条件2 ......;</code></pre><p>4、使用<strong>聚合函数</strong>。所谓聚合函数，也就是平均值、最大值等函数，以下为求该字段名下的平均值函数（AVG），其他函数使用方法与此类似。该类方法在实际使用时可以将统计结果作为一个子表进行查询。</p>\n<pre><code>SELECT AVG(字段名) FROM 表名</code></pre><p><strong>COUNT(*)</strong>用于获得包含空值的记录数，<strong>COUNT(字段名)</strong>用于获取包含非空值的记录数。</p>\n<p>5、<strong>分组查询</strong>，使用<strong>GROUP BY</strong>字句。即通过一定规则将数据集分为若干个部分进行查询处理。以下即为使用字段1进行分组统计每一组中字段2的平均值。</p>\n<pre><code>SELECT 字段1,AVG(字段2) FROM 表名 GROUP BY 字段1;</code></pre><p>使用分组查询SELECT语句中只能出现用以分组的字段以及其他字段的聚合函数，否则会报错（由于产生了<strong>一对多</strong>的关系）。为解决这个问题，可以使用<code>GROUP_CONCAT</code>函数，这个函数可以将符合条件的值连接起来进行输出，可以理解为将“多”的部分进行了字符串拼接。</p>\n<pre><code>SELECT 字段1,GROUP_CONCAT(字段2) FROM 表名 GROUP BY 字段1;</code></pre><p>同时可以加上<code>WITH ROLLUP</code>再进行一次汇总运算（即在返回的查询结果之下再加上一条汇总记录）。</p>\n<pre><code>SELECT 字段1,AVG(字段2) FROM 表名 GROUP BY 字段1 WITH ROLLUP;</code></pre><p>6、<strong>HAVING</strong>子句，以及为何要使用HAVING子句</p>\n<p>由于WHERE子句执行在GROUP BY子句之前，因此如果WHERE子句中出现了如平均值等信息时SQL会不知道在哪个范围内进行平均，因此会出错，如以下代码即为错误的（聚合函数作为判断条件）。所以需要使用<code>HAVING</code>子句。</p>\n<pre><code># 使用错误\nSELECT f1\nFROM table\nWHERE AVG(f2) &gt; 10\nGROUP BY f1;</code></pre><pre><code># 使用正确\nSELECT f1\nFROM table\nGROUP BY f1 HAVING AVG(f2) &gt; 10;</code></pre><h3 id=\"表的连接\"><a href=\"#表的连接\" class=\"headerlink\" title=\"表的连接\"></a>表的连接</h3><p>表的连接很重要，具体有内外两种连接构成。</p>\n<p>1、<strong>内连接</strong>：结果集中只保留符合连接条件的记录</p>\n<pre><code>SELECT * FROM 表1 [INNER] JOIN 表2 ON 连接条件;\n\nSELECT * FROM 表1 [INNER] JOIN 表2 WHERE 连接条件;\n\nSELECT * FROM 表1, 表2 WHERE 连接条件;</code></pre><p>2、<strong>外连接</strong>：不管是否符合连接条件，记录都要保留在结果集里</p>\n<pre><code>// 右表出NULL值和左表连接\nLEFT JOIN </code></pre><p>3、<strong>内外连接的区别</strong>。具体如图所示（图片摘自LeetCode）</p>\n<p>1）左联结（left join），联结结果保留左表的全部数据<br>2）右联结（right join），联结结果保留右表的全部数据<br>3）内联结（inner join），取两表的公共数据</p>\n<p><img src=\"/page/mysql2/%5CSQL%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94%E6%9F%A5%5Csql%E8%BF%9E%E6%8E%A5.png\" alt></p>\n<p>应用在<a href=\"https://leetcode-cn.com/problems/combine-two-tables/\" target=\"_blank\" rel=\"noopener\">175.组合两个表中</a>。该题需要满足“无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息”，所以当person表在左时采用左连接。</p>\n<h3 id=\"一些注意事项\"><a href=\"#一些注意事项\" class=\"headerlink\" title=\"一些注意事项\"></a>一些注意事项</h3><p>1、<strong>表连接时on和where的区别</strong></p>\n<p>以下不推荐，因为查询速度会很慢，每一次都会执行WHERE语句中的内容。</p>\n<pre><code>SELECT ename \nFROM t_emp\nWHERE deptno = (SELECT deptno FROM t_emp WHERE ename=&quot;SCOTT&quot;)</code></pre><pre><code>SELECT e2.ename\nFROM t_emp e1 JOIN t_emp e2 ON e1.deptno=e2.deptno\nWHERE e1.ename = &quot;SCOTT&quot;</code></pre><p>将AVG的结果视为一个表，与原表进行连接。</p>\n<p>错误</p>\n<pre><code>SELECT e2.ename\nFROM t_emp e1 JOIN t_emp e2 ON e2.sal &gt;= AVG(e1.sal)</code></pre><p>正确</p>\n<pre><code>SELECT e.ename\nFROM t_emp e \nJOIN (SELECT AVG(sal) avg FROM t_emp) t\nON e.sal &gt;= t.avg;</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"SELECT语句\"><a href=\"#SELECT语句\" class=\"headerlink\" title=\"SELECT语句\"></a>SELECT语句</h3><p>1、基本使用框架</p>\n<pre><code>SELECT * FROM 数据表\n[WHERE]\n[LIMIT]\n[OFFSET]</code></pre><p>2、使用别名</p>\n<pre><code>SELECT\n    字段名 AS 别名\nFROM 数据表</code></pre><p>3、查询语句的执行顺序：</p>\n<p>先进行语法分析和优化，找到关键字优先级，先执行FROM，再执行SELECT</p>\n<h3 id=\"查询相关功能\"><a href=\"#查询相关功能\" class=\"headerlink\" title=\"查询相关功能\"></a>查询相关功能</h3><p>1、<strong>ORDER BY</strong>子句功能，对查询的结果进行<strong>排序</strong>，示例如下</p>\n<pre><code>// 按照相关信息进行排序\nSELECT * FROM * ORDER BY 列名 [ASC|DESC]\n// 多个排序信息\nSELECT * FROM * ORDER BY 列名 [ASC|DESC],列名 [ASC|DESC]</code></pre><p>2、去除结果中的<strong>重复记录</strong>，在字段名称前加上<strong>DISTINCT</strong>字段，只支持一个字段名。</p>\n<pre><code>SELECT DISTINCT 字段名 FROM *;</code></pre><p>3、<strong>条件查询</strong>，使用<strong>WHERE</strong>语句指定查询的条件逻辑，中间使用AND|OR等逻辑连接符连接，同时注意判断相等的条件是“=”而不是“==”。</p>\n<pre><code>SELECT * FROM * WHERE 条件1 [AND|OR] 条件2 ......;</code></pre><p>4、使用<strong>聚合函数</strong>。所谓聚合函数，也就是平均值、最大值等函数，以下为求该字段名下的平均值函数（AVG），其他函数使用方法与此类似。该类方法在实际使用时可以将统计结果作为一个子表进行查询。</p>\n<pre><code>SELECT AVG(字段名) FROM 表名</code></pre><p><strong>COUNT(*)</strong>用于获得包含空值的记录数，<strong>COUNT(字段名)</strong>用于获取包含非空值的记录数。</p>\n<p>5、<strong>分组查询</strong>，使用<strong>GROUP BY</strong>字句。即通过一定规则将数据集分为若干个部分进行查询处理。以下即为使用字段1进行分组统计每一组中字段2的平均值。</p>\n<pre><code>SELECT 字段1,AVG(字段2) FROM 表名 GROUP BY 字段1;</code></pre><p>使用分组查询SELECT语句中只能出现用以分组的字段以及其他字段的聚合函数，否则会报错（由于产生了<strong>一对多</strong>的关系）。为解决这个问题，可以使用<code>GROUP_CONCAT</code>函数，这个函数可以将符合条件的值连接起来进行输出，可以理解为将“多”的部分进行了字符串拼接。</p>\n<pre><code>SELECT 字段1,GROUP_CONCAT(字段2) FROM 表名 GROUP BY 字段1;</code></pre><p>同时可以加上<code>WITH ROLLUP</code>再进行一次汇总运算（即在返回的查询结果之下再加上一条汇总记录）。</p>\n<pre><code>SELECT 字段1,AVG(字段2) FROM 表名 GROUP BY 字段1 WITH ROLLUP;</code></pre><p>6、<strong>HAVING</strong>子句，以及为何要使用HAVING子句</p>\n<p>由于WHERE子句执行在GROUP BY子句之前，因此如果WHERE子句中出现了如平均值等信息时SQL会不知道在哪个范围内进行平均，因此会出错，如以下代码即为错误的（聚合函数作为判断条件）。所以需要使用<code>HAVING</code>子句。</p>\n<pre><code># 使用错误\nSELECT f1\nFROM table\nWHERE AVG(f2) &gt; 10\nGROUP BY f1;</code></pre><pre><code># 使用正确\nSELECT f1\nFROM table\nGROUP BY f1 HAVING AVG(f2) &gt; 10;</code></pre><h3 id=\"表的连接\"><a href=\"#表的连接\" class=\"headerlink\" title=\"表的连接\"></a>表的连接</h3><p>表的连接很重要，具体有内外两种连接构成。</p>\n<p>1、<strong>内连接</strong>：结果集中只保留符合连接条件的记录</p>\n<pre><code>SELECT * FROM 表1 [INNER] JOIN 表2 ON 连接条件;\n\nSELECT * FROM 表1 [INNER] JOIN 表2 WHERE 连接条件;\n\nSELECT * FROM 表1, 表2 WHERE 连接条件;</code></pre><p>2、<strong>外连接</strong>：不管是否符合连接条件，记录都要保留在结果集里</p>\n<pre><code>// 右表出NULL值和左表连接\nLEFT JOIN </code></pre><p>3、<strong>内外连接的区别</strong>。具体如图所示（图片摘自LeetCode）</p>\n<p>1）左联结（left join），联结结果保留左表的全部数据<br>2）右联结（right join），联结结果保留右表的全部数据<br>3）内联结（inner join），取两表的公共数据</p>\n<p><img src=\"/page/mysql2/%5CSQL%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94%E6%9F%A5%5Csql%E8%BF%9E%E6%8E%A5.png\" alt></p>\n<p>应用在<a href=\"https://leetcode-cn.com/problems/combine-two-tables/\" target=\"_blank\" rel=\"noopener\">175.组合两个表中</a>。该题需要满足“无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息”，所以当person表在左时采用左连接。</p>\n<h3 id=\"一些注意事项\"><a href=\"#一些注意事项\" class=\"headerlink\" title=\"一些注意事项\"></a>一些注意事项</h3><p>1、<strong>表连接时on和where的区别</strong></p>\n<p>以下不推荐，因为查询速度会很慢，每一次都会执行WHERE语句中的内容。</p>\n<pre><code>SELECT ename \nFROM t_emp\nWHERE deptno = (SELECT deptno FROM t_emp WHERE ename=&quot;SCOTT&quot;)</code></pre><pre><code>SELECT e2.ename\nFROM t_emp e1 JOIN t_emp e2 ON e1.deptno=e2.deptno\nWHERE e1.ename = &quot;SCOTT&quot;</code></pre><p>将AVG的结果视为一个表，与原表进行连接。</p>\n<p>错误</p>\n<pre><code>SELECT e2.ename\nFROM t_emp e1 JOIN t_emp e2 ON e2.sal &gt;= AVG(e1.sal)</code></pre><p>正确</p>\n<pre><code>SELECT e.ename\nFROM t_emp e \nJOIN (SELECT AVG(sal) avg FROM t_emp) t\nON e.sal &gt;= t.avg;</code></pre>"},{"title":"SQL的一些机制","date":"2020-06-12T02:39:37.000Z","fileName":"mysql3","_content":"\n123\n\n事务机制\n\n事务是一个或多个SQL语句组成的整体，要么全部执行成功，要么全部执行失败\n\n```\nSTART TRANSACTION\nSQL语句\n[COMMIT | ROLLBACK]\n```\n\n\n\n\n\n导出SQL文件\n\n```\n\n```\n\n\n\n导出\n\n\n\nSQL注入攻击：\n\n\n\nSQL预编译机制\n\n\n\n\n\n\n\n\n\n数据加密\n\n对称加密（DES加密、AES加密）\n\n\n\nAES加密函数：`AES_ENCRYPT(原始数据，密钥字符串)`\n\nAES解密函数：`AES_DECRYPT(加密结果，密钥字符串)`\n\n\n\n非对称加密（RSA加密、DSA加密、ECC加密）\n\n\n\n\n\n数据库连接池（Connection Pool）：预先创建一些数据库连接，然后缓存起来，避免了程序语言反复创建和销毁连接的昂贵代价\n\n","source":"_posts/数据库/MySQL/SQL的一些机制.md","raw":"---\ntitle: SQL的一些机制\ndate: 2020-06-12 10:39:37\ntags:\n\t- 数据库\ncategories:\n\t- 数据库\n\t- MySQL\nfileName: mysql3\n---\n\n123\n\n事务机制\n\n事务是一个或多个SQL语句组成的整体，要么全部执行成功，要么全部执行失败\n\n```\nSTART TRANSACTION\nSQL语句\n[COMMIT | ROLLBACK]\n```\n\n\n\n\n\n导出SQL文件\n\n```\n\n```\n\n\n\n导出\n\n\n\nSQL注入攻击：\n\n\n\nSQL预编译机制\n\n\n\n\n\n\n\n\n\n数据加密\n\n对称加密（DES加密、AES加密）\n\n\n\nAES加密函数：`AES_ENCRYPT(原始数据，密钥字符串)`\n\nAES解密函数：`AES_DECRYPT(加密结果，密钥字符串)`\n\n\n\n非对称加密（RSA加密、DSA加密、ECC加密）\n\n\n\n\n\n数据库连接池（Connection Pool）：预先创建一些数据库连接，然后缓存起来，避免了程序语言反复创建和销毁连接的昂贵代价\n\n","slug":"数据库/MySQL/SQL的一些机制","published":1,"updated":"2020-06-16T15:28:14.867Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8ud001yl4js4o9o1den","content":"<p>123</p>\n<p>事务机制</p>\n<p>事务是一个或多个SQL语句组成的整体，要么全部执行成功，要么全部执行失败</p>\n<pre><code>START TRANSACTION\nSQL语句\n[COMMIT | ROLLBACK]</code></pre><p>导出SQL文件</p>\n<pre><code></code></pre><p>导出</p>\n<p>SQL注入攻击：</p>\n<p>SQL预编译机制</p>\n<p>数据加密</p>\n<p>对称加密（DES加密、AES加密）</p>\n<p>AES加密函数：<code>AES_ENCRYPT(原始数据，密钥字符串)</code></p>\n<p>AES解密函数：<code>AES_DECRYPT(加密结果，密钥字符串)</code></p>\n<p>非对称加密（RSA加密、DSA加密、ECC加密）</p>\n<p>数据库连接池（Connection Pool）：预先创建一些数据库连接，然后缓存起来，避免了程序语言反复创建和销毁连接的昂贵代价</p>\n","site":{"data":{}},"excerpt":"","more":"<p>123</p>\n<p>事务机制</p>\n<p>事务是一个或多个SQL语句组成的整体，要么全部执行成功，要么全部执行失败</p>\n<pre><code>START TRANSACTION\nSQL语句\n[COMMIT | ROLLBACK]</code></pre><p>导出SQL文件</p>\n<pre><code></code></pre><p>导出</p>\n<p>SQL注入攻击：</p>\n<p>SQL预编译机制</p>\n<p>数据加密</p>\n<p>对称加密（DES加密、AES加密）</p>\n<p>AES加密函数：<code>AES_ENCRYPT(原始数据，密钥字符串)</code></p>\n<p>AES解密函数：<code>AES_DECRYPT(加密结果，密钥字符串)</code></p>\n<p>非对称加密（RSA加密、DSA加密、ECC加密）</p>\n<p>数据库连接池（Connection Pool）：预先创建一些数据库连接，然后缓存起来，避免了程序语言反复创建和销毁连接的昂贵代价</p>\n"},{"title":"SQL的增删改等语句","date":"2020-06-07T01:44:15.000Z","fileName":"mysql1","_content":"\n\n\n逻辑库\n\n```\nCREATE DATABASE; 逻辑库名称\nSHOW DATABASES;\nDROP DATABASE 逻辑库名称;\nUSE 逻辑库名称;\n```\n\n数据表\n\n```\nCREATE TABLE 数据表(\n\t\t\t列名 数据类型 [约束] [COMMENT 注释],\n\t\t\t列名 数据类型 [约束] [COMMENT 注释],\n\t\t\t)[COMMENT 注释];\n```\n\n```\nSHOW 表名;\nDESC 表名; // 查看表的情况\nSHOW CREATE TABLE 表名;\t// 查看创建该表时的SQL语句\nDROP TABLEE 表名;\t// 删除数据表\n```\n\n\n\n添加字段\n\n```\nALTER TABLE 表名\nADD 列名 数据类型 [约束] [COMMENT 注释],\n...\nADD 列名 数据类型 [约束] [COMMENT 注释];\n```\n\n修改字段数据类型等信息\n\n```\nALTER TABLE 表名\nMODIFY 列名 数据类型 [约束] [COMMENT 注释],\n...\nMODIFY 列名 数据类型 [约束] [COMMENT 注释];\n```\n\n修改字段名称\n\n```\nALTER TABLE 表名\nCHANGE 列名 新列名 数据类型 [约束] [COMMENT 注释],\n...\nCHANGE 列名 新列名 数据类型 [约束] [COMMENT 注释];\n```\n\n删除字段\n\n```\nALTER TABLE 表名\nDROP 字段名称,\n...\nDROP 字段名称;\n```\n\n\n\n添加索引\n\n```\nCREATE TABLE *(\n\t\tINDEX 索引名称 (字段名称),\n\t\t);\n```\n\n添加、显示、删除索引\n\n```\nCREATE INDEX 索引名称 ON 表名(字段);\nALTER TABLE 表名 ADD INDEX [索引名](字段);\n\nSHOW INDEX FROM 表名;\nDROP INDEX 索引名称 ON 表名;\n```\n\n\n\n\n\n向数据表中写入记录\n\n```\nINSERT INTO 表名(字段1,字段2......)\nVALUES(值1,值2......);\n```\n\n\n\n```\n// 当插入数据有问题时直接忽略\nNSERT IGNORE INTO\n```\n\n\n\n修改表的记录\n\n```\nUPDATE [IGNORE] 表名\nSET 字段1=值1, 字段2=值2 ......\nWHERE\nORDER BY\nLIMIT\n```\n\n\n\n删除数据\n\n```\nDELETE [IGNORE] FROM 表名\n[WHERE]\n[ORDER BY]\n[LIMIT]\n```\n\n\n\n","source":"_posts/数据库/MySQL/SQL的增删改等语句.md","raw":"---\ntitle: SQL的增删改等语句\ndate: 2020-06-07 09:44:15\ntags:\n\t- 数据库\ncategories:\n\t- 数据库\n\t- MySQL\nfileName: mysql1\n---\n\n\n\n逻辑库\n\n```\nCREATE DATABASE; 逻辑库名称\nSHOW DATABASES;\nDROP DATABASE 逻辑库名称;\nUSE 逻辑库名称;\n```\n\n数据表\n\n```\nCREATE TABLE 数据表(\n\t\t\t列名 数据类型 [约束] [COMMENT 注释],\n\t\t\t列名 数据类型 [约束] [COMMENT 注释],\n\t\t\t)[COMMENT 注释];\n```\n\n```\nSHOW 表名;\nDESC 表名; // 查看表的情况\nSHOW CREATE TABLE 表名;\t// 查看创建该表时的SQL语句\nDROP TABLEE 表名;\t// 删除数据表\n```\n\n\n\n添加字段\n\n```\nALTER TABLE 表名\nADD 列名 数据类型 [约束] [COMMENT 注释],\n...\nADD 列名 数据类型 [约束] [COMMENT 注释];\n```\n\n修改字段数据类型等信息\n\n```\nALTER TABLE 表名\nMODIFY 列名 数据类型 [约束] [COMMENT 注释],\n...\nMODIFY 列名 数据类型 [约束] [COMMENT 注释];\n```\n\n修改字段名称\n\n```\nALTER TABLE 表名\nCHANGE 列名 新列名 数据类型 [约束] [COMMENT 注释],\n...\nCHANGE 列名 新列名 数据类型 [约束] [COMMENT 注释];\n```\n\n删除字段\n\n```\nALTER TABLE 表名\nDROP 字段名称,\n...\nDROP 字段名称;\n```\n\n\n\n添加索引\n\n```\nCREATE TABLE *(\n\t\tINDEX 索引名称 (字段名称),\n\t\t);\n```\n\n添加、显示、删除索引\n\n```\nCREATE INDEX 索引名称 ON 表名(字段);\nALTER TABLE 表名 ADD INDEX [索引名](字段);\n\nSHOW INDEX FROM 表名;\nDROP INDEX 索引名称 ON 表名;\n```\n\n\n\n\n\n向数据表中写入记录\n\n```\nINSERT INTO 表名(字段1,字段2......)\nVALUES(值1,值2......);\n```\n\n\n\n```\n// 当插入数据有问题时直接忽略\nNSERT IGNORE INTO\n```\n\n\n\n修改表的记录\n\n```\nUPDATE [IGNORE] 表名\nSET 字段1=值1, 字段2=值2 ......\nWHERE\nORDER BY\nLIMIT\n```\n\n\n\n删除数据\n\n```\nDELETE [IGNORE] FROM 表名\n[WHERE]\n[ORDER BY]\n[LIMIT]\n```\n\n\n\n","slug":"数据库/MySQL/SQL的增删改等语句","published":1,"updated":"2020-06-14T14:34:16.917Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8ue0021l4js2w662un9","content":"<p>逻辑库</p>\n<pre><code>CREATE DATABASE; 逻辑库名称\nSHOW DATABASES;\nDROP DATABASE 逻辑库名称;\nUSE 逻辑库名称;</code></pre><p>数据表</p>\n<pre><code>CREATE TABLE 数据表(\n            列名 数据类型 [约束] [COMMENT 注释],\n            列名 数据类型 [约束] [COMMENT 注释],\n            )[COMMENT 注释];</code></pre><pre><code>SHOW 表名;\nDESC 表名; // 查看表的情况\nSHOW CREATE TABLE 表名;    // 查看创建该表时的SQL语句\nDROP TABLEE 表名;    // 删除数据表</code></pre><p>添加字段</p>\n<pre><code>ALTER TABLE 表名\nADD 列名 数据类型 [约束] [COMMENT 注释],\n...\nADD 列名 数据类型 [约束] [COMMENT 注释];</code></pre><p>修改字段数据类型等信息</p>\n<pre><code>ALTER TABLE 表名\nMODIFY 列名 数据类型 [约束] [COMMENT 注释],\n...\nMODIFY 列名 数据类型 [约束] [COMMENT 注释];</code></pre><p>修改字段名称</p>\n<pre><code>ALTER TABLE 表名\nCHANGE 列名 新列名 数据类型 [约束] [COMMENT 注释],\n...\nCHANGE 列名 新列名 数据类型 [约束] [COMMENT 注释];</code></pre><p>删除字段</p>\n<pre><code>ALTER TABLE 表名\nDROP 字段名称,\n...\nDROP 字段名称;</code></pre><p>添加索引</p>\n<pre><code>CREATE TABLE *(\n        INDEX 索引名称 (字段名称),\n        );</code></pre><p>添加、显示、删除索引</p>\n<pre><code>CREATE INDEX 索引名称 ON 表名(字段);\nALTER TABLE 表名 ADD INDEX [索引名](字段);\n\nSHOW INDEX FROM 表名;\nDROP INDEX 索引名称 ON 表名;</code></pre><p>向数据表中写入记录</p>\n<pre><code>INSERT INTO 表名(字段1,字段2......)\nVALUES(值1,值2......);</code></pre><pre><code>// 当插入数据有问题时直接忽略\nNSERT IGNORE INTO</code></pre><p>修改表的记录</p>\n<pre><code>UPDATE [IGNORE] 表名\nSET 字段1=值1, 字段2=值2 ......\nWHERE\nORDER BY\nLIMIT</code></pre><p>删除数据</p>\n<pre><code>DELETE [IGNORE] FROM 表名\n[WHERE]\n[ORDER BY]\n[LIMIT]</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>逻辑库</p>\n<pre><code>CREATE DATABASE; 逻辑库名称\nSHOW DATABASES;\nDROP DATABASE 逻辑库名称;\nUSE 逻辑库名称;</code></pre><p>数据表</p>\n<pre><code>CREATE TABLE 数据表(\n            列名 数据类型 [约束] [COMMENT 注释],\n            列名 数据类型 [约束] [COMMENT 注释],\n            )[COMMENT 注释];</code></pre><pre><code>SHOW 表名;\nDESC 表名; // 查看表的情况\nSHOW CREATE TABLE 表名;    // 查看创建该表时的SQL语句\nDROP TABLEE 表名;    // 删除数据表</code></pre><p>添加字段</p>\n<pre><code>ALTER TABLE 表名\nADD 列名 数据类型 [约束] [COMMENT 注释],\n...\nADD 列名 数据类型 [约束] [COMMENT 注释];</code></pre><p>修改字段数据类型等信息</p>\n<pre><code>ALTER TABLE 表名\nMODIFY 列名 数据类型 [约束] [COMMENT 注释],\n...\nMODIFY 列名 数据类型 [约束] [COMMENT 注释];</code></pre><p>修改字段名称</p>\n<pre><code>ALTER TABLE 表名\nCHANGE 列名 新列名 数据类型 [约束] [COMMENT 注释],\n...\nCHANGE 列名 新列名 数据类型 [约束] [COMMENT 注释];</code></pre><p>删除字段</p>\n<pre><code>ALTER TABLE 表名\nDROP 字段名称,\n...\nDROP 字段名称;</code></pre><p>添加索引</p>\n<pre><code>CREATE TABLE *(\n        INDEX 索引名称 (字段名称),\n        );</code></pre><p>添加、显示、删除索引</p>\n<pre><code>CREATE INDEX 索引名称 ON 表名(字段);\nALTER TABLE 表名 ADD INDEX [索引名](字段);\n\nSHOW INDEX FROM 表名;\nDROP INDEX 索引名称 ON 表名;</code></pre><p>向数据表中写入记录</p>\n<pre><code>INSERT INTO 表名(字段1,字段2......)\nVALUES(值1,值2......);</code></pre><pre><code>// 当插入数据有问题时直接忽略\nNSERT IGNORE INTO</code></pre><p>修改表的记录</p>\n<pre><code>UPDATE [IGNORE] 表名\nSET 字段1=值1, 字段2=值2 ......\nWHERE\nORDER BY\nLIMIT</code></pre><p>删除数据</p>\n<pre><code>DELETE [IGNORE] FROM 表名\n[WHERE]\n[ORDER BY]\n[LIMIT]</code></pre>"},{"title":"数组","date":"2020-07-05T09:52:25.000Z","fileName":"ds-array","_content":"\n 均摊复杂度：相应耗时的操作不会每次进行，那么可以计算均摊复杂度\n\n\n\n复杂度震荡：\n\n先进行addLast，再调用removeLast","source":"_posts/计算机基础/数据结构/1、动态数组.md","raw":"---\ntitle: 数组\ndate: 2020-07-05 17:52:25\ntags:\n\t- 数据结构\ncategories:\n\t- 计算机基础\n\t- 数据结构\nfileName: ds-array\n---\n\n 均摊复杂度：相应耗时的操作不会每次进行，那么可以计算均摊复杂度\n\n\n\n复杂度震荡：\n\n先进行addLast，再调用removeLast","slug":"计算机基础/数据结构/1、动态数组","published":1,"updated":"2020-07-16T15:58:08.756Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8ul0029l4jsfqw2ampt","content":"<p> 均摊复杂度：相应耗时的操作不会每次进行，那么可以计算均摊复杂度</p>\n<p>复杂度震荡：</p>\n<p>先进行addLast，再调用removeLast</p>\n","site":{"data":{}},"excerpt":"","more":"<p> 均摊复杂度：相应耗时的操作不会每次进行，那么可以计算均摊复杂度</p>\n<p>复杂度震荡：</p>\n<p>先进行addLast，再调用removeLast</p>\n"},{"title":"栈和队列","date":"2020-07-06T03:08:00.000Z","fileName":"ds","_content":"\n栈相关的应用\n\n1、撤销\n\n2、程序调用系统栈","source":"_posts/计算机基础/数据结构/2、栈.md","raw":"---\ntitle: 栈和队列\ndate: 2020-07-06 11:08:00\ntags:\n\t- 数据结构\ncategories:\n\t- 计算机基础\n\t- 数据结构\nfileName: ds\n---\n\n栈相关的应用\n\n1、撤销\n\n2、程序调用系统栈","slug":"计算机基础/数据结构/2、栈","published":1,"updated":"2020-07-16T15:58:18.074Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8up002dl4js3jjnf6i9","content":"<p>栈相关的应用</p>\n<p>1、撤销</p>\n<p>2、程序调用系统栈</p>\n","site":{"data":{}},"excerpt":"","more":"<p>栈相关的应用</p>\n<p>1、撤销</p>\n<p>2、程序调用系统栈</p>\n"},{"title":"3、队列","date":"2020-07-14T03:32:36.000Z","fileName":"dssss","_content":"\n\n\n\n\n```\nimport java.util.Random;\n\npublic class Main {\n\n\t// 用于计算运行时间\n    private static double testQueue(Queue<Integer> q, int opCount) {\n        long startTime = System.nanoTime();\n\n        Random random = new Random();\n        for(int i=0; i<opCount;i++) {\n            q.enqueue(random.nextInt(Integer.MAX_VALUE));\n        }\n        for(int i=0; i<opCount;i++) {\n            q.dequeue();\n        }\n\n        long endTime = System.nanoTime();\n        return (endTime - startTime) / 1000000000.0;\n    }\n\n    public static void main(String[] args) {\n        int opCount = 100000;\n        ArrayQueue<Integer> arrayQueue = new ArrayQueue<>();\n        double time1 = testQueue(arrayQueue, opCount);\n        LoopQueue<Integer> loopQueue = new LoopQueue<>();\n        double time2 = testQueue(loopQueue,opCount);\n        System.out.println(\"ArrayQueue: \"+time1+\" s\");\n        System.out.println(\"LoopQueue: \"+time2+\" s\");\n    }\n}\n///////////////////////////////////////////\nArrayQueue: 67.2911912 s\nLoopQueue: 0.0214542 s\n```\n\n","source":"_posts/计算机基础/数据结构/3、队列.md","raw":"---\ntitle: 3、队列\ndate: 2020-07-14 11:32:36\ntags:\n\t- 数据结构\ncategories:\n\t- 计算机基础\n\t- 数据结构\nfileName: dssss\n---\n\n\n\n\n\n```\nimport java.util.Random;\n\npublic class Main {\n\n\t// 用于计算运行时间\n    private static double testQueue(Queue<Integer> q, int opCount) {\n        long startTime = System.nanoTime();\n\n        Random random = new Random();\n        for(int i=0; i<opCount;i++) {\n            q.enqueue(random.nextInt(Integer.MAX_VALUE));\n        }\n        for(int i=0; i<opCount;i++) {\n            q.dequeue();\n        }\n\n        long endTime = System.nanoTime();\n        return (endTime - startTime) / 1000000000.0;\n    }\n\n    public static void main(String[] args) {\n        int opCount = 100000;\n        ArrayQueue<Integer> arrayQueue = new ArrayQueue<>();\n        double time1 = testQueue(arrayQueue, opCount);\n        LoopQueue<Integer> loopQueue = new LoopQueue<>();\n        double time2 = testQueue(loopQueue,opCount);\n        System.out.println(\"ArrayQueue: \"+time1+\" s\");\n        System.out.println(\"LoopQueue: \"+time2+\" s\");\n    }\n}\n///////////////////////////////////////////\nArrayQueue: 67.2911912 s\nLoopQueue: 0.0214542 s\n```\n\n","slug":"计算机基础/数据结构/3、队列","published":1,"updated":"2020-07-16T16:09:17.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckcozp8ux002yl4jscvtca81b","content":"<pre><code>import java.util.Random;\n\npublic class Main {\n\n    // 用于计算运行时间\n    private static double testQueue(Queue&lt;Integer&gt; q, int opCount) {\n        long startTime = System.nanoTime();\n\n        Random random = new Random();\n        for(int i=0; i&lt;opCount;i++) {\n            q.enqueue(random.nextInt(Integer.MAX_VALUE));\n        }\n        for(int i=0; i&lt;opCount;i++) {\n            q.dequeue();\n        }\n\n        long endTime = System.nanoTime();\n        return (endTime - startTime) / 1000000000.0;\n    }\n\n    public static void main(String[] args) {\n        int opCount = 100000;\n        ArrayQueue&lt;Integer&gt; arrayQueue = new ArrayQueue&lt;&gt;();\n        double time1 = testQueue(arrayQueue, opCount);\n        LoopQueue&lt;Integer&gt; loopQueue = new LoopQueue&lt;&gt;();\n        double time2 = testQueue(loopQueue,opCount);\n        System.out.println(&quot;ArrayQueue: &quot;+time1+&quot; s&quot;);\n        System.out.println(&quot;LoopQueue: &quot;+time2+&quot; s&quot;);\n    }\n}\n///////////////////////////////////////////\nArrayQueue: 67.2911912 s\nLoopQueue: 0.0214542 s</code></pre>","site":{"data":{}},"excerpt":"","more":"<pre><code>import java.util.Random;\n\npublic class Main {\n\n    // 用于计算运行时间\n    private static double testQueue(Queue&lt;Integer&gt; q, int opCount) {\n        long startTime = System.nanoTime();\n\n        Random random = new Random();\n        for(int i=0; i&lt;opCount;i++) {\n            q.enqueue(random.nextInt(Integer.MAX_VALUE));\n        }\n        for(int i=0; i&lt;opCount;i++) {\n            q.dequeue();\n        }\n\n        long endTime = System.nanoTime();\n        return (endTime - startTime) / 1000000000.0;\n    }\n\n    public static void main(String[] args) {\n        int opCount = 100000;\n        ArrayQueue&lt;Integer&gt; arrayQueue = new ArrayQueue&lt;&gt;();\n        double time1 = testQueue(arrayQueue, opCount);\n        LoopQueue&lt;Integer&gt; loopQueue = new LoopQueue&lt;&gt;();\n        double time2 = testQueue(loopQueue,opCount);\n        System.out.println(&quot;ArrayQueue: &quot;+time1+&quot; s&quot;);\n        System.out.println(&quot;LoopQueue: &quot;+time2+&quot; s&quot;);\n    }\n}\n///////////////////////////////////////////\nArrayQueue: 67.2911912 s\nLoopQueue: 0.0214542 s</code></pre>"}],"PostAsset":[{"_id":"source/_posts/GIS/OSM数据基本操作/arcgis.png","slug":"arcgis.png","post":"ckcox355q001768js9e62ga2t","modified":0,"renderable":0},{"_id":"source/_posts/GIS/OSM数据基本操作/arcgis1.png","slug":"arcgis1.png","post":"ckcox355q001768js9e62ga2t","modified":0,"renderable":0},{"_id":"source/_posts/GIS/OSM数据基本操作/code.png","slug":"code.png","post":"ckcox355q001768js9e62ga2t","modified":0,"renderable":0},{"_id":"source/_posts/GIS/OSM数据基本操作/exports.png","slug":"exports.png","post":"ckcox355q001768js9e62ga2t","modified":0,"renderable":0},{"_id":"source/_posts/GIS/OSM数据基本操作/map1.png","slug":"map1.png","post":"ckcox355q001768js9e62ga2t","modified":0,"renderable":0},{"_id":"source/_posts/GIS/OSM数据基本操作/query.png","slug":"query.png","post":"ckcox355q001768js9e62ga2t","modified":0,"renderable":0},{"_id":"source/_posts/GIS/OSM数据基本操作/total.jpg","slug":"total.jpg","post":"ckcox355q001768js9e62ga2t","modified":0,"renderable":0},{"_id":"source/_posts/Python/GUI/Anaconda+PyCharm配置PyQt5全过程/6.png","slug":"6.png","post":"ckcozp8sm000dl4js3y0sd1r8","modified":1,"renderable":0},{"_id":"source/_posts/Python/GUI/Anaconda+PyCharm配置PyQt5全过程/4.png","slug":"4.png","post":"ckcozp8sm000dl4js3y0sd1r8","modified":1,"renderable":0},{"_id":"source/_posts/数据库/MySQL/SQL语句——查/sql连接.png","slug":"sql连接.png","post":"ckcozp8uc001vl4js3skp5h9k","modified":1,"renderable":0},{"_id":"source/_posts/Python/GUI/Anaconda+PyCharm配置PyQt5全过程/1.png","post":"ckcozp8sm000dl4js3y0sd1r8","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/Python/GUI/Anaconda+PyCharm配置PyQt5全过程/2.png","post":"ckcozp8sm000dl4js3y0sd1r8","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/Python/GUI/Anaconda+PyCharm配置PyQt5全过程/3.png","post":"ckcozp8sm000dl4js3y0sd1r8","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/Python/GUI/Anaconda+PyCharm配置PyQt5全过程/5.png","post":"ckcozp8sm000dl4js3y0sd1r8","slug":"5.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"ckcox1368000068jsac1w10tm","category_id":"ckcokw9qw0006tkjsdk105r9v","_id":"ckcox137l000268jsh1ojdxk5"},{"post_id":"ckcox1368000068jsac1w10tm","category_id":"ckcokw9rb000btkjs4w6e91qt","_id":"ckcox137l000368jseijtaiow"},{"post_id":"ckcox1f6m000868js9bf46cp2","category_id":"ckbf6822t0001sgjs7y2g59bc","_id":"ckcox1f6m000a68jsdvvvd76l"},{"post_id":"ckcox2wxz001368js7e8862ic","category_id":"ckbf5c0rl00074sjsb3yp5yc0","_id":"ckcox2wy0001568js2ahd0r7i"},{"post_id":"ckcox2wxz001368js7e8862ic","category_id":"ckbf5c0rn000a4sjs0ruq6t3j","_id":"ckcox2wy0001668jsczb5cl7l"},{"post_id":"ckcox355q001768js9e62ga2t","category_id":"ckbf6822t0001sgjs7y2g59bc","_id":"ckcox355q001968jsgilqb8f1"},{"post_id":"ckcox3wli001a68js97npdw1o","category_id":"ckbf331r4000pzwjs2csf4hnd","_id":"ckcox3wlj001c68js6tst1ygc"},{"post_id":"ckcox3wli001a68js97npdw1o","category_id":"ckbf331rj000tzwjsaap1g5gd","_id":"ckcox3wlj001d68js1kg1hind"},{"post_id":"ckcox3wlp001e68js1ekl2tu3","category_id":"ckbf331r4000pzwjs2csf4hnd","_id":"ckcox3wlq001g68jseqg4fj89"},{"post_id":"ckcox3wlp001e68js1ekl2tu3","category_id":"ckbf331rj000tzwjsaap1g5gd","_id":"ckcox3wlq001h68js6qr46h4x"},{"post_id":"ckcox3wls001i68js3kuk3art","category_id":"ckbf331r4000pzwjs2csf4hnd","_id":"ckcox3wls001k68jsd8qyhusn"},{"post_id":"ckcox3wls001i68js3kuk3art","category_id":"ckbf331rj000tzwjsaap1g5gd","_id":"ckcox3wlt001l68jsdd1r4x2k"},{"post_id":"ckcox5qk0001z68jscwtn5m2v","category_id":"ckcox5dgp001v68jsbf393inc","_id":"ckcox5qk1002168jsdsw6fcj6"},{"post_id":"ckcox5qk0001z68jscwtn5m2v","category_id":"ckcox5dgr001w68js1czbfdzy","_id":"ckcox5qk1002268jsfax00196"},{"post_id":"ckcox688h002668js6axa5to9","category_id":"ckcox5dgp001v68jsbf393inc","_id":"ckcox688i002968jshyd1foah"},{"post_id":"ckcox688h002668js6axa5to9","category_id":"ckcox65zg002368js10c323kq","_id":"ckcox688i002a68js4krx75if"},{"post_id":"ckcox6lju002b68jscc1669lb","category_id":"ckcokw9qw0006tkjsdk105r9v","_id":"ckcox6ljw002d68jsh2e851y9"},{"post_id":"ckcox6lju002b68jscc1669lb","category_id":"ckcokw9rb000btkjs4w6e91qt","_id":"ckcox6ljw002e68js68pdc7ic"},{"post_id":"ckcox6lk0002f68js55yib0sa","category_id":"ckcokw9qw0006tkjsdk105r9v","_id":"ckcox6lk2002j68js0f4ig8ku"},{"post_id":"ckcox6lk0002f68js55yib0sa","category_id":"ckcokw9rb000btkjs4w6e91qt","_id":"ckcox6lk2002k68js43ru3c04"},{"post_id":"ckcox6lk1002g68js20d94tjs","category_id":"ckcokw9qw0006tkjsdk105r9v","_id":"ckcox6lk2002l68jsbwzh5d7o"},{"post_id":"ckcox6qti002m68js3y3b9vov","category_id":"ckcokw9qw0006tkjsdk105r9v","_id":"ckcox6qtj002o68js5qvzbfhh"},{"post_id":"ckcox6qti002m68js3y3b9vov","category_id":"ckcokw9rb000btkjs4w6e91qt","_id":"ckcox6qtj002p68jsau8ah9u7"},{"post_id":"ckcox7saf002z68jsb43p9365","category_id":"ckbf5c0rl00074sjsb3yp5yc0","_id":"ckcox7sag003168js9vom5jmk"},{"post_id":"ckcoz3dve004r68js639rdgm6","category_id":"ckcoz3xh5004u68jsdg4x7aj0","_id":"ckcoz3xh6004v68js2k3e2loe"},{"post_id":"ckcoz48rs004w68js9o0abpnf","category_id":"ckcox5dgp001v68jsbf393inc","_id":"ckcoz4hxe005168js8rgz25mt"},{"post_id":"ckcoz48rs004w68js9o0abpnf","category_id":"ckcoz4hxe005068js5j750qgz","_id":"ckcoz4hxe005268jsg5ee6bat"},{"post_id":"ckcoz0gft003e68jsfw2u7nil","category_id":"ckcox5dgp001v68jsbf393inc","_id":"ckcoz4v6x005368jsfxtk82r6"},{"post_id":"ckcoz0gft003e68jsfw2u7nil","category_id":"ckcox65zg002368js10c323kq","_id":"ckcoz4v6x005468jsa05la3j1"},{"post_id":"ckcox2plr000p68js9kze4iy6","category_id":"ckbf5c0rl00074sjsb3yp5yc0","_id":"ckcoz5kjp005668js49qh3ent"},{"post_id":"ckcox2plr000p68js9kze4iy6","category_id":"ckcoz5kjp005568jsbr35a9kk","_id":"ckcoz5kjp005768js9z764646"},{"post_id":"ckcox2plu000u68js8how0myp","category_id":"ckbf5c0rl00074sjsb3yp5yc0","_id":"ckcoz5tqv005868js8nylg4n1"},{"post_id":"ckcox2plu000u68js8how0myp","category_id":"ckcoz5kjp005568jsbr35a9kk","_id":"ckcoz5tqv005968js5btla716"},{"post_id":"ckcox2plv000v68js0zn79i43","category_id":"ckbf5c0rl00074sjsb3yp5yc0","_id":"ckcoz5yur005a68js113q2ox1"},{"post_id":"ckcox2plv000v68js0zn79i43","category_id":"ckcoz5kjp005568jsbr35a9kk","_id":"ckcoz5yur005b68js3e7l7ba2"},{"post_id":"ckcox7saf002z68jsb43p9365","category_id":"ckbf5c0rn000a4sjs0ruq6t3j","_id":"ckcoz6dv0005c68jsh63qbrht"},{"post_id":"ckcoz8l88005o68js3lvl7xgr","category_id":"ckcoz6nr9005d68js16ltd91g","_id":"ckcoz8l89005p68js47v23lr1"},{"post_id":"ckcoz8l88005o68js3lvl7xgr","category_id":"ckcoz6ubx005f68js0pb98sh0","_id":"ckcoz8l89005q68js6lvj19tl"},{"post_id":"ckcoz8l8a005r68jsbz7w7g96","category_id":"ckcoz6nr9005d68js16ltd91g","_id":"ckcoz8l8b005t68jsdke977e6"},{"post_id":"ckcoz8l8a005r68jsbz7w7g96","category_id":"ckcoz6ubx005f68js0pb98sh0","_id":"ckcoz8l8b005u68jsc5uqamlm"},{"post_id":"ckcoz8rn5005v68js7lj4h3gp","category_id":"ckcoz6nr9005d68js16ltd91g","_id":"ckcoz8rn6005x68js1z1ref8r"},{"post_id":"ckcoz8rn7005z68js74zg71gb","category_id":"ckcoz6nr9005d68js16ltd91g","_id":"ckcoz8rn8006268jsgsr5b0iz"},{"post_id":"ckcoz8rn5005v68js7lj4h3gp","category_id":"ckcoz8ywj006468js4xzyfym7","_id":"ckcoz8ywk006568js7mzsdr3i"},{"post_id":"ckcoz8rn7005z68js74zg71gb","category_id":"ckcoz8ywj006468js4xzyfym7","_id":"ckcoz96dh006668jsea5w08ly"},{"post_id":"ckcoz2fv0003v68js3o7w1b5d","category_id":"ckbf6822t0001sgjs7y2g59bc","_id":"ckcozp8qb0000l4js8nxq5cey"},{"post_id":"ckcozp8s90007l4js3035evnp","category_id":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8sn000el4js15xvg5uj"},{"post_id":"ckcozp8s90007l4js3035evnp","category_id":"ckbrje4c5000eckjsetth8q64","_id":"ckcozp8st000il4jscl0b15q7"},{"post_id":"ckcozp8rt0001l4jsaytbhcbk","category_id":"ckcokw9qw0006tkjsdk105r9v","_id":"ckcozp8sx000ll4js6alwaqin"},{"post_id":"ckcozp8rt0001l4jsaytbhcbk","category_id":"ckcozp8ry0005l4jseeoo301d","_id":"ckcozp8t0000pl4jset4c9iv2"},{"post_id":"ckcozp8sc0009l4js1hdlfn2d","category_id":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8t3000sl4js3q5nbsuc"},{"post_id":"ckcozp8sj000cl4js9oevhe66","category_id":"ckcokw9qw0006tkjsdk105r9v","_id":"ckcozp8t8000wl4jsh35fffix"},{"post_id":"ckcozp8sj000cl4js9oevhe66","category_id":"ckcozp8ry0005l4jseeoo301d","_id":"ckcozp8ta000zl4js246o88c8"},{"post_id":"ckcozp8ru0002l4js646zbtrp","category_id":"ckcokw9qw0006tkjsdk105r9v","_id":"ckcozp8td0013l4jsf5je89e4"},{"post_id":"ckcozp8ru0002l4js646zbtrp","category_id":"ckcozp8ry0005l4jseeoo301d","_id":"ckcozp8te0015l4js5hga41en"},{"post_id":"ckcozp8sp000hl4js4kk84nf9","category_id":"ckcokw9qw0006tkjsdk105r9v","_id":"ckcozp8tj0018l4jsfd3y4p6p"},{"post_id":"ckcozp8sp000hl4js4kk84nf9","category_id":"ckcozp8ry0005l4jseeoo301d","_id":"ckcozp8tn001al4js0ptb31sz"},{"post_id":"ckcozp8rw0004l4js3fhz6j73","category_id":"ckcokw9qw0006tkjsdk105r9v","_id":"ckcozp8tq001dl4js0qfj6gua"},{"post_id":"ckcozp8rw0004l4js3fhz6j73","category_id":"ckcozp8ry0005l4jseeoo301d","_id":"ckcozp8ts001fl4js8ip2ad7e"},{"post_id":"ckcozp8sm000dl4js3y0sd1r8","category_id":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8tu001il4js2q6waj14"},{"post_id":"ckcozp8sm000dl4js3y0sd1r8","category_id":"ckcozp8sx000ml4js903o0osb","_id":"ckcozp8tw001jl4js4n5ycd9v"},{"post_id":"ckcozp8sv000kl4jsfcfm81n3","category_id":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8tz001ll4jshn6003qv"},{"post_id":"ckcozp8sv000kl4jsfcfm81n3","category_id":"ckcozp8t4000tl4jsb8occcko","_id":"ckcozp8u1001ml4js6yxt487n"},{"post_id":"ckcozp8tb0012l4jsgyoy4adr","category_id":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8u5001nl4js9r978luo"},{"post_id":"ckcozp8tb0012l4jsgyoy4adr","category_id":"ckcozp8ta0011l4js45vyagdd","_id":"ckcozp8u6001ol4jsbl744bko"},{"post_id":"ckcozp8sz000ol4js2obc4x3i","category_id":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8u7001pl4jsbhpv01hx"},{"post_id":"ckcozp8sz000ol4js2obc4x3i","category_id":"ckcozp8ta0011l4js45vyagdd","_id":"ckcozp8u8001ql4js9fjua7lw"},{"post_id":"ckcozp8td0014l4jsfzo92e1s","category_id":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8ua001rl4jsgpe60492"},{"post_id":"ckcozp8td0014l4jsfzo92e1s","category_id":"ckcozp8ta0011l4js45vyagdd","_id":"ckcozp8ub001sl4js4kgg3bk4"},{"post_id":"ckcozp8t1000rl4jscw0v11l0","category_id":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8uc001ul4jscpp20ltn"},{"post_id":"ckcozp8t1000rl4jscw0v11l0","category_id":"ckcozp8ta0011l4js45vyagdd","_id":"ckcozp8ud001wl4js53phd5b7"},{"post_id":"ckcozp8tl0019l4js3dyy0gj8","category_id":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8ue001zl4jscahr2llj"},{"post_id":"ckcozp8tl0019l4js3dyy0gj8","category_id":"ckcozp8ta0011l4js45vyagdd","_id":"ckcozp8uf0022l4js3wwd0odz"},{"post_id":"ckcozp8to001bl4jsct5q07vg","category_id":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8ug0024l4jse4pi73cm"},{"post_id":"ckcozp8to001bl4jsct5q07vg","category_id":"ckcozp8ta0011l4js45vyagdd","_id":"ckcozp8ui0026l4js2usr7kac"},{"post_id":"ckcozp8t5000vl4jsflq20cno","category_id":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8uj0028l4jsepvv9mjc"},{"post_id":"ckcozp8t5000vl4jsflq20cno","category_id":"ckcozp8ta0011l4js45vyagdd","_id":"ckcozp8um002al4jsdjzt7jaq"},{"post_id":"ckcozp8tr001el4jsgba4dwnh","category_id":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8up002bl4jsg8by8mh6"},{"post_id":"ckcozp8tr001el4jsgba4dwnh","category_id":"ckcozp8ta0011l4js45vyagdd","_id":"ckcozp8uq002el4jse7ntg8yb"},{"post_id":"ckcozp8tt001gl4jsh9x9bte9","category_id":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8ur002fl4js2br074i4"},{"post_id":"ckcozp8tt001gl4jsh9x9bte9","category_id":"ckcozp8ta0011l4js45vyagdd","_id":"ckcozp8ur002hl4jsbita6njw"},{"post_id":"ckcozp8t8000yl4jsdn9k6k6u","category_id":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8us002il4jsbkewdyuc"},{"post_id":"ckcozp8t8000yl4jsdn9k6k6u","category_id":"ckcozp8ta0011l4js45vyagdd","_id":"ckcozp8us002jl4jsdj5d50qz"},{"post_id":"ckcozp8tf0016l4jsd8eq1asi","category_id":"cka5hfrqp0002skjscs0jc8w0","_id":"ckcozp8us002kl4jsf3kd9a1b"},{"post_id":"ckcozp8tf0016l4jsd8eq1asi","category_id":"ckcozp8ty001kl4jsdyl1d8eg","_id":"ckcozp8us002ll4js6hpd3cou"},{"post_id":"ckcozp8ub001tl4jsae811ozx","category_id":"ckcozactj006i68jsag34e9bv","_id":"ckcozp8us002ml4js5mlb3704"},{"post_id":"ckcozp8ub001tl4jsae811ozx","category_id":"ckcozactj006j68jse1nobiru","_id":"ckcozp8us002nl4js4lc512zd"},{"post_id":"ckcozp8uc001vl4js3skp5h9k","category_id":"ckbf331r4000pzwjs2csf4hnd","_id":"ckcozp8us002ol4jsdm7p9i9w"},{"post_id":"ckcozp8uc001vl4js3skp5h9k","category_id":"ckbf331rj000tzwjsaap1g5gd","_id":"ckcozp8us002pl4jsfwxt4q0j"},{"post_id":"ckcozp8ud001yl4js4o9o1den","category_id":"ckbf331r4000pzwjs2csf4hnd","_id":"ckcozp8ut002ql4js2mwwd5f8"},{"post_id":"ckcozp8ud001yl4js4o9o1den","category_id":"ckbf331rj000tzwjsaap1g5gd","_id":"ckcozp8ut002rl4js97lmg1op"},{"post_id":"ckcozp8ue0021l4js2w662un9","category_id":"ckbf331r4000pzwjs2csf4hnd","_id":"ckcozp8ut002sl4js0repc485"},{"post_id":"ckcozp8ue0021l4js2w662un9","category_id":"ckbf331rj000tzwjsaap1g5gd","_id":"ckcozp8ut002tl4js7bj9dufu"},{"post_id":"ckcozp8ul0029l4jsfqw2ampt","category_id":"ckcoz9im3006768jsfolxe0kq","_id":"ckcozp8uu002ul4js3ih56nfj"},{"post_id":"ckcozp8ul0029l4jsfqw2ampt","category_id":"ckcoz9im4006868js34i1gmue","_id":"ckcozp8uu002vl4js8glg37rq"},{"post_id":"ckcozp8up002dl4js3jjnf6i9","category_id":"ckcoz9im3006768jsfolxe0kq","_id":"ckcozp8uu002wl4js3z7qbvue"},{"post_id":"ckcozp8up002dl4js3jjnf6i9","category_id":"ckcoz9im4006868js34i1gmue","_id":"ckcozp8uu002xl4js119u106g"},{"post_id":"ckcozp8ux002yl4jscvtca81b","category_id":"ckcoz9im3006768jsfolxe0kq","_id":"ckcozp8ve0030l4js9sh391tr"},{"post_id":"ckcozp8ux002yl4jscvtca81b","category_id":"ckcoz9im4006868js34i1gmue","_id":"ckcozp8vf0031l4js24cc9ww5"}],"PostTag":[{"post_id":"ckcox1368000068jsac1w10tm","tag_id":"ckcol4yl60000xwjs2eodf5ba","_id":"ckcox137k000168js4kx3ek7s"},{"post_id":"ckcox1f6m000868js9bf46cp2","tag_id":"ckbf5g5d8000e4sjs2zhm1os6","_id":"ckcox1f6m000968js6a1d7mpn"},{"post_id":"ckcox2plr000p68js9kze4iy6","tag_id":"cka5hfrs5000oskjs6gai0x2e","_id":"ckcox2plt000q68jsh6r08usc"},{"post_id":"ckcox2plr000p68js9kze4iy6","tag_id":"cka5hfrsa000tskjsdvoagyh3","_id":"ckcox2plt000r68js2l3j0e7a"},{"post_id":"ckcox2plu000u68js8how0myp","tag_id":"cka5hfrs5000oskjs6gai0x2e","_id":"ckcox2plw000w68js7w3abnq6"},{"post_id":"ckcox2plv000v68js0zn79i43","tag_id":"cka5hfrs5000oskjs6gai0x2e","_id":"ckcox2plw000x68js6m5a1qsy"},{"post_id":"ckcox2plv000v68js0zn79i43","tag_id":"cka5hfrsn0015skjs3y03ce6e","_id":"ckcox2plw000z68js5zuo4s3r"},{"post_id":"ckcox2wxz001368js7e8862ic","tag_id":"ckbf5c0rm00084sjsfv7m8uso","_id":"ckcox2wy0001468jsdnvvdcsr"},{"post_id":"ckcox355q001768js9e62ga2t","tag_id":"ckbf5i3g7000i4sjs188r2hew","_id":"ckcox355q001868jsc8h1h0iw"},{"post_id":"ckcox3wli001a68js97npdw1o","tag_id":"ckbf6826u000jsgjsbrc4bxhu","_id":"ckcox3wlj001b68js9jd77jww"},{"post_id":"ckcox3wlp001e68js1ekl2tu3","tag_id":"ckbf6826u000jsgjsbrc4bxhu","_id":"ckcox3wlp001f68jshx4jcvuw"},{"post_id":"ckcox3wls001i68js3kuk3art","tag_id":"ckbf6826u000jsgjsbrc4bxhu","_id":"ckcox3wls001j68js46u8a4pe"},{"post_id":"ckcox5qk0001z68jscwtn5m2v","tag_id":"cka5hfru5002qskjs4mqc9naw","_id":"ckcox5qk0002068js0k0zcbuz"},{"post_id":"ckcox688h002668js6axa5to9","tag_id":"cka5hfru7002uskjscod4efqc","_id":"ckcox688h002768jsbzeb14l4"},{"post_id":"ckcox688h002668js6axa5to9","tag_id":"cka5hfru2002nskjs3lg1hftz","_id":"ckcox688i002868js0x1x6gkf"},{"post_id":"ckcox6lju002b68jscc1669lb","tag_id":"ckcol4yl60000xwjs2eodf5ba","_id":"ckcox6ljw002c68js4uu17n79"},{"post_id":"ckcox6lk0002f68js55yib0sa","tag_id":"ckcol4yl60000xwjs2eodf5ba","_id":"ckcox6lk2002h68jsg99caixg"},{"post_id":"ckcox6lk1002g68js20d94tjs","tag_id":"ckcol4yl60000xwjs2eodf5ba","_id":"ckcox6lk2002i68js4ekbcf5u"},{"post_id":"ckcox6qti002m68js3y3b9vov","tag_id":"ckcol4yl60000xwjs2eodf5ba","_id":"ckcox6qtj002n68js9u1t1csg"},{"post_id":"ckcox7saf002z68jsb43p9365","tag_id":"ckbf5c0rm00084sjsfv7m8uso","_id":"ckcox7sag003068js73m5e8tv"},{"post_id":"ckcoz0gft003e68jsfw2u7nil","tag_id":"cka5hfru2002nskjs3lg1hftz","_id":"ckcoz0gfu003f68jsapmsdbnr"},{"post_id":"ckcoz2fv0003v68js3o7w1b5d","tag_id":"ckbf3trug00024sjs4919gr42","_id":"ckcoz2fv1003w68js3myxhmg5"},{"post_id":"ckcoz2fv0003v68js3o7w1b5d","tag_id":"ckbf3truh00034sjs12zy86eg","_id":"ckcoz2fv1003x68jsa9sj1926"},{"post_id":"ckcoz3dve004r68js639rdgm6","tag_id":"cka5hfrt5001nskjs532b92ml","_id":"ckcoz3dvf004s68jse8m7bj74"},{"post_id":"ckcoz48rs004w68js9o0abpnf","tag_id":"cka5hfrs0000iskjs2u7x6hwt","_id":"ckcoz48rt004x68js7sis412t"},{"post_id":"ckcoz8l8a005r68jsbz7w7g96","tag_id":"ckbf68270000usgjsbmoygynw","_id":"ckcoz8l8b005s68jshz1dgmhx"},{"post_id":"ckcoz8rn5005v68js7lj4h3gp","tag_id":"cka5hfrsn0015skjs3y03ce6e","_id":"ckcoz8rn6005w68js8ggl5moy"},{"post_id":"ckcoz8rn7005z68js74zg71gb","tag_id":"cka5hfrsu001eskjsdr0pbjoj","_id":"ckcoz8rn8006068jsdobh7gkd"},{"post_id":"ckcoz8rn7005z68js74zg71gb","tag_id":"cka5hfrsx001jskjs2ay2fvsc","_id":"ckcoz8rn8006168js0s9y3j3n"},{"post_id":"ckcozp8rt0001l4jsaytbhcbk","tag_id":"ckcol4yl60000xwjs2eodf5ba","_id":"ckcozp8rw0003l4js00eocqus"},{"post_id":"ckcozp8ru0002l4js646zbtrp","tag_id":"ckcol4yl60000xwjs2eodf5ba","_id":"ckcozp8s90006l4jsd2umedd7"},{"post_id":"ckcozp8rw0004l4js3fhz6j73","tag_id":"ckcol4yl60000xwjs2eodf5ba","_id":"ckcozp8sc0008l4jsgsssfltj"},{"post_id":"ckcozp8s90007l4js3035evnp","tag_id":"ckbf68270000usgjsbmoygynw","_id":"ckcozp8sj000bl4js1wiw6uyv"},{"post_id":"ckcozp8sj000cl4js9oevhe66","tag_id":"ckcol4yl60000xwjs2eodf5ba","_id":"ckcozp8sp000gl4js5tpkb6i9"},{"post_id":"ckcozp8sm000dl4js3y0sd1r8","tag_id":"cka5hfrqs0003skjsg3v05zkb","_id":"ckcozp8su000jl4js6cbv6u7t"},{"post_id":"ckcozp8sm000dl4js3y0sd1r8","tag_id":"cka5hfrr30008skjs08qxd2qb","_id":"ckcozp8sy000nl4jsegpmgbl6"},{"post_id":"ckcozp8sp000hl4js4kk84nf9","tag_id":"ckcol4yl60000xwjs2eodf5ba","_id":"ckcozp8t1000ql4js0onbhv60"},{"post_id":"ckcozp8sv000kl4jsfcfm81n3","tag_id":"ckav33tks0001fgjsbxe0hub3","_id":"ckcozp8t5000ul4js2iyv8s52"},{"post_id":"ckcozp8sz000ol4js2obc4x3i","tag_id":"cka5hfrqs0003skjsg3v05zkb","_id":"ckcozp8t8000xl4jsa57z4h2k"},{"post_id":"ckcozp8t1000rl4jscw0v11l0","tag_id":"cka5hfrqs0003skjsg3v05zkb","_id":"ckcozp8ta0010l4js4roy76y7"},{"post_id":"ckcozp8ub001tl4jsae811ozx","tag_id":"cka5hfrt8001tskjs9h3wh088","_id":"ckcozp8ud001xl4jshw72clx9"},{"post_id":"ckcozp8ub001tl4jsae811ozx","tag_id":"cka5hfrta001xskjs9exbbsx8","_id":"ckcozp8ue0020l4js3gecau0o"},{"post_id":"ckcozp8uc001vl4js3skp5h9k","tag_id":"ckbf6826u000jsgjsbrc4bxhu","_id":"ckcozp8uf0023l4jshx518137"},{"post_id":"ckcozp8ud001yl4js4o9o1den","tag_id":"ckbf6826u000jsgjsbrc4bxhu","_id":"ckcozp8uh0025l4js2q2l23tx"},{"post_id":"ckcozp8ue0021l4js2w662un9","tag_id":"ckbf6826u000jsgjsbrc4bxhu","_id":"ckcozp8ui0027l4js8mjme15g"},{"post_id":"ckcozp8ul0029l4jsfqw2ampt","tag_id":"ckcol4yll0007xwjse0fi16rd","_id":"ckcozp8up002cl4js7rv1aqo0"},{"post_id":"ckcozp8up002dl4js3jjnf6i9","tag_id":"ckcol4yll0007xwjse0fi16rd","_id":"ckcozp8ur002gl4js590la0nl"},{"post_id":"ckcozp8ux002yl4jscvtca81b","tag_id":"ckcol4yll0007xwjse0fi16rd","_id":"ckcozp8v0002zl4js97o1142u"}],"Tag":[{"name":"python","_id":"cka5hfrqs0003skjsg3v05zkb"},{"name":"GUI","_id":"cka5hfrr30008skjs08qxd2qb"},{"name":"剧评","_id":"cka5hfrs0000iskjs2u7x6hwt"},{"name":"hexo","_id":"cka5hfrs5000oskjs6gai0x2e"},{"name":"云服务器","_id":"cka5hfrsa000tskjsdvoagyh3"},{"name":"git","_id":"cka5hfrsn0015skjs3y03ce6e"},{"name":"latex","_id":"cka5hfrsu001eskjsdr0pbjoj"},{"name":"论文","_id":"cka5hfrsx001jskjs2ay2fvsc"},{"name":"二叉树","_id":"cka5hfrt5001nskjs532b92ml"},{"name":"CNN","_id":"cka5hfrt8001tskjs9h3wh088"},{"name":"语义分割","_id":"cka5hfrta001xskjs9exbbsx8"},{"name":"散文","_id":"cka5hfru2002nskjs3lg1hftz"},{"name":"杂文","_id":"cka5hfru5002qskjs4mqc9naw"},{"name":"日志","_id":"cka5hfru7002uskjscod4efqc"},{"name":"pygame","_id":"ckav33tks0001fgjsbxe0hub3"},{"name":"matlab","_id":"ckbf3trug00024sjs4919gr42"},{"name":"图像","_id":"ckbf3truh00034sjs12zy86eg"},{"name":"前端","_id":"ckbf5c0rm00084sjsfv7m8uso"},{"name":"ArcGIS","_id":"ckbf5g5d8000e4sjs2zhm1os6"},{"name":"GIS","_id":"ckbf5i3g7000i4sjs188r2hew"},{"name":"数据库","_id":"ckbf6826u000jsgjsbrc4bxhu"},{"name":"Python","_id":"ckbf68270000usgjsbmoygynw"},{"name":"Java","_id":"ckcol4yl60000xwjs2eodf5ba"},{"name":"数据结构","_id":"ckcol4yll0007xwjse0fi16rd"}]}}
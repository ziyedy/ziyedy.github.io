<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>blender</title>
    <url>/page/null.html</url>
    <content><![CDATA[<p>gg</p>
<p><code>Shift + A</code></p>
<p><code>Ctrl + C</code></p>
<p><code>Ctrl +V</code></p>
<h2 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h2><p><code>Shift X</code>与<code>Shift Y</code>是控制相机朝向的</p>
]]></content>
  </entry>
  <entry>
    <title>霍夫变换</title>
    <url>/page/hough.html</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="7b2854d742a9a9d617bd1db6799dea02223608554ce00ee699f2d832618aae31">20c692944ea548884f6dd8e82619e827b321cdc290408d3225599e6ce53ef90d9e64039afe8f83de6c885f520e0f467a28d26ad5e6fcc8e8d7d41a0b42e2f2b7466b8308701c4545a736f3718334334d7c8e2b0cb1de1050a3d3690f1d6081e2f0918c01ec50a23ec4356853c2cefccef0544d40358e35f4e491a7ab701253a0668ee28fff200c3c434b6e9f4459b34192c2f53d1fd127cbfe74ca626501f12958d2cd108504370e700a7db3c54cfa298e4d1f4cb933f28a1ebdb549de2178d18d9251cf4372f1b11c44eae49a8d97f4cb376cbf2d5dd037a155e277187b072e332e40c743ac218ca6e9af8b63b968d663728b94201da2bc03645227b7b88c48239f0d787d0be866446b994f2ce53140c526c60bcaa7f042f5ed165a0b24af90a30b56164682b4d43c4a50cf34c84623c9658bee3bad232174ec01135ebfab19a4a8424e8217a0dc1c725dc1a23146841034822924108a3693354ba29ee9dc3246ac19decb60f8336a49bc1daf5f8458b7015d3aa06ae7fdc1be9fd4fac5cfdd6e60da4bd46fa9f387ca222bbc2891115a5e3b11fb2054f541a7b48edeb47883d8cfd5020a39804550fca3c39412478e799f80c6a59850761585770bd308ba66821fb2c43c29c220b429959c8ed6e91262e78c12c397cd5991a14f87c0f51c40c1a5c367985af429f267d34dc5f1b4cc2204e40d9516763283ade4101d7f75662a55ef4a3446f54e89bb5955e6d533d931ea2aa7f23a0fd631481949a699659f2f11ff86d6cae16179d0ccfd51b74f4f15a9646f6079b0a47b1b4e8cab5c1014cf61477cd3399831f3d3a299ef0c22e8dfbefc208b427350778c1f88cb50e055ef80a70c946126c6f3611994e17773e3ab4d9fa86bf99f08ae59cb0159e9664e556591718a644ef483ae2ad617f8255187206c5234e7453fe0397c6fc21ec056a3263dce92b87b75ec301ac7792e1ab5e51ec750e42763afab31a608f356f3252bda85e588ad129aea17a3e23ada5e6b8800f67f142e6bdaf9aa9d2cd85385670aa73f6f6964d1feeb38d115099a077a03bc14cd9275c192d598c285fddfad22008ee24901149532c067252bc715adab9bc6b59c75270c0dcb8662df509ba250b678f593ad80ad7debc0ea73a9a4f9cf12b7e598a3275e4f7b9db5d7900a2eafba0b0918709ad4b3e8413182ed8059eee0d4724bcfbd5344f5c22e12bf03a1b02aabdfa9ca0afa256c6036d068cf36498c61c7857e5287a1f207e21128aeb198c62e8aa94bc5093a8ba964ef7c24006d9c4f52ffdcb4805950f61174f44e6ba160834ce0f2aac0996a6f956f0842c0c587654cb8eaf4ab1625384fd5938e84ba804847e3df6e7bdf69ff27e8782d6098b1ebdc3d75907a9deec072ce19c1d96e</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>
      </label>
    </div>
  </div>
</div>
<script src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>post</title>
    <url>/page/null.html</url>
    <content><![CDATA[<h2 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h2><h3 id="写操作"><a href="#写操作" class="headerlink" title="写操作"></a>写操作</h3><blockquote>
<p>使用<code>openFileOutput()</code>方法，接收以下两个参数，返回一个<code>FileOutputStream</code>对象：</p>
<p>1、 文件名（不包括路径）</p>
<p>2、 文件操作模式（MODE_PRIVATE&lt;默认，写入数据覆盖原文件&gt; 和 MODE_APPEND&lt;向后追加文件&gt;）</p>
</blockquote>
<h3 id="读操作"><a href="#读操作" class="headerlink" title="读操作"></a>读操作</h3><blockquote>
<p><code>openFileInput()</code>方法，传入文件名，得到一个<code>FileInputStream</code>对象</p>
</blockquote>
<h2 id="SharedPreferences存储"><a href="#SharedPreferences存储" class="headerlink" title="SharedPreferences存储"></a>SharedPreferences存储</h2><blockquote>
<p>使用<code>xml</code>文件存储数据</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>Android开发二：活动（Activity）</title>
    <url>/page/Android2-activity.html</url>
    <content><![CDATA[<h2 id="从0构建一个活动"><a href="#从0构建一个活动" class="headerlink" title="从0构建一个活动"></a>从0构建一个活动</h2><h3 id="构建活动及布局"><a href="#构建活动及布局" class="headerlink" title="构建活动及布局"></a>构建活动及布局</h3><ol>
<li>在创建项目时选择<strong>“Add no Activity”</strong></li>
<li>在项目架构中的app-&gt;src-&gt;main下的包中右击，选择新建一个Activity，命名为FirstActivity</li>
<li>在布局文件夹layout中新建一个布局，命名为first_layout，并修改加上一个按钮，代码如下</li>
</ol>
<pre><code>&lt;Button
    android:id=&quot;@+id/button_1&quot;    &lt;!-- 定义id用于代码中使用 --&gt;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&quot;Button 1&quot;
    /&gt;</code></pre><ol start="4">
<li>在<strong>AndroidManifest.xml</strong>文件中注册活动，使用<code>&lt;activity&gt;</code>标签注册活动（AS已经自动注册好了），并放在<code>&lt;application&gt;</code>标签内，之后</li>
</ol>
<h3 id="使用Toast完成消息提醒"><a href="#使用Toast完成消息提醒" class="headerlink" title="使用Toast完成消息提醒"></a>使用Toast完成消息提醒</h3><p><strong>Android中的Toast类似于其他GUI中的messagebox，“弹出”一条消息</strong></p>
<pre><code class="java">@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.first_layout);
    Button button1 = (Button) findViewById(R.id.button_1);    // 获取该活动中的按钮
    button1.setOnClickListener(new View.OnClickListener() {    // 为按钮注册一个监听器
        @Override
        public void onClick(View view) {    // 点击按钮，即执行监听器下的onClick方法
            Toast.makeText(FirstActivity.this, &quot;You clicked Button 1&quot;,
                    Toast.LENGTH_SHORT).show();
        }
    });
}</code></pre>
<p>其中makeText()包含三个参数，第一个是要求的上下文，第二个是显示的文本内容，第三个是显示的时长</p>
<img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%BA%8C%EF%BC%9A%E6%B4%BB%E5%8A%A8%EF%BC%88Activity%EF%BC%89/toast-demo.png" style="zoom: 50%;" />

<h3 id="使用menu"><a href="#使用menu" class="headerlink" title="使用menu"></a>使用menu</h3><ol>
<li>在res目录下创建一个menu文件，之后创建一个menu资源文件。</li>
<li>之后使用<code>&lt;item&gt;</code>标签创建一个菜单项，如下</li>
</ol>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
    &lt;item
        android:id=&quot;@+id/add_item&quot;    &lt;!-- 创建唯一标识符 --&gt;
        android:title=&quot;Add&quot; /&gt;    &lt;!-- 创建菜单项的名称 --&gt;
    &lt;item
        android:id=&quot;@+id/remove_item&quot;
        android:title=&quot;Remove&quot; /&gt;
&lt;/menu&gt;</code></pre><ol start="3">
<li>之后在相应活动中重写<code>onCreateOptionsMenu</code>函数，用以显示菜单，如下</li>
</ol>
<pre><code class="java">@Override
public boolean onCreateOptionsMenu(Menu menu) {
    getMenuInflater().inflate(R.menu.main, menu);    // 
    return true;    // 返回true表示允许菜单显示出来
}</code></pre>
<ol start="4">
<li>定义菜单响应事件，重写<code>onOptionsItemSelected()</code>方法</li>
</ol>
<pre><code>@Override
public boolean onOptionsItemSelected(@NonNull MenuItem item) {
    switch (item.getItemId()) {
        case R.id.add_item:
            Toast.makeText(this, &quot;You clicked Add&quot;, Toast.LENGTH_SHORT).show();
            break;
        case R.id.remove_item:
            Toast.makeText(this, &quot;You clicked remove&quot;, Toast.LENGTH_SHORT).show();
            break;
        default:
    }
    return true;
}</code></pre><img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%BA%8C%EF%BC%9A%E6%B4%BB%E5%8A%A8%EF%BC%88Activity%EF%BC%89/menu-demo.png" style="zoom:50%;" />



<h3 id="使用finish-销毁一个活动，类似于返回键"><a href="#使用finish-销毁一个活动，类似于返回键" class="headerlink" title="使用finish()销毁一个活动，类似于返回键"></a>使用finish()销毁一个活动，类似于返回键</h3><p>使用Activity类提供的<strong>finish()</strong>方法，取得的效果跟按下Back一致</p>
<h2 id="使用Intent构建不同活动间的联系"><a href="#使用Intent构建不同活动间的联系" class="headerlink" title="使用Intent构建不同活动间的联系"></a>使用Intent构建不同活动间的联系</h2><p>intent是Android程序中<strong>各组件之间进行交互的一种重要方式</strong>，一般可用于启动活动、启动服务以及发送广播。根据指定响应对象是否直接可以分为显式Intent和隐式Intent。</p>
<p>以下，像之前一样构建一个<code>SecondActivity</code>，用于响应实验。</p>
<h3 id="显式Intent"><a href="#显式Intent" class="headerlink" title="显式Intent"></a>显式Intent</h3><p><strong>直接指定响应对象</strong>，如下（点击按钮即可跳转到第二个页面）</p>
<pre><code>button1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        Intent intent = new Intent(FirstActivity.this, SecondActivity.class);    // 由上下文响应目标活动
        startActivity(intent);    // 启动传入的Intent参数
    }
});</code></pre><p><code>Intent(Context packageContext, Class &lt;?&gt; cls)</code>，第一个参数 Context 要求提供一个启动活动的上下文，第二个参数 Class 则是指定想要启动的目标活动</p>
<p>Activity 类中提供了一个 startActivity() 方法，这个方法是专门用于启动活动的，它接收一个 Intent 参数，这里我们将构建好的 Intent 传入 startActivity() 方法就可以启动目标活动了。</p>
<h3 id="隐式Intent"><a href="#隐式Intent" class="headerlink" title="隐式Intent"></a>隐式Intent</h3><p>隐式Intent<strong>并不明确指出我们想要启动哪一个活动，而是指定了一系列更为抽象的 action 和 category 等信息，然后交由系统去分析这个 Intent，并帮我们找出合适的活动</strong>（即能够相应该隐式intent的活动）去启动</p>
<p>通过在<code>&lt;activity&gt;</code>标签下配置<code>&lt; intent-filter &gt;</code>的内容，可以指定当前活动能够响应的 action 和 category。同时，<strong>只有 <code>&lt;action&gt;</code> 和 <code>&lt;category&gt;</code> 中的内容同时能够匹配上 Intent 中指定的 action 和 category 时，这个活动才能响应该 Intent</strong>。</p>
<p>如下，在<strong>AndroidManifest.xml</strong>文件中配置SecondActivity的信息如下</p>
<pre><code>&lt;activity android:name=&quot;.SecondActivity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
        &lt;category android:name=&quot;com.example.activitytest.MY_CATEGORY&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
&lt;activity</code></pre><p>在FirstActivity中使用隐式Intent，完成点击按钮跳转到第二个界面</p>
<pre><code>button1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        Intent intent = new Intent(&quot;com.example.activitytest.ACTION_START&quot;);
        intent.addCategory(&quot;com.example.activitytest.MY_CATEGORY&quot;);
        startActivity(intent);
    }
});</code></pre><p>用隐式 Intent，我们<strong>不仅可以启动自己程序内的活动，还可以启动其他程序的活动（如调用浏览器）</strong>，这使得 Android 多个应用程序之间的功能共享成为了可能</p>
<pre><code>button1.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View view) {
        Intent intent = new Intent(Intent.ACTION_VIEW);
        intent.setData(Uri.parse(&quot;http://www.baidu.com&quot;));    // 将Uri对象传递进去，可以使用浏览器打开
        startActivity(intent);
    }
});</code></pre><img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%BA%8C%EF%BC%9A%E6%B4%BB%E5%8A%A8%EF%BC%88Activity%EF%BC%89/%E6%89%93%E5%BC%80%E6%B5%8F%E8%A7%88%E5%99%A8.png" style="zoom:50%;" />



<h3 id="Intent向下一个活动传递数据"><a href="#Intent向下一个活动传递数据" class="headerlink" title="Intent向下一个活动传递数据"></a>Intent向下一个活动传递数据</h3><p>Intent 中提供了一系列 <strong>putExtra()</strong> 方法的重载，可以把我们想要传递的数据暂存在 Intent 中，启动了另一个活动后，只需要把这些数据再从 Intent 中取出就可以了</p>
<p>putExtra() 方法接收两个参数，第一个参数是键，用于后面从 Intent 中取值，第二个参数才是真正要传递的数据。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在FirstActivity中相应位置填入以下代码</p>
<pre><code>String data = &quot;Hello, Second Activity&quot;;
Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
intent.putExtra(&quot;extra_data&quot;, data);    // 将data传入，同时键值为extra_dat
startActivity(intent);</code></pre><p>在SecondActivity中相应位置填入以下代码</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.second_layout);
    Intent intent = getIntent();
    String data = intent.getStringExtra(&quot;extra_data&quot;);    // 通过键值获取信息
    Toast.makeText(this, data, Toast.LENGTH_SHORT).show();    // 显示信息
}</code></pre><img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%BA%8C%EF%BC%9A%E6%B4%BB%E5%8A%A8%EF%BC%88Activity%EF%BC%89/%E4%BC%A0%E9%80%92%E6%B6%88%E6%81%AF%E7%BB%99%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8.png" style="zoom: 67%;" />

<h3 id="Intent返回数据给上一个活动"><a href="#Intent返回数据给上一个活动" class="headerlink" title="Intent返回数据给上一个活动"></a>Intent返回数据给上一个活动</h3><p><strong>1、 使用startActivityForResult() 方法启动活动，在活动销毁后即可将数据传递回来</strong></p>
<blockquote>
<p>startActivityForResult() 方法接收两个参数，第一个参数还是 Intent，第二个参数是<strong>请求码（requestCode）</strong>，用于在之后的回调中判断数据的来源。</p>
</blockquote>
<p><strong>2、在第二个活动中使用setResult() 方法将带有数据的Intent传递回去</strong></p>
<blockquote>
<p>setResult() 方法接收两个参数，第一个参数用于向上一个活动返回处理结果，一般只使用 RESULT_OK 或 RESULT_CANCELED 这两个值，第二个参数则把带有数据的 Intent 传递回去</p>
</blockquote>
<p><strong>3、使用startActivityForResult() 方法启动活动在活动销毁后会回调onActivityResult() 方法</strong>，因此在第一个活动中重写该方法。</p>
<blockquote>
<p> onActivityResult() 方法带有三个参数，第一个参数 requestCode ，即我们在启动活动时传入的请求码。第二个参数 resultCode ，即我们在返回数据时传入的处理结果。第三个参数 data，即携带着返回数据的 Intent</p>
</blockquote>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>在FirstActivity中相应位置填入以下代码</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.first_layout);
    Button button1 = (Button) findViewById(R.id.button_1);
    button1.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            Intent intent = new Intent(FirstActivity.this, SecondActivity.class);
            startActivityForResult(intent, 1);    // 请求码为1
        }
    });
}

@Override
protected void onActivityResult(int requestCode, int resultCode, @Nullable Intent data) {
    super.onActivityResult(requestCode, resultCode, data);
    if (requestCode == 1) {
        if (resultCode == RESULT_OK) {
            assert data != null;
            String returnData = data.getStringExtra(&quot;data_return&quot;);
            Toast.makeText(FirstActivity.this, returnData, Toast.LENGTH_SHORT).show();
        }
    }
}</code></pre><p>在SecondActivity中相应位置填入以下代码</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.second_layout);
    Button button2 = (Button) findViewById(R.id.button_2);
    button2.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            Intent intent = new Intent();
            intent.putExtra(&quot;data_return&quot;, &quot;Return message from SecondActivity&quot;);
            setResult(RESULT_OK, intent);
            finish();
        }
    });
}</code></pre><img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%BA%8C%EF%BC%9A%E6%B4%BB%E5%8A%A8%EF%BC%88Activity%EF%BC%89/%E4%BB%8E%E4%B8%8B%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E8%BF%94%E5%9B%9E%E6%B6%88%E6%81%AF.png" style="zoom:67%;" />



<h2 id="活动的生命周期"><a href="#活动的生命周期" class="headerlink" title="活动的生命周期"></a>活动的生命周期</h2><h3 id="活动状态"><a href="#活动状态" class="headerlink" title="活动状态"></a>活动状态</h3><p>每个活动在其生命周期最多可能有4种状态</p>
<h4 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h4><p>一个活动位于返回栈的<strong>栈顶</strong>时，这时活动就处于运行状态</p>
<h4 id="暂停状态"><a href="#暂停状态" class="headerlink" title="暂停状态"></a>暂停状态</h4><p>当一个活动<strong>不再处于栈顶位置，但仍然可见</strong>时，这时活动就进入了暂停状态。</p>
<h4 id="停止状态"><a href="#停止状态" class="headerlink" title="停止状态"></a>停止状态</h4><p>当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。（当其他地方需要内存时，处于停止状态的活动有可能会被系统回收）</p>
<h4 id="销毁状态"><a href="#销毁状态" class="headerlink" title="销毁状态"></a>销毁状态</h4><p>当一个活动<strong>从返回栈中移除后</strong>就变成了销毁状态。系统会最倾向于回收处于这种状态的活动，从而保证手机的内存充足。</p>
<h3 id="活动的生存期"><a href="#活动的生存期" class="headerlink" title="活动的生存期"></a>活动的生存期</h3><p>Activity 类中定义了 7 个回调方法，覆盖了活动生命周期的每一个环节</p>
<h4 id="onCreate"><a href="#onCreate" class="headerlink" title="onCreate()"></a>onCreate()</h4><blockquote>
<p>在活动第一次被创建的时候调用</p>
<p>在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等</p>
</blockquote>
<h4 id="onStart"><a href="#onStart" class="headerlink" title="onStart()"></a>onStart()</h4><blockquote>
<p>活动由不可见变为可见的时候调用</p>
</blockquote>
<h4 id="onResume"><a href="#onResume" class="headerlink" title="onResume()"></a>onResume()</h4><blockquote>
<p>活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的栈顶，并且处于运行状态</p>
</blockquote>
<h4 id="onPause"><a href="#onPause" class="headerlink" title="onPause()"></a>onPause()</h4><blockquote>
<p>这个方法在系统准备去启动或者恢复另一个活动的时候调用</p>
</blockquote>
<h4 id="onStop"><a href="#onStop" class="headerlink" title="onStop()"></a>onStop()</h4><blockquote>
<p>这个方法在活动完全不可见的时候调用</p>
</blockquote>
<h4 id="onDestroy"><a href="#onDestroy" class="headerlink" title="onDestroy()"></a>onDestroy()</h4><blockquote>
<p>这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。</p>
</blockquote>
<h4 id="onRestart"><a href="#onRestart" class="headerlink" title="onRestart()"></a>onRestart()</h4><blockquote>
<p>这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。</p>
</blockquote>
<h2 id="活动的启动模式"><a href="#活动的启动模式" class="headerlink" title="活动的启动模式"></a>活动的启动模式</h2><h3 id="standard"><a href="#standard" class="headerlink" title="standard"></a>standard</h3><blockquote>
<p>活动默认的启动模式，每次启动都会创建该活动的一个新的实例</p>
</blockquote>
<h3 id="singleTop"><a href="#singleTop" class="headerlink" title="singleTop"></a>singleTop</h3><blockquote>
<p>启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例</p>
<p><strong>不重复创建栈顶活动</strong></p>
</blockquote>
<p>在<code>AndroidManifest.xml</code>中<code>&lt;activity&gt;</code>标签内设置</p>
<pre><code>android:launchMode=&quot;singleTop&quot;</code></pre><h3 id="singleTask"><a href="#singleTask" class="headerlink" title="singleTask"></a>singleTask</h3><blockquote>
<p>让任意活动在整个应用程序的上下文中<strong>只存在一个实例</strong></p>
<p><code>android:launchMode=&quot;singleTask&quot;</code></p>
</blockquote>
<h3 id="singleInstance"><a href="#singleInstance" class="headerlink" title="singleInstance"></a>singleInstance</h3><blockquote>
<p>这种模式下会有一个<strong>单独的返回栈</strong>来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，解决了<strong>共享活动实例</strong>的问题</p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>第一行代码——Android（郭霖）</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发三：布局（layout）</title>
    <url>/page/Android3-layout.html</url>
    <content><![CDATA[<h2 id="Android常用控件"><a href="#Android常用控件" class="headerlink" title="Android常用控件"></a>Android常用控件</h2><h3 id="TextView"><a href="#TextView" class="headerlink" title="TextView"></a>TextView</h3><blockquote>
<p>在界面上显示一段文本信息</p>
</blockquote>
<h4 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h4><pre><code>android:text=&quot;TextView&quot;        显示的文本
android:gravity=&quot;center&quot;    对齐方式
android:textSize=&quot;30sp&quot;        文字大小
android:textColor=&quot;#03A9F4&quot;    文字颜色</code></pre><p><img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%B8%89%EF%BC%9A%E5%B8%83%E5%B1%80%EF%BC%88layout%EF%BC%89/TextView.png" alt=""></p>
<h3 id="Button"><a href="#Button" class="headerlink" title="Button"></a>Button</h3><blockquote>
<p>配置一个按钮，默认全为大写</p>
</blockquote>
<h4 id="常用属性-1"><a href="#常用属性-1" class="headerlink" title="常用属性"></a>常用属性</h4><p>常用属性与TextView类似</p>
<pre><code>android:textAllCaps=&quot;false&quot;        将默认文字全部大写关掉</code></pre><h4 id="绑定逻辑代码（注册监听器）"><a href="#绑定逻辑代码（注册监听器）" class="headerlink" title="绑定逻辑代码（注册监听器）"></a>绑定逻辑代码（注册监听器）</h4><p><strong>使用匿名类的写法，不需要对view进行判断</strong></p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Button button = (Button) findViewById(R.id.button);
    button.setOnClickListener(new View.OnClickListener() {
        @Override
        public void onClick(View view) {
            // 添加逻辑代码
        }
    });
}</code></pre><p><strong>使用实现View.OnClickListener接口的方法</strong></p>
<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener {

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    Button button = (Button) findViewById(R.id.button);
    button.setOnClickListener(this);
}

@Override
public void onClick(View v) {
    switch (v.getId()) {    // 判断触发监听器的是哪个按钮
        case R.id.button:
            // 添加逻辑代码
            break;
        default:
            break;
    }
}</code></pre><h3 id="EditText"><a href="#EditText" class="headerlink" title="EditText"></a>EditText</h3><blockquote>
<p>允许用户在控件里输入和编辑内容，并可以在程序中对这些内容进行处理</p>
</blockquote>
<h4 id="常用属性-2"><a href="#常用属性-2" class="headerlink" title="常用属性"></a>常用属性</h4><pre><code>android:hint=&quot;Type something here&quot;    输入时的提示信息
android:maxLines=&quot;1&quot;    指定最大行数（如密码输入框最大行数为1），大于最大行数向下滚动</code></pre><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><pre><code>getText()    // 获取输入的内容</code></pre><h3 id="AlertDialog"><a href="#AlertDialog" class="headerlink" title="AlertDialog"></a>AlertDialog</h3><blockquote>
<p>在当前的界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽掉其他控件的交互能力，因此 AlertDialog 一般都是用于提示一些非常重要的内容或者警告信息</p>
</blockquote>
<h4 id="对话框使用流程"><a href="#对话框使用流程" class="headerlink" title="对话框使用流程"></a>对话框使用流程</h4><ol>
<li>通过<code>AlertDialog.Builder</code>创建一个 AlertDialog 的实例</li>
<li>为这个对话框设置标题、内容（<code>setMessage</code>）、可否用 Back 键关闭对话框（<code>setCancelable</code>）等属性</li>
<li>调用 setPositiveButton() 方法为对话框设置确定按钮的点击事件，调用 setNegativeButton() 方法设置取消按钮的点击事件</li>
<li>调用 show()方法将对话框显示出来</li>
</ol>
<h4 id="点击按钮将EditText在对话框中弹出"><a href="#点击按钮将EditText在对话框中弹出" class="headerlink" title="点击按钮将EditText在对话框中弹出"></a>点击按钮将EditText在对话框中弹出</h4><p>该示例需要使用到按钮点击事件，从EditText获取内容，及AlertDialog的相关操作。</p>
<pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener {

    private EditText editText;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        Button button = (Button) findViewById(R.id.button);
        editText = (EditText) findViewById(R.id.edit_text);
        button.setOnClickListener(this);
    }


    @Override
    public void onClick(View v) {
        switch (v.getId()) {
            case R.id.button:
                String inputText = editText.getText().toString();    // 获取输入内容
                AlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this);
                dialog.setMessage(inputText);
                dialog.setCancelable(false);
                dialog.setPositiveButton(&quot;OK&quot;, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialogInterface, int i) {

                    }
                });
                dialog.setNegativeButton(&quot;Cancel&quot;, new DialogInterface.OnClickListener() {
                    @Override
                    public void onClick(DialogInterface dialogInterface, int i) {

                    }
                });
                dialog.show();
                break;
            default:
                break;
        }
    }
}</code></pre><img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%B8%89%EF%BC%9A%E5%B8%83%E5%B1%80%EF%BC%88layout%EF%BC%89/%E8%BE%93%E5%85%A5%E6%A1%86%E5%BC%B9%E5%87%BA%E6%95%88%E6%9E%9C.png" style="zoom:67%;" />



<h3 id="ImageView"><a href="#ImageView" class="headerlink" title="ImageView"></a>ImageView</h3><blockquote>
<p>在界面上展示图片的一个控件</p>
<p>图片通常放置在以 “drawable” 开头的目录下（drawable后会跟具体的分辨率）</p>
</blockquote>
<h4 id="常用属性和方法"><a href="#常用属性和方法" class="headerlink" title="常用属性和方法"></a>常用属性和方法</h4><pre><code>android:src=&quot;@drawable/img_1 &quot;    指定显示图片的位置</code></pre><p>在代码中可以使用<code>setImageResource(R.drawable.img_2)</code>来指定图片的位置</p>
<h3 id="ProgressBar"><a href="#ProgressBar" class="headerlink" title="ProgressBar"></a>ProgressBar</h3><blockquote>
<p>在界面上显示一个进度条，表示我们的程序正在加载一些数据</p>
</blockquote>
<h4 id="常用属性-3"><a href="#常用属性-3" class="headerlink" title="常用属性"></a>常用属性</h4><pre><code>style=&quot;?android:attr/progressBarStyleHorizontal&quot;    使用style属性改变进度条的样式（该行为指定为水平条状）
android:max=&quot;100&quot;    max设置进度条最大值</code></pre><h4 id="常用方法-1"><a href="#常用方法-1" class="headerlink" title="常用方法"></a>常用方法</h4><pre><code>getVisibility()
setVisibility(View.VISIBLE)    // 设置可见度
getProgress()    // 获取进度条进度
setProgress(progress)    // 更改进度条进度</code></pre><h3 id="ProgressDialog"><a href="#ProgressDialog" class="headerlink" title="ProgressDialog"></a>ProgressDialog</h3><blockquote>
<p>与<code>AlertDialog</code>类似，都可以在界面上弹出一个对话框，都能够屏蔽掉其他控件的交互能力</p>
<p>不同的是，ProgressDialog 会在对话框中显示一个进度条，一般用于表示当前操作比较耗时，让用户耐心地等待</p>
<p><strong>用法和 AlertDialog 也相似</strong></p>
<p>可以使用<code>dismiss()</code> 方法来关闭对话框</p>
</blockquote>
<h2 id="滚动控件（ListView与RecyclerView）"><a href="#滚动控件（ListView与RecyclerView）" class="headerlink" title="滚动控件（ListView与RecyclerView）"></a>滚动控件（ListView与RecyclerView）</h2><h3 id="ListView"><a href="#ListView" class="headerlink" title="ListView"></a>ListView</h3><blockquote>
<p>ListView 允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据则会滚动出屏幕（如聊天记录等等）</p>
</blockquote>
<h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><ol>
<li>编写相关的布局代码</li>
</ol>
<pre><code>&lt;ListView
    android:id=&quot;@+id/list_view&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; /&gt;</code></pre><ol start="2">
<li>定义数据，并使用<code>ArrayAdapter</code>适配器将要适配的数据传入</li>
</ol>
<blockquote>
<p><code>ArrayAdapter</code>可以指定数据泛型。</p>
<p>参数分别为<code>(当前上下文, ListView 子项布局的 id, 要适配的数据)</code></p>
</blockquote>
<ol start="3">
<li>调用 ListView 的<code>setAdapter()</code>方法，将构建好的适配器对象传递进去，建立ListView与数据的关联</li>
</ol>
<pre><code>private String[] data = { &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Watermelon&quot;,
            &quot;Pear&quot;, &quot;Grape&quot;, &quot;Pineapple&quot;, &quot;Strawberry&quot;, &quot;Cherry&quot;, &quot;Mango&quot;,
            &quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Watermelon&quot;, &quot;Pear&quot;, &quot;Grape&quot;,
            &quot;Pineapple&quot;, &quot;Strawberry&quot;, &quot;Cherry&quot;, &quot;Mango&quot; };

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    // 使用适配器
    ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;&gt;(MainActivity.this,
                android.R.layout.simple_list_item_1, data);
    ListView listView = (ListView) findViewById(R.id.list_view);
    listView.setAdapter(adapter);    // 传入适配器
}</code></pre><p><strong>显示效果如下</strong></p>
<img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%B8%89%EF%BC%9A%E5%B8%83%E5%B1%80%EF%BC%88layout%EF%BC%89/ListView%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.png" style="zoom: 50%;" />



<h4 id="自定义ListView界面"><a href="#自定义ListView界面" class="headerlink" title="自定义ListView界面"></a>自定义ListView界面</h4><blockquote>
<p>1、自定义 ListView 子项布局的样式（即写一个layout的xml）</p>
<p>2、写一个实例类，用于作为列表项的泛型</p>
<p>3、创建一个自定义的适配器，这个适配器继承自 ArrayAdapter。重写构造方法与getView()等方法</p>
<p>4、按ListView的基础用法在主活动中引入即可</p>
</blockquote>
<h4 id="ListView的点击事件"><a href="#ListView的点击事件" class="headerlink" title="ListView的点击事件"></a>ListView的点击事件</h4><p><strong>标准写法如下：<code>setOnItemClickListener</code></strong></p>
<pre><code>listView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
    @Override
    public void onItemClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
        // position指列表中点击的索引
        // 添加逻辑代码
    }
});</code></pre><h3 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h3><blockquote>
<p>加强版的ListView，更推荐使用</p>
<p>ListView 的布局排列是由自身去管理的，而 RecyclerView 则将这个工作交给了<code>LayoutManager</code>等接口，因此在布局上非常方便</p>
</blockquote>
<h4 id="标准使用"><a href="#标准使用" class="headerlink" title="标准使用"></a>标准使用</h4><blockquote>
<p>与ListView相比不同之处在于<code>setLayoutManager</code>设置了“滚动方式”</p>
</blockquote>
<pre><code>RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view);

LinearLayoutManager layoutManager = new LinearLayoutManager(this);
layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL);    // 设置滚动方式（此处设置为水平）
recyclerView.setLayoutManager(layoutManager);    // 设置LinearLayoutManager对象
FruitAdapter adapter = new FruitAdapter(fruitList);
recyclerView.setAdapter(adapter);</code></pre><p>除此之外，还可以通过<code>GridLayoutManager</code>与<code>StaggeredGridLayoutManager</code>这两种方式实现网格布局和瀑布流布局</p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><h3 id="常用布局属性"><a href="#常用布局属性" class="headerlink" title="常用布局属性"></a>常用布局属性</h3><pre><code>android:layout_width=&quot;match_parent&quot;        表示width与父布局的width相同
android:layout_height=&quot;wrap_content&quot;    表示height刚好能够容纳内容</code></pre><h3 id="线性布局（LinearLayout）"><a href="#线性布局（LinearLayout）" class="headerlink" title="线性布局（LinearLayout）"></a>线性布局（LinearLayout）</h3><pre><code>&lt;LinearLayout
    android:orientation=&quot;horizontal&quot;    
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;!-- 添加布局内部的组件 --&gt;

&lt;/LinearLayout&gt;</code></pre><h4 id="常用属性-4"><a href="#常用属性-4" class="headerlink" title="常用属性"></a>常用属性</h4><pre><code>android:orientation=&quot;horizontal&quot;    指定是水平还是垂直（horizontal与vertical可选）
android:layout _gravity        指定布局内控件的对齐方式
android:layout _weight        使用比例的方式来指定控件的大小（即将所有控件按比例指定长宽大小）</code></pre><h4 id="layout-weight示例"><a href="#layout-weight示例" class="headerlink" title="layout_weight示例"></a>layout_weight示例</h4><pre><code>&lt;LinearLayout
    android:orientation=&quot;horizontal&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

&lt;EditText
    android:id=&quot;@+id/edit_text&quot;
    android:layout_width=&quot;0dp&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:layout_weight=&quot;3&quot;
    /&gt;

&lt;Button
    android:id=&quot;@+id/button&quot;
    android:layout_width=&quot;0dp&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:text=&quot;send&quot;
    android:layout_weight=&quot;1&quot;
    /&gt;

&lt;/LinearLayout&gt;</code></pre><p><img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%B8%89%EF%BC%9A%E5%B8%83%E5%B1%80%EF%BC%88layout%EF%BC%89/layout-weight%E6%95%88%E6%9E%9C.png" alt="layout-weight：3比1的效果"></p>
<h3 id="相对布局（RelativeLayout）"><a href="#相对布局（RelativeLayout）" class="headerlink" title="相对布局（RelativeLayout）"></a>相对布局（RelativeLayout）</h3><blockquote>
<p>相对布局较为灵活，可以通过相对定位的方式让控件出现在布局的任何位置</p>
</blockquote>
<h4 id="相对于父布局定位"><a href="#相对于父布局定位" class="headerlink" title="相对于父布局定位"></a>相对于父布局定位</h4><img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%B8%89%EF%BC%9A%E5%B8%83%E5%B1%80%EF%BC%88layout%EF%BC%89/%E7%9B%B8%E5%AF%B9%E7%88%B6%E5%B8%83%E5%B1%80.png" style="zoom: 50%;" />



<h4 id="相对于控件定位"><a href="#相对于控件定位" class="headerlink" title="相对于控件定位"></a>相对于控件定位</h4><img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%B8%89%EF%BC%9A%E5%B8%83%E5%B1%80%EF%BC%88layout%EF%BC%89/%E7%9B%B8%E5%AF%B9%E6%8E%A7%E4%BB%B6.png" style="zoom:50%;" />



<h3 id="帧布局（FrameLayout）"><a href="#帧布局（FrameLayout）" class="headerlink" title="帧布局（FrameLayout）"></a>帧布局（FrameLayout）</h3><blockquote>
<p>所有的控件都会默认摆放在布局的左上角，应用很少</p>
</blockquote>
<h3 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h3><blockquote>
<p>百分比布局为 FrameLayout 和 RelativeLayout 进行了<strong>功能扩展</strong>，提供了 PercentFrameLayout 和 PercentRelativeLayout 这两个全新的布局</p>
</blockquote>
<h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><h3 id="引入布局"><a href="#引入布局" class="headerlink" title="引入布局"></a>引入布局</h3><blockquote>
<p>引入布局即新建一个布局文件，并在“主布局文件中”进行引用，达到<strong>重复应用某一布局的效果</strong></p>
</blockquote>
<p>引用布局使用include语句即可，示例：<code>&lt;include layout=&quot;@layout/title&quot; /&gt;</code>。即引入了一个<code>title.xml</code>的布局文件</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ol>
<li>新建<code>title.xml</code>文件，并在其中编写相应控件代码。</li>
<li>在<code>activity_main.xml</code>中使用<code>include</code>语句将新建的布局添加进去（就像添加常规布局一样）</li>
</ol>
<h3 id="自定义控件-1"><a href="#自定义控件-1" class="headerlink" title="自定义控件"></a>自定义控件</h3><blockquote>
<p>引入布局解决了重复编写布局代码的问题，但布局中的响应事件常常还需要编写</p>
<p>自定义控件即编写布局中的响应事件，避免重复编写相同代码</p>
</blockquote>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>在之前自定义布局的基础上，新建一个Java类，继承自<code>LinearLayout</code>，代码如下（即实现了该布局中控件的相关功能）：</p>
<pre><code>public class TitleLayout extends LinearLayout {
    public TitleLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
        LayoutInflater.from(context).inflate(R.layout.title, this);    // 进行加载

        // 编写控件中的按钮代码
        Button titleBack = (Button) findViewById(R.id.title_back);
        Button titleEdit = (Button) findViewById(R.id.title_edit);
        titleBack.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View view) {
                ((Activity) getContext()).finish();
            }
        });
        titleEdit.setOnClickListener(new OnClickListener() {
            @Override
            public void onClick(View view) {
                Toast.makeText(getContext(), &quot;You clicked Edit button&quot;,
                        Toast.LENGTH_SHORT).show();
            }
        });
    }
}</code></pre><img src="http://cdn.ziyedy.top/Android%E5%BC%80%E5%8F%91%E4%B8%89%EF%BC%9A%E5%B8%83%E5%B1%80%EF%BC%88layout%EF%BC%89/%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%A7%E4%BB%B6.png" style="zoom:67%;" />





<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>第一行代码——Android（郭霖）</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发五：广播机制</title>
    <url>/page/Android5-broadcast.html</url>
    <content><![CDATA[<h2 id="接收系统广播"><a href="#接收系统广播" class="headerlink" title="接收系统广播"></a>接收系统广播</h2><h3 id="动态注册（app运行时能够进行接收）"><a href="#动态注册（app运行时能够进行接收）" class="headerlink" title="动态注册（app运行时能够进行接收）"></a>动态注册（app运行时能够进行接收）</h3><ol>
<li>创建一个广播接收器</li>
</ol>
<blockquote>
<p>新建一个继承自 <code>BroadcastReceiver</code>的类，并重写父类的 <code>onReceive()</code> 方法</p>
</blockquote>
<pre><code>class NetworkChangeReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        // 若检测到变化，则弹出相关信息
        Toast.makeText(context, &quot;network changes&quot;, Toast.LENGTH_SHORT).show();
    }
}</code></pre><ol start="2">
<li>在<code>onCreate()</code>中创建一个<code>IntentFilter</code>实例，并使用<code>addAction()</code>添加系统发送的广播（<code>action1</code>）。之后创建一个步骤1类的实例。调用<code>registerReceiver()</code>方法将<code>NetworkChangeReceiver</code>的实例与<code>IntentFilter</code>的实例都传进去，即可<strong>使得<code>NetworkChangeReceiver</code>接收到对应的<code>action1</code></strong></li>
</ol>
<pre><code>private IntentFilter intentFilter;
private NetworkChangeReceive networkChangeReceive;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    intentFilter = new IntentFilter();
    intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;);    // 添加需要监听的广播
    networkChangeReceive = new NetworkChangeReceive();
    registerReceiver(networkChangeReceive, intentFilter);    // 绑定
}</code></pre><ol start="3">
<li>动态注册的广播接收器一定都要取消注册才行，在<code>onDestroy()</code>方法中通过调用<code>unregisterReceiver()</code>方法来实现</li>
</ol>
<pre><code>@Override
protected void onDestroy() {
    super.onDestroy();
    unregisterReceiver(networkChangeReceive);
}</code></pre><ol start="4">
<li>在<code>AndroidManifest.xml</code>中声明权限</li>
</ol>
<blockquote>
<p>注：如果程序需要进行一些对用户来说比较敏感的操作，就必须在配置文件中声明权限才可以，否则程序将会直接崩溃</p>
</blockquote>
<pre><code>&lt;uses-permission android:name=&quot;填入相关权限&quot; /&gt;</code></pre><h3 id="静态注册（开机启动）"><a href="#静态注册（开机启动）" class="headerlink" title="静态注册（开机启动）"></a>静态注册（开机启动）</h3><ol>
<li><p>右击 com.example.broadcasttest 包 →New→Other→ Broadcast Receiver，创建一个广播接收器</p>
</li>
<li><p>重写<code>onReceive()</code>方法</p>
</li>
<li><p>在<code>AndroidManifest.xml</code>文件中注册（AS通常情况会自动注册）</p>
</li>
</ol>
<pre><code>&lt;!-- 声明权限 --&gt;
&lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt;

&lt;receiver
    android:name=&quot;.BootCompleteReceiver&quot;
    android:enabled=&quot;true&quot;
    android:exported=&quot;true&quot;&gt;
    &lt;intent-filter&gt;
        &lt;!-- 开机启动 --&gt;
        &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;</code></pre><h2 id="自定义广播"><a href="#自定义广播" class="headerlink" title="自定义广播"></a>自定义广播</h2><h3 id="发送标准广播"><a href="#发送标准广播" class="headerlink" title="发送标准广播"></a>发送标准广播</h3><ol>
<li>定义接收器（与上一部分一样）</li>
</ol>
<pre><code>public class MyReceiver extends BroadcastReceiver {
    @Override
    public void onReceive(Context context, Intent intent) {
        Toast.makeText(context, &quot;received in MyReceiver&quot;, Toast.LENGTH_SHORT).show();
    }
}</code></pre><ol start="2">
<li>在<code>AndroidManifest.xml</code>中对事件接收器进行注册（注册接收什么事件）</li>
</ol>
<pre><code>&lt;receiver
    android:name=&quot;.MyReceiver&quot;
    android:enabled=&quot;true&quot;
    android:exported=&quot;true&quot;&gt;
    &lt;intent-filter&gt;
        &lt;!-- 接收名为MY_BROADCAST的广播 --&gt;
        &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/receiver&gt;</code></pre><ol start="3">
<li>定义发送广播（名称与接收处一致，此处以点击事件作为例子）。首先构建一个<code>Intent</code>对象，并传入广播值，之后调用<code>sendBroadcast()</code>方法将广播发送出去（此时所有监听该广播的广播接收器就会收到消息）</li>
</ol>
<pre><code>@Override
public void onClick(View view) {
    Intent intent = new Intent(&quot;com.example.broadcasttest.MY_BROADCAST&quot;);
    sendBroadcast(intent);
}</code></pre><h3 id="发送有序广播"><a href="#发送有序广播" class="headerlink" title="发送有序广播"></a>发送有序广播</h3><blockquote>
<p>广播是一种可以跨进程的通信方式，即在我们应用程序内发出的广播，其他的应用程序应该也可以收到</p>
</blockquote>
<p>发送有序广播只需要改变广播发送的代码为<code>sendOrderedBroadcast()</code>，传入Intent和与权限相关的字符串。</p>
<pre><code>sendOrderedBroadcast(intent, null);</code></pre><h4 id="设置广播接收器的先后顺序"><a href="#设置广播接收器的先后顺序" class="headerlink" title="设置广播接收器的先后顺序"></a>设置广播接收器的先后顺序</h4><p>如下，使用<code>android:priority</code>设置优先级为100</p>
<pre><code>&lt;intent-filter android:priority=&quot;100&quot;&gt;
    &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot; /&gt;
&lt;/intent-filter&gt;</code></pre><h4 id="中断广播"><a href="#中断广播" class="headerlink" title="中断广播"></a>中断广播</h4><p>在<code>onReceive()</code>方法中调用了<code>abortBroadcast()</code>方法，就表示将这条广播截断，后面的广播接收器将无法再接收到这条广播。</p>
<h2 id="本地广播"><a href="#本地广播" class="headerlink" title="本地广播"></a>本地广播</h2><blockquote>
<p><strong>本地广播机制</strong>：使用这个机制发出的广播只能够在应用程序的内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播</p>
</blockquote>
<blockquote>
<p><strong>本地广播使用</strong>：使用一个<code>LocalBroadcastManager</code>来对广播进行管理，并提供了发送广播和注册广播接收器的方法（<em>与动态注册广播流程基本一致</em>）</p>
</blockquote>
<pre><code>LocalBroadcastManager localBroadcastManager;
localBroadcastManager = LocalBroadcastManager.getInstance(this);    // 获取实例
localBroadcastManager.sendBroadcast(intent);    // 发送本地广播
localBroadcastManager.registerReceiver(localReceiver, intentFilter);     // 注册本地广播监听器</code></pre>]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发四：碎片（Fragment）</title>
    <url>/page/Android4-fragment.html</url>
    <content><![CDATA[<h2 id="碎片的基本使用"><a href="#碎片的基本使用" class="headerlink" title="碎片的基本使用"></a>碎片的基本使用</h2><blockquote>
<p>碎片是一种可嵌入在活动当中的UI片段，能让程序更加合理充分的利用大屏幕空间（常应用在平板上）</p>
</blockquote>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol>
<li>新建一个碎片布局（xml文件）</li>
<li>新建一个<code>LeftFragment</code>类，并让它继承自 <code>Fragment</code>，并重写<code>onCreateView()</code>方法（将刚刚新建的布局文件加载进来）</li>
</ol>
<pre><code>public class RightFragment extends Fragment {

    @Override
    public View onCreateView(LayoutInflater inflater, ViewGroup container,
                             Bundle savedInstanceState) {
        View view = inflater.inflate(R.layout.right_fragment, container, false);
        return view;
    }
}</code></pre><ol start="3">
<li>使用<code>&lt;fragment&gt;</code>标签在<em>主布局</em>中添加碎片，通过 <code>android:name</code>属性来显式指明要添加的碎片类名</li>
</ol>
<pre><code>&lt;fragment
    android:id=&quot;@+id/right_fragment&quot;
    android:name=&quot;com.example.fragmenttest.RightFragment&quot;
    android:layout_width=&quot;0dp&quot;
    android:layout_height=&quot;match_parent&quot;
    android:layout_weight=&quot;1&quot; /&gt;</code></pre><h3 id="动态添加碎片"><a href="#动态添加碎片" class="headerlink" title="动态添加碎片"></a>动态添加碎片</h3><ol>
<li>创建待添加的碎片实例</li>
<li>获取 <code>FragmentManager</code> ，在活动中可以直接通过调用 <code>getSupportFragmentManager()</code> 方法得到</li>
<li>通过调用<code>beginTransaction()</code>方法开启一个事务</li>
<li>向容器内添加或替换碎片，一般使用<code>replace()</code>方法实现，需要传入<em>容器</em>的 id 和待添加的碎片实例</li>
<li>调用<code>commit()</code>方法来提交事务</li>
</ol>
<p><em>实现动态添加碎片如下：</em></p>
<pre><code>private void replaceFragment(Fragment fragment) {
    FragmentManager fragmentManager = getSupportFragmentManager();
    FragmentTransaction transaction = fragmentManager.beginTransaction();
    transaction.replace(R.id.right_layout, fragment);
    // transaction.addToBackStack(null);    // 将该事务添加到返回栈
    transaction.commit();
}</code></pre><h3 id="碎片与活动之间的通信"><a href="#碎片与活动之间的通信" class="headerlink" title="碎片与活动之间的通信"></a>碎片与活动之间的通信</h3><h4 id="在碎片中获取活动"><a href="#在碎片中获取活动" class="headerlink" title="在碎片中获取活动"></a>在碎片中获取活动</h4><p>使用<code>getActivity()</code>方法来得到与当前碎片相关联的活动实例</p>
<pre><code>MainActivity activity = (MainActivity) getActivity();</code></pre><h4 id="在活动中获取碎片"><a href="#在活动中获取碎片" class="headerlink" title="在活动中获取碎片"></a>在活动中获取碎片</h4><pre><code>RightFragment rightFragment = (RightFragment) getSupportFragmentManager().findFragmentById(R.id.right_fragment);</code></pre><h2 id="动态加载布局"><a href="#动态加载布局" class="headerlink" title="动态加载布局"></a>动态加载布局</h2><blockquote>
<p>使程序根据设备的分辨率或屏幕大小在运行时来决定加载哪个布局</p>
</blockquote>
<h3 id="限定符（Qualifiers）"><a href="#限定符（Qualifiers）" class="headerlink" title="限定符（Qualifiers）"></a>限定符（Qualifiers）</h3><p>可以简单理解为在资源文件夹名字之后添加的关键字</p>
<h4 id="常用限定符"><a href="#常用限定符" class="headerlink" title="常用限定符"></a>常用限定符</h4><table>
<thead>
<tr>
<th>屏幕特征</th>
<th>限定符</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>大小</td>
<td>small</td>
<td>提供给小屏幕设备</td>
</tr>
<tr>
<td></td>
<td>large</td>
<td>提供给大屏幕设备</td>
</tr>
<tr>
<td>分辨率</td>
<td>ldpi</td>
<td>120dpi以下的设备</td>
</tr>
<tr>
<td></td>
<td>mdpi</td>
<td>120-160dpi的设备</td>
</tr>
<tr>
<td></td>
<td>hdpi</td>
<td>160-240dpi的设别</td>
</tr>
<tr>
<td>方向</td>
<td>land</td>
<td>横屏设备</td>
</tr>
<tr>
<td></td>
<td>port</td>
<td>竖屏设备</td>
</tr>
</tbody></table>
<h4 id="最小宽度限定符（Smallest-width-Qualifier）"><a href="#最小宽度限定符（Smallest-width-Qualifier）" class="headerlink" title="最小宽度限定符（Smallest-width Qualifier）"></a>最小宽度限定符（Smallest-width Qualifier）</h4><p><strong>以 dp 为单位</strong>，如新建<code>layout-sw 600dp</code>文件夹，当程序运行在屏幕宽度大于 600dp 的设备上时，则会加载 <code>layout-sw 600dp/activity_main</code>布局</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>在 res 目录下新建<code>layout-large</code>文件夹，并新建布局<code>activity_main.xml</code>。之后在两个<code>activity_main.xml</code>中分别写入布局信息</p>
<ul>
<li>当使用平板运行时，会使用<code>layout-large</code>中的布局信息</li>
<li>当使用手机运行时，会使用<code>layout</code>中的布局信息</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>Android开发一：HelloWorld</title>
    <url>/page/android-dev-helloworld.html</url>
    <content><![CDATA[<h2 id="HelloWorld程序运行"><a href="#HelloWorld程序运行" class="headerlink" title="HelloWorld程序运行"></a>HelloWorld程序运行</h2><h3 id="AS设置"><a href="#AS设置" class="headerlink" title="AS设置"></a>AS设置</h3><h4 id="gradle版本设置"><a href="#gradle版本设置" class="headerlink" title="gradle版本设置"></a>gradle版本设置</h4><p>在<code>gradle-wrapper.properties</code>文件中修改以下代码中的版本号即可</p>
<pre><code>distributionUrl=https\://services.gradle.org/distributions/gradle-6.1.1-all.zip</code></pre><p>同时，可以去gradle官网上下载相关版本，避免下载缓慢的问题</p>
<h4 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h4><p>在<code>build.gradle</code>文件中的仓库前加上阿里镜像加快下载速度（两处都要进行更改）</p>
<pre><code>repositories {
    maven{ url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39;}
    google()
    jcenter()
}</code></pre><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>在AS设置正常的情况下，直接按运行健即可运行IDE自动创建的helloworld程序了，此时需要先在右上角的<code>AVD Manager</code>中创建虚拟机器，之后按运行按钮即可运行，运行效果如下</p>
<img src="http://cdn.ziyedy.top/%E4%B8%80%E3%80%81Android%E5%BC%80%E5%8F%91HelloWorld/helloworld.png" style="zoom:50%;" />

<h2 id="Android项目结构"><a href="#Android项目结构" class="headerlink" title="Android项目结构"></a>Android项目结构</h2><p>将项目结构模式设置为<strong>Project</strong>后（默认为Android），项目结构如下。</p>
<p>其中重点需要关注的是<strong>app</strong>文件，项目中的代码、资源等内容基本都在该文件夹下。而其他文件多半是自动生成的配置文件，一般情况下不需要进行修改</p>
<p><img src="http://cdn.ziyedy.top/%E4%B8%80%E3%80%81Android%E5%BC%80%E5%8F%91HelloWorld/%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84.png" alt=""></p>
<h3 id="app文件下的文件"><a href="#app文件下的文件" class="headerlink" title="app文件下的文件"></a>app文件下的文件</h3><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>包含了一些在编译时自动生成的文件，一般情况下不需要修改</p>
<h4 id="libs"><a href="#libs" class="headerlink" title="libs"></a>libs</h4><p>项目中需要用到的jar包都放置在该目录下</p>
<h4 id="androidTest"><a href="#androidTest" class="headerlink" title="androidTest"></a>androidTest</h4><p>用来编写Android Test测试用例的，可以对项目进行一些自动化测试</p>
<h4 id="java"><a href="#java" class="headerlink" title="java"></a>java</h4><p>放置Java代码的文件夹</p>
<h4 id="res"><a href="#res" class="headerlink" title="res"></a>res</h4><p>项目中用到的所有图片、布局等资源都存放在该目录下（如：<strong>图片放在drawable下，布局放在layout下，字符串放在values下</strong>）</p>
<h4 id="AndroidManifest-xml"><a href="#AndroidManifest-xml" class="headerlink" title="AndroidManifest.xml"></a>AndroidManifest.xml</h4><p>整个Android项目的配置文件，在程序中定义的四大组件都需要在这个文件中注册，也可以在该文件中给应用程序添加权限声明。</p>
<p>如下是该文件中的部分代码，该段代码表示对MainActivity这个活动进行注册（未在该文件中进行注册的活动是不能使用的）</p>
<pre><code>&lt;activity android:name=&quot;.MainActivity&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;    &lt;!--表示该活动是主活动--&gt;

        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;</code></pre><h4 id="test"><a href="#test" class="headerlink" title="test"></a>test</h4><p>用来编写单元测试用例</p>
<h3 id="主活动代码"><a href="#主活动代码" class="headerlink" title="主活动代码"></a>主活动代码</h3><p>由于Android讲究<strong>逻辑和视图分离</strong>，因此应该在<strong>布局文件中编写界面，在活动中引入进来</strong>。</p>
<pre><code class="java">public class MainActivity extends AppCompatActivity {

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);    // 引入了一个布局
    }
}</code></pre>
<p>因此，在<code>res/layout</code>中能够找到helloworld程序的布局样式如下</p>
<p><img src="http://cdn.ziyedy.top/%E4%B8%80%E3%80%81Android%E5%BC%80%E5%8F%91HelloWorld/%E5%B8%83%E5%B1%80.png" alt=""></p>
<h3 id="res中的资源文件"><a href="#res中的资源文件" class="headerlink" title="res中的资源文件"></a>res中的资源文件</h3><p>在之前已经简单叙述过了，现在简单讲讲如何使用这些资源</p>
<p>以<code>res/values/strings.xml</code>为例，该处定义了一个应用程序名的字符串</p>
<pre><code>&lt;resources&gt;
    &lt;string name=&quot;app_name&quot;&gt;My Application&lt;/string&gt;
&lt;/resources&gt;</code></pre><blockquote>
<p><strong>在代码中通过<code>R.string.app_name</code>来引用</strong></p>
<p><strong>在XML中通过<code>@string/app_name</code>来引用</strong></p>
</blockquote>
<p>如AndroidManifest.xml中部分代码如下</p>
<pre><code>android:icon=&quot;@mipmap/ic_launcher&quot;
android:label=&quot;@string/app_name&quot;
android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;</code></pre><h3 id="build-gradle文件"><a href="#build-gradle文件" class="headerlink" title="build.gradle文件"></a>build.gradle文件</h3><p>整个项目结构中有两个这个文件，一个是在项目最外层（之前添加阿里镜像就是在这儿添加的），一个则是在app文件夹下面</p>
<h4 id="外层build-gradle"><a href="#外层build-gradle" class="headerlink" title="外层build.gradle"></a>外层build.gradle</h4><p>其中<strong>jcenter()</strong>声明了一个代码托管仓库，很多开源项目都会选择将代码托管在jcenter中。</p>
<p>之后<strong>classpath</strong>声明了一个Gradle插件，该插件表示是使用Gradle来构建Android项目</p>
<pre><code>buildscript {
    repositories {
        maven{ url &#39;http://maven.aliyun.com/nexus/content/groups/public/&#39;}
        google()
        jcenter()
    }
    dependencies {
        classpath &quot;com.android.tools.build:gradle:4.0.1&quot;

        // NOTE: Do not place your application dependencies here; they belong
        // in the individual module build.gradle files
    }
}</code></pre><h4 id="app文件下的build-gradle"><a href="#app文件下的build-gradle" class="headerlink" title="app文件下的build.gradle"></a>app文件下的build.gradle</h4><pre><code>apply plugin: &#39;com.android.application&#39;

android {
    compileSdkVersion 30
    buildToolsVersion &quot;30.0.2&quot;

    defaultConfig {
        applicationId &quot;com.example.myapplication&quot;
        minSdkVersion 15
        targetSdkVersion 30
        versionCode 1
        versionName &quot;1.0&quot;

        testInstrumentationRunner &quot;androidx.test.runner.AndroidJUnitRunner&quot;
    }

    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&#39;proguard-android-optimize.txt&#39;), &#39;proguard-rules.pro&#39;
        }
    }
}

dependencies {
    implementation fileTree(dir: &quot;libs&quot;, include: [&quot;*.jar&quot;])
    implementation &#39;androidx.appcompat:appcompat:1.2.0&#39;
    implementation &#39;androidx.constraintlayout:constraintlayout:2.0.1&#39;
    testImplementation &#39;junit:junit:4.12&#39;
    androidTestImplementation &#39;androidx.test.ext:junit:1.1.2&#39;
    androidTestImplementation &#39;androidx.test.espresso:espresso-core:3.3.0&#39;

}</code></pre><p><strong>apply plugin</strong>：</p>
<blockquote>
<p>应用了一个插件，通常是com.android.application与com.android.library二选一。</p>
<p>前者表示一个应用程序模块，后者表示一个库模块（不能直接运行）</p>
</blockquote>
<p><strong>android</strong></p>
<blockquote>
<p>配置项目构建的各种属性</p>
</blockquote>
<p><strong>dependencies</strong></p>
<blockquote>
<p>指定项目所有依赖关系：</p>
<p>1、本地依赖</p>
<p>2、库依赖</p>
<p>3、远程依赖：对jcenter库上的开源项目添加依赖关系</p>
</blockquote>
<h2 id="日志工具"><a href="#日志工具" class="headerlink" title="日志工具"></a>日志工具</h2><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>第一行代码——Android（郭霖）</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>移动端</tag>
      </tags>
  </entry>
  <entry>
    <title>QGis专题地图编制</title>
    <url>/page/qgis-thematic-map-drawing.html</url>
    <content><![CDATA[<h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><p>本次任务是制作蕲春县株林镇的土地覆盖专题图，因此重点主要是通过一些空间分析方法对相关数据进行处理，从而得到相关专题数据，同时，对专题图底图也应在实习一的基础上进行简化修改，总结而言，本次任务具体环节如下：</p>
<p>1、对之前的TDFG数据添加村代码和村名。使用按位置连接等工具连接相关的村名、村代码。</p>
<p>2、土地利用数据的权属数据和行政区数据整理。xzq数据与地类图斑数据边界不一致，需要处理成为一致的。同时增加一个新的村，有自己的学号，以及自己命名一个村名。以改好权属的dltb为基础，采用融合方法，按权属代码融合得到新的xzq层，并转一个新界线层。</p>
<p>3、准备专题图数据。使用相应方法统计与计算各村各大类的各种面积属性项，如耕地面积、人均耕地面积、人口等等。</p>
<p>4、制作专题地图底图。图纸采用A4大小，版式自己进行设计横版或竖版；注意主图比例尺设计合适，使主图、整饰要素、统计图表、图文等要素布局均衡、松紧适宜。底图要素保留行政界线、主要河流、水库、居民点；道路根据各自设计处理。增加必要的地图注记，如选取居民点、主要河流、水库等名称，可采用标注方法。</p>
<p>5、制作专题地图主图。以输入专题数据的xzq为基础，用渐变填色方法制作人均耕地分级色图；由XZQ生成质点，加载质点数据，用结构图方法制作各类用地结构图表；根据全市或分村统计各坡度级耕地面积，制作图外统计图表。</p>
<p>6、制作专题图整饰。添加色带、图名、指北针、数字比例尺、位置图、图例等。</p>
<h2 id="土地利用数据的权属数据整理"><a href="#土地利用数据的权属数据整理" class="headerlink" title="土地利用数据的权属数据整理"></a>土地利用数据的权属数据整理</h2><h3 id="添加村代码和村名"><a href="#添加村代码和村名" class="headerlink" title="添加村代码和村名"></a>添加村代码和村名</h3><p>此处总体步骤为使用实习一中的TDFG数据，对各地类多边形进行求质心操作，进而通过对质心位置的判断，链接上村名和村代码。本人的具体操作如下。</p>
<p>1、首先对实习1中的TDFG数据，选择“矢量”下的“拓扑结构检查器”（需要在插件中加载该功能）进行拓扑检查（检查无效多边形），避免生成质心时QGIS报错。如下图1即为本次实习中有拓扑错误的多边形。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%871.png" style="zoom:67%;" />

<p>2、根据拓扑错误对多边形进行修改，主要应避免如下图的拓扑错误，方法为在该处取消吸附功能。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%872.png" style="zoom:33%;" />

<p>3、对修改后的TDFG图层进行求质心操作，可右击菜单栏打开“处理工具箱”工具，之后的一系列相关操作功能都可在该工具栏中进行搜索获得。如下一图即为“质心”工具运行结果，如下二图为求质心之后的效果。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%873.png" style="zoom: 80%;" />

<p>4、使用“按位置连接”工具，选择“内含于”等选项，运行结果如下。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%874.png" style="zoom:67%;" />

<p>5、选择“按字段值连接属性”，各选项如下。完成村名和村代码的添加。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%875.png" style="zoom: 50%;" />

<h3 id="按各村界线进行图形分割"><a href="#按各村界线进行图形分割" class="headerlink" title="按各村界线进行图形分割"></a>按各村界线进行图形分割</h3><p>本步骤主要就是按照实习一中的XZQ图层对各个跨越XZQ的图版进行分割（主要就是实习一中补充的那部分），方法是启动编辑后使用“编辑”中的“分割要素”工具对图形进行切割，如图所示。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%876.png" style="zoom: 50%;" />

<h3 id="新增村庄"><a href="#新增村庄" class="headerlink" title="新增村庄"></a>新增村庄</h3><p>按照要求，随便选一块区域，将属性表中的村名、村代码进行更改，形成一个新的村子，如图所示。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%877.png" style="zoom: 50%;" />

<h3 id="融合"><a href="#融合" class="headerlink" title="融合"></a>融合</h3><p>融合的目的即为使属性表中为一个村的地区真正“融”为一个村，从而形成的边界图层替代实习一中的XZQ图层，为之后的专题图制作提供基础底图。本次实习先使用了QGIS中的融合工具，但效果不佳，有如下图所示的裂纹，无法使用。</p>
<p><img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%878.png" alt=""></p>
<p>鉴于此，本次实习在该功能上使用了ArcGIS中的“融合”功能，其相关参数如下（由于数据源的问题，村名中出现了一些代码，因此本处使用村代码作为融合依据，之后根据村名和村代码的对应关系将村名链接了上去）。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%879.png" style="zoom:50%;" />

<p>由于之前在QGIS中对部分图形进行了切割的缘故，在ArcGIS生成的融合图形中仍有部分毛边，本次实习在ArcGIS中启用编辑，使用“删除点”工具对这些毛边进行了处理，同时使用“添加点”功能对部分细小缝隙进行了修补，以避免之后生成质心时出现拓扑错误，完成操作后使用QGIS打开相关shp文件，效果如下。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8710.png" style="zoom: 33%;" />

<h2 id="专题图数据处理与统计"><a href="#专题图数据处理与统计" class="headerlink" title="专题图数据处理与统计"></a>专题图数据处理与统计</h2><h3 id="相关数据的分村统计"><a href="#相关数据的分村统计" class="headerlink" title="相关数据的分村统计"></a>相关数据的分村统计</h3><p>所需的数据主要包括各村的面积、人口、各大类地面积、人均耕地面积等数据，除去人口数据是需要自己进行输入，其余都需通过各分析方法得到。</p>
<p>1、对2.1节中得到的“新界线”图层TDFG_RH添加新字段，主要内容为以上所述的各内容，类型选择为“小数”。 </p>
<p>2、在“处理工具箱”中搜索找到“添加几何属性”功能，输入要素如下图，得到一个有相关面积等数据的图层，将该临时图层中相关字段中的面积数据连接到TDFG_RH中的相关字段，得到各村面积数据。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8711.png" style="zoom:50%;" />

<p>3、在“处理工具箱”中搜索找到“按类别统计工具”，输入要素如下图1所示，字段选择为地类字段和村名字段。之后程序输出为一个表格，“打开属性表”打开之后，可见其信息如下图2，各村的各类面积都已补充完整，将相关数据填入TDFG_RH中的相关字段即可。</p>
<p><img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8712.png" alt=""></p>
<p>4、将TDFG_RH图层中的RK（人口）字段按照相关资料（主要是网上相关的资料）进行填入，大致区间在300-1300人之间，之后打开编辑后，使用“字段计算器”，填入相应内容后，将RJGDMJ（人均耕地面积）进行计算与填入。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8713.png" style="zoom:50%;" />

<h3 id="坡度的分村统计"><a href="#坡度的分村统计" class="headerlink" title="坡度的分村统计"></a>坡度的分村统计</h3><p>坡度的统计需要借用ArcGIS中的相关功能以及已有的DGX、GCD等数据，主要步骤如下。 </p>
<p>1、在ArcGIS中借用“3D Analyst工具”-&gt;“数据管理”-&gt;“TIN”-&gt;“创建TIN”，输入如下图1参数，得到TIN数据如下图2。TIN数据与DEM数据最大的区别是一个是矢量数据一个是栅格数据，因此要实现转化须将其进行矢栅转化。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8714.png" style="zoom: 50%;" />

<p>2、“3D Analyst工具”-&gt;“转换”-&gt;“由TIN转出”-&gt;“TIN转栅格”，实现TIN数据与DEM数据的转化，具体输入见下图1，DEM数据效果见下图2。</p>
<p><img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8715.png" alt=""></p>
<p>3、使用ArcGIS中的“坡度”工具，将DEM数据输入，得到相应的坡度图，效果如下两图。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8716.png" style="zoom: 67%;" />

<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8717.png" style="zoom:50%;" />

<p>4、使用ArcGIS中的转换工具（可以直接转也可以使用ArcToolBoxzhon给的相关工具）将坡度图导出为tif格式，并将其导入QGIS，如图所示。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8718.png" style="zoom:50%;" />

<p>5、使用“分区统计”工具对各村坡度进行计算，该程序运行完之后会发现输入的TDFG_RH图层中多了三个计算图层，如下。</p>
<p><img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8719.png" alt=""></p>
<p>6、取上表的相关数据导入excel中进行数据统计，便于之后绘制图表。</p>
<h2 id="制作专题地图底图"><a href="#制作专题地图底图" class="headerlink" title="制作专题地图底图"></a>制作专题地图底图</h2><p>在《QGis地表覆盖图编制》基础上进行要素选取，最后结果如下</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8720.png" style="zoom:50%;" />

<h2 id="制作专题地图主图"><a href="#制作专题地图主图" class="headerlink" title="制作专题地图主图"></a>制作专题地图主图</h2><h3 id="分级设色"><a href="#分级设色" class="headerlink" title="分级设色"></a>分级设色</h3><p>1、在相关图层的属性下的“符号”中，进行如下选择，可得到分级设色的效果。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8721.png" style="zoom:50%;" />

<p>2、调整相关颜色（颜色1与颜色2）如下，使其符合基本的色彩视觉要求要求。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8722.png" style="zoom:50%;" />

<p>3、完成分级设色，效果如下。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8723.png" style="zoom:50%;" />

<h3 id="饼状图绘制"><a href="#饼状图绘制" class="headerlink" title="饼状图绘制"></a>饼状图绘制</h3><p>1、利用质心工具对新界线进行求质心操作，得到质心图如下，同时该质心图层已经包含了TDFG_RH中在2.2.2中进行统计后的字段。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8724.png" style="zoom:50%;" />

<p>2、利用已经统计了的数据实现饼状图的绘制，在属性中“图表”中进行如下选择，可实现饼状图绘制，更改颜色后，完成饼状图绘制。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8725.png" style="zoom:67%;" />

<p>3、由于饼状图的图例绘制在QGIS中效果不好，因此本次实习选择在AI中对其进行绘制，绘制完成后如下，可导出为PNG格式。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8726.png" style="zoom: 80%;" />

<p>4、整体效果如下。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8727.png" style="zoom: 50%;" />

<h3 id="柱状图"><a href="#柱状图" class="headerlink" title="柱状图"></a>柱状图</h3><p>同样根据统计数据使用AI进行绘制，不再赘述</p>
<h2 id="地图整饰"><a href="#地图整饰" class="headerlink" title="地图整饰"></a>地图整饰</h2><p>地图整饰包括制作色带、图名、指北针、数字比例尺、位置图、图例等内容，本节也以此为基础进行相关叙述。其中其余参考《QGis地表覆盖图编制》即可</p>
<h3 id="位置图"><a href="#位置图" class="headerlink" title="位置图"></a>位置图</h3><p>1、将位置图图片导入项目，并使用配准工具对其进行处理，如下图所示。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8728.png" style="zoom:50%;" />

<p>2、使用QGIS中的“栅格矢量化”工具对该位图进行矢量化，具体见面如下，可得到位置图的矢量图（本次实习使用该功能效果不太好）</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8729.png" style="zoom:67%;" />

<p>3、对其进行分类处理，并新增一个MC（名称）字段，调整颜色，设置标志（注记），即完成位置图的制作，效果如下。</p>
<p><img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8730.png" alt=""></p>
<h3 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h3><p>1、在菜单栏左侧使用相应工具添加图例，并设置其条目属性，并将图例置于右下角，效果如下。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8731.png" style="zoom:50%;" />

<p>2、将4.2小节中绘制好的饼状图图例以导入图片的形式导入，并将其置于右下角。</p>
<h2 id="整体效果"><a href="#整体效果" class="headerlink" title="整体效果"></a>整体效果</h2><p><img src="http://cdn.ziyedy.top/image/QGis%E4%B8%93%E9%A2%98%E5%9C%B0%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8732.png" alt=""></p>
]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>QGis</tag>
      </tags>
  </entry>
  <entry>
    <title>QGis地表覆盖图编制</title>
    <url>/page/qgis-Surface-coverage-mapping.html</url>
    <content><![CDATA[<h2 id="数据采集"><a href="#数据采集" class="headerlink" title="数据采集"></a>数据采集</h2><h3 id="图像配准与提取"><a href="#图像配准与提取" class="headerlink" title="图像配准与提取"></a>图像配准与提取</h3><p>没有精确的图像配准，后续对数据的判读及精确的矢量化便无从谈起，将影像投影设置为与DLTB图层一致之后，便可按如下步骤在QGIS中完成相应的工作。 </p>
<p>1、右键菜单栏加载出对应的菜单，并且在插件菜单栏中调出默认安装了的GDAL配准插件， 并且将相应的影像数据等加入建立好的工程。 </p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%871.png" style="zoom:67%;" />

<p>2、打开配准工具，将要进行操作的影像图导入，之后根据地图地名等信息使得DLTB图层上相应点与影像上的点一一对应，选择四个点及以上时完成配准，本次实验选点及配置如下图。 </p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%872.png" style="zoom: 67%;" />

<p>3、结束点对对应后，点击配准菜单栏上的“开始配准”并完成配准，得到一个配准完成后的影像图层。效果如下所示。 </p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%873.png" style="zoom:67%;" />

<p>4、配准完成后在菜单栏“栅格”中选择“提取”下的“按掩膜图层裁剪栅格”，并将无数据区透明度设置为0，此举使得影像数据与DLTB数据基本重合，便于后续操作 </p>
<h3 id="空缺数据补充"><a href="#空缺数据补充" class="headerlink" title="空缺数据补充"></a>空缺数据补充</h3><p>在使用原始的DLTB数据时，根据“核对修改范围”数据的提示，可以很清楚的看到其中间部分有一空缺处，而根据3.1.1处理好的结果，对DLTB数据在“符号化”中进行分类， 如下图。并在分类的基础上根据影像图进行地图矢量化，并按照影像图对其相关字段进行命名，从而完成空缺数据的补充（其中各矢量化工具的使用基本与ArcGIS中的相应工具类似，因此不再赘述）。 </p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%874.png" style="zoom:50%;" />

<h3 id="其他数据的补充"><a href="#其他数据的补充" class="headerlink" title="其他数据的补充"></a>其他数据的补充</h3><p>除去DLTB空缺的数据，还应对居民地，相应公路等数据进行补充，与以上相比，矢量化工具由多边形变为了点和线，因此不再赘述，大致结果图如下</p>
<p><img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%875.png" style="zoom: 67%;" /><img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%876.png" alt=""></p>
<h2 id="数据检查"><a href="#数据检查" class="headerlink" title="数据检查"></a>数据检查</h2><p>一些基本的数据检查方法此处略，只对应QGis的相关操作。由于原始数据中编码相对较老，因此需要进行更新编码的操作，此处可以使用表连接方法</p>
<h3 id="更改数据对应编码"><a href="#更改数据对应编码" class="headerlink" title="更改数据对应编码"></a>更改数据对应编码</h3><p>在QGIS当中，本次具体的对应操作为建立一个相应的Excel表，在表中设置三列数据， 分别对应两类名称与对应的新编码，如下图所示。 </p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%876.png" style="zoom:70%;" />



<p>之后在属性中选择“连接”并选择相应Excel表的相应字段，具体见下图，连接完成后可见DLTB图层的属性表中多出了两条字段，分别对应新名称与新编号。 </p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%877.png" style="zoom:50%;" />

<p>最后将其导出为TDFG图层，按照新字段进行分类后（见下图），之后便以此为基础在TDFG图层上进行之后的符号化。 </p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%878.png" style="zoom: 50%;" />

<h2 id="地图的编绘"><a href="#地图的编绘" class="headerlink" title="地图的编绘"></a>地图的编绘</h2><p>完成了之前包括影像配准，数据对应整理与处理，空缺数据矢量化与补充，数据相应转化后，便可进入地图绘制的阶段，此阶段主要可概括为符号的使用与制作， 地图的整饰与制作两个阶段。 </p>
<h3 id="符号的使用与制作"><a href="#符号的使用与制作" class="headerlink" title="符号的使用与制作"></a>符号的使用与制作</h3><p>本次操作较为简单，在TDFG图层的分类下右击鼠标选中“编辑符号”，进入符号后更改填充颜色、线宽、点状符号、线状符号即可，如下图。由于相应符号老师都已给出，因此总体而言较为方便，唯一不便的地方就是得将CMYK转化为RGB再输入， 此过程本人使用AI得到。 </p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%879.png" style="zoom:67%;" />

<h3 id="地图的整饰设计"><a href="#地图的整饰设计" class="headerlink" title="地图的整饰设计"></a>地图的整饰设计</h3><p>本次实习所进行的地图整饰设计主要包括色带、图廓、方里网、图名、图例、比例尺等内容。进行整饰在QGIS中可在“项目”菜单中选择“新建打印布局”，之后在其中完成一系列相关操作即可。 </p>
<h4 id="色带"><a href="#色带" class="headerlink" title="色带"></a>色带</h4><p>即图地图外部上的条带。本次实习色带是使用QGIS自带的轮廓功能制作的。具体步骤为在“矢量”菜单栏地学数据处理工具中选择“轮廓”，并选择相关数值， 对TDFG图层进行两次使用后，即可得到两个色带。 </p>
<h4 id="图廓"><a href="#图廓" class="headerlink" title="图廓"></a>图廓</h4><p>图廓相关在4.2总述中已经涉及了，页面即为外图廓，而内图廓即拖动地图使之与外图廓契合并能够很好显示地图即可。可使用左侧菜单栏中“选择/移动条目”与“移动条目内容”对其进行设置。</p>
<h4 id="方里网"><a href="#方里网" class="headerlink" title="方里网"></a>方里网</h4><p>方里网在地图的条目属性中添加网格，并更改并应用网格属性，设置如下图所示。 </p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8710.png" style="zoom:67%;" />

<h4 id="图名"><a href="#图名" class="headerlink" title="图名"></a>图名</h4><p>在菜单栏左侧使用相应工具添加图名，并更改其条目属性如下，再将其置于相应位置，本次为图面左上角。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8711.png" style="zoom:67%;" />

<h4 id="图例"><a href="#图例" class="headerlink" title="图例"></a>图例</h4><p>在菜单栏左侧使用相应工具添加图例，并设置其条目属性如下，并将图例置于右下角。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8712.png" style="zoom:67%;" />

<h4 id="比例尺"><a href="#比例尺" class="headerlink" title="比例尺"></a>比例尺</h4><p>在菜单栏左侧使用相应工具添加比例尺，并设置其条目属性如下，并将其置于图面右下角。</p>
<img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8713.png" style="zoom: 67%;" />

<h2 id="成果图"><a href="#成果图" class="headerlink" title="成果图"></a>成果图</h2><p><img src="http://cdn.ziyedy.top/image/QGis%E5%9C%B0%E8%A1%A8%E8%A6%86%E7%9B%96%E5%9B%BE%E7%BC%96%E5%88%B6/%E5%9B%BE%E7%89%8714.png" alt=""></p>
]]></content>
      <categories>
        <category>GIS</category>
      </categories>
      <tags>
        <tag>GIS</tag>
      </tags>
  </entry>
  <entry>
    <title>Blender物体渲染脚本</title>
    <url>/page/blender-script-basic.html</url>
    <content><![CDATA[<blockquote>
<p>渲染可以简单理解为将3D场景转化为2D场景的过程</p>
</blockquote>
<h2 id="bpy模块"><a href="#bpy模块" class="headerlink" title="bpy模块"></a>bpy模块</h2><p>bpy模块是blender脚本插件核心库</p>
<h3 id="bpy-ops"><a href="#bpy-ops" class="headerlink" title="bpy.ops"></a>bpy.ops</h3><blockquote>
<p>对于操纵3D对象，最重要的两个类是<code>bpy.ops.object</code>和<code>bpy.ops.mesh</code></p>
<p>Object类包含用于同时操作多个选定对象的函数以及许多常规实用程序。Mesh类包含用于一次操作一个对象的顶点、边和面的函数</p>
</blockquote>
<h3 id="bpy-context"><a href="#bpy-context" class="headerlink" title="bpy.context"></a>bpy.context</h3><blockquote>
<p>context（正文）是blender数据管理中的一个全局变量集合，它包含了目前被选择的和激活的（物体的两种属性状态）的物体的信息，还记录了当前物体的编辑模式<br>用于按各种状态条件访问 Blender 的对象和区域（如用户选定的对象），用于将我们指向对象组（即<code>bpy.context</code>类将生成对<code>bpy.data</code>类的数据块的引用）</p>
</blockquote>
<pre><code># 访问选定对象的列表
bpy.context.selected_objects

# 访问目前激活的对象
bpy.context.active_object</code></pre><h3 id="bpy-data"><a href="#bpy-data" class="headerlink" title="bpy.data"></a>bpy.data</h3><blockquote>
<p>blender界面上所有可使用调节的对象内容（包括mesh模型、lamp灯光、camera摄像机，material材质等）都在python中以特定的类型存储起来</p>
<p>用于访问Blender的内部数据，包含确定对象形状和位置的所有数据</p>
</blockquote>
<p>访问出现的对象</p>
<pre><code>bpy.data.objects  #访问场景内普通对象列表，包括lamp、camera以及mesh模型的
bpy.data.scenes  #访问场景列表
bpy.data.materials  #访问材质对象列表</code></pre><p>访问具体的对象</p>
<pre><code>bpy.data.objects[&#39;Cube&#39;]  #访问名为`Cube`的对象
bpy.data.objects[1]  #访问列表中的第1个对象</code></pre><p>访问对象属性</p>
<pre><code>bpy.data.objects[&#39;Cube&#39;].name #访问对象名称
bpy.data.objects[&#39;Cube&#39;].location #访问对象的位置</code></pre><h2 id="常用基本操作"><a href="#常用基本操作" class="headerlink" title="常用基本操作"></a>常用基本操作</h2><h3 id="选择对象"><a href="#选择对象" class="headerlink" title="选择对象"></a>选择对象</h3><pre><code># 选中所有
bpy.ops.object.select_all(action=&#39;SELECT&#39;)

# 取消所有选中
bpy.ops.object.select_all(action=&#39;DESELECT&#39;)

#通过select_pattern命令来按照物体命名查找选定物体，支持通配符*模糊匹配
bpy.ops.object.select_pattern(pattern=&quot;Cube&quot;, case_sensitive=False, extend=True)

# 选中名为Cube的对象
bpy.data.objects[&#39;Cube&#39;].select_set(True)</code></pre><h3 id="对选中物体进行缩放"><a href="#对选中物体进行缩放" class="headerlink" title="对选中物体进行缩放"></a>对选中物体进行缩放</h3><pre><code># 按 x y z 进行缩放
bpy.ops.transform.resize(value=(1.1, 1.2, 1.4))</code></pre><h3 id="对选中物体进行旋转"><a href="#对选中物体进行旋转" class="headerlink" title="对选中物体进行旋转"></a>对选中物体进行旋转</h3><pre><code># 绕 Z轴 旋转 3.14 弧度
bpy.ops.transform.rotate(value=3.14, orient_axis=&#39;Z&#39;)</code></pre><h3 id="对选中物体进行平移操作"><a href="#对选中物体进行平移操作" class="headerlink" title="对选中物体进行平移操作"></a>对选中物体进行平移操作</h3><pre><code># 按 x y z 方向平移物体
bpy.ops.transform.translate(value=(1, -2, 3))

# 设置位置
bpy.data.objects[&#39;Cube&#39;].location = (1, 2, 3)</code></pre><h2 id="灯光操作"><a href="#灯光操作" class="headerlink" title="灯光操作"></a>灯光操作</h2><pre><code># 新建一个点光源
light_data = bpy.data.lights.new(name=&#39;Light&#39;, type=&#39;POINT&#39;)

# 设置该光源的一些属性（具体属性可查看文档）
light_data.distance = 2400.
light_data.use_nodes = True
light_data.energy = 5

# 激活灯光
light = bpy.data.objects.new(name=&quot;Light&quot;, object_data=light_data)
scene.objects.link(light)
bpy.context.view_layer.objects.active = light

# 脚本使用完毕后删除灯光
bpy.data.objects[&#39;Light&#39;+str(i)].select_set(True)
bpy.ops.object.delete()</code></pre><h2 id="相机操作"><a href="#相机操作" class="headerlink" title="相机操作"></a>相机操作</h2><h3 id="改变相机指向"><a href="#改变相机指向" class="headerlink" title="改变相机指向"></a>改变相机指向</h3><pre><code>def look_at(obj_camera, point=Vector((0, 0, 0))):
    &quot;&quot;&quot;
    使相机指向point点
    &quot;&quot;&quot;
    loc_camera = obj_camera.location
    direction = point - loc_camera
    rot_quat = direction.to_track_quat(&#39;-Z&#39;, &#39;Y&#39;)
    obj_camera.rotation_euler = rot_quat.to_euler()</code></pre><h2 id="实现多角度渲染物体"><a href="#实现多角度渲染物体" class="headerlink" title="实现多角度渲染物体"></a>实现多角度渲染物体</h2><blockquote>
<p>实现多角度渲染物体生成物体模板主要需要进行以下工作</p>
<p>1、合理设置相机的位置（以LineMOD方法为例就利用球面的几何特征设置相机位置）</p>
<p>2、合理布局灯光（调整使得灯光能够覆盖）</p>
<p>3、得到此时相机的Rt变换矩阵用于标识该角度下物体的姿态</p>
<p>4、输入模型，进行渲染输出图片</p>
</blockquote>
<p>第1点和第2点其实就是之前的灯光操作与相机操作</p>
<h3 id="进行模型渲染"><a href="#进行模型渲染" class="headerlink" title="进行模型渲染"></a>进行模型渲染</h3><h4 id="导入模型"><a href="#导入模型" class="headerlink" title="导入模型"></a>导入模型</h4><p>以.obj文件为例，其余文件格式的导入方法可以查官方文档（导入的模型默认的位置为坐标原点）</p>
<pre><code># 导入.obj文件
bpy.ops.import_scene.obj(filepath=obj_path)</code></pre><p>除导入模型外，就是合理设置输入路径和输出路径了，这个可以用os等模块进行处理</p>
<h4 id="设置渲染输出的基本信息"><a href="#设置渲染输出的基本信息" class="headerlink" title="设置渲染输出的基本信息"></a>设置渲染输出的基本信息</h4><p>根据官网可以设置输出分辨率等基本信息</p>
<pre><code>context = bpy.context
scene = context.scene

scene.render.engine = &#39;CYCLES&#39;
scene.render.film_transparent = True
scene.render.resolution_x = 360
scene.render.resolution_y = 360
scene.render.image_settings.file_format = &#39;PNG&#39;</code></pre><h4 id="渲染输出"><a href="#渲染输出" class="headerlink" title="渲染输出"></a>渲染输出</h4><pre><code># 设置输出路径
scene.render.filepath = output_path + &quot;0&quot;.zfill(5) + &quot;.png&quot;

# 渲染输出
bpy.ops.render.render(write_still=True, use_viewport=False)</code></pre><h4 id="渲染结果"><a href="#渲染结果" class="headerlink" title="渲染结果"></a>渲染结果</h4><p>渲染结果如下，实现了<strong>模型的批量渲染处理</strong></p>
<p><img src="http://cdn.ziyedy.top/Blender%E7%89%A9%E4%BD%93%E6%B8%B2%E6%9F%93%E8%84%9A%E6%9C%AC/%E6%B8%B2%E6%9F%93%E7%BB%93%E6%9E%9C1.png" alt=""></p>
<p><img src="http://cdn.ziyedy.top/Blender%E7%89%A9%E4%BD%93%E6%B8%B2%E6%9F%93%E8%84%9A%E6%9C%AC/%E6%B8%B2%E6%9F%93%E7%BB%93%E6%9E%9C2.png" alt=""></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总而言之，blender插件脚本的python开发是一个文档相对欠缺（官方文档写的我个人认为很烂）而且不同版本之间差别较大的二次开发工具。</p>
<p>如果没有特别的要求非得使用blender，我的建议是能不用就不用（尤其对于新手）。顺带一提，blender内置的Python脚本开发环境也极其糟糕，理论上vscode内是有相应的插件的，但bug较多我个人认为也很不好用。</p>
<p>之后如果还会使用blender的话我会写一个专题好好记录一下学习的过程（希望不会有这一天）</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/zju3dv/pvnet-rendering" target="_blank" rel="noopener">https://github.com/zju3dv/pvnet-rendering</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>插件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Python实现深度图转点云</title>
    <url>/page/python-depth-points.html</url>
    <content><![CDATA[<h2 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h2><p>深度图转点云本质上我认为就算利用深度信息<strong>将图像从像素坐标系转化到相机坐标系的过程</strong>（很多资料说是转到世界坐标系，但我认为这是一个如何定义世界坐标系的问题）</p>
<p><img src="http://cdn.ziyedy.top/Python%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%BA%A6%E5%9B%BE%E8%BD%AC%E7%82%B9%E4%BA%91/%E5%9D%90%E6%A0%87%E7%B3%BB.jpg" alt=""></p>
<p>忽略推导过程，其实可以归纳为从图像点<code>[u, v]</code>到相机坐标点<code>[x_c, y_c, z_c]</code>的过程，具体公式如下（其中depth(u, v)表示深度图(u, v)位置的像素值）<br>$$<br>x_c = z_c (u - u_0) / f_x \<br>y_c = z_c (v - v_0) / f_y \<br>z_c = depth(u, v)<br>$$</p>
<h2 id="Python实现"><a href="#Python实现" class="headerlink" title="Python实现"></a>Python实现</h2><h3 id="深度图"><a href="#深度图" class="headerlink" title="深度图"></a>深度图</h3><p><img src="http://cdn.ziyedy.top/Python%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%BA%A6%E5%9B%BE%E8%BD%AC%E7%82%B9%E4%BA%91/%E6%B7%B1%E5%BA%A6%E5%9B%BE.png" alt="深度图"></p>
<h3 id="转换代码"><a href="#转换代码" class="headerlink" title="转换代码"></a>转换代码</h3><pre><code>def depth2pc(depth_img):
    &quot;&quot;&quot;
    深度图转点云数据
    图像坐标系 -&gt; 世界坐标系 
    :param depth_img: 深度图
    :return: 点云数据 N*3
    &quot;&quot;&quot;

    # 相机内参
    cam_fx = 1120.12
    cam_fy = 1120.12
    cam_cx = 640.5
    cam_cy = 360.5
    factor = 1

    # 逐点处理，此过程可以使用numpy优化
    m, n = depth_img.shape
    point_cloud = []
    for v in range(m):
        for u in range(n):
            if depth_img[v, u] == 0:
                continue
            depth = depth_img[v, u]
            p_z = depth / factor
            p_x = (u - cam_cx) * p_z / cam_fx
            p_y = (v - cam_cy) * p_z / cam_fy
            point_cloud.append([p_x, p_y, p_z])

    point_cloud = np.array(point_cloud)

    return point_cloud</code></pre><h3 id="转换后的点云"><a href="#转换后的点云" class="headerlink" title="转换后的点云"></a>转换后的点云</h3><p><em>略去了将桌面等背景略去的相关代码</em>，转换后的点云数据如下</p>
<p><img src="http://cdn.ziyedy.top/Python%E5%AE%9E%E7%8E%B0%E6%B7%B1%E5%BA%A6%E5%9B%BE%E8%BD%AC%E7%82%B9%E4%BA%91/%E7%82%B9%E4%BA%91%E6%95%B0%E6%8D%AE.png" alt=""></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>由于本人是初次接触点云相关数据，而任务又有时间要求，所以没有使用较为主流的C++下的pcl库，未来两个月打算学习以下点云相关的操作与理论，届时再进行更新</p>
<p><a href="https://blog.csdn.net/weixin_30284355/article/details/98320637" target="_blank" rel="noopener">https://blog.csdn.net/weixin_30284355/article/details/98320637</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>3D视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu安装摘记</title>
    <url>/page/ubuntu-install-summary.html</url>
    <content><![CDATA[<h2 id="卸载双系统Ubuntu"><a href="#卸载双系统Ubuntu" class="headerlink" title="卸载双系统Ubuntu"></a>卸载双系统Ubuntu</h2><blockquote>
<p>从Win10系统中卸载ubuntu</p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://blog.csdn.net/mtllyb/article/details/78635757" target="_blank" rel="noopener">https://blog.csdn.net/mtllyb/article/details/78635757</a></p>
]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>使用plyfile库对.ply文件进行读写操作</title>
    <url>/page/plyfile.html</url>
    <content><![CDATA[<h3 id="安装plyfile库"><a href="#安装plyfile库" class="headerlink" title="安装plyfile库"></a>安装plyfile库</h3><p>直接使用pip命令即可</p>
<pre><code>pip install plyfile</code></pre><h3 id="进行-ply文件读取"><a href="#进行-ply文件读取" class="headerlink" title="进行*.ply文件读取"></a>进行*.ply文件读取</h3><p>读取ply文件返回的是numpy数组，读取的方法也比较简单</p>
<pre><code># 读入ply文件
plydata = PlyData.read(&#39;tet.ply&#39;)

# 读取所有x坐标
plydata.elements[0].data[&#39;x&#39;]
plydata[&#39;vertex&#39;].data[&#39;x&#39;]
plydata[&#39;vertex&#39;][&#39;x&#39;]

# 读取第一个点的3d坐标
plydata.elements[0].data[0]
plydata[&#39;vertex&#39;][0]</code></pre><h4 id="读取函数"><a href="#读取函数" class="headerlink" title="读取函数"></a>读取函数</h4><pre><code>from plyfile import PlyData, PlyElement
def read_ply(filename):
    &quot;&quot;&quot; 读取坐标，返回值为 n * 3 &quot;&quot;&quot;
    plydata = PlyData.read(filename)
    pc = plydata[&#39;vertex&#39;].data
    pc_array = np.array([[x, y, z] for x,y,z in pc])
    return pc_array</code></pre><h3 id="进行-ply文件写入"><a href="#进行-ply文件写入" class="headerlink" title="进行*.ply文件写入"></a>进行*.ply文件写入</h3><pre><code>from plyfile import PlyData, PlyElement
def write_ply(save_path, points, text=True):
    &quot;&quot;&quot;
    输入点云数据，并写入一个*.ply文件
    :param save_path: 文件路径 + *.ply
    :param points:
    :param text:
    :return: 
    &quot;&quot;&quot;
    points = [(points[i, 0], points[i, 1], points[i, 2]) for i in range(points.shape[0])]
    vertex = np.array(points, dtype=[(&#39;x&#39;, &#39;f4&#39;), (&#39;y&#39;, &#39;f4&#39;), (&#39;z&#39;, &#39;f4&#39;)])
    el = PlyElement.describe(vertex, &#39;vertex&#39;, comments=[&#39;vertices&#39;])
    PlyData([el], text=text).write(save_path)</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><blockquote>
<p>以上主要就是利用plyfile库进行点数据的读取，关于面数据之类的其实与点数据差别不大，重点在于对ply文件格式的认识</p>
</blockquote>
<p><a href="https://blog.csdn.net/phy12321/article/details/107373073" target="_blank" rel="noopener">https://blog.csdn.net/phy12321/article/details/107373073</a></p>
<p><a href="https://pypi.org/project/plyfile/" target="_blank" rel="noopener">https://pypi.org/project/plyfile/</a></p>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>3D视觉</tag>
      </tags>
  </entry>
  <entry>
    <title>树（二）二叉树</title>
    <url>/page/undefined.html</url>
    <content><![CDATA[<h2 id="二叉树的基本名词"><a href="#二叉树的基本名词" class="headerlink" title="二叉树的基本名词"></a>二叉树的基本名词</h2><p>满二叉树：树中每层都含有最多的结点<br>完全二叉树：简单来讲就是每一个结点编号都与满二叉树相同的二叉树，满二叉树是一种特殊的完全二叉树。<strong>(lchild=father*2)</strong></p>
<h2 id="二叉树的几种遍历"><a href="#二叉树的几种遍历" class="headerlink" title="二叉树的几种遍历"></a>二叉树的几种遍历</h2><p>PreOrder Traversal<br>InOrder Traversal<br>PostOrder Traversal<br>LevelOrder Traversal<br><strong>规律：</strong>显然，中序遍历可以与其余三种遍历方法的任何一种完成对二叉树的重建（唯一），而其余三种遍历方法任何一种两两结合都无法构建唯一的二叉树。<br>这很好理解，其余三种遍历方法告知了我们根节点的位置，而根据这一点我们可以由中序遍历确定左右子树，然后根据二叉树的递归定义完成重建。<a id="more"></a></p>
<h2 id="相应OJ链接"><a href="#相应OJ链接" class="headerlink" title="相应OJ链接"></a>相应OJ链接</h2><h3 id="1020-Tree-Traversals"><a href="#1020-Tree-Traversals" class="headerlink" title="1020 Tree Traversals"></a>1020 Tree Traversals</h3><p><strong>试题概述：</strong><br>input：给定二叉树结点个数，二叉树的后序遍历与中序遍历<br>output：二叉树的层序遍历<br><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805485033603072" target="_blank" rel="noopener">OJ试题传送门</a></p>
<pre><code>#include &lt;iostream&gt;
#include &lt;queue&gt;
using namespace std;
const int x = 31;
int n;
int in[x], post[x];//inorder and postorder

struct Nodes
{
    int data;
    Nodes *lchild, *rchild;
};

//recreate the BT
Nodes* creat(int postl, int postr, int inl, int inr) 
{
    if (postr&lt;postl)
    {
        return NULL;
    }
    Nodes *root = new Nodes;
    root-&gt;data = post[postr];
    int k;
    for ( k = inl; k &lt; inr; k++)
    {
        if (in[k] == post[postr]) {
            break;
        }
    }
    int numl = k - inl;
    root-&gt;lchild = creat(postl, postl + numl - 1, inl, k - 1);
    root-&gt;rchild = creat(postl + numl, postr - 1, k + 1, inr);
    return root;
}

int cou = 0; //用于计数

//用构建好的BT，打印level order 
void print_level(Nodes *root) {
    queue&lt;Nodes*&gt; q;
    q.push(root);
    while (!q.empty())
    {
        Nodes *node = new Nodes;
        node = q.front();
        q.pop();
        cout &lt;&lt; node-&gt;data;
        cou++;
        if (cou&lt;n)
        {
            cout &lt;&lt; &quot; &quot;;
        }
        if (node-&gt;lchild!=NULL)
        {
            q.push(node-&gt;lchild);
        }
        if (node-&gt;rchild!=NULL)
        {
            q.push(node-&gt;rchild);
        }
    }
}

int main()
{
    cin &gt;&gt; n;
    for (int i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; post[i];
    }
    for (int i = 0; i &lt; n; i++)
    {
        cin &gt;&gt; in[i];
    }
    Nodes *root = creat(0, n - 1, 0, n - 1);
    print_level(root);
    return 0;
}</code></pre><h3 id="1086-Tree-Traversals-Again"><a href="#1086-Tree-Traversals-Again" class="headerlink" title="1086 Tree Traversals Again"></a>1086 Tree Traversals Again</h3><p><strong>试题概述：</strong><br>input：用堆栈描述二叉树的结构<br>output：打印二叉树的后序遍历<br>说明：这道题跟Test 1我认为是没有什么区别的，由题设可知这一系列堆栈的操作其实是给出了二叉树的PreOrder与InOrder，只需做一些简单字符串的处理将其提取出来即可，剩下的与Test 1基本没有区别（构造二叉树以及标准的遍历操作）。<br><a href="https://pintia.cn/problem-sets/994805342720868352/problems/994805380754817024" target="_blank" rel="noopener">OJ试题传送门</a></p>
<pre><code>#include &lt;iostream&gt;
#include&lt;stack&gt;
#include&lt;string&gt;
using namespace std;
const int N = 31;
int    n;
int pre[N], in[N];

struct Nodes
{
    int data;
    Nodes *lchild, *rchild;
};

//recreate the BT through the preorder traversal and the inorder traversal
Nodes* creat(int preL, int preR, int inL, int inR) {
    if (preR&lt;preL)
    {
        return NULL;
    }
    Nodes *root = new Nodes;
    root-&gt;data = pre[preL];
    int k;
    for ( k = inL; k &lt; inR; k++)
    {
        if (in[k] == pre[preL])
            break;
    }
    int numL = k - inL;
    root-&gt;lchild = creat(preL + 1, preL + numL, inL, k-1);
    root-&gt;rchild = creat(preL + numL + 1, preR, k + 1, inR);
    return root;
}

//print the BT&#39;s postorder traversal
int cou = 0;
void print_post(Nodes* root) {
    if (root==NULL)
    {
        return;
    }
    print_post(root-&gt;lchild);
    print_post(root-&gt;rchild);
    cout &lt;&lt; root-&gt;data;
    cou++;
    if (cou&lt;n)
    {
        cout &lt;&lt; &quot; &quot;;
    }
}

int main()
{
    cin &gt;&gt; n;
    string s;
    int x;
    int n1 = 0, n2 = 0;
    stack&lt;int&gt; ss;
    for (int i = 0; i &lt; 2*n; i++)
    {
        cin &gt;&gt; s;
        if (s[1]==&#39;u&#39;)
        {
            cin &gt;&gt; x;
            pre[n1++] = x;
            ss.push(x);
        }
        else
        {
            in[n2++] = ss.top();
            ss.pop();
        }
    }
    Nodes *root = creat(0, n - 1, 0, n - 1);
    print_post(root);
    return 0;
}</code></pre>]]></content>
      <categories>
        <category>刷题</category>
      </categories>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>PCA算法</title>
    <url>/page/pca-basic-use.html</url>
    <content><![CDATA[<h2 id="算法概述"><a href="#算法概述" class="headerlink" title="算法概述"></a>算法概述</h2><blockquote>
<p>PCA算法是一种使用广泛的数据降维算法，主要思想是将n维特征映射到k维上（k &lt; n）。降维的本质也就是<em>从原始坐标系映射到另一个维数更小的坐标系</em></p>
<p>PCA的工作就是从原始的空间中<em>顺序地</em>找一组<em>相互正交</em>的坐标轴（所以<strong>主成分也可以理解为降维后新坐标系的坐标轴</strong>，比如，第一主成分即为求出来的第一个坐标轴），新的坐标轴的选择与数据本身是密切相关的（原始数据中方差最大的方向）</p>
</blockquote>
<h2 id="二维数据可视化"><a href="#二维数据可视化" class="headerlink" title="二维数据可视化"></a>二维数据可视化</h2><h3 id="原始二维数据"><a href="#原始二维数据" class="headerlink" title="原始二维数据"></a>原始二维数据</h3><pre><code># 构建原始二维数据
x = np.empty((50, 2))
x[:, 0] = np.random.uniform(0, 50, size=50)
x[:, 1] = 0.8 * x[:, 0] + 2 + np.random.normal(0, 5, size=50)</code></pre><img src="http://cdn.ziyedy.top/PCA%E7%AE%97%E6%B3%95/%E5%88%9D%E5%A7%8B%E6%95%B0%E6%8D%AE.png" style="zoom:67%;" />



<h3 id="对数据样本进行中心化"><a href="#对数据样本进行中心化" class="headerlink" title="对数据样本进行中心化"></a>对数据样本进行中心化</h3><p>进行中心化即<strong>将样本的均值归为0</strong>，在计算方差时可以将尾数约掉</p>
<pre><code>def demean(x):
    return x - np.mean(x, axis=0)

x_demean = demean(x)</code></pre><img src="http://cdn.ziyedy.top/PCA%E7%AE%97%E6%B3%95/%E5%BD%920%E5%8C%96%E6%95%B0%E6%8D%AE.png" style="zoom:67%;" />



<h3 id="最大化方差"><a href="#最大化方差" class="headerlink" title="最大化方差"></a>最大化方差</h3><p>找到<strong>一组权重</strong>，使得样本空间中所有点映射到这个轴后方差最大（有点类似于“梯度上升”）</p>
<pre><code>def f(w, x):
    return np.sum((x.dot(w)**2)) / len(x)

def df(w, x):
    return x.T.dot(x.dot(w)) * 2. / len(x)

def gradient_ascent(x, w):
    def direction(w):
        &quot;&quot;&quot; 将w转化为单位方向向量 &quot;&quot;&quot;
        return w / np.linalg.norm(w)
    cur_iter = 0
    w = direction(w)
    while cur_iter &lt; 1e4:
        gradient = df(w, x)
        last_w = w
        w = w + 0.001 * gradient
        w = direction(w)
        if abs(f(w, x) - f(last_w, x) &lt; 1e-8):
            break
        cur_iter += 1
    return w


initial_w = np.random.random(x.shape[1])
w = gradient_ascent(x_demean, initial_w)

plt.scatter(x_demean[:, 0], x_demean[:, 1])
plt.plot([-w[0]*50, w[0]*50], [-w[1]*50, w[1]*50], c=&#39;r&#39;)
plt.show()</code></pre><p>如图所示，该红线即为方差最大时的权重（可以理解为将这些数据点投影上去能够保留最多信息）</p>
<img src="http://cdn.ziyedy.top/PCA%E7%AE%97%E6%B3%95/%E6%A0%87%E5%87%86%E6%AD%A3%E4%BA%A4%E5%9F%BA%E5%90%91%E9%87%8F.png" style="zoom:67%;" />



<h2 id="PCA的实现"><a href="#PCA的实现" class="headerlink" title="PCA的实现"></a>PCA的实现</h2><p>模仿<code>sklearn</code>机器学习库的API，实现PCA类</p>
<pre><code>class PCA:

    def __init__(self, n_components):
        &quot;&quot;&quot; 初始化PCA &quot;&quot;&quot;
        self.n_components = n_components
        self.components_ = None

    def fit(self, x):
        &quot;&quot;&quot; 获取数据集的前n个主成分 &quot;&quot;&quot;
        def demean(x):
            return x - np.mean(x, axis=0)

        def f(w, x):
            return np.sum((x.dot(w) ** 2)) / len(x)

        def df(w, x):
            return x.T.dot(x.dot(w)) * 2. / len(x)

        def gradient_ascent(x, w):
            &quot;&quot;&quot; 梯度上升法获取第1主成分 &quot;&quot;&quot;
            def direction(w):
                &quot;&quot;&quot; 将w转化为单位方向向量 &quot;&quot;&quot;
                return w / np.linalg.norm(w)
            cur_iter = 0
            w = direction(w)
            while cur_iter &lt; 1e4:
                gradient = df(w, x)
                last_w = w
                w = w + 0.001 * gradient
                w = direction(w)
                if abs(f(w, x) - f(last_w, x) &lt; 1e-8):
                    break
                cur_iter += 1
            return w

        x_pca = demean(x)
        self.components_ = np.empty(shape=(self.n_components, x.shape[1]))
        for i in range(self.n_components):
            initial_w = np.random.random(x_pca.shape[1])
            # 在x_pca上求得第一主成分
            w = gradient_ascent(x_pca, initial_w)
            self.components_[i, :] = w
            # 将x_pca映射到求出来的主成分上，在此基础上再求第一主成分
            x_pca = x_pca - x_pca.dot(w).reshape(-1, 1) * w
        return self

    def transform(self, X):
        &quot;&quot;&quot; 将给定的X，映射到各个主成分分量z中 &quot;&quot;&quot;
        return X.dot(self.components_.T)

    def detransform(self, X):
        &quot;&quot;&quot; 将给定的X，反向映射回原来的特征空间 &quot;&quot;&quot;
        return X.dot(self.components_)</code></pre><h2 id="PCA的使用"><a href="#PCA的使用" class="headerlink" title="PCA的使用"></a>PCA的使用</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>sklearn</code>库中的PCA的用法与之前实现的基本一致。</p>
<pre><code>from sklearn.decomposition import PCA

pca = PCA(n_components=1)
pca.fit(x_data)
pca.components_  # 得到的主成分
x_reduction = pca.transform(x_data)
x_restore = pca.inverse_transform(x_reduction)</code></pre><h3 id="PCA效果的查看"><a href="#PCA效果的查看" class="headerlink" title="PCA效果的查看"></a>PCA效果的查看</h3><pre><code>pca.explained_variance_ratio_</code></pre><blockquote>
<p>该方法返回一个表示降维后每个轴能够代表整个数据信息的比例，可以查看降维的效果以及数据损失的程度</p>
</blockquote>
<pre><code># 获取PCA所有轴数据损失的程度
pca = PCA(n_components=x_train.shape[1])
pca.fit(x_train)
pca.explained_variance_ratio_</code></pre>]]></content>
      <categories>
        <category>AI</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>经典算法</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络基础概念总结</title>
    <url>/page/nn-basic-concept-summary.html</url>
    <content><![CDATA[<h3 id="神经网络复杂度"><a href="#神经网络复杂度" class="headerlink" title="神经网络复杂度"></a>神经网络复杂度</h3><p><strong>NN复杂度：多用NN层数和NN参数的个数表示</strong></p>
<p>层数 = 隐藏层的层数+1个输出层</p>
<p>总参数 = 总w + 总b</p>
<p><strong>空间复杂度</strong>：即为总参数个数</p>
<p><strong>时间复杂度</strong>：即为乘加运算次数</p>
<p><img src="http://cdn.ziyedy.top/image/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/%E5%A4%8D%E6%9D%82%E5%BA%A6.png" alt=""></p>
<h3 id="学习率"><a href="#学习率" class="headerlink" title="学习率"></a>学习率</h3><p><img src="http://cdn.ziyedy.top/image/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/%E5%AD%A6%E4%B9%A0%E7%8E%87.png" alt=""></p>
<h4 id="指数衰减学习率"><a href="#指数衰减学习率" class="headerlink" title="指数衰减学习率"></a>指数衰减学习率</h4><p>先用较大的学习率，快速得到较优解，然后逐步减小学习率，使模型在训练后期稳定。公式如下：</p>
<pre><code>指数衰减学习率 = 初始学习率 * 学习率衰减率 (当前轮数 / 多少轮衰减一次)</code></pre><h3 id="激活函数"><a href="#激活函数" class="headerlink" title="激活函数"></a>激活函数</h3><p><img src="http://cdn.ziyedy.top/image/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0.png" alt=""></p>
<h4 id="优秀的激活函数"><a href="#优秀的激活函数" class="headerlink" title="优秀的激活函数"></a>优秀的激活函数</h4><ul>
<li>非线性：激活函数非线性时，多层神经网络可逼近所有函数</li>
<li>可微性： 优化器大多用梯度下降更新参数</li>
<li>单调性： 当激活函数是单调的，能保证单层网络的损失函数是凸函数</li>
<li>近似恒等性： f(x)≈x 当参数初始化为随机小值时，神经网络更稳定</li>
</ul>
<h4 id="Sigmoid函数"><a href="#Sigmoid函数" class="headerlink" title="Sigmoid函数"></a>Sigmoid函数</h4><p>$$<br>f(x) = \frac {1} {1 + e^{-x}}<br>$$</p>
<p><img src="http://cdn.ziyedy.top/image/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/sigmoid.png" alt=""></p>
<p>特点：</p>
<p>（1）易造成梯度消失<br>（2）输出非0均值，收敛慢<br>（3）幂运算复杂，训练时间长</p>
<h4 id="Tanh函数"><a href="#Tanh函数" class="headerlink" title="Tanh函数"></a>Tanh函数</h4><p><img src="http://cdn.ziyedy.top/image/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/tanh.png" alt=""></p>
<p>特点<br>（1）输出是0均值<br>（2）易造成梯度消失<br>（3）幂运算复杂，训练时间长</p>
<h4 id="Relu函数（用的最多）"><a href="#Relu函数（用的最多）" class="headerlink" title="Relu函数（用的最多）"></a>Relu函数（用的最多）</h4><p>$$<br>f(x) = max(x, 0)<br>$$</p>
<p><img src="http://cdn.ziyedy.top/image/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/relu.png" alt=""></p>
<p>优点：</p>
<p>（1）解决了梯度消失问题 解决了梯度消失问题 (在正区间）</p>
<p>（2）只需判断输入是否大于 只需判断输入是否大于0，计算速度快</p>
<p>（3）收敛速度远快于 收敛速度远快于sigmoid 和tanh</p>
<p>缺点：</p>
<p>（1）输出非0均值，收敛慢</p>
<p>（2）Dead Relu问题：某些神经元永远不会被激活，导致相应的参数永远不会被更新</p>
<h4 id="Leaky-Relu函数"><a href="#Leaky-Relu函数" class="headerlink" title="Leaky Relu函数"></a>Leaky Relu函数</h4><p><img src="http://cdn.ziyedy.top/image/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/Leaky-relu.png" alt=""></p>
<h4 id="激活函数的使用"><a href="#激活函数的使用" class="headerlink" title="激活函数的使用"></a>激活函数的使用</h4><p>1、首选relu激活函数</p>
<p>2、学习率设置较小值</p>
<p>3、输入特征标准化，即让输入特征满足以0为均值，1为标准差的正态分布； </p>
<p>4、初始参数中心化，即让随机生成的参数满足以0为均值，$\frac {2} {当前层特征个数}$ 为标准差的正态分布</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>神经网络的优化目标就是使得损失函数最小</p>
<h4 id="自定义损失函数"><a href="#自定义损失函数" class="headerlink" title="自定义损失函数"></a>自定义损失函数</h4><p>可以根据具体的项目自定义损失函数</p>
<h4 id="均方误差（MSE）"><a href="#均方误差（MSE）" class="headerlink" title="均方误差（MSE）"></a>均方误差（MSE）</h4><p>很好理解，平时最基本的曲线拟合就是用的均方误差的损失函数。<br>$$<br>MSE(y_, y) = \frac {\sum^n_{i=1} (y-y_)^2} {n}<br>$$</p>
<h4 id="交叉熵损失函数（Cross-Entropy）"><a href="#交叉熵损失函数（Cross-Entropy）" class="headerlink" title="交叉熵损失函数（Cross Entropy）"></a>交叉熵损失函数（Cross Entropy）</h4><p>$$<br>H(y_, y) = - \sum y_ * ln y<br>$$</p>
<p>用来表征两个概率分布之间的距离，常与softmax函数结合</p>
<p><strong>输出先进行softmax函数，再计算y与y_的交叉熵损失函数</strong></p>
<pre><code>tf.nn.softmax_cross_entropy_with_logits(y_ ，y)</code></pre><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>正则化一般用于<strong>缓解过拟合（训练准确性和测试准确性之间的差距代表<em>过度拟合</em> ）</strong>，即在损失函数中引入模型复杂度指标，利用给W加权值，弱化了训练数据的噪声</p>
<p><img src="http://cdn.ziyedy.top/image/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%80%BB%E7%BB%93/%E6%AD%A3%E5%88%99%E5%8C%96.png" alt=""></p>
<h4 id="L1正则化"><a href="#L1正则化" class="headerlink" title="L1正则化"></a>L1正则化</h4><p>$$<br>loss_{L1}(w) = \sum_{i} |x|<br>$$</p>
<blockquote>
<p>L1正则化大概率会使很多参数变为0，因此该方法可通过稀疏参数，即减少参数的数量降低复杂度</p>
</blockquote>
<h4 id="L2正则化"><a href="#L2正则化" class="headerlink" title="L2正则化"></a>L2正则化</h4><p>$$<br>loss_{L1}(w) = \sum_{i} |x^2|<br>$$</p>
<blockquote>
<p>L2正则化会使参数很接近零但不为零，因此该方法可通过减小参数值的大小降低复杂度。</p>
</blockquote>
<h3 id="参数优化器"><a href="#参数优化器" class="headerlink" title="参数优化器"></a>参数优化器</h3><h4 id="SGD"><a href="#SGD" class="headerlink" title="SGD"></a>SGD</h4><h4 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h4>]]></content>
      <categories>
        <category>AI</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>TF2原生语法构建简单网络</title>
    <url>/page/tf2-basic-builder-simple-nn.html</url>
    <content><![CDATA[<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><h3 id="数据集"><a href="#数据集" class="headerlink" title="数据集"></a>数据集</h3><p>本实验采用的数据为鸢尾属植物数据集，存储了150个样本的4个特征，分别对应了3类不同的鸢尾属植物。</p>
<h3 id="基本流程可视化"><a href="#基本流程可视化" class="headerlink" title="基本流程可视化"></a>基本流程可视化</h3><p>每个数据可以视为1×4的向量，且最后对应3类，那么权重w就应该是4×3，偏置量b就应该是1×3。</p>
<p><img src="http://cdn.ziyedy.top/image/AI/TF2/%E6%9D%83%E9%87%8D%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p>
<p>上述过程可以即可以视为一个全连接神经网络，可视化如下。</p>
<p><img src="http://cdn.ziyedy.top/image/AI/TF2/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p>
<h2 id="主要流程"><a href="#主要流程" class="headerlink" title="主要流程"></a>主要流程</h2><h3 id="一、数据准备"><a href="#一、数据准备" class="headerlink" title="一、数据准备"></a>一、数据准备</h3><h4 id="1、数据集读入"><a href="#1、数据集读入" class="headerlink" title="1、数据集读入"></a>1、数据集读入</h4><pre><code>from sklearn.datasets import datasets
x_data = datasets.load_iris().data
y_data = datasets.load_iris().target</code></pre><h4 id="2、数据集乱序"><a href="#2、数据集乱序" class="headerlink" title="2、数据集乱序"></a>2、数据集乱序</h4><pre><code>np.random.seed(116)
np.random.shuffle(x_data)
np.random.seed(116)
np.random.shuffle(y_data)</code></pre><h4 id="3、生成训练集和测试集，并根据需要转换数据格式"><a href="#3、生成训练集和测试集，并根据需要转换数据格式" class="headerlink" title="3、生成训练集和测试集，并根据需要转换数据格式"></a>3、生成训练集和测试集，并根据需要转换数据格式</h4><pre><code># 取后30个为测试集，其余为训练集
x_train = x_data[:-30]
y_train = y_data[:-30]
x_test = x_data[-30:]
y_test = y_data[-30:]

# 转换x的数据类型，避免数据不一致的问题
x_train = tf.cast(x_train, tf.float32)
x_test = tf.cast(x_test, tf.float32)</code></pre><h4 id="4、将（输入特征，标签）组成对，每次读入一部分（batch）"><a href="#4、将（输入特征，标签）组成对，每次读入一部分（batch）" class="headerlink" title="4、将（输入特征，标签）组成对，每次读入一部分（batch）"></a>4、将（输入特征，标签）组成对，每次读入一部分（batch）</h4><pre><code>train_db = tf.data.Dataset.from_tensor_slices((x_train, y_train)).batch(32)
test_db = tf.data.Dataset.from_tensor_slices((x_test, y_test)).batch(32)</code></pre><h3 id="二、搭建网络，迭代进行训练"><a href="#二、搭建网络，迭代进行训练" class="headerlink" title="二、搭建网络，迭代进行训练"></a>二、搭建网络，迭代进行训练</h3><h4 id="1、定义神经网络中所有可训练参数"><a href="#1、定义神经网络中所有可训练参数" class="headerlink" title="1、定义神经网络中所有可训练参数"></a>1、定义神经网络中所有可训练参数</h4><pre><code>w1 = tf.Variable(tf.random.truncated_normal([4, 3], stddev=0.1, seed=1))
b1 = tf.Variable(tf.random.truncated_normal([3], stddev=0.1, seed=1))</code></pre><h4 id="2、定义一些超参数，及后续可能会用到的参数"><a href="#2、定义一些超参数，及后续可能会用到的参数" class="headerlink" title="2、定义一些超参数，及后续可能会用到的参数"></a>2、定义一些超参数，及后续可能会用到的参数</h4><pre><code>lr = 0.1  # 学习率为0.1
train_loss_results = []  # 将每轮的loss记录在此列表中，为后续画loss曲线提供数据
test_acc = []  # 将每轮的acc记录在此列表中，为后续画acc曲线提供数据
epoch = 500  # 循环500轮
loss_all = 0  # 每轮分4个step，loss_all记录四个step生成的4个loss的和</code></pre><h4 id="3、嵌套循环迭代，with结构更新参数，显示loss等信息"><a href="#3、嵌套循环迭代，with结构更新参数，显示loss等信息" class="headerlink" title="3、嵌套循环迭代，with结构更新参数，显示loss等信息"></a>3、嵌套循环迭代，with结构更新参数，显示loss等信息</h4><pre><code># 数据集级别的循环，每个epoch循环一次数据集
for epoch in range(epoch):  
    # batch级别的循环 ，每个step循环一个batch
    for step, (x_train, y_train) in enumerate(train_db):
        # with结构记录梯度信息
        with tf.GradientTape() as tape:
            # 前向传播计算y_
            y = tf.matmul(x_train, w1) + b1
            y = tf.nn.softmax(y)
            y_ = tf.one_hot(y_train, depth=3)
            # 计算总loss
            loss = tf.reduce_mean(tf.square(y_ - y))
            loss_all += loss.numpy()

        # 计算loss对各个参数的梯度
        grads = tape.gradient(loss, [w1, b1])

        # 参数自更新
        w1.assign_sub(lr * grads[0])  # 参数w1自更新
        b1.assign_sub(lr * grads[1])  # 参数b自更新

    # 每个epoch，打印loss信息并记录
    print(&quot;Epoch {}, loss: {}&quot;.format(epoch, loss_all/4))
    train_loss_results.append(loss_all / 4)
    loss_all = 0</code></pre><h4 id="4、在该轮epoch中，计算当前参数前向传播的准确率并进行记录"><a href="#4、在该轮epoch中，计算当前参数前向传播的准确率并进行记录" class="headerlink" title="4、在该轮epoch中，计算当前参数前向传播的准确率并进行记录"></a>4、在该轮epoch中，计算当前参数前向传播的准确率并进行记录</h4><pre><code>    # total_correct为预测对的样本个数, total_number为测试的总样本数，将这两个变量都初始化为0
    total_correct, total_number = 0, 0
    for x_test, y_test in test_db:
        # 使用更新后的参数进行预测
        y = tf.matmul(x_test, w1) + b1
        y = tf.nn.softmax(y)
        pred = tf.argmax(y, axis=1)  # 返回y中最大值的索引，即预测的分类
        # 将pred转换为y_test的数据类型
        pred = tf.cast(pred, dtype=y_test.dtype)
        # 若分类正确，则correct=1，否则为0，将bool型的结果转换为int型
        correct = tf.cast(tf.equal(pred, y_test), dtype=tf.int32)
        # 将每个batch的correct数加起来
        correct = tf.reduce_sum(correct)
        # 将所有batch中的correct数加起来
        total_correct += int(correct)
        # total_number为测试的总样本数，也就是x_test的行数，shape[0]返回变量的行数
        total_number += x_test.shape[0]
    # 总的准确率等于total_correct/total_number
    acc = total_correct / total_number
    test_acc.append(acc)
    print(&quot;Test_acc:&quot;, acc)
    print(&quot;--------------------------&quot;)</code></pre><h3 id="三、绘制相应训练曲线"><a href="#三、绘制相应训练曲线" class="headerlink" title="三、绘制相应训练曲线"></a>三、绘制相应训练曲线</h3><pre><code># 绘制 loss 曲线
plt.title(&#39;Loss Function Curve&#39;)  
plt.xlabel(&#39;Epoch&#39;) 
plt.ylabel(&#39;Loss&#39;) 
plt.plot(train_loss_results, label=&quot;$Loss$&quot;) 
plt.legend() 
plt.show() 

# 绘制 Accuracy 曲线
plt.title(&#39;Acc Curve&#39;) 
plt.xlabel(&#39;Epoch&#39;) 
plt.ylabel(&#39;Acc&#39;) 
plt.plot(test_acc, label=&quot;$Accuracy$&quot;) 
plt.legend()
plt.show()</code></pre>]]></content>
      <categories>
        <category>AI</category>
        <category>TF2</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>TF2存储模型参数等基本操作</title>
    <url>/page/tf2-nn-basic-handle.html</url>
    <content><![CDATA[<h2 id="存储模型"><a href="#存储模型" class="headerlink" title="存储模型"></a>存储模型</h2>]]></content>
      <categories>
        <category>AI</category>
        <category>TF2</category>
      </categories>
  </entry>
  <entry>
    <title>TF2实现经典CNN架构</title>
    <url>/page/tf2-classic-cnn.html</url>
    <content><![CDATA[<h2 id="卷积神经网络经典操作"><a href="#卷积神经网络经典操作" class="headerlink" title="卷积神经网络经典操作"></a>卷积神经网络经典操作</h2><h3 id="卷积操作"><a href="#卷积操作" class="headerlink" title="卷积操作"></a>卷积操作</h3><pre><code>tf.keras.layers.Conv2D (
    filters = 卷积核个数,
    kernel_size = 卷积核尺寸, # 正方形写核长整数，或（核高h，核宽w）
    strides = 滑动步长, # 横纵向相同写步长整数，或(纵向步长h，横向步长w)，默认1
    padding = “same” or “valid”, # same表示全零填充，valid为默认值
    activation = &quot;relu&quot; # 激活函数，如有BN，此处不写
    input_shape = (高, 宽 , 通道数) # 输入特征图维度，可省略
)</code></pre><h3 id="批标准化（Batch-Normalization，BN）"><a href="#批标准化（Batch-Normalization，BN）" class="headerlink" title="批标准化（Batch Normalization，BN）"></a>批标准化（Batch Normalization，BN）</h3><pre><code>tf.keras.layers.BatchNormalization()</code></pre><h3 id="激活函数（使用BN的情况下才要）"><a href="#激活函数（使用BN的情况下才要）" class="headerlink" title="激活函数（使用BN的情况下才要）"></a>激活函数（使用BN的情况下才要）</h3><pre><code>Activation(对应激活函数)</code></pre><h3 id="池化（Pooling）"><a href="#池化（Pooling）" class="headerlink" title="池化（Pooling）"></a>池化（Pooling）</h3><pre><code># 最大池化
tf.keras.layers.MaxPool2D(
    pool_size= 池化核尺寸,
    strides= 池化步长, # 默认为pool_size
    padding=‘valid’ or ‘same’
)

# 平均池化
tf.keras.layers.AveragePooling2D(
    pool_size= 池化核尺寸,
    strides= 池化步长, # 默认为pool_size
    padding=‘valid’or‘same’
)</code></pre><h3 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h3><pre><code>tf.keras.layers.Dropout(舍弃概率)</code></pre><h3 id="VGG"><a href="#VGG" class="headerlink" title="VGG"></a>VGG</h3>]]></content>
      <categories>
        <category>AI</category>
        <category>TF2</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>逻辑回归</title>
    <url>/page/logistic-regression.html</url>
    <content><![CDATA[<p>j</p>
<p>将样本的特征与样本发生的概率联系起来，概率是一个数</p>
<p>逻辑回归既可以看作回归算法也可以看作分类算法。通常作为分类算法使用，只解决二分类问题</p>
<p>决策边界</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>TF2的基础函数</title>
    <url>/page/TF2-basic-function.html</url>
    <content><![CDATA[<h3 id="张量生成"><a href="#张量生成" class="headerlink" title="张量生成"></a>张量生成</h3><h4 id="直接创建"><a href="#直接创建" class="headerlink" title="直接创建"></a>直接创建</h4><pre><code>tf.constant(张量内容, dtype=数据类型&lt;可选&gt;)</code></pre><h4 id="创建全为0的张量"><a href="#创建全为0的张量" class="headerlink" title="创建全为0的张量"></a>创建全为0的张量</h4><pre><code>tf.zeros(维度)</code></pre><h4 id="创建全为1的张量"><a href="#创建全为1的张量" class="headerlink" title="创建全为1的张量"></a>创建全为1的张量</h4><pre><code>tf.ones(维度)</code></pre><h4 id="创建全为指定值的张量"><a href="#创建全为指定值的张量" class="headerlink" title="创建全为指定值的张量"></a>创建全为指定值的张量</h4><pre><code>tf.fill(维度, 指定值)</code></pre><h4 id="将numpy数据转化为Tensor数据"><a href="#将numpy数据转化为Tensor数据" class="headerlink" title="将numpy数据转化为Tensor数据"></a>将numpy数据转化为Tensor数据</h4><pre><code>tf.convert_to_tensor(数据名, dtype=数据类型&lt;可选&gt;)</code></pre><h4 id="生成正态分布的随机数，默认均值为0，标准差为1"><a href="#生成正态分布的随机数，默认均值为0，标准差为1" class="headerlink" title="生成正态分布的随机数，默认均值为0，标准差为1"></a>生成正态分布的随机数，默认均值为0，标准差为1</h4><pre><code>tf.random.normal(维度, mean=均值, stddev=标准差)</code></pre><h4 id="生成截断式正态分布随机数"><a href="#生成截断式正态分布随机数" class="headerlink" title="生成截断式正态分布随机数"></a>生成截断式正态分布随机数</h4><pre><code>tf.random.truncated_normal(维度, mean=均值, stddev=标准差)</code></pre><h4 id="生成均匀分布随机数（-minval-maxval-）"><a href="#生成均匀分布随机数（-minval-maxval-）" class="headerlink" title="生成均匀分布随机数（[minval, maxval)）"></a>生成均匀分布随机数（[minval, maxval)）</h4><pre><code>tf.random.uniform(维度, minval=0, maxval=1)</code></pre><h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><h4 id="将输入特征与标签配对（常用于构建数据集）"><a href="#将输入特征与标签配对（常用于构建数据集）" class="headerlink" title="将输入特征与标签配对（常用于构建数据集）"></a>将输入特征与标签配对（常用于构建数据集）</h4><pre><code>tf.data.Dataset.from_tensor_slices( (输入特征, 标签) )</code></pre><h4 id="强制tensor转换为该数据类型"><a href="#强制tensor转换为该数据类型" class="headerlink" title="强制tensor转换为该数据类型"></a>强制tensor转换为该数据类型</h4><pre><code>tf.cast(张量名, dtype=数据类型)</code></pre><h4 id="将变量标记为“可训练”"><a href="#将变量标记为“可训练”" class="headerlink" title="将变量标记为“可训练”"></a>将变量标记为“可训练”</h4><p>使用该方法标记的变量会在反向传播中记录梯度信息</p>
<pre><code>tf.Variable(初始值)</code></pre><h4 id="某个函数对指定参数的求导运算"><a href="#某个函数对指定参数的求导运算" class="headerlink" title="某个函数对指定参数的求导运算"></a>某个函数对指定参数的求导运算</h4><p>with 结构记录计算过程，gradient求出张量的梯度</p>
<pre><code>with tf.GradientTape() as tape:
    若干个计算过程
grad = tape.gradient(函数, 对谁求导)</code></pre><h4 id="自减函数（常用于更新参数的值）"><a href="#自减函数（常用于更新参数的值）" class="headerlink" title="自减函数（常用于更新参数的值）"></a>自减函数（常用于更新参数的值）</h4><p>需要先用<code>tf.Variable(w)</code>定义w为可训练</p>
<pre><code>w.assign_sub(w要自减的内容)</code></pre><h4 id="独热编码"><a href="#独热编码" class="headerlink" title="独热编码"></a>独热编码</h4><p>分类问题中，常用独热码做标签标记类别，1表示是，2表示非</p>
<pre><code>tf.one_hot(带转换数据, depth=几分类)</code></pre><blockquote>
<p>one-hot编码，把正整数变为向量表达（生成一个不小于正整数的向量，只有正整数的位置为1，其余位置为0）</p>
<p>三分类：2 -&gt; one-hot -&gt; [0, 0, 1]</p>
</blockquote>
<h4 id="softmax：使数值变为0-1之间的概率分布"><a href="#softmax：使数值变为0-1之间的概率分布" class="headerlink" title="softmax：使数值变为0-1之间的概率分布"></a>softmax：使数值变为0-1之间的概率分布</h4><pre><code>tf.nn.softmax(张量名)</code></pre><h4 id="argmax：返回张量沿指定维度最大值的索引"><a href="#argmax：返回张量沿指定维度最大值的索引" class="headerlink" title="argmax：返回张量沿指定维度最大值的索引"></a>argmax：返回张量沿指定维度最大值的索引</h4><pre><code>tf.argmax(张量名, axis=操作轴)</code></pre><h3 id="张量数值统计"><a href="#张量数值统计" class="headerlink" title="张量数值统计"></a>张量数值统计</h3><h4 id="计算张量元素最小值-最大值"><a href="#计算张量元素最小值-最大值" class="headerlink" title="计算张量元素最小值/最大值"></a>计算张量元素最小值/最大值</h4><pre><code>tf.reduce_min()
tf.reduce_max()</code></pre><h4 id="计算张量沿着指定维度的平均值（不指定维度对所有操作）"><a href="#计算张量沿着指定维度的平均值（不指定维度对所有操作）" class="headerlink" title="计算张量沿着指定维度的平均值（不指定维度对所有操作）"></a>计算张量沿着指定维度的平均值（不指定维度对所有操作）</h4><pre><code>tf.reduce_mean(张量名, axis=操作轴)</code></pre><h4 id="计算张量沿着指定维度的和"><a href="#计算张量沿着指定维度的和" class="headerlink" title="计算张量沿着指定维度的和"></a>计算张量沿着指定维度的和</h4><pre><code>tf.reduce_sum(张量名, axis=操作轴)</code></pre><h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><h4 id="两个张量对应元素相加"><a href="#两个张量对应元素相加" class="headerlink" title="两个张量对应元素相加"></a>两个张量对应元素相加</h4><pre><code>tf.add(张量1, 张量2)</code></pre><h4 id="相减"><a href="#相减" class="headerlink" title="相减"></a>相减</h4><pre><code>tf.subtract()</code></pre><h4 id="相乘"><a href="#相乘" class="headerlink" title="相乘"></a>相乘</h4><pre><code>tf.multiply</code></pre><h4 id="相除"><a href="#相除" class="headerlink" title="相除"></a>相除</h4><pre><code>tf.divide</code></pre><h4 id="计算张量的平方"><a href="#计算张量的平方" class="headerlink" title="计算张量的平方"></a>计算张量的平方</h4><pre><code>tf.square(张量名)</code></pre><h4 id="n次方"><a href="#n次方" class="headerlink" title="n次方"></a>n次方</h4><pre><code>tf.pow(张量名, n次方)</code></pre><h4 id="开方"><a href="#开方" class="headerlink" title="开方"></a>开方</h4><pre><code>tf.sqrt(张量名)</code></pre><h4 id="两个矩阵相乘"><a href="#两个矩阵相乘" class="headerlink" title="两个矩阵相乘"></a>两个矩阵相乘</h4><pre><code>tf.matmul(矩阵1, 矩阵2)</code></pre>]]></content>
      <categories>
        <category>AI</category>
        <category>TF2</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础方法与应用</title>
    <url>/page/sklearn-ml.html</url>
    <content><![CDATA[<h2 id="分类：K近邻算法（KNN）"><a href="#分类：K近邻算法（KNN）" class="headerlink" title="分类：K近邻算法（KNN）"></a>分类：K近邻算法（KNN）</h2><h3 id="sklearn使用"><a href="#sklearn使用" class="headerlink" title="sklearn使用"></a>sklearn使用</h3><pre><code>from sklearn.neighbors import KNeighborsClassifier

knn = KNeighborsClassifier(n_neighbors=6)
knn.fit(x_train, y_train)    # 进行训练
knn.score(x_test, y_test)    # 获取训练得分
y_predict = knn.predict(x_predict)</code></pre><h3 id="决策边界"><a href="#决策边界" class="headerlink" title="决策边界"></a>决策边界</h3><h2 id="回归：线性回归"><a href="#回归：线性回归" class="headerlink" title="回归：线性回归"></a>回归：线性回归</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><h3 id="sklearn实现"><a href="#sklearn实现" class="headerlink" title="sklearn实现"></a>sklearn实现</h3><pre><code>from sklearn.linear_model import LinearRegression

lin_reg = LinearRegression()
lin_reg.fit(X_train, Y_train)
lin_reg.coef_   # 系数矩阵
lin_reg.intercept_  # 截距</code></pre><p>多项式回归使用线性回归的思路，为原来的样本添加新的特征，原有的特征的多项式组合</p>
<h2 id="多项式回归"><a href="#多项式回归" class="headerlink" title="多项式回归"></a>多项式回归</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><h3 id="sklearn使用多项式回归"><a href="#sklearn使用多项式回归" class="headerlink" title="sklearn使用多项式回归"></a>sklearn使用多项式回归</h3><pre><code>from sklearn.preprocessing import PolynomialFeatures

poly = PolynomialFeatures(degree=2)  # 指定x的最高维度为2
poly.fit(x)
x2 = poly.transform(x)  # 输出x^0 x^1 x^2作为输入线性回归的参数</code></pre><h3 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h3><pre><code>from sklearn.pipeline import Pipeline

poly_reg = Pipeline([
    (&quot;Poly&quot;, PolynomialFeatures(degree=3)),
    (&quot;std_scaler&quot;, StandardScaler()),
    (&quot;lin_reg&quot;, LinearRegression())
])
poly_reg.fit(x, y)
poly_reg.predict(x)</code></pre><h2 id="sklearn基本操作"><a href="#sklearn基本操作" class="headerlink" title="sklearn基本操作"></a>sklearn基本操作</h2><h3 id="数据集的获取与创建"><a href="#数据集的获取与创建" class="headerlink" title="数据集的获取与创建"></a>数据集的获取与创建</h3><pre><code>from sklearn import datasets
from sklearn.model_selection import train_test_split

# 获取包中自带的数据集，以鸢尾花数据集为例
iris = datasets.load_iris()
x = iris.data
y = iris.target

# 将数据集分割为测试数据集和训练数据集
# 可以传入测试数据集的比例以及一个随机种子
x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2, random_state=666)</code></pre><pre><code>from sklearn.metrics import accuracy_score

accuracy_score(y_test, y_predict)</code></pre><h3 id="超参数搜索"><a href="#超参数搜索" class="headerlink" title="超参数搜索"></a>超参数搜索</h3><blockquote>
<p>用于搜索确定获取最优解的超参数</p>
<p>GridSearchCV中的CV指的是交叉验证</p>
</blockquote>
<pre><code>from sklearn.model_selection import GridSearchCV
from sklearn.neighbors import KNeighborsClassifier

# 定义参数的搜索范围
param_grid = [
    {
        &#39;weights&#39;: [&#39;uniform&#39;],
        &#39;n_neighbors&#39;: [i for i in range(1, 4)]
    },
    {
        &#39;weights&#39;: [&#39;distance&#39;],
        &#39;n_neighbors&#39;: [i for i in range(1, 4)],
        &#39;p&#39;: [i for i in range(1, 6)]
    }
]

knn_clf = KNeighborsClassifier()

# 进行网格搜索，n_jobs代表使用核的个数
grid_search = GridSearchCV(knn_clf, param_grid, n_jobs=-1)
grid_search.fit(x_train, y_train)

grid_search.best_estimator_ # 获取最佳分类器
grid_search.best_score_     # 获取最佳参数的准确度
grid_search.best_params_    # 获取最佳参数
knn_clf = grid_search.best_estimator_   # 将最佳分类器赋给原模型
</code></pre><h3 id="归一化处理"><a href="#归一化处理" class="headerlink" title="归一化处理"></a>归一化处理</h3><blockquote>
<p>即将所有数据映射到同一尺度，包括最值归一化（映射到0-1之间）与均值方差归一化（将所有数据归一到均值为0方差为1的分布中）</p>
<p>对测试数据集进行归一化处理时，通常使用训练数据集的均值与方差等统计数据</p>
</blockquote>
<p>scikit-learn中使用Scaler，实现<em>均值方差归一化</em></p>
<pre><code>from sklearn.preprocessing import StandardScaler

standardScaler = StandardScaler()
standardScaler.fit(x_train)
standardScaler.mean_    # 不是用户传来的变量，而是用户传进去的数据计算出来的变量
standardScaler.scale_   # 得到标准差
x_train = standardScaler.transform(x_train)
x_test = standardScaler.transform(x_test)</code></pre><p>仿照<code>sklearn</code>中的对应类实现一个均值方差归一化的类。</p>
<pre><code>import numpy as np

class StandardScaler:

    def __init__(self):
        self.mean_ = None
        self.scale_ = None

    def fit(self, X):
        &quot;&quot;&quot; 计算X获得数据的均值与标准差 &quot;&quot;&quot;
        self.mean_ = np.array([np.mean(X[:, i]) for i in range(X.shape[1])])
        self.scale_ = np.array([np.std(X[:, i]) for i in range(X.shape[1])])
        return self

    def transform(self, X):
        &quot;&quot;&quot; 将X进行均值方差归一化处理 &quot;&quot;&quot;
        res = np.empty(shape=X.shape, dtype=float)
        for col in range(X.shape[1]):
            res[:, col] = (X[:, col] - self.mean_[col]) / self.scale_[col]
        return res</code></pre><h3 id="模型正则化"><a href="#模型正则化" class="headerlink" title="模型正则化"></a>模型正则化</h3><p>导致偏差：对问题本身的定义不正确（选取不相关的特征），欠拟合（线性回归天生高偏差，对数据有极强的假设）</p>
<p>导致方差：数据的扰动会影响，模型太复杂（KNN天生高方差，对数据依赖）</p>
<p>大多数算法具有相应的参数，可以调整偏差与方差</p>
<p>解决高方差：降低模型复杂度、减少数据噪声、增加样本数、实验验证集、模型正则化</p>
<p>模型正则化：限制参数的大小</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>sklearn</tag>
      </tags>
  </entry>
  <entry>
    <title>使用TF2创建数据集</title>
    <url>/page/tf2-create-dataset.html</url>
    <content><![CDATA[<h3 id="使用数据集"><a href="#使用数据集" class="headerlink" title="使用数据集"></a>使用数据集</h3><p>本例中使用的数据集分布在图片文件夹中，一个文件夹含有一类图片。数据集存储格式如下</p>
<pre><code>flower_photo/
  daisy/
  dandelion/
  roses/
  sunflowers/
  tulips/</code></pre><h3 id="下载并查看数据集"><a href="#下载并查看数据集" class="headerlink" title="下载并查看数据集"></a>下载并查看数据集</h3><h4 id="获取数据根目录"><a href="#获取数据根目录" class="headerlink" title="获取数据根目录"></a>获取数据根目录</h4><pre><code>import pathlib
data_url = &#39;https://storage.googleapis.com/download.tensorflow.org/example_images/flower_photos.tgz&#39;
data_root_orig = tf.keras.utils.get_file(origin=data_url,
                                         fname=&#39;flower_photos&#39;, 
                                         untar=True)
data_root = pathlib.Path(data_root_orig)    # data_root存储数据的文件夹的根目录</code></pre><h4 id="获取所有图片路径并打乱"><a href="#获取所有图片路径并打乱" class="headerlink" title="获取所有图片路径并打乱"></a>获取所有图片路径并打乱</h4><pre><code class="python">all_image_paths = list(data_root.glob(&#39;*/*.jpg&#39;))    ## 获取所有图片路径
all_image_paths = [str(path) for path in all_image_paths]    # 转化为str
random.shuffle(all_image_paths)    # 打乱
image_count = len(all_image_paths)    # 获取图片个数：3670

print(all_image_paths[99])    # 打印第100张图的路径
# C:\Users\lenovo\.keras\datasets\flower_photos\tulips\5704726114_a92f753514.jpg</code></pre>
<h4 id="获取图片标签信息"><a href="#获取图片标签信息" class="headerlink" title="获取图片标签信息"></a>获取图片标签信息</h4><pre><code class="python">label_names = sorted(item.name for item in data_root.glob(&#39;*/&#39;) if item.is_dir())    # 根据文件夹名获取标签名
label_to_index = dict((name, index) for index, name in enumerate(label_names))    # 从0开始给标签设置索引
all_image_labels = [label_to_index[pathlib.Path(path).parent.name]
                    for path in all_image_paths]    # 将每张图片与标签一一对应

print(label_names)    # [&#39;daisy&#39;, &#39;dandelion&#39;, &#39;roses&#39;, &#39;sunflowers&#39;, &#39;tulips&#39;]
print(label_to_index)    # {&#39;daisy&#39;: 0, &#39;dandelion&#39;: 1, &#39;roses&#39;: 2, &#39;sunflowers&#39;: 3, &#39;tulips&#39;: 4}
print(all_image_labels[99])    # 打印第100张图的标签：4</code></pre>
<p>由此可见，已经完成了图片与标签一一对应的关系</p>
<h4 id="可视化图片与标签"><a href="#可视化图片与标签" class="headerlink" title="可视化图片与标签"></a>可视化图片与标签</h4><pre><code>import matplotlib.pyplot as plt
for i in range(200, 209):
    plt.subplot(3, 3, i-199)
    img = plt.imread(all_image_paths[i])
    plt.imshow(img)
    plt.xlabel(label_names[all_image_labels[i]])
plt.show()</code></pre><p><img src="http://cdn.ziyedy.top/%E4%BD%BF%E7%94%A8TF2%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86/%E5%8F%AF%E8%A7%86%E5%8C%96%E5%9B%BE%E7%89%87%E4%B8%8E%E6%A0%87%E7%AD%BE.png" alt=""></p>
<h3 id="加载和格式化图片"><a href="#加载和格式化图片" class="headerlink" title="加载和格式化图片"></a>加载和格式化图片</h3><pre><code class="python">def load_and_preprocess_image(path):
    &quot;&quot;&quot; 输入为图片路径列表，输出为图片处理后的列表 &quot;&quot;&quot;
    images = []
    for i in range(len(path)):
        url = path[i]
        image = tf.io.read_file(url)
        image = tf.image.decode_jpeg(image, channels=3)
        image = tf.image.resize(image, [192, 192])
        image = image / 255.0
        images.append(image)
    return images</code></pre>
<p><img src="http://cdn.ziyedy.top/%E4%BD%BF%E7%94%A8TF2%E5%88%9B%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86/%E5%A4%84%E7%90%86%E5%90%8E%E6%95%B0%E6%8D%AE%E5%B1%95%E7%A4%BA.png" alt="处理后数据可视化"></p>
<h3 id="构建数据集"><a href="#构建数据集" class="headerlink" title="构建数据集"></a>构建数据集</h3><h4 id="tf-data-Dataset的基本使用"><a href="#tf-data-Dataset的基本使用" class="headerlink" title="tf.data.Dataset的基本使用"></a>tf.data.Dataset的基本使用</h4><p>tf.data.Dataset是TF2中专门用于数据输入的接口，可以高效的实现数据的读入、打乱（shuffle）、增强（augment）等功能，以下示例简单介绍该接口使用方法</p>
<pre><code>data = np.array([0.1, 0.2, 0.4, 0.05])
label = np.array([0, 1, 1, 0])
dataset = tf.data.Dataset.from_tensor_slices((data, label))    # 组合为数据集

# 遍历打印
# tf.Tensor(0.1, shape=(), dtype=float64) tf.Tensor(0, shape=(), dtype=int32)
# tf.Tensor(0.2, shape=(), dtype=float64) tf.Tensor(1, shape=(), dtype=int32)
# tf.Tensor(0.4, shape=(), dtype=float64) tf.Tensor(1, shape=(), dtype=int32)
# tf.Tensor(0.05, shape=(), dtype=float64) tf.Tensor(0, shape=(), dtype=int32)

dataset = dataset.shuffle(buffer_size=image_count)    # 打乱数据
dataset = dataset.repeat()    # 使数据能够重复使用
dataset = dataset.batch(batch_size=32)    # 每一个batch为32

# 设置batch后遍历打印
# tf.Tensor([0.1 0.2], shape=(2,), dtype=float64) tf.Tensor([0 1], shape=(2,), dtype=int32)
# tf.Tensor([0.4  0.05], shape=(2,), dtype=float64) tf.Tensor([1 0], shape=(2,), dtype=int32)</code></pre><p><strong>使用map函数</strong></p>
<pre><code>def func(data, label):
    data = data * 100
    return data, label

dataset = dataset.map(func)

# tf.Tensor(10.0, shape=(), dtype=float64) tf.Tensor(0, shape=(), dtype=int32)
# tf.Tensor(20.0, shape=(), dtype=float64) tf.Tensor(1, shape=(), dtype=int32)
# tf.Tensor(40.0, shape=(), dtype=float64) tf.Tensor(1, shape=(), dtype=int32)
# tf.Tensor(5.0, shape=(), dtype=float64) tf.Tensor(0, shape=(), dtype=int32)</code></pre><p><strong>处理data的map函数的通用格式：</strong></p>
<pre><code>def func(data, label):
    # 对data进行处理
    return data, label</code></pre><h3 id="本次构建数据集"><a href="#本次构建数据集" class="headerlink" title="本次构建数据集"></a>本次构建数据集</h3><pre><code>dataset = tf.data.Dataset.from_tensor_slices((load_and_preprocess_image(all_image_paths), all_image_labels))
dataset = dataset.shuffle(buffer_size=image_count)
dataset = dataset.repeat()
dataset = dataset.batch(batch_size=32)</code></pre><h3 id="进行训练"><a href="#进行训练" class="headerlink" title="进行训练"></a>进行训练</h3><p>之后按照通用的构建网络的模板进行训练即可（构建网络的过程略）</p>
<pre><code>history = model.fit(dataset, epochs=10, steps_per_epoch=115)</code></pre><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.tensorflow.org/tutorials/load_data/images?hl=zh-cn" target="_blank" rel="noopener">https://www.tensorflow.org/tutorials/load_data/images?hl=zh-cn</a></p>
]]></content>
      <categories>
        <category>AI</category>
        <category>TF2</category>
      </categories>
      <tags>
        <tag>TF2</tag>
      </tags>
  </entry>
  <entry>
    <title>使用tf.keras快速搭建网络</title>
    <url>/page/tf2-keras-build-nn.html</url>
    <content><![CDATA[<p>主要在于与《TF2原生语法构建简单网络》的比较</p>
<h2 id="逐层搭建网络结构（使用Sequential-）"><a href="#逐层搭建网络结构（使用Sequential-）" class="headerlink" title="逐层搭建网络结构（使用Sequential()）"></a>逐层搭建网络结构（使用Sequential()）</h2><h3 id="tf-keras-models-Sequential"><a href="#tf-keras-models-Sequential" class="headerlink" title="tf.keras.models.Sequential()"></a>tf.keras.models.Sequential()</h3><p>Sequential 函数是一个容器，封装了神经网络结构，主要可以进行以下输入：</p>
<pre><code># 直接在列表中加入各层
model = tf.keras.models.Sequential([layer1, layer2, ...])

# 使用add加入各层
model = tf.keras.models.Sequential()
model.add(layer1)
model.add(layer2)</code></pre><h4 id="压平层"><a href="#压平层" class="headerlink" title="压平层"></a>压平层</h4><p>将输入特征拉直为一维向量</p>
<pre><code>tf.keras.layers.Flatten()</code></pre><h4 id="全连接层"><a href="#全连接层" class="headerlink" title="全连接层"></a>全连接层</h4><pre><code>tf.keras.layers.Dense(输出神经元个数,
                      activation=&quot;激活函数&quot;,
                      kernel_regularizer=&quot;正则化方式&quot;
)</code></pre><p><strong>activation可选</strong>：relu、softmax、sigmoid、tanh等</p>
<p><strong>kernel_regularizer可选</strong>：tf.keras.regularizers.l1()、tf.keras.regularizers.l2()</p>
<h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><pre><code>tf.keras.layers.Conv2D( filter = 卷积核个数,
                        kernel_size = 卷积核尺寸,
                        strides = 卷积步长,
                        padding = “valid” or “same”)</code></pre><h4 id="LSTM层"><a href="#LSTM层" class="headerlink" title="LSTM层"></a>LSTM层</h4><pre><code>tf.keras.layers.LSTM()</code></pre><h4 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h4><p>在TF2原生语法构建简单网络的例子中，改用该api可以简化为：</p>
<pre><code>model = tf.keras.models.Sequential([
    tf.keras.layers.Dense(3, activation=&#39;softmax&#39;, kernel_regularizer=tf.keras.regularizers.l2())
])</code></pre><h3 id="使用model-layers查看模型信息"><a href="#使用model-layers查看模型信息" class="headerlink" title="使用model.layers查看模型信息"></a>使用model.layers查看模型信息</h3><pre><code>model.layers

[&lt;tensorflow.python.keras.layers.core.Flatten at 0x2239c7f9888&gt;,
 &lt;tensorflow.python.keras.layers.core.Dense at 0x2239c7f9f08&gt;,
 &lt;tensorflow.python.keras.layers.core.Dense at 0x2239c800248&gt;,
 &lt;tensorflow.python.keras.layers.core.Dense at 0x2239c800688&gt;]</code></pre><h3 id="model-summary"><a href="#model-summary" class="headerlink" title="model.summary()"></a>model.summary()</h3><blockquote>
<p> 同时，在最后可以使用<code>model.summary()</code>查看网络参数量等基本信息。</p>
</blockquote>
<h3 id="训练网络（在-model-compile-中配置训练方法）"><a href="#训练网络（在-model-compile-中配置训练方法）" class="headerlink" title="训练网络（在 model.compile()中配置训练方法）"></a>训练网络（在 model.compile()中配置训练方法）</h3><pre><code>model.compile(optimizer=优化器,
              loss=损失函数,
              metrics=[&quot;准确率&quot;]
)</code></pre><h4 id="optimizer"><a href="#optimizer" class="headerlink" title="optimizer"></a>optimizer</h4><p><strong>optimizer 可以是字符串形式给出的优化器名字，也可以是函数形式 ，使用函数形式可以设置学习率、动量和超参数。</strong></p>
<p>可选项：</p>
<pre><code>‘sgd’or tf.optimizers.SGD( lr=学习率, decay=学习率衰减率, momentum=动量参数)

‘adagrad’or tf.keras.optimizers.Adagrad(lr=学习率, decay=学习率衰减率)

‘adadelta’or tf.keras.optimizers.Adadelta(lr=学习率, decay=学习率衰减率)

‘adam’or tf.keras.optimizers.Adam (lr=学习率, decay=学习率衰减率)</code></pre><h4 id="loss"><a href="#loss" class="headerlink" title="loss"></a>loss</h4><p><strong>Loss 可以是字符串形式给出的损失函数的名字，也可以是函数形式。</strong></p>
<pre><code>‘mse’ or tf.keras.losses.MeanSquaredError()

‘sparse_categorical_crossentropy&#39; or tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False)</code></pre><p>损失函数常需要经过 softmax 等函数将输出转化为概率分布的形式。<strong>from_logits 则用来标注该损失函数是否需要转换为概率的形式，取 False 时表示转化为概率分布，取 True 时表示没有转化为概率分布，直接输出</strong>。</p>
<h4 id="metrics"><a href="#metrics" class="headerlink" title="metrics"></a>metrics</h4><blockquote>
<p>‘accuracy’：y_和 y 都是数值，如 y_=[1] y=[1]。<br>‘categorical_accuracy’：y_和 y 都是以独热码和概率分布表示。如 y_=[0, 1, 0], y=[0.256, 0.695, 0.048]。<br>‘sparse_ categorical_accuracy’：y_是以数值形式给出，y 是以独热码形式给出。如 y_=[1],y=[0.256, 0.695, 0.048]。</p>
</blockquote>
<h4 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h4><pre><code>model.compile(optimizer=tf.keras.optimizers.SGD(lr=0.1),
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),
              metrics=[&#39;accuracy&#39;])</code></pre><h3 id="在model-fit-中执行训练过程"><a href="#在model-fit-中执行训练过程" class="headerlink" title="在model.fit()中执行训练过程"></a>在model.fit()中执行训练过程</h3><pre><code># fit可以返回中间的一些数据结构
# 通常命名为history
history = model.fit( 训练集的输入特征， 训练集的标签， batch _size, epochs,
           validation_data = ( 测试集的输入特征，测试集的标签 ) ，
           validataion_split = 从测试集划分多少比例给训练集，
           validation_freq = 测试的 epoch 间隔次数
           )</code></pre><h4 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h4><pre><code>history = model.fit(x_train, y_train, batch_size=32, epochs=500, validation_split=0.2, validation_freq=20)</code></pre><h3 id="使用history-history绘制训练图表"><a href="#使用history-history绘制训练图表" class="headerlink" title="使用history.history绘制训练图表"></a>使用history.history绘制训练图表</h3><h4 id="history类型"><a href="#history类型" class="headerlink" title="history类型"></a>history类型</h4><pre><code>type(history)
tensorflow.python.keras.callbacks.History</code></pre><h4 id=""><a href="#" class="headerlink" title=""></a></h4><pre><code>print(history.history)

{&#39;loss&#39;: [nan, nan, nan, nan, nan, nan, nan, nan, nan, nan],
 &#39;accuracy&#39;: [0.101127274,
  0.10078182,
  0.10078182,
  0.10078182,
  0.10078182,
  0.10078182,
  0.10078182,
  0.10078182,
  0.10078182,
  0.10078182],
 &#39;val_loss&#39;: [nan, nan, nan, nan, nan, nan, nan, nan, nan, nan],
 &#39;val_accuracy&#39;: [0.0914,
  0.0914,
  0.0914,
  0.0914,
  0.0914,
  0.0914,
  0.0914,
  0.0914,
  0.0914,
  0.0914]}</code></pre><h2 id="使用class搭建网络"><a href="#使用class搭建网络" class="headerlink" title="使用class搭建网络"></a>使用class搭建网络</h2><p>将上述流程封装到一个类中，即为：（<strong>只需要重写构造函数和call函数即可</strong>）</p>
<pre><code>import tensorflow as tf
from tensorflow.keras.layers import Dense
from tensorflow.keras import Model

class IrisModel(Model):
    def __init__(self):
        super(IrisModel, self).__init__()
        self.d1 = Dense(3, activation=&#39;softmax&#39;, kernel_regularizer=tf.keras.regularizers.l2())

    def call(self, x):
        y = self.d1(x)
        return y

model = IrisModel()
model.compile(optimizer=tf.keras.optimizers.SGD(lr=0.1),
              loss=tf.keras.losses.SparseCategoricalCrossentropy(from_logits=False),
              metrics=[&#39;sparse_categorical_accuracy&#39;])

model.fit(x_train, y_train, batch_size=32, epochs=500, validation_split=0.2, validation_freq=20)
model.summary()</code></pre><h2 id="实例（以Fashion-MNIST数据集）为例"><a href="#实例（以Fashion-MNIST数据集）为例" class="headerlink" title="实例（以Fashion MNIST数据集）为例"></a>实例（以Fashion MNIST数据集）为例</h2><h3 id="载入并可视化数据"><a href="#载入并可视化数据" class="headerlink" title="载入并可视化数据"></a>载入并可视化数据</h3><pre><code>import tensorflow as tf
from tensorflow import keras
import matplotlib.pyplot as plt

fashion_mnist = keras.datasets.fashion_mnist
(train_images, train_labels), (test_images, test_labels) = fashion_mnist.load_data()

class_names = [&#39;T-shirt/top&#39;, &#39;Trouser&#39;, &#39;Pullover&#39;, &#39;Dress&#39;, &#39;Coat&#39;,
               &#39;Sandal&#39;, &#39;Shirt&#39;, &#39;Sneaker&#39;, &#39;Bag&#39;, &#39;Ankle boot&#39;]

plt.figure(figsize=(10, 10))
for i in range(100, 125):
    plt.subplot(5, 5, i-99)
    plt.imshow(train_images[i])
    plt.title(class_names[train_labels[i]])
plt.show()</code></pre><img src="http://cdn.ziyedy.top/image/%E4%BD%BF%E7%94%A8tf.keras%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96.png" style="zoom: 80%;" />

<h3 id="进行数据预处理，将值置于0-1范围内"><a href="#进行数据预处理，将值置于0-1范围内" class="headerlink" title="进行数据预处理，将值置于0-1范围内"></a>进行数据预处理，将值置于0-1范围内</h3><pre><code>train_images = train_images / 255.0
test_images = test_images / 255.0</code></pre><h3 id="构建网络并进行训练"><a href="#构建网络并进行训练" class="headerlink" title="构建网络并进行训练"></a>构建网络并进行训练</h3><pre><code>model = keras.Sequential([
    keras.layers.Flatten(input_shape=(28, 28)),
    keras.layers.Dense(128, activation=&#39;relu&#39;),
    keras.layers.Dense(10)
])

model.compile(optimizer=&#39;adam&#39;,
              loss=keras.losses.SparseCategoricalCrossentropy(from_logits=True),
              metrics=[&#39;accuracy&#39;])

history = model.fit(train_images, train_labels, epochs=10)</code></pre><h3 id="进行评估并绘制训练曲线"><a href="#进行评估并绘制训练曲线" class="headerlink" title="进行评估并绘制训练曲线"></a>进行评估并绘制训练曲线</h3><pre><code>test_loss, test_acc = model.evaluate(test_images, test_labels)

plt.plot(history.history[&#39;accuracy&#39;], label=&#39;accuracy&#39;)
plt.plot(history.history[&#39;loss&#39;], label=&#39;loss&#39;)
plt.xlabel(&#39;Epoch&#39;)
plt.ylabel(&#39;Accuracy and Loss&#39;)
plt.legend(loc=&#39;lower left&#39;)
plt.show()</code></pre><img src="http://cdn.ziyedy.top/%E4%BD%BF%E7%94%A8tf.keras%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C/%E8%AE%AD%E7%BB%83%E6%9B%B2%E7%BA%BF.png" style="zoom:67%;" />

<h3 id="使用模型进行预测"><a href="#使用模型进行预测" class="headerlink" title="使用模型进行预测"></a>使用模型进行预测</h3><pre><code>predict_model = keras.Sequential([
    model,
    tf.keras.layers.Softmax()
])
prediction = predict_model.predict(test_images)
print(prediction[0])
# [7.7702840e-05 5.1073805e-08 1.0888911e-05 1.1339294e-07 5.7997750e-06
#  1.0903468e-03 8.1863102e-05 2.4046257e-02 5.1835599e-07 9.7468650e-01]

plt.subplot(1, 2, 1)
plt.imshow(test_images[0])
plt.title(class_names[tf.argmax(prediction[0])])
plt.subplot(1, 2, 2)
plt.bar(class_names, prediction[0])
plt.show()</code></pre><img src="http://cdn.ziyedy.top/image/%E4%BD%BF%E7%94%A8tf.keras%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E7%BD%91%E7%BB%9C/%E9%A2%84%E6%B5%8B%E7%BB%93%E6%9E%9C.png" style="zoom:80%;" />



<h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.tensorflow.org/tutorials/" target="_blank" rel="noopener">https://www.tensorflow.org/tutorials/</a></p>
]]></content>
      <categories>
        <category>AI</category>
        <category>TF2</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>使用TensorFlow Hub进行迁移学习</title>
    <url>/page/TF-Hub-transfer-learning.html</url>
    <content><![CDATA[<p>使用<a href="https://tfhub.dev/" target="_blank" rel="noopener">TensorFlow Hub</a>中的模型能够很轻松的实现模型调用与迁移学习</p>
<pre><code>import tensorflow_hub as hub

# 你所想使用的模型的链接
classifier_url =&quot;https://tfhub.dev/google/tf2-preview/mobilenet_v2/classification/2&quot;

# 构建特征处理器
feature_extractor_layer = hub.KerasLayer(classifier_url, input_shape=(28, 28, 3))

# 冻结特征提取层中的变量
feature_extractor_layer.trainable = False

# 构建自己的模型
classifier = tf.keras.Sequential([
    feature_extractor_layer,
    layers.Dense(image_data.num_classes)    # 全连接分类层
])

# 配置训练过程
model.compile(
  optimizer=tf.keras.optimizers.Adam(),
  loss=tf.keras.losses.CategoricalCrossentropy(from_logits=True),
  metrics=[&#39;acc&#39;])



# 使用该模型进行预测
result = classifier.predict(input_data)</code></pre><p>进行迁移学习，只修改最后的分类层</p>
<pre><code>class CollectBatchStats(tf.keras.callbacks.Callback):
  def __init__(self):
    self.batch_losses = []
    self.batch_acc = []

  def on_train_batch_end(self, batch, logs=None):
    self.batch_losses.append(logs[&#39;loss&#39;])
    self.batch_acc.append(logs[&#39;acc&#39;])
    self.model.reset_metrics()</code></pre>]]></content>
      <categories>
        <category>AI</category>
        <category>TF2</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>DPOD：6D Pose Object Detector and Refiner</title>
    <url>/page/DPOD-summary.html</url>
    <content><![CDATA[<h3 id="DPOD-6D-Pose-Object-Detector-and-Refiner"><a href="#DPOD-6D-Pose-Object-Detector-and-Refiner" class="headerlink" title="DPOD: 6D Pose Object Detector and Refiner"></a>DPOD: 6D Pose Object Detector and Refiner</h3><p>提出了一种从RGB图像进行3D目标检测和6D位姿估计的深度学习方法（DPOD，Dense Pose Object Detector），即密集姿势目标检测器。</p>
<p>用于估计输入图像和可用3D模型之间的密集2D-3D对应图，使用RANSAC与PnP解算6dof姿态，同时基于深度学习的定制细化方案对初始姿态估计值进行细化</p>
<p>简单来讲两个贡献</p>
<p>1、密集的2D-3D点对，比传统8个框点的对应具有更好的鲁棒性</p>
<p>2、一个效果不错的优化器</p>
<h3 id="关键要素"><a href="#关键要素" class="headerlink" title="关键要素"></a>关键要素</h3><p>1、多类对象对应掩膜ID的预测（the pixel-wise prediction of the multi-class object ID masks）</p>
<p>2、直接提供图像像素和3D模型顶点之间关系的对应映射的分类（classification of correspondence maps that directly provide a relation between image pixels and 3D model vertices）</p>
<p><strong>其中第2点保证了本方法的大量的像素对应（相对于那些使用8个框点进行pnp求解的方法来讲），也是本文dense的由来吧</strong></p>
<p>其中应该使用了UV的贴图技术将图像点与3D点进行对应（<strong>UV map的使用应该是本文最大的亮点了</strong>），但UV我只在3dmax等软件中看到过，对其原理并不理解，因此对该部分没有完全看懂。</p>
<p><img src="http://cdn.ziyedy.top/image/DPOD/%E5%AF%B9%E5%BA%94%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<h3 id="整体架构"><a href="#整体架构" class="headerlink" title="整体架构"></a>整体架构</h3><p><img src="http://cdn.ziyedy.top/image/DPOD/%E6%95%B4%E4%BD%93%E6%9E%B6%E6%9E%84.png" alt=""></p>
<p>输入：RGB图像（320×240×3）</p>
<p><strong>对应模块</strong>：编码器-解码器架构，编码器采用类似ResNet的12层架构（具有残差层，可加快收敛速度），解码器使用双线性内插和卷积层的堆叠进行上采样到原始大小</p>
<p>输出：目标ID掩码（标识是哪个物体）与其对应2D位置；UV对应图（提供了明确的2D-3D对应关系）</p>
<p><strong>姿态模块</strong>：基于PnP+RANSAC有效计算各个6D姿势</p>
<h3 id="Refinement"><a href="#Refinement" class="headerlink" title="Refinement"></a>Refinement</h3><p>图中绿色是已知的</p>
<p><img src="http://cdn.ziyedy.top/image/DPOD/refinement.png" alt=""></p>
<p>结构：</p>
<p>使用ResNet做backbone，用ImageNet权重初始化，两个分支提取完特征后相减，再送到 E2 中，然后三个分支分别回归旋转R、XY、Z，每个头都是两个FC层。</p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>损失函数依然使用的加权的思想，充分考虑到了三个分支的状态</p>
<p><img src="http://cdn.ziyedy.top/image/DPOD/%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0.png" alt=""></p>
]]></content>
      <categories>
        <category>AI</category>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>6dof</tag>
      </tags>
  </entry>
  <entry>
    <title>DeepIM：Deep Iterative Matching for 6D Pose Estimation</title>
    <url>/page/deepim-summary.html</url>
    <content><![CDATA[<h3 id="DeepIM-Deep-Iterative-Matching-for-6D-Pose-Estimation"><a href="#DeepIM-Deep-Iterative-Matching-for-6D-Pose-Estimation" class="headerlink" title="DeepIM: Deep Iterative Matching for 6D Pose Estimation"></a>DeepIM: Deep Iterative Matching for 6D Pose Estimation</h3><p>这篇论文可以理解为6d姿态估计问题中的一个refinement行为，经过测试可以使RGB数据的精度达到RGB-D数据的程度。</p>
<p>具体可见该论文。</p>
<h3 id="主要问题"><a href="#主要问题" class="headerlink" title="主要问题"></a>主要问题</h3><p>鉴于直接从图像中回归得到的物体姿态精度不高，将输入图像和物体渲染得到的图像进行匹配，能够得到更加精确的结果。</p>
<p>本文提出的DeepIM深度神经网络：给定一个初始位姿，网络能将观测图像和渲染得到的图像匹配，迭代地优化位姿。网络训练后能够预测一个相对的姿态变换，使用了一种分开表示的3D坐标和3D朝向，并且是用了一种迭代的训练过程。</p>
<h3 id="算法综述"><a href="#算法综述" class="headerlink" title="算法综述"></a>算法综述</h3><p>给定图像中一个物体的初始6D位姿，DeepIM能够将物体渲染得到的图像和当前观测的图像匹配，预测一个相对的SE(3)变换；之后迭代地根据估计的更为精确的位姿重新渲染物体得到渲染图像，并和观测图像相匹配，从而会变得越来越相似，使网络得到越来越精确的位姿。整体框架如下图所示：</p>
<p><img src="http://cdn.ziyedy.top/image/DeepIM/%E7%BD%91%E7%BB%9C%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p>
<h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><p><strong>输入：</strong>观测图像、渲染图像以及对应的蒙板区域串联形成一个8通道（观测和渲染图像各自具有3通道，蒙板具有1通道）的张量</p>
<p><strong>主干网络</strong>同时本文使用预测图像间光流的FlowNetSimple架构作为支撑网络；位姿估计分支将由FlowNetSimple网络的11层卷积层得到的特征图作为输入，之后经过2个256维的全连接层，再分别由两个全连接层得到四元数表示的3D旋转和3D平移。</p>
<p>主干网络如下（关于光流法我也不清楚，算一个坑吧）</p>
<p><img src="http://cdn.ziyedy.top/image/DeepIM/FlowNetSimple1.png" alt=""></p>
<p><img src="http://cdn.ziyedy.top/image/DeepIM/FlowNetSimple2.png" alt=""></p>
<p><strong>网络采用的分支（仅用于训练）：</strong>在训练过程中，增加了两个辅助的分支来归一化网络的特征表示以提高训练的稳定性。一个分支训练后预测渲染图像和观测图像的光流，另一个分支预测观测图像的前景蒙板；</p>
<p><img src="http://cdn.ziyedy.top/image/DeepIM/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png" alt=""></p>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><p>以上三个分支分别对应一个损失函数，经过加权后共同构成了本文网络的损失函数，其中a=0.1，b=0.25，c=0.03<br>$$<br>L = aL_{pose} + bL_{flow} + cL_{mask}<br>$$</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>6dof</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础语法</title>
    <url>/page/java-basic-grammar.html</url>
    <content><![CDATA[<p>参考：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p>
<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>1、<strong>JVM</strong>：Java虚拟机，用于运行Java字节码，其针对不同的操作系统有着特定的实现，使得相同的字节码运行会给出相同的结果。</p>
<p>在Java中，JVM能够理解的代码就叫做<strong>字节码</strong>（.class文件）。其不面向任何特定的处理器，只面向虚拟机。</p>
<p>2、<strong>JDK（Java Development Kit）</strong>，即Java Development Kit，是功能齐全的Java软件开发包，拥有JRE所拥有的一切，有编译器（javac）和一些其他工具，能够创建和编译程序。</p>
<p>3、<strong>JRE（Java Runtime Environment）</strong>，即Java运行时环境。其为运行已编译Java程序所需要的所有内容的集合，包括Java虚拟机、Java类库、Java命令和其他一些基础的构建。但是，其不能用于创建新程序。</p>
<p><strong>编译与解释并存</strong>：Java程序要经过先编译、后解释两个步骤。（先经过编译生成字节码文件*.class，再经过解释进行执行）</p>
<h3 id="命令行编译"><a href="#命令行编译" class="headerlink" title="命令行编译"></a>命令行编译</h3><pre><code>javac Test.java
java Test</code></pre><p><code>javac</code>程序是一个Java编译器，将<code>*.java</code>编译成<code>*.class</code>（需要<code>.java</code>后缀）</p>
<p><code>java</code>程序启动Java虚拟机（只需要指定类名）</p>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java有8中基本数据类型，数字类型（byte&lt;1&gt;、short&lt;2&gt;、int&lt;4&gt;、long&lt;8&gt;、float&lt;4&gt;、double&lt;8&gt;）；字符类型（char&lt;2&gt;）；布尔型（boolean&lt;依赖于JVM的具体实现&gt;），其中&lt;&gt;内为其所对应的字节数，每个基本数据类型又有对应的默认值。</p>
<h3 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h3><p>参考：<a href="https://www.cnblogs.com/dolphin0520/p/3780005.html" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3780005.html</a></p>
<p>Java为每种基本数据类型都提供了对应的包装器类型，将基本数据类型转换成包装类称为<strong>装箱</strong>，反之则称为<strong>拆箱</strong>。</p>
<p>1、装箱：其中第一种方法不会触发自动装箱的机制，在执行效率和资源占用上，第二种方法通常要优于第一种情况。</p>
<pre><code>Integer i = new Integer(10);    // 手动装箱
Integer i = 10;    // 自动装箱</code></pre><p>拆箱（直接进行赋值语句即可）：</p>
<pre><code>int i2 = i;</code></pre><p><strong>装箱过程是通过调用包装器的valueOf方法实现的，而拆箱过程是通过调用包装器的 xxxValue方法实现的。（xxx代表对应的基本数据类型）。</strong></p>
<hr>
<p><strong>注意：</strong></p>
<p>如下代码的输出不同，原因在于valueOf的实现方法，<em>可以简单总结为若数值在[-128,127]之间，便返回IntegerCache.cache中已存在的对象的引用，否则创建一个新的Integer对象</em></p>
<pre><code>Integer i1 = 100;
Integer i2 = 100;

Integer i3 = 200;
Integer i4 = 200;

System.out.println(i1==i2);
System.out.println(i3==i4);

####################################
true
false</code></pre><p>同时，Integer、Short、Byte、Character、Long这几个类的valueOf方法的实现是类似的（<strong>这些方法实现了常量池技术</strong>），而Double、Float的valueOf方法的实现是类似的（<strong>这些方法没有使用常量池技术</strong>）。因此，上述代码若换成Double，会输出“false false”，换成Boolean会输出“true true”。</p>
<p>除此之外，还应该注意的是，如果这些包装类使用了算数运算符，那么“==”比较的将会是数值（即触发了自动拆箱），如下：</p>
<pre><code>Integer a = 1;
Integer b = 2;
Integer c = 3;
System.out.println(c==(a+b));

#########################################
true</code></pre><hr>
<p>对于包装器类型，equals方法并不会进行类型转换，如下：</p>
<pre><code>Integer a = 1;
Integer b = 2;

Long c = 3L;
Long d = 2L;

System.out.println(c==a+b);
System.out.println(c.equals(a+b));
System.out.println(c.equals(a+d));

###########################################
true
false
true</code></pre><h2 id="方法（函数）"><a href="#方法（函数）" class="headerlink" title="方法（函数）"></a>方法（函数）</h2><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p><strong>1、一个方法不能修改一个基本数据类型的参数</strong></p>
<p>示例：</p>
<pre><code>public static void main(String[] args) {
    int num1 = 10;
    int num2 = 20;

    swap(num1, num2);

    System.out.println(&quot;num1 = &quot; + num1);
    System.out.println(&quot;num2 = &quot; + num2);
}

public static void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;

    System.out.println(&quot;a = &quot; + a);
    System.out.println(&quot;b = &quot; + b);
}</code></pre><p>结果：</p>
<pre><code>a = 20
b = 10
num1 = 10
num2 = 20</code></pre><p>说明：</p>
<p>在 swap 方法中，a、b 的值进行交换，并不会影响到 num1、num2。因为，a、b 中的值，只是从 num1、num2 的复制过来的（<strong>值传递</strong>）。也就是说，a、b 相当于 num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>
<p><strong>2、一个方法可以改变一个对象参数的状态</strong></p>
<p>示例：</p>
<pre><code>public static void main(String[] args) {
    int[] arr = { 1, 2, 3, 4, 5 };
    System.out.println(arr[0]);
    change(arr);
    System.out.println(arr[0]);
}

public static void change(int[] array) {
    // 将数组的第一个元素变为0
    array[0] = 0;
}</code></pre><p>结果：</p>
<pre><code>1
0</code></pre><p>说明：</p>
<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的是同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上（类似于C++ 的引用传递）。</p>
<p><strong>3、一个方法不能让对象参数引用一个新的对象</strong></p>
<p>示例：</p>
<pre><code>public class Test {

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        Student s1 = new Student(&quot;小张&quot;);
        Student s2 = new Student(&quot;小李&quot;);
        Test.swap(s1, s2);
        System.out.println(&quot;s1:&quot; + s1.getName());
        System.out.println(&quot;s2:&quot; + s2.getName());
    }

    public static void swap(Student x, Student y) {
        Student temp = x;
        x = y;
        y = temp;
        System.out.println(&quot;x:&quot; + x.getName());
        System.out.println(&quot;y:&quot; + y.getName());
    }
}</code></pre><p>结果：</p>
<pre><code>x:小李
y:小张
s1:小张
s2:小李</code></pre><p>说明：</p>
<p>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap 方法的参数 x 和 y 被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</p>
<h4 id="深拷贝、浅拷贝"><a href="#深拷贝、浅拷贝" class="headerlink" title="深拷贝、浅拷贝"></a>深拷贝、浅拷贝</h4><p>1、<strong>浅拷贝</strong>：对基本数据类型进行值传递，对引用数据类型进行引用传递般的拷贝，此为浅拷贝。</p>
<p>2、<strong>深拷贝</strong>：对基本数据类型进行值传递，对引用数据类型，创建一个新的对象，并复制其内容，此为深拷贝。</p>
<p><img src="1%E3%80%81Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/java-deep-and-shallow-copy.jpg" alt=""></p>
<h3 id="方法重载（Overload）"><a href="#方法重载（Overload）" class="headerlink" title="方法重载（Overload）"></a>方法重载（Overload）</h3><p>同样的方法根据输入数据的不同，做出不同处理（同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理）。满足如下要求：</p>
<p>a、同一个类中</p>
<p>b、方法名相同，参数列表不同，方法返回值相同</p>
<p>c、访问修饰符。</p>
<h3 id="方法重写（Override）"><a href="#方法重写（Override）" class="headerlink" title="方法重写（Override）"></a>方法重写（Override）</h3><p>重写发生在<strong>运行期</strong>，是子类对父类的允许访问的方法的实现过程进行重新编写（重写就是<strong>子类对父类方法的重新改造</strong>，外部样子不能改变，内部逻辑可以改变）。满足以下条件：</p>
<p>1、发生有继承关系的子类中，且父类方法的<strong>访问修饰符为private/final/static则表示该方法不能重写</strong>，但是使用static修饰的方法能够被再次声明。同时构造方法不能被重写。</p>
<p>2、子类方法的<strong>访问权限必须大于等于</strong>父类方法；</p>
<p>3、子类方法的返回类型必须是父类方法返回类型或为其子类型。</p>
<p>4、子类方法抛出的异常类型必须是父类抛出异常类型或为其子类型。</p>
<pre><code>class SuperClass {
    protected List&lt;Integer&gt; func() throws Throwable {
        return new ArrayList&lt;&gt;();
    }
}

class SubClass extends SuperClass {
    @Override
    public ArrayList&lt;Integer&gt; func() throws Exception {
        return new ArrayList&lt;&gt;();
    }
}</code></pre><p>如上代码段，子类的访问权限public&gt;父类访问权限protected；子类返回值是父类接口的一个类实现（父类的子类型）；子类抛出的异常为父类抛出异常的子类。</p>
<p><em>注：使用 @Override 注解，可以让编译器帮忙检查是否满足上面的限制条件</em></p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="1、final"><a href="#1、final" class="headerlink" title="1、final"></a>1、final</h3><p><strong>a. 数据</strong></p>
<p>声明数据为常量，可以是编译时常量，也可以是在运行时被初始化后不能被改变的常量。</p>
<ul>
<li>对于基本类型，final 使数值不变；</li>
<li>对于引用类型，final 使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。</li>
</ul>
<p><strong>b. 方法</strong></p>
<p>声明方法不能被子类重写。</p>
<p>其中，<strong>private方法隐式的被指定为final</strong>。如果在子类中定义的方法和父类中的一个private方法相同，则视为子类中定义了一个新方法。</p>
<p><strong>c. 类</strong></p>
<p>声明类不能被继承</p>
<h3 id="4、static"><a href="#4、static" class="headerlink" title="4、static"></a>4、static</h3><p><strong>a. 静态变量</strong></p>
<p>又称为类变量，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。</p>
<pre><code>public class A() {
    private static int x;    // 静态变量
}</code></pre><p><strong>b. 静态方法</strong>（main方法就是）</p>
<p>静态方法在类加载的时候就存在了，它<strong>不依赖于任何实例</strong>。所以静态方法<strong>必须有实现</strong>，也就是说它不能是抽象方法。</p>
<p>同时，静态方法只能访问所属类的静态字段和静态方法。</p>
<p><strong>方法中不能有this和super关键字</strong>（这两个关键字与具体对象关联，而静态方法是不依赖于实例的）</p>
<p><strong>c.静态语句块</strong></p>
<p>静态语句块在<strong>类初始化</strong>时运行一次（注意不是实例化运行）</p>
<pre><code>public class test {
    static {
        System.out.println(&quot;gg&quot;);
    }

    public static void main(String[] args) {
    }
}
///////////////////////////////////////////
gg</code></pre><p><strong>4. 静态内部类</strong></p>
<p>非静态内部类依赖于外部类的实例，也就是说需要先创建外部类实例，才能用这个实例去创建非静态内部类。而静态内部类不需要。静态内部类不能访问外部类的非静态的变量和方法。</p>
<p>构造函数需要一个有参构造和一个无参构造</p>
<p>getter/setter</p>
<p>包：一个JAVA源文件中只能有一个package语句</p>
<p>命名方法：域名倒序+模块+功能</p>
<p>共有：public：任意位置</p>
<p>私有：private：本类中访问</p>
<p>保护：protected：当前类、同包子类/非子类、跨包子类（跨包子类不允许）</p>
<p>默认：当前类、同包子类（跨包子类不允许调用）</p>
<p>super：父类对象的引用</p>
<p>super.print() 访问父类成员方法</p>
<p>super.name 访问父类属性</p>
<p>super() 访问父类构造方法，必须位于子类构造方法的第一行</p>
<p>子类的构造过程必须调用其父类的构造方法，若子类构造方法中没有显式标注，则系统默认调用父类无参构造方法（若子类构造方法无显式标值且父类中没有无参构造方法，则编译出错）</p>
<p>多态：不同类的对象对同一消息做出不同响应</p>
<p>编译时多态：（方法重载）</p>
<p>运行时多态：程序运行时动态决定调用哪个方法</p>
<p>多态必要条件</p>
<p>1、满足继承关系</p>
<p>2、父类引用指向子类对象</p>
<p>向上转型，父类引用指向子类实例。可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法</p>
<p>Animal two = new Cat()</p>
<p>向下转型，子类引用指向父类实例，此处要求必须进行强转</p>
<p>instanceof 运算符，返回 true false</p>
<pre><code>if(obj instanceof Cat) {
    Cat temp = (Cat)obj
}</code></pre><pre><code>if() {
    return new Dog();
} else {
    return new Cat();
}</code></pre><p>abstract关键字</p>
<p>抽象类，无法进行实例化的类（可以通过向上转型指向子类实例 ）</p>
<p>抽象方法：子类必须进行实现（或者子类也设置为抽象类），在父类定义时不能有方法体</p>
<p>包含抽象方法的类是抽象类</p>
<p>抽象类中可以没有抽象方法</p>
<p>static/final/private不能与abstract共存</p>
<p>接口：命名通常以“I”打头</p>
<p>接口定义了某一批类所需要遵守的规范</p>
<p>接口不关心这些类的内部数据，也不关心类中方法的实现细节，只规定这些类中必须提供某些方法</p>
<p>接口访问修饰符：public 默认</p>
<p>接口中抽象方法可以不写abstract关键字</p>
<p>作为接口的实现类必须实现接口中定义的所有方法，否则需要将该类设置为抽象类</p>
<p>接口中可以包含常量，默认public static final</p>
<pre><code>public interface ITest {
    public void func();
}</code></pre><pre><code>public class A implements ITest {

    @java.lang.Override
    public void func() {

    }
}</code></pre><pre><code>INet net = new A();
</code></pre><p>default 关键字</p>
<pre><code>public interface ITest {
    // 默认方法
    default void func1() {

    }
    // 静态方法
    static void func2() {

    }
}

// 调用接口中的默认方法
ITest.super.func1();</code></pre><p>接口的继承，可以一对多</p>
<p>在Java中，可以将一个类定义在另一个类中或者一个方法中，这样的类称为内部类</p>
<p>1、成员内部类</p>
<p>获取内部类</p>
<pre><code>A.a1 me = new A().new a1();</code></pre><p>2、静态内部类</p>
<p>3、方法内部类</p>
<p>4、匿名内部类</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Fully Convolutional Networks for Semantic Segmentation</title>
    <url>/page/FCN-summary.html</url>
    <content><![CDATA[<h3 id="Fully-Convolutional-Networks-for-Semantic-Segmentation"><a href="#Fully-Convolutional-Networks-for-Semantic-Segmentation" class="headerlink" title="Fully Convolutional Networks for Semantic Segmentation"></a>Fully Convolutional Networks for Semantic Segmentation</h3><h3 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h3><p>建立全卷积神经网络，将经典的分类网络如AlexNet、VGG、GoogLeNet中网络结构最后的全连接层用上采样替换</p>
<p>pixelwise prediction</p>
<h3 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h3><ol>
<li><strong>全卷积化</strong></li>
</ol>
<ul>
<li>将经典CNN网络结构最后的全连接层替换为卷积层（即对最后一个特征图（feature）进行反卷积操作），使得输出图像与输入图像的尺寸完全一致。</li>
<li>经典CNN网络全连接层后对图像进行分类改为了对所有像素都进行softmax分类计算。可以理解为传统分类网络将一幅图像作为一个分类样本，而FCN则将图像中的每一个像素作为分类样本。这样其实就解决了图像语义分割的问题，即进行了密集预测（dense prediction）</li>
</ul>
<ol start="2">
<li>进行了对特征图的<strong>上采样</strong></li>
</ol>
<p>文中主要提出了三种上采样方法</p>
<ol>
<li>Shift-and-Stitch</li>
<li>decreasing subsampling</li>
<li>Deconvolution</li>
</ol>
<ol start="3">
<li>使用了<strong>跳跃结构</strong>（ skip architecture）</li>
</ol>
<blockquote>
<p>We address this by <strong>adding skips</strong> that combine the final prediction layer with lower layers with finer strides</p>
</blockquote>
<p>使用跳跃结构融合多层输出，使得网络能够预测更多的位置信息。因为在浅层网络位置信息等保留的比较好，将他们加入到深层输出中，就可以预测到更精细的信息。</p>
<p>本文的做法为将对应的两个位置的网络进行逐元素相加的处理。</p>
]]></content>
      <categories>
        <category>AI</category>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>语义分割</tag>
      </tags>
  </entry>
  <entry>
    <title>Normalized Object Coordinate Space for Category-Level 6D Object Pose and Size Estimation</title>
    <url>/page/nocs.html</url>
    <content><![CDATA[<blockquote>
<p>[CVPR 2019]Normalized Object Coordinate Space for Category-Level 6D Object Pose and Size Estimation</p>
<p>论文地址：<a href="https://arxiv.org/abs/1901.02970" target="_blank" rel="noopener">https://arxiv.org/abs/1901.02970</a></p>
<p>GitHub：<a href="https://github.com/hughw19/NOCS_CVPR2019" target="_blank" rel="noopener">https://github.com/hughw19/NOCS_CVPR2019</a></p>
</blockquote>
<h2 id="文章主要内容"><a href="#文章主要内容" class="headerlink" title="文章主要内容"></a>文章主要内容</h2><h3 id="问题提出"><a href="#问题提出" class="headerlink" title="问题提出"></a>问题提出</h3><p>现有的相关6dof姿态估计方法都是instance-level的（即有目标物体的CAD模型作为先验知识）</p>
<p>相关的三维目标检测方法能够得到目标物体的3D边界框，但缺乏精确方向</p>
<h3 id="category-level的6dof姿态估计"><a href="#category-level的6dof姿态估计" class="headerlink" title="category-level的6dof姿态估计"></a>category-level的6dof姿态估计</h3><p>作为严格意义上6dof的类别估计下的<em>第一篇文章</em>，本文对category-level的叙述非常简单易懂，需要解决的核心问题即为<strong>如何对同属一类的不同实例进行统一规范的表示（a shared canonical representation）</strong></p>
<p>面临的主要挑战</p>
<ol>
<li>在特定类别中为不同实例寻找一种能够<strong>统一表示</strong>其<em>6D信息和尺寸信息</em>的表示方法</li>
<li>现有的<strong>数据集</strong>很难作为训练和测试的基准（相关数据集缺乏相关注释，且很多不包含桌面级物体类别）</li>
</ol>
<h3 id="本文的主要贡献"><a href="#本文的主要贡献" class="headerlink" title="本文的主要贡献"></a>本文的主要贡献</h3><p>针对上面两个问题，本文分别提出了相应的解决方案，相应的算法流程如下</p>
<p><img src="http://cdn.ziyedy.top/NOCS/%E6%B5%81%E7%A8%8B.png" alt=""></p>
<h4 id="1、针对对同类物体的统一表示"><a href="#1、针对对同类物体的统一表示" class="headerlink" title="1、针对对同类物体的统一表示"></a>1、针对对同类物体的统一表示</h4><blockquote>
<p>本文提出了一种NOCS的共享空间关系（Normalized Object Coordinate Spac），用于建立物体像素点与NOCS中物体的信息的对应关系</p>
</blockquote>
<p>NOCS是一个三维空间中的单位立方体，对给定的类别将其规范化并“放置”于该立方体当中。</p>
<p><img src="http://cdn.ziyedy.top/NOCS/NOCS.png" alt=""></p>
<p>立方体中每个点存储的是一个3维的RGB信息，我个人认为这种思路与instance-level中的热力图的方法思路很相近，利用一种可视化的思路表示物体的朝向进而表示物体位姿（比如在NOCS中红色表示模型正前方，那么经过网络前向传播输出的NOCS图中红色最”浓“的地方就表示物体的正前方）</p>
<h4 id="2、针对缺乏数据集的问题"><a href="#2、针对缺乏数据集的问题" class="headerlink" title="2、针对缺乏数据集的问题"></a>2、针对缺乏数据集的问题</h4><blockquote>
<p>本文提出了一种CAMERA（Context-Aware MixEd ReAlity）的数据生成方法用于生成数据</p>
<p>模型来源于ShapeNet，同时创建时考虑了图像上下文（即在将模型2D投影嵌入背景前在Unity中使用灯光对其进行了渲染），并且加入了一些错误的类用以增加训练的鲁棒性</p>
</blockquote>
<h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><h3 id="网络结构"><a href="#网络结构" class="headerlink" title="网络结构"></a>网络结构</h3><blockquote>
<p>使用Mask R-CNN作为骨架网络，并且多了三条分支用于分别估计NOCS中的RGB</p>
</blockquote>
<p><img src="http://cdn.ziyedy.top/NOCS/%E7%BD%91%E7%BB%9C%E7%BB%93%E6%9E%84.png" alt=""></p>
<h3 id="训练trick"><a href="#训练trick" class="headerlink" title="训练trick"></a>训练trick</h3><ol>
<li>将回归NOCS变为了一个分类问题（经过文章的实验验证得出改为B=32的分类问题具有最佳的性能）</li>
<li>在训练中没有使用深度图（作者使用COCO数据集来提高网络鲁棒性，而COCO不包含深度图）</li>
</ol>
<h3 id="后序6D位姿与尺寸估计"><a href="#后序6D位姿与尺寸估计" class="headerlink" title="后序6D位姿与尺寸估计"></a>后序6D位姿与尺寸估计</h3><p>利用输出的NOCS图和深度图来进行被检测物体的6D姿态估计与尺寸大小检查。</p>
<p>首先将深度图与RGB图对齐，之后利用输出的Mask来获得物体的3D点云Pm，同时使用NOCS图获得预测位姿Pn。之后，<strong>估计将Pn转换为Pm的比例、旋转和平移</strong>。对于这个7维刚性变换估计问题，作者使用Umeyama算法，而对于离群点去除，作者使用RANSAC。</p>
<h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><h4 id="在合成数据上"><a href="#在合成数据上" class="headerlink" title="在合成数据上"></a>在合成数据上</h4><p>对于50%的3D IoU，mAP为83.9%，位姿使用(5cm，5°)度量，mAP为40.9%</p>
<h4 id="在真实数据集上"><a href="#在真实数据集上" class="headerlink" title="在真实数据集上"></a>在真实数据集上</h4><p>对于50%的3D IoU， mAP为76.4%，位姿使用(5cm，5°)，mAP为10.2%</p>
<h4 id="与PoseCNN进行比较"><a href="#与PoseCNN进行比较" class="headerlink" title="与PoseCNN进行比较"></a>与PoseCNN进行比较</h4><p>使用2D重投影误差，本文的方法误差的mAP为30.2%，PoseCNN为17.2%</p>
<h2 id="文章的不足与可改进之处"><a href="#文章的不足与可改进之处" class="headerlink" title="文章的不足与可改进之处"></a>文章的不足与可改进之处</h2><ol>
<li>显然，处理对称物体是6dof问题的一个难点，本文所提出的NOCS类别表示器并没有将<strong>物体的对称性</strong>考虑进去（只设计了处理对称物体的损失函数）</li>
<li>文章的输入数据是RGB-D数据，可以该进的地方在于仅使用较容易获取的RGB数据</li>
<li>文章中构建的NOCS表示方法仅仅利用了物体的朝向信息，而忽略了可能隐藏的刚体之间的几何等信息，处理类别个人认为应当使用网络对这些信息进行归纳与学习（新的问题）。</li>
</ol>
]]></content>
      <categories>
        <category>AI</category>
        <category>论文阅读</category>
      </categories>
      <tags>
        <tag>6dof</tag>
      </tags>
  </entry>
  <entry>
    <title>Java容器</title>
    <url>/page/java-collection.html</url>
    <content><![CDATA[<p>equal方法指内容是否相同</p>
<p>==指地址是否相同</p>
<p>String的对象一旦被创建，则不能修改，是不可变的（即使用substr等函数时其本身是不会变的）</p>
<p>当频繁操作字符串时，使用StringBuilder</p>
<p>常用方法</p>
<pre><code>StringBuilder str = new StringBuilder(&quot;hello&quot;);
str.append(&quot; world&quot;);    // 向后添加字符串
str.delete(0,5);    // 删除第0-4个字符
str.insert(4,&quot;gg&quot;);    // 在索引4向后插入gg
str.replace(4,6,&quot;aa&quot;);    // 在缩影4到5处替换为aa
</code></pre><h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>Collection：List，Queue，Set</p>
<p>List是元素有序并且可以重复的集合，称为序列</p>
<p>两个主要实现类：ArrayList，LinkedList</p>
<p>ArrayList底层由数组实现，动态增长，其中元素可以为null</p>
<pre><code>ArrayList list = new ArrayList();
list.add(1);    // 向后添加
list.size();    // 获取元素数量
list.get(1);    // 取出索引值为1的元素
list.remove(2);    // 移除索引为2的元素
</code></pre><p>Set</p>
<p>元素无序且不可以重复的集合。</p>
<p>HashSet是Set的一个重要元素，称为哈希集，其中元素无序且不可以重复，只允许一个null元素。</p>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>Iterator接口可以以统一的方式对各种集合元素进行遍历，调用各种集合元素的iterator()方法得到迭代器。</p>
<p>hasNext()方法检测集合中是否还有下一个元素</p>
<p>next()方法返回集合中的下一个元素</p>
<pre><code>Iterator it = set.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}</code></pre><p>hashCode()和equals()，用于判断是否相同，选哟进行重写  </p>
<p>Map。以键值对的形式存储</p>
<p>HashMap：基于哈希表的Map接口的实现，允许使用null值和null键，无序排列。</p>
<p>排序</p>
<pre><code>Collections.sort(list);</code></pre><p>使用Comparable或Comparator接口对自定义类进行排序</p>
<p>Comparator接口</p>
<p>强行对某个对象进行整体排序的比较函数</p>
<p>可以将Comparator传递给sort方法（Collections.sort()或Arrays.sort）</p>
<p>int compare()</p>
<p>Comparable接口</p>
<p>此接口强行对实现它的每个类的对象进行整体排序</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面向对象</title>
    <url>/page/java-orient-object.html</url>
    <content><![CDATA[<h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。同时，<strong>Java语言中的继承是单继承</strong>。</p>
<p>1、子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</p>
<p>2、子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</p>
<p>3、子类可以用自己的方式实现父类的方法（方法重写）。</p>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><h3 id="Object类的常见方法总结"><a href="#Object类的常见方法总结" class="headerlink" title="Object类的常见方法总结"></a>Object类的常见方法总结</h3><p><strong>Object类是所有类的父类</strong>，主要提供11个方法。</p>
<pre><code>// 用于返回当前运行时对象的Class对象。
public final native Class&lt;?&gt; getClass()

// 用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap
public native int hashCode()

// 用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等
public boolean equals(Object obj)

// 用于创建并返回当前对象的一份拷贝。
// 一般情况下，对于任何对象 x
// 表达式 x.clone() != x 为true
// x.clone().getClass() == x.getClass() 为true
// Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会产生异常。
protected native Object clone() throws CloneNotSupportedException

// 返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。
public String toString()

// 不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。
public final native void notify()

// 不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。
public final native void notifyAll()

// 不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。
public final native void wait(long timeout) throws InterruptedException

// 多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。
public final void wait(long timeout, int nanos) throws InterruptedException

// 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念
public final void wait() throws InterruptedException

// 实例被垃圾回收器回收的时候触发的操作
protected void finalize() throws Throwable
</code></pre><p>其中native方法即为调用非Java代码的接口，一个native方法是指该方法的实现由非Java语言实现。</p>
<h3 id="访问权限修饰符"><a href="#访问权限修饰符" class="headerlink" title="访问权限修饰符"></a>访问权限修饰符</h3><p>Java 中有三个访问权限修饰符：private、protected 以及 public，如果不加访问修饰符，表示包级可见。<strong>所以Java的访问权限应该有四个</strong></p>
<p>主要参考：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java异常</title>
    <url>/page/Java-exception.html</url>
    <content><![CDATA[<h3 id="异常层次结构"><a href="#异常层次结构" class="headerlink" title="异常层次结构"></a>异常层次结构</h3><img src="5、Java异常/exception-chart.png" style="zoom:67%;" />

<p> java.lang 包中的<strong>Throwable类</strong>是所有异常的根类。它有两个重要的子类</p>
<p>1、<strong>Error。程序无法处理的错误</strong>。表示运行程序中较为严重的错误，通常是代码运行时JVM出现的问题</p>
<p>2、<strong>Exception。程序本身可以处理的异常</strong>。</p>
<h3 id="Throwable常用方法"><a href="#Throwable常用方法" class="headerlink" title="Throwable常用方法"></a>Throwable常用方法</h3><pre><code>public string getMessage():返回异常发生时的简要描述

public string toString():返回异常发生时的详细信息

public void printStackTrace():在控制台上打印 Throwable 对象封装的异常信息</code></pre><h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><h4 id="try"><a href="#try" class="headerlink" title="try"></a>try</h4><p>用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</p>
<pre><code>try {

} catch(Exception e) {
    e.printStackTrace();
} finally {

}</code></pre><h4 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h4><p>用于处理 try 捕获到的异常。</p>
<h4 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h4><p>无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</p>
<h4 id="throw与throws"><a href="#throw与throws" class="headerlink" title="throw与throws"></a>throw与throws</h4><p>throws声明方法将要抛出何种异常的声明，通过throw将产生的异常抛出</p>
<p>若一个方法可能出现异常，但没有能力处理异常，可以在方法声明处用throws子句来声明抛出异常</p>
<pre><code>public void method() throws Exception1, Exception2 {
    //可能产生异常的代码
}</code></pre><p>本文参考：</p>
<p><a href="https://gitee.com/SnailClimb/JavaGuide/blob/master/docs/java/Java基础知识.md#14-%E6%96%B9%E6%B3%95%E5%87%BD%E6%95%B0" target="_blank" rel="noopener">异常处理参考</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java接口与抽象类</title>
    <url>/page/java-interface.html</url>
    <content><![CDATA[<h3 id="接口与抽象类的区别"><a href="#接口与抽象类的区别" class="headerlink" title="接口与抽象类的区别"></a>接口与抽象类的区别</h3><p>1、 </p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
  </entry>
  <entry>
    <title>Java中的输入输出流</title>
    <url>/page/java-input-output.html</url>
    <content><![CDATA[<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>Java 的 I/O 大概可以分成以下几类：</p>
<ul>
<li>磁盘操作：File</li>
<li>字节操作：InputStream 和 OutputStream</li>
<li>字符操作：Reader 和 Writer</li>
<li>对象操作：Serializable</li>
<li>网络操作：Socket</li>
<li>新的输入/输出：NIO</li>
</ul>
<h3 id="字节操作"><a href="#字节操作" class="headerlink" title="字节操作"></a>字节操作</h3><p>从文件系统中的某个文件中获得输入字节</p>
<p>用于读取如图像数据之类的原始字节流</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>public int read()</td>
<td>从输入流中读取一个数据字节</td>
</tr>
<tr>
<td>public int read(byte[] b)</td>
<td>从输入流中将最多b.length个字节的数据据读入一个byte数组</td>
</tr>
<tr>
<td>public void close()</td>
<td>关闭此文件输入流并释放与此流有关的所有系统资源</td>
</tr>
</tbody></table>
<p>n表示长度</p>
<h3 id="输入字节流：InputStream"><a href="#输入字节流：InputStream" class="headerlink" title="输入字节流：InputStream"></a>输入字节流：InputStream</h3><blockquote>
<p><code>InputStream</code>是一个抽象类，是所有输入流的超类，最重要的方法为<code>int read()</code>方法，返回字节的int值，返回<code>-1</code>表示无法继续读取。</p>
<p>常用的子类有<code>FileInputStream</code>，从文件流中读取数据。</p>
</blockquote>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code>public static void main(String[] args) throws IOException {
    InputStream input = new FileInputStream(&quot;aa.txt&quot;);
    while (true) {
        int n = input.read();
        if(n == -1)
            break;
        System.out.println(n);
    }
    input.close();    // 最后需要关闭
}</code></pre><h4 id="常用写法"><a href="#常用写法" class="headerlink" title="常用写法"></a>常用写法</h4><blockquote>
<p>使用<code>try(resource)</code>语法，让编译器自动关闭资源</p>
<p>编译器只看<code>try(resource = ...)</code>中的对象是否实现了<code>java.lang.AutoCloseable</code>接口，如果实现了，就自动加上<code>finally</code>语句并调用<code>close()</code>方法。</p>
</blockquote>
<pre><code>try (InputStream input = new FileInputStream(&quot;src/readme.txt&quot;)) {
    int n;
    while ((n = input.read()) != -1) {
        System.out.println(n);
    }
}</code></pre><h3 id="输出字节流：OutputStream"><a href="#输出字节流：OutputStream" class="headerlink" title="输出字节流：OutputStream"></a>输出字节流：OutputStream</h3><h3 id="缓冲输入流：BufferedInputStream"><a href="#缓冲输入流：BufferedInputStream" class="headerlink" title="缓冲输入流：BufferedInputStream"></a>缓冲输入流：BufferedInputStream</h3><h3 id="缓冲输出流：BufferedOutputStream"><a href="#缓冲输出流：BufferedOutputStream" class="headerlink" title="缓冲输出流：BufferedOutputStream"></a>缓冲输出流：BufferedOutputStream</h3><p>缓冲区满了自动写入，不满不写入，则需要调用<code>flush()</code>方法</p>
<pre><code>BufferedOutputStream(OutputStream out)

// 创建size大小的buffer
BufferedOutputStream(OutputStream out, int size)</code></pre><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>void flush()</td>
<td>清空缓冲区</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="字符输入流：Reader"><a href="#字符输入流：Reader" class="headerlink" title="字符输入流：Reader"></a>字符输入流：Reader</h3><p>字节字符转换流</p>
<p>InputStreamReader</p>
<pre><code>InputStreamReader(InputSteam in)</code></pre><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://zhuanlan.zhihu.com/p/25418336" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/25418336</a></p>
<p><a href="https://www.liaoxuefeng.com/" target="_blank" rel="noopener">https://www.liaoxuefeng.com/</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java泛型</title>
    <url>/page/Java-generic.html</url>
    <content><![CDATA[<h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
<p>Java的泛型是<strong>伪泛型</strong>，这是因为Java在编译期间，所有的泛型信息都会被擦掉</p>
<p>Java的泛型基本上都是在编译器这个层次上实现的，在生成的字节码中是不包含泛型中的类型信息的，使用泛型的时候加上类型参数，在编译器编译的时候会去掉，这个过程成为<strong>类型擦除</strong>。</p>
<p>如在代码中定义<code>List&lt;Object&gt;</code>和<code>List&lt;String&gt;</code>等类型，在编译后都会变成<code>List</code>，JVM看到的只是List，而由泛型附加的类型信息对JVM是看不到的。Java编译器会在编译时尽可能的发现可能出错的地方，但是仍然无法在运行时刻出现的类型转换异常的情况，类型擦除也是Java的泛型与C++模板机制实现方式之间的重要区别。</p>
<h4 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h4><p>注：变量声明的类型必须匹配传递给实际对象的类型（即前后尖括号中的内容必须相同）</p>
<p><strong>1、泛型类</strong></p>
<pre><code>//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
//在实例化泛型类时，必须指定T的具体类型
public class Generic&lt;T&gt;{ 

    private T key;

    public Generic(T key) { 
        this.key = key;
    }

    public T getKey(){ 
        return key;
    }
}</code></pre><p><strong>2、泛型接口</strong></p>
<pre><code>public interface Generator&lt;T&gt; {
    public T method();
}</code></pre><p>实现泛型接口时不指定类型</p>
<pre><code>class GeneratorImpl&lt;T&gt; implements Generator&lt;T&gt;{
    @Override
    public T method() {
        return null;
    }
}</code></pre><p>实现泛型接口时指定类型</p>
<pre><code class="\">class GeneratorImpl&lt;T&gt; implements Generator&lt;String&gt;{
    @Override
    public String method() {
        return &quot;hello&quot;;
    }
}</code></pre>
<p><strong>3、泛型方法</strong></p>
<p>注：泛型方法不一定要写在泛型类当中</p>
<pre><code>public static &lt;E&gt; void printArray( E[] inputArray )
{         
    for ( E element : inputArray ){        
        System.out.printf( &quot;%s &quot;, element );
    }
        System.out.println();
}</code></pre><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p><strong>常用的通配符为： T，E，K，V，？</strong></p>
<p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。<strong>通常情况下，T，E，K，V，？ 是这样约定的：</strong></p>
<ul>
<li>？ 表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个java类型</li>
<li>K V (key value) 分别代表java键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>
<p><strong>上界通配符 &lt;? extends 类名&gt; **：表示参数化的类型可能是所指定的类型，或者是此类型的</strong>子类**。</p>
<p><strong>下界通配符 &lt; ? super 类名&gt;</strong>：表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p>
<p>参考：</p>
<p>类型擦除：<a href="https://www.cnblogs.com/wuqinglong/p/9456193.html" target="_blank" rel="noopener">https://www.cnblogs.com/wuqinglong/p/9456193.html</a></p>
<p><a href="https://juejin.im/post/5d5789d26fb9a06ad0056bd9" target="_blank" rel="noopener">https://juejin.im/post/5d5789d26fb9a06ad0056bd9</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java多线程</title>
    <url>/page/java4.html</url>
    <content><![CDATA[<h3 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h3><p>1、创建一个Thread类，或者一个Thread子类的对象</p>
<p>2、创建一个实现Runnable接口的类的对象（解决Java只能单继承的限制，同时可以避免重写Thread类中的其他方法）</p>
<pre><code>class Test implements Runnable {
    @Override
    public void run() {
        // 添加你的代码
    }
}</code></pre><p>之后在主函数中输入</p>
<pre><code>Test t = new Test();
Thread t1 = new Thread(pr);    // 将创建好的通过参数传入Thread
t1.start();</code></pre><p>Thread类的常用方法</p>
<pre><code># 线程相关的代码写入该方法，一般需要重写
public void run()

# 启动线程
public void start()

# 线程休眠m毫秒的方法
public static void sleep(long m)

# 优先执行调用join()方法的线程
public void join()
# 等待该线程终止的最长时间为millis毫秒
public final void join(long millis)</code></pre><p>Runnable接口</p>
<p>Runnable是Java中用以实现线程的接口，只有一个方法run()</p>
<p>任何实现线程功能的类都必须实现该接口</p>
<h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>Java为线程类提供了10个优先级，优先级可以用整数1-10表示，超过范围会抛出异常，主线程默认优先级为5</p>
<p>优先级常量</p>
<pre><code>MAX_PRIORITY：线程的最高优先级10
MIN_PRIORITY：线程的最低优先级1
NORM_PRIORITY：线程的默认优先级5</code></pre><p>优先级相关方法：</p>
<pre><code class=";">// 获取线程优先级
public int getPriority()

// 设置线程优先级
public void setPriority(int newPriority)

// 获取主线程优先级
int mainpriority = Thread.currentThread().getPriority()</code></pre>
<h3 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h3><p>各线程通过竞争CPU时间而获得运行机会，各线程什么时候得到CPU时间，占用多久，是不可预测的，一个正在运行着的线程在什么地方被暂停是不确定的</p>
<p>synchronized</p>
<p>成员方法，静态方法、语句块</p>
<pre><code>public synchronized void func() {}
public static synchronized void func() {}
synchronized(obj) {}</code></pre><p>线程间通信</p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java字符串</title>
    <url>/page/Java-string.html</url>
    <content><![CDATA[<h3 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h3><h4 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h4><p>String被声明为final，因此不可被继承。在<strong>Java8</strong>中，String内部使用char数组存储数据。</p>
<pre><code>public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    /** The value is used for character storage. */
    private final char value[];
}</code></pre><p>在<strong>Java9</strong>之后，String类的实现改用byte数组存储字符串，同时使用coder来标识使用哪种编码。</p>
<pre><code>public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence {
    /** The value is used for character storage. */
    private final byte[] value;

    /** The identifier of the encoding used to encode the bytes in {@code value}. */
    private final byte coder;
}</code></pre><h4 id="不可变特性"><a href="#不可变特性" class="headerlink" title="不可变特性"></a>不可变特性</h4><p>上述中<em>value</em>使用了final关键字修饰，这说明value数组初始化后就不能再引用其他数组，因此String是不可变的。</p>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><pre><code>// 获取字符串长度
int length()

// 获取从begin到end的字符串
String substring(int beginIndex, int endIndex)

// 获取指定位置的字符
char charAt(int index)

// 将字符串分割为子字符串
String[] split(String regex, int limit)    

// 将该字符串转换为byte数组
byte[] getBytes()    </code></pre><h3 id="StringBuild类"><a href="#StringBuild类" class="headerlink" title="StringBuild类"></a>StringBuild类</h3><p>String具有不可变性（变化都是通过赋值完成的，类内方法不能使当前对象中的字符串进行改变），而StringBuild不具备</p>
<p>当频繁操作字符串时，应该使用StringBuild</p>
<pre><code>// 追加内容到当前StringBuild对象的末尾
StringBuild append(字符串)    

// 将内容插入到指定的位置
StringBuild insert(位置， 字符串)

// 将之转化为String对象
String toString()

// 删除start到end的字符串。[start, end)
String delete(start, end)

// 将start到end之间的字符串替换为str
String replace(start, end, str)

// 获取字符串长度
int length()</code></pre>]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java算法题的常用语法</title>
    <url>/page/java-for-algorithm-test.html</url>
    <content><![CDATA[<h2 id="控制台输入与输出"><a href="#控制台输入与输出" class="headerlink" title="控制台输入与输出"></a>控制台输入与输出</h2><h3 id="控制台输入"><a href="#控制台输入" class="headerlink" title="控制台输入"></a>控制台输入</h3><pre><code class="java">Scanner sc = new Scanner(System.in);</code></pre>
<h4 id="输入一整行数据"><a href="#输入一整行数据" class="headerlink" title="输入一整行数据"></a>输入一整行数据</h4><p>以换行为终止，返回一个String类型变量.</p>
<pre><code>String s = sc.nextLine();</code></pre><h4 id="输入单个数据（方法名为next后面跟基本数据类型名）"><a href="#输入单个数据（方法名为next后面跟基本数据类型名）" class="headerlink" title="输入单个数据（方法名为next后面跟基本数据类型名）"></a>输入单个数据（方法名为next后面跟基本数据类型名）</h4><p>如下为输入一个整型</p>
<pre><code>int a = sc.nextInt();</code></pre><h4 id="输入一个字符串"><a href="#输入一个字符串" class="headerlink" title="输入一个字符串"></a>输入一个字符串</h4><pre><code>String str = sc.next();</code></pre><h3 id="控制台输出"><a href="#控制台输出" class="headerlink" title="控制台输出"></a>控制台输出</h3><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><p>输出内容：<code>System.out.print(&quot;&quot;);</code></p>
<p>输出内容并换行：<code>System.out.println(&quot;&quot;);</code></p>
<p>格式化输出1： <code>System.out.format(String format, Object ... args);</code></p>
<p>格式化输出2：<code>System.out.printf((String format, Object ... args);</code></p>
<h4 id="格式化输出常用转换符"><a href="#格式化输出常用转换符" class="headerlink" title="格式化输出常用转换符"></a>格式化输出常用转换符</h4><table>
<thead>
<tr>
<th>转 换 符</th>
<th>说  明</th>
</tr>
</thead>
<tbody><tr>
<td>%s</td>
<td>字符串类型</td>
</tr>
<tr>
<td>%c</td>
<td>字符类型</td>
</tr>
<tr>
<td>%d</td>
<td>整数类型（十进制）</td>
</tr>
<tr>
<td>%f</td>
<td>浮点类型</td>
</tr>
<tr>
<td>%n 或 \n</td>
<td>换行符</td>
</tr>
</tbody></table>
<h4 id="搭配转换符的常用标志"><a href="#搭配转换符的常用标志" class="headerlink" title="搭配转换符的常用标志"></a>搭配转换符的常用标志</h4><table>
<thead>
<tr>
<th>标  志</th>
<th>说  明</th>
<th>示  例</th>
<th>结  果</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>为正数或者负数添加符号</td>
<td>(“%+d %+d”, -10, 10)</td>
<td>-10 +10</td>
</tr>
<tr>
<td>0</td>
<td>数字前面补0</td>
<td>(“%05d”, 10)</td>
<td>00010</td>
</tr>
</tbody></table>
<h4 id="常用示例"><a href="#常用示例" class="headerlink" title="常用示例"></a>常用示例</h4><pre><code>// 输出带有五位小数的浮点型
System.out.printf(&quot;%.5f&quot;, 99.89);    // 99.89000
// 输出在前面补齐5位数
System.out.printf(&quot;%05d&quot;, 99);    // 00099</code></pre><h2 id="基本容器的使用"><a href="#基本容器的使用" class="headerlink" title="基本容器的使用"></a>基本容器的使用</h2><h3 id="常用容器的基本使用"><a href="#常用容器的基本使用" class="headerlink" title="常用容器的基本使用"></a>常用容器的基本使用</h3><p><img src="http://cdn.ziyedy.top/image/Java%E7%AE%97%E6%B3%95%E9%A2%98%E7%9A%84%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/Collection.png" alt=""></p>
<h2 id="容器的基本操作"><a href="#容器的基本操作" class="headerlink" title="容器的基本操作"></a>容器的基本操作</h2><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><h4 id="Arrays-sort-——排序"><a href="#Arrays-sort-——排序" class="headerlink" title="Arrays.sort()——排序"></a>Arrays.sort()——排序</h4><p>对所有数组元素进行排序（默认正序）</p>
<pre><code class="java">int[] a = new int[]{-2,-3,2,1,9};
Arrays.sort(a);    // 默认升序： -3 -2 1 2 9
</code></pre>
<p>使用<strong>lamda表达式</strong>更改排序方式，以倒序为例，此时需要注意<strong>声明数组必须使用其包装类</strong>，否则会报错</p>
<pre><code class="java">Integer[] a = new Integer[]{-2,-3,2,1,9};
Arrays.sort(a, (a1, a2)-&gt;a2-a1);    // 倒序：9 2 1 -2 -3</code></pre>
<p>对指定索引范围内元素进行排序</p>
<pre><code>int[] b = new int[]{-2,-3,2,1,9};
// 对[0, 2)范围内数组元素进行排序
// 之后也可更改排序方式
Arrays.sort(b, 0, 2);    // -3 -2 2 1 9</code></pre><h4 id="Arrays-fill-——填充"><a href="#Arrays-fill-——填充" class="headerlink" title="Arrays.fill()——填充"></a>Arrays.fill()——填充</h4><p>为数组元素填充相同值</p>
<pre><code>int[] a = new int[]{-2,-3,2,1,9};
Arrays.fill(a, 10);    // 10 10 10 10 10</code></pre><p>为指定索引范围内数组填充相同值</p>
<pre><code>int[] a = new int[]{-2,-3,2,1,9};
// 在索引[1, 3)范围内填充5
Arrays.fill(a, 1, 3, 5);    // -2 5 5 1 9</code></pre><h4 id="Arrays-equals-——判断两个数组各元素是否都相等"><a href="#Arrays-equals-——判断两个数组各元素是否都相等" class="headerlink" title="Arrays.equals()——判断两个数组各元素是否都相等"></a>Arrays.equals()——判断两个数组各元素是否都相等</h4><pre><code class="java">int[] a = new int[]{-2,-3,2,1,9};
int[] b = new int[]{-2,-3,2,1,9};
System.out.println(Arrays.equals(a, b));    // true</code></pre>
<h4 id="Arrays-binarySerch-——二分查找定位元素下标"><a href="#Arrays-binarySerch-——二分查找定位元素下标" class="headerlink" title="Arrays.binarySerch()——二分查找定位元素下标"></a>Arrays.binarySerch()——二分查找定位元素下标</h4><p>注意：数组一定要是<strong>排好序的</strong>，否则会出错，若没有搜索到返回一个负值</p>
<pre><code>int[] a = new int[]{-3,-2,2,3,9};
System.out.println(Arrays.binarySearch(a, 2));    // 2</code></pre><h4 id="Arrays-copyOfRange-——截取数组"><a href="#Arrays-copyOfRange-——截取数组" class="headerlink" title="Arrays.copyOfRange()——截取数组"></a>Arrays.copyOfRange()——截取数组</h4><pre><code>int[] a = new int[]{-2,-3,2,1,9};
// 截取[1, 3)的数组
int[] b = Arrays.copyOfRange(a,1,3);
for (int m : b) System.out.print(m + &quot; &quot;);    // -3 2</code></pre><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>示例列表如下：</p>
<pre><code>ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();
list.add(2);
list.add(-2);
list.add(5);
list.add(99);
list.add(-10);
for (int v : list) System.out.print(v + &quot; &quot;);    // 2 -2 5 99 -10</code></pre><h4 id="void-reverse-List-list-：反转"><a href="#void-reverse-List-list-：反转" class="headerlink" title="void reverse(List list)：反转"></a>void reverse(List list)：反转</h4><pre><code>// 反转整个列表
Collections.reverse(list);    // -10 99 5 -2 2

// 反转[1, 3)的列表
Collections.reverse(list.subList(1, 3));    // 2 5 -2 99 -10</code></pre><h4 id="void-sort-List-list-：排序"><a href="#void-sort-List-list-：排序" class="headerlink" title="void sort(List list)：排序"></a>void sort(List list)：排序</h4><pre><code>// 自然升序
Collections.sort(list);    // -10 -2 2 5 99

// 自定义排序方法（此处为降序）
Collections.sort(list, (a, b)-&gt;b-a);    // 99 5 2 -2 -10</code></pre><h4 id="void-swap-List-list-int-i-int-j-：交换两个索引位置的元素"><a href="#void-swap-List-list-int-i-int-j-：交换两个索引位置的元素" class="headerlink" title="void swap(List list, int i , int j)：交换两个索引位置的元素"></a>void swap(List list, int i , int j)：交换两个索引位置的元素</h4><pre><code>// 交换索引为0 和 4的元素
Collections.swap(list, 0, 4);    // -10 -2 5 99 2</code></pre>]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java父类引用指向子类对象（向上转型）</title>
    <url>/page/java_polymorphic.html</url>
    <content><![CDATA[<p>参考：<a href="https://www.cnblogs.com/ChrisMurphy/p/5054256.html" target="_blank" rel="noopener">https://www.cnblogs.com/ChrisMurphy/p/5054256.html</a></p>
<p>父类的引用指向子类的对象是Java中多态的重要表现形式</p>
<h4 id="表现形式"><a href="#表现形式" class="headerlink" title="表现形式"></a>表现形式</h4><p>父类为Animal，子类为Cat，如下即为父类引用指向子类对象的形式，<strong>声明的是父类，实际指向的是子类的一个对象</strong>。（其中Animal可以是类也可以是接口，Cat是继承或实现Animal的子类）</p>
<pre><code>Animal animal = new Cat()</code></pre><p>这种情况也即为<strong>向上转型</strong>，父类引用指向子类实例。<strong>可以调用子类重现父类的方法以及父类派生的方法，无法调用子类独有的方法</strong>。</p>
<h4 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h4><p>子类是对父类的一个改进和扩充，所以一般子类在功能上较父类更强大，属性较父类更独特， 定义一个父类类型的引用指向一个子类的对象既可以<strong>使用子类强大的功能</strong>，又可以<strong>抽取父类的共性</strong>。 所以，父类类型的引用可以调用父类中定义的所有属性和方法，而对于子类中定义而父类中没有的方法，父类引用是无法调用的</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>父类</p>
<pre><code>public class Father {
    // 父类中的func1方法
    // 由于子类中对该方法只是进行了重载而没有进行重写
    // 因此该方法仍然有效
    public void func1() {
        System.out.println(&quot;Father func1&quot;);
    }

    // 父类中的func2方法
    // 由于在子类中重写了该方法
    // 所以在“向上转型”中，该方法不再有效
    // 取而代之的是子类中的fun2方法
    public void func2() {
        System.out.println(&quot;Father func2&quot;);
    }
}</code></pre><p>子类</p>
<pre><code>public class Child extends Father {
    // 对func1方法的一个重载
    // 由于在父类中没有定义该方法，所以该方法不能被父类的引用调用
    // 如果进行调用即会报错
    public void func1(int i) {
        System.out.println(&quot;Child func1&quot;);
    }

    // 对父类方法的重写
    // 能够起作用
    public void func2() {
        System.out.println(&quot;Child func2&quot;);
    }
}</code></pre><p>主函数</p>
<pre><code>public class Main {
    public static void main(String[] args) {
    // write your code here
        Father test = new Child();
        test.func1();   // Father func1
        test.func2();   // Child func2
        test.func1(10); // 报错
    }
}</code></pre><p>上述示例中，子类Child继承了父类Father，并重载了父类的func1()方法，重写了父类的func2()方法。重载后的func1(int i)和func1()不再是同一个方法，由于父类中没有func1(int i)，那么，父类类型的引用child就不能调用func1(int i)方法。而子类重写了func2()方法，那么父类类型的引用child在调用该方法时将会调用子类中重写的func2()。 </p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、<strong>使用父类类型的引用指向子类的对象；</strong> </p>
<p>2、<strong>该引用只能调用父类中定义的方法和变量；</strong> </p>
<p>3、<strong>如果子类中重写了父类中的一个方法，那么在调用这个方法的时候，将会调用子类中的这个方法；（动态连接、动态调用）</strong> </p>
<p>4、<strong>变量不能被重写（覆盖），”重写“的概念只针对方法，如果在子类中”重写“了父类中的变量，那么在编译时会报错。</strong></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>信号与槽</title>
    <url>/page/pyqt5-signals-and-slots.html</url>
    <content><![CDATA[<h2 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a>信号与槽</h2><p>创建事件循环后，通过建立信号与槽的连接就可以实现对象之间的通信（<strong>信号发射时，连接的槽函数会自动执行</strong>）</p>
<p>QObject.signal.connect()</p>
]]></content>
  </entry>
  <entry>
    <title>Anaconda+PyCharm配置PyQt5全过程</title>
    <url>/page/pyqt5-env-ide-build.html</url>
    <content><![CDATA[<p>前段时间写了一个手写电话号码识别的小程序，GUI用的是Python自带的Tkinter，但这种GUI太简陋可视化效果不佳，因此打算使用别的更加强大的GUI重构一下，目光就瞄准了pyqt，因为用C++时接触过，知道这是个好用的GUI吧。</p>
<h2 id="Anaconda下安装"><a href="#Anaconda下安装" class="headerlink" title="Anaconda下安装"></a>Anaconda下安装</h2><p>在Anaconda在GitHub上的issue下知道由于兼容Python2的原因没法用conda安装最新版PyQt5包，所以得使用pip命令进行安装。</p>
<p>在Anaconda自带的prompt下输入以下命令即可完成安装。</p>
<pre><code>pip3 install PyQt5</code></pre><p>但速度通常很慢，因此建议改为清华的镜像进行安装。</p>
<pre><code>pip install -i https://pypi.tuna.tsinghua.edu.cn/simple PyQt5</code></pre><p>之后在命令行窗口输入<code>import PyQt5</code>，不报错，说明安装成功。</p>
<h2 id="Pycharm下配置相关环境"><a href="#Pycharm下配置相关环境" class="headerlink" title="Pycharm下配置相关环境"></a>Pycharm下配置相关环境</h2><p>用过Qt的应该都知道Qt有QtDesigner这种优秀的可视化设计工具，可以简化编码，所以如果使用PyCharm作为IDE编写Python的话需要将QtDesigner作为拓展程序进行配置（这样可以在IDE中直接进行调用了，会很方便）。除此之外，还需要配置将QtDesigner生成的.ui文件转化为.py文件。</p>
<h3 id="配置QtDesigner"><a href="#配置QtDesigner" class="headerlink" title="配置QtDesigner"></a>配置QtDesigner</h3><p>在PyCharm中的<code>File-&gt;Settings</code>下，进行如下操作，即可配置完成QDesigner。</p>
<p><img src="http://cdn.ziyedy.top/image/Python/GUI/Anaconda%2BPyCharm%E9%85%8D%E7%BD%AEPyQt5%E5%85%A8%E8%BF%87%E7%A8%8B/1.png" alt=""></p>
<h3 id="配置PyUIC"><a href="#配置PyUIC" class="headerlink" title="配置PyUIC"></a>配置PyUIC</h3><p>使用QDesigner生成的文件格式为.ui的格式，要将其转化为.py格式安装的pyqt包中也已经写好的相应的程序。在上图中的相同界面中输入以下信息。</p>
<p><img src="http://cdn.ziyedy.top/image/Python/GUI/Anaconda%2BPyCharm%E9%85%8D%E7%BD%AEPyQt5%E5%85%A8%E8%BF%87%E7%A8%8B/2.png" alt=""></p>
<p>program中输入pyuic5.exe的路径。</p>
<p>在参数栏中输入如下命令：(该命令就是将.ui转化为.py文件)</p>
<pre><code>$FileName$ -o $FileNameWithoutExtension$.py</code></pre><p>该步骤中也有直接输入pyuic.py文件的，但我试验了以下没有成功，所以使用.exe文件还是最靠谱的（Windows下）。</p>
<h2 id="使用实验"><a href="#使用实验" class="headerlink" title="使用实验"></a>使用实验</h2><p>在菜单栏“工具”中找到拓展工具，选择QDesigner即可。</p>
<p><img src="http://cdn.ziyedy.top/image/Python/GUI/Anaconda%2BPyCharm%E9%85%8D%E7%BD%AEPyQt5%E5%85%A8%E8%BF%87%E7%A8%8B/3.png" alt=""></p>
<p>打开设计工具之后，即可创建相应的ui界面如下：</p>
<p><img src="http://cdn.ziyedy.top/image/Python/GUI/Anaconda%2BPyCharm%E9%85%8D%E7%BD%AEPyQt5%E5%85%A8%E8%BF%87%E7%A8%8B/4.png" alt=""></p>
<p>这时候可以看到PyCharm界面中多了一个.ui文件，在该文件上右击，选择拓展工具中的PyUIC即可完成.ui到.py的转换。</p>
<p><img src="http://cdn.ziyedy.top/image/Python/GUI/Anaconda%2BPyCharm%E9%85%8D%E7%BD%AEPyQt5%E5%85%A8%E8%BF%87%E7%A8%8B/5.png" alt=""></p>
<p>此时可以发现多了一个同名的.py文件，打开文件里面包含的就是之前设计好的界面的python代码了，加入以下主函数运行：</p>
<pre><code>import sys
from PyQt5.QtWidgets import QApplication, QMainWindow
if __name__ == &#39;__main__&#39;:
    app = QApplication(sys.argv)
    MainWindow = QMainWindow()
    ui = Ui_MainWindow()
    ui.setupUi(MainWindow)
    MainWindow.show()
    sys.exit(app.exec_())</code></pre><p>即可得到如下结果：</p>
<p><img src="http://cdn.ziyedy.top/image/Python/GUI/Anaconda%2BPyCharm%E9%85%8D%E7%BD%AEPyQt5%E5%85%A8%E8%BF%87%E7%A8%8B/6.png" alt=""></p>
<p>OK，那使用PyQt5构建python的GUI程序的流程总算整通了。</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="https://www.jianshu.com/p/094928ac0b73" target="_blank" rel="noopener">https://www.jianshu.com/p/094928ac0b73</a></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>PyQt5</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>GUI</tag>
      </tags>
  </entry>
  <entry>
    <title>PyQt5基本组件</title>
    <url>/page/pyqt5-basic-widget.html</url>
    <content><![CDATA[<h3 id="构建一般程序"><a href="#构建一般程序" class="headerlink" title="构建一般程序"></a>构建一般程序</h3><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><pre><code>import sys
from PyQt5.QtWidgets import QApplication, QWidget</code></pre><h4 id="创建一个QApplication对象"><a href="#创建一个QApplication对象" class="headerlink" title="创建一个QApplication对象"></a>创建一个QApplication对象</h4><p>每一个PyQt5程序都需要有一个QApplication对象。</p>
<pre><code>app = QApplication(sys.argv)</code></pre><h4 id="创建一个QWidget对象"><a href="#创建一个QWidget对象" class="headerlink" title="创建一个QWidget对象"></a>创建一个QWidget对象</h4><p>不为控件指定一个父对象，那么该控件就会被当作窗口处理</p>
<pre><code>window = QWidget()
window.show()</code></pre><h4 id="进入主循环"><a href="#进入主循环" class="headerlink" title="进入主循环"></a>进入主循环</h4><p>进入程序主循环，事件处理从本行代码开始。主循环接收事件消息并将其分发给程序的各个控件。</p>
<p>使用<code>sys.exit()</code>方法退出可以确保程序完整的结束，若程序运行成功，<code>exec_()</code>的返回值为0，否则为非0。（与底层使用C++有关）</p>
<pre><code>sys.exit(app.exec_())</code></pre><h2 id="布局管理"><a href="#布局管理" class="headerlink" title="布局管理"></a>布局管理</h2><h3 id="绝对布局"><a href="#绝对布局" class="headerlink" title="绝对布局"></a>绝对布局</h3><h3 id="布局管理器"><a href="#布局管理器" class="headerlink" title="布局管理器"></a>布局管理器</h3><p>选中需要布局的几个元素，右键在“布局”中即可选择相应布局</p>
<p>使用布局管理器后，属性编辑器中geometry属性变为了灰色不可用，说明这些标签的位置大小已经由布局管理器接管了。</p>
<h2 id="信号与槽"><a href="#信号与槽" class="headerlink" title="信号与槽"></a>信号与槽</h2><p>创建事件循环后，通过建立信号与槽的连接就可以实现对象之间的通信（信号发射时，连接的槽函数会自动执行）</p>
<p>QObject.signal.connect()</p>
<h2 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h2><h3 id="QMainWindow"><a href="#QMainWindow" class="headerlink" title="QMainWindow"></a>QMainWindow</h3><p>QMainWindow、QWidget、QDialog三个类都可以创建窗口。其中主窗口包含菜单栏等等，主窗口继承自（QWidget）</p>
<p>将按钮button的clicked信号与closeWin槽函数关联起来</p>
<pre><code>self.button = QPushButton(&#39;关闭&#39;)
self.button.clicked.connect(self.closeWin)</code></pre><h3 id="QWidget"><a href="#QWidget" class="headerlink" title="QWidget"></a>QWidget</h3><p>基础窗口控件QWidget类是所有用户界面对象的基类，所有窗口和控件都直接或间接继承自QWidget</p>
<h3 id="QLabel"><a href="#QLabel" class="headerlink" title="QLabel"></a>QLabel</h3><h2 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h2><p>按钮的基类是QAbstractButton，提供了按钮的通用性功能</p>
<h2 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h2><p>对话框的基类是QDialog，主要子类有QMessageBox、QFileDialog、QFontDialog、QInputDialog</p>
<h3 id="QMessageBox"><a href="#QMessageBox" class="headerlink" title="QMessageBox"></a>QMessageBox</h3><p>弹出提示信息，各参数如下</p>
<pre><code>QMessageBox.information(QWidget, title, text, buttons, defaultButton)
QMessageBox.warning()
QMessageBox.question()
QMessageBox.critical()
QMessageBox.about()</code></pre><p>示例</p>
<pre><code>QMessageBox.information(self, &quot;标题&quot;, &quot;关于对话框&quot;, QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)</code></pre><h3 id="QInputDialog"><a href="#QInputDialog" class="headerlink" title="QInputDialog"></a>QInputDialog</h3><p>该标准对话框可以收集控件输入的信息</p>
<pre><code>self.btn2 = QPushButton(&quot;获得字符串&quot;)
self.btn2.clicked.connect(self.getIext)
self.le2 = QLineEdit()</code></pre><pre><code>def getIext(self):    
    text, ok = QInputDialog.getText(self, &#39;Text Input Dialog&#39;, &#39;输入姓名:&#39;)
    if ok:
        self.le2.setText(str(text)) </code></pre><h3 id="QFileDialog"><a href="#QFileDialog" class="headerlink" title="QFileDialog"></a>QFileDialog</h3><p>QFileDialog是用于打开和保存文件的标准对话框</p>
<p>主要方法如下</p>
<pre><code>QFileDialog.getOpenFileName(父组件, 标题, 默认打开目录, 文件拓展名过滤器)</code></pre><p>示例</p>
<pre><code>f = QFileDialog.getOpenFileName()
print(f)
########################
(&#39;C:/Users/lenovo/Desktop/pyqt/t1.ui&#39;, &#39;All Files (*)&#39;)</code></pre><h2 id="绘图"><a href="#绘图" class="headerlink" title="绘图"></a>绘图</h2><p>主要可以通过QPainter、QPen与QBrush等三个类进行绘图</p>
<h3 id="QPainter"><a href="#QPainter" class="headerlink" title="QPainter"></a>QPainter</h3><p>绘制方法在QPainter对象的begin()和end()之间。</p>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><p>GUI中部分程序十分耗时可能会造成卡顿，这时候就需要使用多线程技术。PyQt中主要涉及三个内容，一个是使用计时器模块QTimer；一种是使用多线程模块QThread，还有使用事件处理的功能</p>
<h3 id="QTimer"><a href="#QTimer" class="headerlink" title="QTimer"></a>QTimer</h3><h3 id="QThread"><a href="#QThread" class="headerlink" title="QThread"></a>QThread</h3><p>PyQt线程使用非常简单，建立一个自定义的类（继承自QThread），并实现其run()方法</p>
<h2 id="网页交互"><a href="#网页交互" class="headerlink" title="网页交互"></a>网页交互</h2><p>PyQt5使用PyQt5.QtWebEngineWidgets中的QWebEngineView控件来展示HTML页面</p>
<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>class MainWindow(QMainWindow):

def __init__(self):
    super(QMainWindow, self).__init__()
    self.setWindowTitle(&#39;打开外部网页例子&#39;)
    self.setGeometry(5, 30, 1355, 730)
    self.browser = QWebEngineView()
    # 加载外部页面
    self.browser.load(QUrl(&#39;http://ziyedy.top&#39;))
    self.setCentralWidget(self.browser)</code></pre>]]></content>
      <categories>
        <category>Python</category>
        <category>PyQt5</category>
      </categories>
      <tags>
        <tag>PyQt5</tag>
      </tags>
  </entry>
  <entry>
    <title>Pandas库基本用法</title>
    <url>/page/pandas-basic-use.html</url>
    <content><![CDATA[<h2 id="Pandas基础"><a href="#Pandas基础" class="headerlink" title="Pandas基础"></a>Pandas基础</h2><p>Pandas是Python第三方库，提供高性能易用数据类型和分析工具，其基于NumPy实现，常与NumPy和Matplotlib一同使用.</p>
<p>器有两个主要数据类型：<strong>Series, DataFrame</strong></p>
<p>基于上述数据类型的各类操作<br>基本操作、运算操作、特征类操作、关联类操作</p>
<table>
<thead>
<tr>
<th>NumPy</th>
<th>Pandas</th>
</tr>
</thead>
<tbody><tr>
<td>基础数据类型</td>
<td>扩展数据类型</td>
</tr>
<tr>
<td>关注数据的结构表达</td>
<td>关注数据的应用表达</td>
</tr>
<tr>
<td>维度：数据间关系</td>
<td>数据与索引间关系</td>
</tr>
</tbody></table>
<h2 id="Series类型"><a href="#Series类型" class="headerlink" title="Series类型"></a>Series类型</h2><p>Series类型由一组数据及与之相关的数据索引组成（类似python的enumerate）</p>
<p>如下所示，Series为列表<strong>自动创建了索引</strong></p>
<pre><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; p = pd.Series([4,3,2,1])
&gt;&gt;&gt; p
0    4
1    3
2    2
3    1
dtype: int64</code></pre><p>也可以使用index参数<strong>手动指定索引</strong>（index可省略）</p>
<pre><code>&gt;&gt;&gt; import pandas as pd
&gt;&gt;&gt; a = pd.Series([1,2,3],[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;])
&gt;&gt;&gt; a
a    1
b    2
c    3
dtype: int64</code></pre><h3 id="Series类型的创建"><a href="#Series类型的创建" class="headerlink" title="Series类型的创建"></a>Series类型的创建</h3><blockquote>
<ul>
<li><p>Python列表，index与列表元素个数一致</p>
</li>
<li><p>标量值，index表达Series类型的尺寸</p>
</li>
<li><p>Python字典，键值对中的“键”是索引，index从字典中进行选择操作</p>
</li>
<li><p>ndarray，索引和数据都可以通过ndarray类型创建</p>
</li>
<li><p>其他函数，range()函数等</p>
</li>
</ul>
</blockquote>
<h3 id="Series类型的操作"><a href="#Series类型的操作" class="headerlink" title="Series类型的操作"></a>Series类型的操作</h3><h4 id="获得索引与数据"><a href="#获得索引与数据" class="headerlink" title="获得索引与数据"></a>获得索引与数据</h4><pre><code>&gt;&gt;&gt; a.index
Index([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;], dtype=&#39;object&#39;)
&gt;&gt;&gt; a.values
array([1, 2, 3], dtype=int64)</code></pre><h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><p><strong>其他操作基本与numpy和Python中自带的字典一致，包括切片等功能，其中自定义索引与自动索引并存，但不能混用</strong></p>
<h2 id="DataFrame类型"><a href="#DataFrame类型" class="headerlink" title="DataFrame类型"></a>DataFrame类型</h2><p><strong>DataFrame类型由共用相同索引的一组列组成（一种表格型的数据类型）</strong></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>MOOC上北理工相关课程PPT</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>常用模块</category>
      </categories>
  </entry>
  <entry>
    <title>bs4库基本使用</title>
    <url>/page/python-bs4-basic.html</url>
    <content><![CDATA[<p><strong>BeautifulSoup库是解析、遍历、维护“标签树”的功能库</strong></p>
<h3 id="bs4的HTML解析器"><a href="#bs4的HTML解析器" class="headerlink" title="bs4的HTML解析器"></a>bs4的HTML解析器</h3><pre><code>BeautifulSoup(html文件,&#39;html.parser&#39;)</code></pre>]]></content>
      <categories>
        <category>Python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>路径操作常用模块（os与pathlib）</title>
    <url>/page/Python-path-operation.html</url>
    <content><![CDATA[<h2 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h2><h3 id="模块简介"><a href="#模块简介" class="headerlink" title="模块简介"></a>模块简介</h3><blockquote>
<p>os模块是Python标准库中的一个用于<strong>访问操作系统功能</strong>的模块。使用os模块中提供的接口可以实现跨平台访问。</p>
</blockquote>
<h3 id="系统操作"><a href="#系统操作" class="headerlink" title="系统操作"></a>系统操作</h3><p>os.sep：用于系统路径的分隔符。Windows为“\\”，Linux为“/”。</p>
<p>os.name：指示正在使用的工作平台。Windows为‘nt’，Linux为‘posix’。</p>
<p>os.getenv(‘path’)：读取环境变量名称</p>
<p>os.getcwd()：获取当前路径</p>
<p>os.getpid()：获取当前进程ID</p>
<h4 id="os-system"><a href="#os-system" class="headerlink" title="os.system"></a>os.system</h4><blockquote>
<p>将字符串转化为命令行在操作系统上执行。每次执行system函数，会创建一个子进程在系统上执行命令（<strong>子进程的执行结果无法影响主进程</strong>）</p>
</blockquote>
<h3 id="目录操作"><a href="#目录操作" class="headerlink" title="目录操作"></a>目录操作</h3><p><strong>os.listdir(path)</strong>：列出指定目录下的所有文件和子目录，包括隐藏文件；参数为空，为当前目录，返回一个列表。</p>
<p>os.mkdir()：创建一个目录。</p>
<p>os.rmdir()：删除一个空目录，如果该目录中有文件则删除不了。</p>
<p>*<em>os.rename(src, dst) *</em>：用于重命名文件或目录，从src改为dst。若运行出错会抛出OSError。</p>
<h3 id="Path模块"><a href="#Path模块" class="headerlink" title="Path模块"></a>Path模块</h3><p>os.path.exists(path)：判断文件或者目录是否存在。存在返回True，不存在返回False。</p>
<p>os.path.isfile(path)：判断是否为文件。是返回True，不是返回False。</p>
<p>os.path.isdir(path)：判断是否为目录。是返回True，不是返回False。</p>
<p>os.path.abspath()：返回绝对路径</p>
<p>os.path.realpath(_<em>file_</em>)：获取当前.py文件的目录</p>
<p>os.path.dirname()：返回文件路径</p>
<p>os.path.basename(path) ：返回文件名</p>
<p>os.path.split(path) ：拆分路径dirname和basename，返回为元组</p>
<p><strong>os.path.splitext(‘’)</strong>：将文件名与后缀名分开</p>
<p><strong>os.path.join(path, name)</strong>：连接目录与文件名或目录</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code>import os

file_path = os.path.realpath(__file__)  # 该py文件目录
print(file_path)
print(os.path.dirname(file_path))   # 上级目录
print(os.path.basename(file_path))  # py文件名称
print(os.path.split(file_path)) # 分割目录与名称

##############################################
C:\Users\lenovo\Desktop\vega\gg.py
C:\Users\lenovo\Desktop\vega
gg.py
(&#39;C:\\Users\\lenovo\\Desktop\\vega&#39;, &#39;gg.py&#39;)</code></pre><h3 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h3><p>1、将某一路径下的文件名称中的广告部分去除并填上文件后缀名</p>
<pre><code>def rename():
    path = &#39;你的路径&#39;
    file_list = os.listdir(path)    # 得到文件名列表
    for file in file_list:
        old_dir = os.path.join(path, file)    #得到初始路径
        # 若该文件名为路径，则继续遍历
        if os.path.isdir(old_dir):
            continue
        file_name = os.path.splitext(file)[0]
        # 在该处进行文件名的字符串更改操作
        file_type = os.path.splitext(file)[1]
        # 在该处变更文件的后缀
        file_name = file_name+file_type
        new_dir = os.path.join(path, file_name)    # 新的路径
        os.rename(old_dir, new_dir)    # 完成文件的重命名</code></pre><h2 id="pathlib模块"><a href="#pathlib模块" class="headerlink" title="pathlib模块"></a>pathlib模块</h2><h3 id="基础使用"><a href="#基础使用" class="headerlink" title="基础使用"></a>基础使用</h3><h4 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h4><pre><code>from pathlib import Path</code></pre><h4 id="列出子目录"><a href="#列出子目录" class="headerlink" title="列出子目录"></a>列出子目录</h4><pre><code>In[5]: p = Path(&#39;C:\\Users\\lenovo\\.keras\\datasets\\flower_photos&#39;)
In[6]: [x for x in p.iterdir() if x.is_dir()]
Out[6]: 
[WindowsPath(&#39;C:/Users/lenovo/.keras/datasets/flower_photos/daisy&#39;),
 WindowsPath(&#39;C:/Users/lenovo/.keras/datasets/flower_photos/dandelion&#39;),
 WindowsPath(&#39;C:/Users/lenovo/.keras/datasets/flower_photos/roses&#39;),
 WindowsPath(&#39;C:/Users/lenovo/.keras/datasets/flower_photos/sunflowers&#39;),
 WindowsPath(&#39;C:/Users/lenovo/.keras/datasets/flower_photos/tulips&#39;)]</code></pre><h4 id="获取当前目录下所有文件与文件夹"><a href="#获取当前目录下所有文件与文件夹" class="headerlink" title="获取当前目录下所有文件与文件夹"></a>获取当前目录下所有文件与文件夹</h4><pre><code>In[7]: list(p.glob(&#39;*/&#39;))
Out[7]: 
[WindowsPath(&#39;C:/Users/lenovo/.keras/datasets/flower_photos/daisy&#39;),
 WindowsPath(&#39;C:/Users/lenovo/.keras/datasets/flower_photos/dandelion&#39;),
 WindowsPath(&#39;C:/Users/lenovo/.keras/datasets/flower_photos/LICENSE.txt&#39;),
 WindowsPath(&#39;C:/Users/lenovo/.keras/datasets/flower_photos/roses&#39;),
 WindowsPath(&#39;C:/Users/lenovo/.keras/datasets/flower_photos/sunflowers&#39;),
 WindowsPath(&#39;C:/Users/lenovo/.keras/datasets/flower_photos/tulips&#39;)]</code></pre><h4 id="路径拼接"><a href="#路径拼接" class="headerlink" title="路径拼接"></a>路径拼接</h4><pre><code>In[9]: q = p / &#39;daisy&#39;
In[10]: print(q)
C:\Users\lenovo\.keras\datasets\flower_photos\daisy</code></pre><h4 id="查询属性"><a href="#查询属性" class="headerlink" title="查询属性"></a>查询属性</h4><p>路径是否存在与是否是路径</p>
<pre><code>In[11]: q.exists()
Out[11]: True
In[12]: q.is_dir()
Out[12]: True</code></pre><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://docs.python.org/zh-cn/3/library/pathlib.html" target="_blank" rel="noopener">https://docs.python.org/zh-cn/3/library/pathlib.html</a></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>常用模块</category>
      </categories>
  </entry>
  <entry>
    <title>numpy常用属性与方法</title>
    <url>/page/numpy-basic-use.html</url>
    <content><![CDATA[<h2 id="n维数组对象：ndarray"><a href="#n维数组对象：ndarray" class="headerlink" title="n维数组对象：ndarray"></a>n维数组对象：ndarray</h2><p>ndarray对象主要由两部分构成，即实际的数据和描述这些数据的元数据（数据维度、类型）等。</p>
<h3 id="相比于Python列表的优势"><a href="#相比于Python列表的优势" class="headerlink" title="相比于Python列表的优势"></a>相比于Python列表的优势</h3><p><strong>1、数组对象可以去掉元素间运算所需的循环，使一维向量更像单个数据</strong>，如下：</p>
<p>Python中的数组对象进行平方：</p>
<pre><code>l = [1, 2, 3]
for i in range(len(a));
    a[i] = a[i]**2</code></pre><p>ndarray进行平方</p>
<pre><code>import numpy as np
a = np.array([1, 2, 3])
a = a**2</code></pre><p>2、设置专门的数组对象，经过优化，可以提升这类应用的运算速度</p>
<p>3、数组对象采用相同的数据类型，有助于节省运算和存储空间</p>
<h3 id="ndarray对象属性"><a href="#ndarray对象属性" class="headerlink" title="ndarray对象属性"></a>ndarray对象属性</h3><table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.ndim</td>
<td>秩，即轴的数量或维度的数量</td>
</tr>
<tr>
<td>.shape</td>
<td>ndarray对象的尺度，对于矩阵，n行m列</td>
</tr>
<tr>
<td>.size</td>
<td>ndarray对象元素的个数，相当于.shape中n*m的值</td>
</tr>
<tr>
<td>.dtype</td>
<td>ndarray对象的元素类型</td>
</tr>
<tr>
<td>.itemsize</td>
<td>ndarray对象中每个元素的大小，以字节为单位</td>
</tr>
</tbody></table>
<h3 id="ndarray元素类型"><a href="#ndarray元素类型" class="headerlink" title="ndarray元素类型"></a>ndarray元素类型</h3><p>包括主要的一些类型，类型后面的数字代表长度，常见的如bool、int32、float32、complex64（虚数）等等。</p>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="创建方法"><a href="#创建方法" class="headerlink" title="创建方法"></a>创建方法</h3><h4 id="从Python中的列表、元组等类型创建"><a href="#从Python中的列表、元组等类型创建" class="headerlink" title="从Python中的列表、元组等类型创建"></a>从Python中的列表、元组等类型创建</h4><pre><code>x = np.array(list/tuple)</code></pre><h4 id="使用相应函数创建"><a href="#使用相应函数创建" class="headerlink" title="使用相应函数创建"></a>使用相应函数创建</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>np.arange(n)</td>
<td>类似range()函数，返回ndarray类型，元素从0到n‐1</td>
</tr>
<tr>
<td>np.ones(shape)</td>
<td>根据shape生成一个全1数组，shape是元组类型</td>
</tr>
<tr>
<td>np.zeros(shape)</td>
<td>根据shape生成一个全0数组，shape是元组类型</td>
</tr>
<tr>
<td>np.full(shape,val)</td>
<td>根据shape生成一个数组，每个元素值都是val</td>
</tr>
<tr>
<td>np.eye(n)</td>
<td>创建一个正方的n*n单位矩阵，对角线为1，其余为0</td>
</tr>
<tr>
<td>np.ones_like(a)</td>
<td>根据数组a的形状生成一个全1数组</td>
</tr>
<tr>
<td>np.zeros_like(a)</td>
<td>根据数组a的形状生成一个全0数组</td>
</tr>
<tr>
<td>np.full_like(a,val)</td>
<td>根据数组a的形状生成一个数组，每个元素值都是val</td>
</tr>
</tbody></table>
<h4 id="创建网格（meshgrid）"><a href="#创建网格（meshgrid）" class="headerlink" title="创建网格（meshgrid）"></a>创建网格（meshgrid）</h4><pre><code></code></pre><h4 id="其他方法创建"><a href="#其他方法创建" class="headerlink" title="其他方法创建"></a>其他方法创建</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>np.linspace(begin, end, bia)</td>
<td>根据起止数据等间距地填充数据，形成数组（从begin到end，共bia个数）</td>
</tr>
<tr>
<td>np.concatenate()</td>
<td>将两个或多个数组合并成一个新的数组</td>
</tr>
</tbody></table>
<p>示例：</p>
<pre><code>&gt;&gt;&gt; a = np.linspace(1,10,3)
&gt;&gt;&gt; a
array([ 1. ,  5.5, 10. ])
&gt;&gt;&gt; b = np.linspace(1,10,3, endpoint=False)
&gt;&gt;&gt; b
array([1., 4., 7.])
&gt;&gt;&gt; c = np.concatenate((a, b))
&gt;&gt;&gt; c
array([ 1. ,  5.5, 10. ,  1. ,  4. ,  7. ])</code></pre><h3 id="变换方法"><a href="#变换方法" class="headerlink" title="变换方法"></a>变换方法</h3><h4 id="维度变换"><a href="#维度变换" class="headerlink" title="维度变换"></a>维度变换</h4><table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>.reshape(shape)</td>
<td>不改变数组元素，返回一个shape形状的数组，<strong>原数组不变</strong></td>
</tr>
<tr>
<td>.resize(shape)</td>
<td>与.reshape()功能一致，但<strong>修改原数组</strong></td>
</tr>
<tr>
<td>.flatten()</td>
<td>对数组进行降维，返回折叠后的一维数组，原数组不变</td>
</tr>
</tbody></table>
<p><strong>如果只想指示一个维度，而自动决定其他维度有多少个值，可以使用-1的写法（如果不能整除会报错）</strong></p>
<pre><code># 想让数组有5行，列数自动决定
x.reshape(5, -1)</code></pre><h4 id="类型变换"><a href="#类型变换" class="headerlink" title="类型变换"></a>类型变换</h4><p>astype()方法一定会创建新的数组（原始数据的一个拷贝），即使两个类型一致</p>
<pre><code>new_l = l.astype(new_type)</code></pre><h4 id="转换为列表"><a href="#转换为列表" class="headerlink" title="转换为列表"></a>转换为列表</h4><pre><code>l = n.tolist()</code></pre><h3 id="数组的操作"><a href="#数组的操作" class="headerlink" title="数组的操作"></a>数组的操作</h3><h4 id="索引与切片"><a href="#索引与切片" class="headerlink" title="索引与切片"></a>索引与切片</h4><p><strong>ndarray数组的索引与切片与Python中的索引与切片大致相同</strong></p>
<h4 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h4><p><strong>ndarray数组与标量之间的运算作用于数组的每一个元素，包括平方立方等等，示例如下：</strong></p>
<pre><code>np.abs(n)    // 各元素的绝对值
np.sqrt(x)    // 各元素的平方根</code></pre><p>同时使用数组中进行大小比较等运算时，会返回一个数值为布尔类型的数组（<strong>也是每个元素进行比较</strong>）</p>
<pre><code>X = np.array([[1,2,3],[4,5,6]])
print(X &gt; 3)
#######################################
[[False False False]
 [ True  True  True]]</code></pre><p>借用这个特性，可以完成对满足某一要求的元素进行如赋值等其他操作</p>
<pre><code>X = np.array([[1,2,3],[4,5,6]])
X[X &gt; 3] = 10
print(X)
####################################
[[ 1  2  3]
 [10 10 10]]</code></pre><h4 id="合并与分割"><a href="#合并与分割" class="headerlink" title="合并与分割"></a>合并与分割</h4><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>np.concatenate([n1, n2], axis=1)</td>
<td>将矩阵n1、n2按照第1个维度合并（axis默认为0）。同时返回一个新的矩阵</td>
</tr>
<tr>
<td>np.vstack([n1, n2])</td>
<td>在垂直的维度合并n1，n2</td>
</tr>
<tr>
<td>np.hstack([n1, n2])</td>
<td>在水平方向合并n1,n2</td>
</tr>
<tr>
<td>x1, x2, x3 = np.split(x, [2,4], axis=1)</td>
<td>将x按照[0, 2)、[2, 4)、[4, end)进行分割并赋值（依此类推）</td>
</tr>
<tr>
<td>np.vsplit()、np.hsplit()</td>
<td></td>
</tr>
</tbody></table>
<h3 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>A.dot(B)</td>
<td>矩阵乘法</td>
</tr>
<tr>
<td>A.T</td>
<td>矩阵转置</td>
</tr>
<tr>
<td>np.linalg.inv(A)</td>
<td>矩阵的逆</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>np.random.shuffle(x)</td>
<td>对x进行乱序处理</td>
</tr>
<tr>
<td>np.sort(x)</td>
<td>返回排序后的x</td>
</tr>
</tbody></table>
<h3 id="随机数函数"><a href="#随机数函数" class="headerlink" title="随机数函数"></a>随机数函数</h3><p>在numpy的子库numpy.random中</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>rand(d0,d1,..,dn)</td>
<td>根据d0‐dn作为维度创建随机数数组，浮点数，[0,1)，均匀分布</td>
</tr>
<tr>
<td>randn(d0,d1,..,dn)</td>
<td>根据d0‐dn创建随机数数组，标准正态分布</td>
</tr>
<tr>
<td>randint(low, high, shape)</td>
<td>根据shape创建随机整数或整数数组，范围是[low, high)</td>
</tr>
<tr>
<td>seed(s)</td>
<td>随机数种子，s是给定的种子值（计算机中随机数都是“伪随机数”，依赖于该随机种子）</td>
</tr>
<tr>
<td>normal(均值, 方差, shape)</td>
<td>生成给定均值与方差的符合正态分布的数或矩阵，shape为(元组)</td>
</tr>
</tbody></table>
<h3 id="统计函数（聚合函数）"><a href="#统计函数（聚合函数）" class="headerlink" title="统计函数（聚合函数）"></a>统计函数（聚合函数）</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sum(a, axis=None)</td>
<td>根据给定轴axis计算数组a相关元素之和，axis整数或元组</td>
</tr>
<tr>
<td>mean(a, axis=None)</td>
<td>根据给定轴axis计算数组a相关元素的期望，axis整数或元组</td>
</tr>
<tr>
<td>average(a,axis=None,weights=None)</td>
<td>根据给定轴axis计算数组a相关元素的加权平均值，weights是列表</td>
</tr>
<tr>
<td>std(a, axis=None)</td>
<td>根据给定轴axis计算数组a相关元素的标准差</td>
</tr>
<tr>
<td>var(a, axis=None)</td>
<td>根据给定轴axis计算数组a相关元素的方差</td>
</tr>
<tr>
<td>min(a)  max(a)</td>
<td>计算数组a中元素的最小值、最大值</td>
</tr>
<tr>
<td>argmin(a)  argmax(a)</td>
<td>计算数组a中元素最小值、最大值的降一维后下标</td>
</tr>
</tbody></table>
<h3 id="梯度函数"><a href="#梯度函数" class="headerlink" title="梯度函数"></a>梯度函数</h3><p><code>np.gradient(f)</code>，计算数组f中元素的梯度（即连续值之间的变化率），当f为多维时，返回每个维度梯度</p>
<pre><code>&gt;&gt;&gt; a = np.arange(5)
&gt;&gt;&gt; a
array([0, 1, 2, 3, 4])
&gt;&gt;&gt; np.gradient(a)
array([1., 1., 1., 1., 1.])</code></pre><p><strong>说明：</strong>以索引为2的值为例，该处梯度的计算值为(a[3] - a[1]) / 2 = 1</p>
<h3 id="ndarray数据的读写"><a href="#ndarray数据的读写" class="headerlink" title="ndarray数据的读写"></a>ndarray数据的读写</h3><h4 id="二维数据读写"><a href="#二维数据读写" class="headerlink" title="二维数据读写"></a>二维数据读写</h4><p><strong>CSV文件</strong>，以逗号作为分隔符的常见文件格式</p>
<p><strong>np.savetxt()</strong>：写入文件</p>
<pre><code class="python"># frame : 文件、字符串或产生器
# array : 存入文件的数组
# fmt : 写入文件的格式
# delimiter : 分割字符串，默认是任何空格
np.savetxt(frame, array, fmt=&#39;%.18e&#39;, delimiter=None)</code></pre>
<p>例:</p>
<pre><code>np.savetxt(&#39;a.csv&#39;, a, fmt=&#39;%d&#39;, delimiter=&#39;,&#39;)</code></pre><p><strong>np.loadtxt()</strong>：读取文件</p>
<pre><code class="python"># unpack  : 如果True，读入属性将分别写入不同变量
np.loadtxt(frame, dtype=np.float, delimiter=None， unpack=False)</code></pre>
<h4 id="多维数据存取"><a href="#多维数据存取" class="headerlink" title="多维数据存取"></a>多维数据存取</h4><p><strong>a.tofile()</strong></p>
<pre><code># frame  : 文件、字符串
# sep : 数据分割字符串，如果是空串，写入文件为二进制
# format : 写入数据的格式
a.tofile(frame, sep=&#39;&#39;, format=&#39;%s&#39;)</code></pre><p><strong>np.fromfile()</strong></p>
<pre><code># count  : 读入元素个数，‐1表示读入整个文件
# sep : 数据分割字符串，如果是空串，写入文件为二进制
np.fromfile(frame, dtype=float, count=‐1, sep=&#39;&#39;)</code></pre><h4 id="便捷文件存取"><a href="#便捷文件存取" class="headerlink" title="便捷文件存取"></a>便捷文件存取</h4><p>其中文件名称通常以.npy为拓展名</p>
<pre><code>np.save(fname, array)

np.load(fname)</code></pre>]]></content>
      <categories>
        <category>Python</category>
        <category>常用模块</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>matplotlib库基本使用</title>
    <url>/page/python-matplotlib-use.html</url>
    <content><![CDATA[<h2 id="matplotlib库的基本用法"><a href="#matplotlib库的基本用法" class="headerlink" title="matplotlib库的基本用法"></a>matplotlib库的基本用法</h2><p>这是一个图表可视化的工具，和matlab中对应的图表可视化很像</p>
<p>参考文档以及一些可视化效果可见：<a href="http://matplotlib.org/gallery.html" target="_blank" rel="noopener">http://matplotlib.org/gallery.html</a></p>
<p>导入：<code>import matplotlib.pyplot as plt</code></p>
<h3 id="绘图函数plot"><a href="#绘图函数plot" class="headerlink" title="绘图函数plot()"></a>绘图函数plot()</h3><p>与matlab中对应的绘图函数类似。</p>
<pre><code class="python"># X轴数据，列表或数组，（可选）
# Y轴数据，列表或数组，只写一个自动就是y轴数据
# 控制曲线的格式字符串，（可选）(颜色字符、风格字符、标记字符)
# 第二组或更多(x,y,format_string)
plt.plot(x, y, format_string, **kwargs)</code></pre>
<h3 id="plt-gca-获取修改坐标轴"><a href="#plt-gca-获取修改坐标轴" class="headerlink" title="plt.gca()获取修改坐标轴"></a>plt.gca()获取修改坐标轴</h3><pre><code></code></pre><h3 id="pyplot的文本显示函数"><a href="#pyplot的文本显示函数" class="headerlink" title="pyplot的文本显示函数"></a>pyplot的文本显示函数</h3><table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>plt.xlabel()</td>
<td>对X轴增加文本标签</td>
</tr>
<tr>
<td>plt.ylabel()</td>
<td>对Y轴增加文本标签</td>
</tr>
<tr>
<td>plt.title()</td>
<td>对图形整体增加文本标签</td>
</tr>
<tr>
<td>plt.text()</td>
<td>在任意位置增加文本</td>
</tr>
<tr>
<td>plt.annotate()</td>
<td>在图形中增加带箭头的注解</td>
</tr>
</tbody></table>
<p>其中annotate()函数中：xy表示箭头指向的坐标，xytest表示文字坐标，之后的arrowprops传入箭头的粗细颜色等信息，具体如下。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><pre><code>import numpy as np
import matplotlib.pyplot as plt

a = np.arange(0.0, 5.0, 0.02)
plt.plot(a, np.cos(2*np.pi*a))

plt.xlabel(&quot;x-axis&quot;)
plt.ylabel(&quot;y-axis&quot;)
plt.title(r&#39;$y = cos(2 \pi x)$&#39;)    # 使用latex
plt.annotate(r&#39;$cos(2 \pi x)$&#39;, xy=(2,1), xytext=(3, 1.5),
            arrowprops=dict(facecolor=&#39;black&#39;, shrink=0.1, width=1))

plt.axis([-1, 6, -2, 2])
plt.grid(True)
plt.show()</code></pre><p><img src="http://cdn.ziyedy.top/image/matplotlib%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/plot%E7%A4%BA%E4%BE%8B.png" alt=""></p>
<h3 id="plt-figure"><a href="#plt-figure" class="headerlink" title="plt.figure()"></a>plt.figure()</h3><h4 id="基本理解"><a href="#基本理解" class="headerlink" title="基本理解"></a>基本理解</h4><img src="http://cdn.ziyedy.top/image/matplotlib%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/fig%E4%B8%8Eaxis.png" style="zoom:67%;" />

<h4 id="语法说明"><a href="#语法说明" class="headerlink" title="语法说明"></a>语法说明</h4><pre><code>figure(num=None, figsize=None, dpi=None, facecolor=None, edgecolor=None, frameon=True)

&quot;&quot;&quot;
      num : 图像编号或名称，数字为编号，字符串为名称
  figsize : 指定figure的宽和高，单位为英寸
      dpi : 指定绘图对象的分辨率，即每英寸多少个像素，缺省值为80
facecolor : 背景的颜色
edgecolor : 边框颜色
  frameon : 是否显示边框
&quot;&quot;&quot;

# 示例
import matplotlib.pyplot as plt

fig = plt.figure(figsize=(4, 3), facecolor=&#39;blue&#39;)
plt.plot([1 ,2, 3, 4])
plt.show()</code></pre><p><img src="http://cdn.ziyedy.top/image/matplotlib%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/figure%E7%A4%BA%E4%BE%8B.png" alt=""></p>
<h3 id="plt-subplot-创建单个子图"><a href="#plt-subplot-创建单个子图" class="headerlink" title="plt.subplot()创建单个子图"></a>plt.subplot()创建单个子图</h3><p>即将绘图区域分为nrows行，ncols列，然后在从上向下从左到右第plot_number处进行绘图。使用与matlab中的函数基本一致，还有一些比较复杂的绘图函数，我个人认为没有什么必要（要是用在文章中放进ai再处理好了，没必要直接输出成图吧）</p>
<pre><code>plt.subplot(nrows, ncols, plot_number)</code></pre><h3 id="plt-subplots-创建多个子图"><a href="#plt-subplots-创建多个子图" class="headerlink" title="plt.subplots()创建多个子图"></a>plt.subplots()创建多个子图</h3><pre><code>import numpy as np
import matplotlib.pyplot as plt

x = np.arange(0, 100)
#划分子图
fig, axes = plt.subplots(2, 2)
ax1 = axes[0, 0]
ax2 = axes[0, 1]
ax3 = axes[1, 0]
ax4 = axes[1, 1]

#作图1
ax1.plot(x, x)
#作图2
ax2.plot(x, x)
#作图3
ax3.plot(x, x ** 2)
#作图4
ax4.plot(x, np.log(x))
plt.show()</code></pre><p><img src="http://cdn.ziyedy.top/image/matplotlib%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/subplots%E7%A4%BA%E4%BE%8B.png" alt=""></p>
<h3 id="面向对象API"><a href="#面向对象API" class="headerlink" title="面向对象API"></a>面向对象API</h3><h4 id="add-subplot新增子图"><a href="#add-subplot新增子图" class="headerlink" title="add_subplot新增子图"></a>add_subplot新增子图</h4><p>该方法与subplot方法类似，如下代码即与plt.subplots()中绘制第一幅图和第三幅图等价</p>
<pre><code>import numpy as np
import matplotlib.pyplot as plt

x = np.arange(0, 100)
#新建figure对象
fig = plt.figure()
#新建子图1
ax1 = fig.add_subplot(2, 2, 1)
ax1.plot(x, x)
#新建子图3
ax3 = fig.add_subplot(2, 2, 3)
ax3.plot(x, x ** 2)</code></pre><h4 id="add-axes新增子区域（图中图）"><a href="#add-axes新增子区域（图中图）" class="headerlink" title="add_axes新增子区域（图中图）"></a>add_axes新增子区域（图中图）</h4><pre><code>import numpy as np
import matplotlib.pyplot as plt

#新建figure对象
fig = plt.figure()

#定义数据
x = [1, 2, 3, 4, 5, 6, 7]
y = [1, 3, 4, 2, 5, 8, 6]

#新建区域ax1
#figure的百分比，从figure 10%的位置开始绘制，宽高是figure的80%
left, bottom, width, height = 0.1, 0.1, 0.8, 0.8
#获得绘制的句柄
ax1 = fig.add_axes([left, bottom, width, height])
ax1.plot(x, y, &#39;r&#39;)
ax1.set_title(&#39;area1&#39;)


#新增区域ax2，嵌套在ax1内
left, bottom, width, height = 0.2, 0.6, 0.25, 0.25
#获得绘制的句柄
ax2 = fig.add_axes([left, bottom, width, height])
ax2.plot(x, y, &#39;b&#39;)
ax2.set_title(&#39;area2&#39;)
plt.show()</code></pre><p><img src="http://cdn.ziyedy.top/image/matplotlib%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/%E5%9B%BE%E4%B8%AD%E5%9B%BE.png" alt=""></p>
<h3 id="保存图像"><a href="#保存图像" class="headerlink" title="保存图像"></a>保存图像</h3><p>使用plt.savefig()能很容易的实现，但应当注意，<strong>必须写在plt.show()之前</strong>，否则保存的图像会是空白的</p>
<pre><code>plt.savefig(&#39;test.png&#39;)</code></pre><h2 id="常用可视化图表绘制"><a href="#常用可视化图表绘制" class="headerlink" title="常用可视化图表绘制"></a>常用可视化图表绘制</h2><p>常见可视化图表如下</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>plt.plot(x,y,fmt,…)</td>
<td>绘制一个坐标图</td>
</tr>
<tr>
<td>plt.scatter(x,y)</td>
<td>绘制散点图，其中，x和y长度相同</td>
</tr>
<tr>
<td>plt.bar(left,height,width,bottom)</td>
<td>绘制一个条形图</td>
</tr>
<tr>
<td>plt.contour(X,Y,Z,N)</td>
<td>绘制等值图</td>
</tr>
<tr>
<td>plt.pie(data, explode)</td>
<td>绘制饼图（explode传入一个元组，表示一块出来的比例）</td>
</tr>
<tr>
<td>plt.hist(x,bins)</td>
<td>绘制直方图（bins代表直方图个数）</td>
</tr>
<tr>
<td>plt.polar(theta, r)</td>
<td>绘制极坐标图</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
</tr>
</tbody></table>
<h3 id="饼图（pie）"><a href="#饼图（pie）" class="headerlink" title="饼图（pie）"></a>饼图（pie）</h3><pre><code>import numpy as np
import matplotlib.pyplot as plt

labels = &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;
sizes = [10, 20 ,30, 40]
explode = (0, 0, 0, 0.15)
plt.pie(sizes, explode=explode, labels=labels)
plt.show()</code></pre><p><img src="http://cdn.ziyedy.top/image/matplotlib%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/%E9%A5%BC%E5%9B%BE.png" alt=""></p>
<h3 id="直方图（hist）"><a href="#直方图（hist）" class="headerlink" title="直方图（hist）"></a>直方图（hist）</h3><pre><code>import numpy as np
import matplotlib.pyplot as plt

np.random.seed(0)
mu, sigma = 100, 20
a = np.random.normal(mu, sigma, size=100)
plt.hist(a, bins=40, facecolor=&#39;r&#39;)
plt.show()</code></pre><p><img src="http://cdn.ziyedy.top/image/matplotlib%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/%E7%9B%B4%E6%96%B9%E5%9B%BE.png" alt=""></p>
<h3 id="等值图（contour）"><a href="#等值图（contour）" class="headerlink" title="等值图（contour）"></a>等值图（contour）</h3><pre><code>import numpy as np
import matplotlib.pyplot as plt

delta = 0.025
x = np.arange(-3.0, 3.0, delta)
y = np.arange(-3.0, 3.0, delta)
X, Y = np.meshgrid(x, y)
Z = np.exp(-X**2/12 - Y**2/2)
plt.contour(X, Y, Z)
plt.show()</code></pre><p><img src="http://cdn.ziyedy.top/image/matplotlib%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/%E7%AD%89%E5%80%BC%E5%9B%BE.png" alt=""></p>
<h2 id="matplotlib总结图（源于知乎）"><a href="#matplotlib总结图（源于知乎）" class="headerlink" title="matplotlib总结图（源于知乎）"></a>matplotlib总结图（源于知乎）</h2><p><img src="http://cdn.ziyedy.top/image/matplotlib%E5%BA%93%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/matplotlib%E6%80%BB%E7%BB%93.jpg" alt="图源自知乎"></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.dazhuanlan.com/2020/01/19/5e24219f9ae61/" target="_blank" rel="noopener">https://www.dazhuanlan.com/2020/01/19/5e24219f9ae61/</a></p>
<p>mooc北理工相关课程</p>
<p><a href="http://matplotlib.org/gallery.html" target="_blank" rel="noopener">http://matplotlib.org/gallery.html</a></p>
<p><a href="https://www.zhihu.com/question/51745620" target="_blank" rel="noopener">https://www.zhihu.com/question/51745620</a></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>常用模块</category>
      </categories>
  </entry>
  <entry>
    <title>1、Django基础内容</title>
    <url>/page/django1.html</url>
    <content><![CDATA[<p>模型（Model）</p>
<p>视图（View）</p>
<p>模板（Template）</p>
<pre><code>django-admin startproject my_project</code></pre><pre><code>python manage.py runserver</code></pre><p>url指定name，方便重定向</p>
<pre><code>url = reverse(&#39;index_two&#39;)
return redirect(url)</code></pre><p>url的嵌套，使用include关键字</p>
<pre><code>from django.conf.urls import include

url(&#39;&#39;, inclued(&#39;child.urls&#39;))</code></pre><p>视图</p>
<p>一个视图函数，简称视图，是一个python函数</p>
<p>接受一个请求，返回一个响应。响应可以是HTML内容、文本、图像，甚至是404、重定向等</p>
<p>在urls.py文件中加上要响应的url</p>
<pre><code>urlpatterns = [
    url(r&#39;^admin/&#39;, admin.site.urls),

    # 展示当前时间
    url(r&#39;^time/$&#39;, views.now_time),
]</code></pre><p>在views.py中加入相应的视图函数</p>
<pre><code># 返回一个展示时间的html
def now_time(request):
    &quot;&quot;&quot; 展示时间 &quot;&quot;&quot;
    now = datetime.now()
    html = &quot;&quot;&quot;
    &lt;html&gt;
        &lt;head&gt;
            &lt;style type=&quot;text/css&quot;&gt;
                body {{color: blue}}
            &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
            now: {0}
        &lt;/body&gt;
    &lt;/html&gt;
    &quot;&quot;&quot;.format(now)
    return HttpResponse(html)</code></pre><p>视图中获取URL参数</p>
<p>视图中获取URL中的请求（GET/POST等）参数</p>
<pre><code># 输入URL
http://index/?par=20
# 视图编写，若找不到par参数则返回默认值10
def index(request):
    par = request.GET.get(&#39;par&#39;, 10)
    request.POST.get()</code></pre><p>返回HTML信息</p>
<p>通过文件读取方式返回</p>
<pre><code>def gg(request):
    &quot;&quot;&quot; 从html文件读取内容，并响应 &quot;&quot;&quot;
    html = &#39;&#39;
    file_name = os.path.join(settings.BASE_DIR, &#39;templates&#39;, &#39;index.html&#39;)
    with open(file_name) as f:
        html = f.read()
    return HttpResponse(html)</code></pre><p>直接使用render_to_response函数</p>
<pre><code>from django.shortcuts import render_to_response

def index(request):
    return render_to_response(&#39;index.html&#39;)</code></pre><p>内置错误处理视图</p>
<p>400 Bad Request</p>
<p>403 Forbidden</p>
<p>404 Not Found</p>
<p>500 Internal Server Error</p>
<p>重写内置错误处理视图</p>
<p>在urls.py中添加配置</p>
<pre><code>handler500 = &#39;django_app.views.page_500&#39;</code></pre><p>在views.py中添加</p>
<pre><code>def page_500(request):
    pass</code></pre><p>请求对象Request</p>
<p>请求方式method（POST/GET….）</p>
<p>请求头信息META</p>
<p>REMOTE_ADDR——请求的IP地址</p>
<p>HTTP_USER_AGENT——用户请求终端信息</p>
<p>获取请求传递参数</p>
<p>GET、POST、COOKIES、FILES</p>
<p>响应对象</p>
<p>HttpResponse</p>
<p>status：查看状态码</p>
<p>content_type：设置响应类型</p>
<p>FileResponse</p>
<p>使用类重写视图</p>
<p>1、继承视图。django.views.generic.TemplateView</p>
<p>2、配置模板地址</p>
<p>3、配置URL</p>
<p>TemplateView原理</p>
<p>1、从项目主目录寻找模板文件</p>
<p>2、从app进行寻找</p>
<pre><code>class ShowClassView(TemplateView):
    &quot;&quot;&quot; class视图 &quot;&quot;&quot;
    template_name = &#39;class.html&#39;

url(r&#39;^show/class/$&#39;, views.ShowClassView.as_view(), name</code></pre><p>模板：</p>
<p>模板具有一定的格式或骨架，可以动态的生成HTML</p>
<p>模板引擎决定以何种方式组织代码</p>
<p>DTL</p>
<p>Jinja2</p>
<p>渲染机制</p>
<p>1、从磁盘读取模板文件（get_template）</p>
<p>2、选择合适模板引擎（select_template）</p>
<p>3、将制定内容对模板进行渲染（render）</p>
<p>4、发送给浏览器显示</p>
<p>渲染python中的对象</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;Title&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    我制定的值为: { { p1 } }
&lt;/body&gt;
&lt;/html&gt;</code></pre><pre><code>url(r&#39;^text/$&#39;, views.text_show)

def text_show(request):
    &quot;&quot;&quot; 变量在模板中的渲染 &quot;&quot;&quot;
    p1 = 10
    return render(request, &#39;index.html&#39;, {
        &#39;p1&#39; : p1
    })</code></pre><pre><code>模板标签

{% %}

循环控制

{% for item in list %}

<li> </li>

{% endfor %}</code></pre><pre><code>条件控制

{% if A %}
	满足A
{% elif B %}
	满足B
{% else %}
	都不满足
{% endif %}</code></pre><pre><code>注释

</code></pre><p>示例</p>
<pre><code>def text_show(request):
    &quot;&quot;&quot; 变量在模板中的渲染 &quot;&quot;&quot;
    list = [&#39;北京&#39;, &quot;上海&quot;, &quot;广州&quot;, &quot;深圳&quot;]
    return render(request, &#39;index.html&#39;, {
        &#39;list&#39;: list
    })</code></pre><pre><code>&lt;ul&gt;
    {% for item in list  %}
        <li>
            {{ item }}
        </li>
    {% endfor %}
&lt;/ul&gt;</code></pre><p>模板过滤器：对变量进行处理后再渲染</p>
<pre><code>{{ value|filter_name:params }}</code></pre><p>自定义过滤器</p>
<p>1、在app目录下新建包templatetags，并新建filter.py</p>
<p>2、定义过滤器</p>
<pre><code>from django import template

register = template.Library()

def func(value):
    pass

# 注册过滤器
register.filter(&#39;func&#39;, func)</code></pre><p>3、在模板中使用过滤器（）</p>
<pre><code>{% load filter %}
{{ value|func }}</code></pre><p>模板的抽象和继承</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>Django</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>requests库基本使用</title>
    <url>/page/python-requests-basic.html</url>
    <content><![CDATA[<p><strong>requests库是python实现的最简单易用的HTTP库。</strong></p>
<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><pre><code>requests.request(method, url, **kwargs)</code></pre><p>method : 请求方式，对应get/put/post等7种<br>url : 拟获取页面的url链接<br>**kwargs: 控制访问的参数，共13个</p>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>基本使用如下：</p>
<pre><code>r = requests.get(url)</code></pre><p>其中r是返回的一个包含服务器资源的<strong>Response对象</strong></p>
<p>get方法是构造了一个向服务器请求资源的<strong>Request对象</strong></p>
<h3 id="Response对象的属性"><a href="#Response对象的属性" class="headerlink" title="Response对象的属性"></a>Response对象的属性</h3><h4 id="判断异常"><a href="#判断异常" class="headerlink" title="判断异常"></a>判断异常</h4><p>r.raise_for_status()在方法内部判断r.status_code是否等于200，不需要增加额外的if语句，该语句<strong>便于利用try‐except进行异常处理</strong></p>
<pre><code>r.raise_for_status()</code></pre><h3 id="爬取网页通用代码框架"><a href="#爬取网页通用代码框架" class="headerlink" title="爬取网页通用代码框架"></a>爬取网页通用代码框架</h3><pre><code>def getHTMLText(url):
    import requests
    try:
        r = requests.get(url)
        r.raise_for_status()
        r.encoding = r.apparent_encoding
        return r.text
    except:
        print(&quot;产生异常&quot;)
        return None</code></pre>]]></content>
      <categories>
        <category>Python</category>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python基本数据类型</title>
    <url>/page/python1.html</url>
    <content><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>1、 单双引号的应用，即字符串中包含单引号时可以使用双引号进行包含，包含双引号时使用单引号进行包含，如下：</p>
<pre><code>&quot;a&#39;s hhh&quot;
&#39;a&quot;s hhh&#39;</code></pre><p>2、 字符串的一些基本操作（拼接、搜索、替换），其中<strong>替换操作必须要将str赋给一个新的变量</strong></p>
<pre><code>str = str1 + str2    # 拼接字符串（直接使用 + 进行操作）
len(str) # 获取长度
str.find(string) # 返回搜索到的第一个index，没搜索到则返回-1
str = str.replace(&#39;A&#39;, &#39;B&#39;) # A替换B</code></pre><p>3、 格式化字符串（使用.format语句），使用{}占位符进行</p>
<pre><code>&quot;{} {} gg&quot;.format(&quot;huangkai&quot;,&quot;is&quot;)
# huangkai is gg

# 带索引的格式化字符串
&quot;{1} {0} gg&quot;.format(&quot;huangkai&quot;,&quot;is&quot;)
is huangkai gg

# f形式的格式化字符串
str1 = &#39;Curry&#39;
str2 = &#39;James&#39;
combi = f&#39;{str1} and {str2}, NBA stars&#39;

# 使用别名
str3 = “gg {s1}， {s2}”。format(s1=str1, s2 str2)</code></pre><h3 id="列表（list）"><a href="#列表（list）" class="headerlink" title="列表（list）"></a>列表（list）</h3><p>列表在内存中按照顺序存储</p>
<p>1、 列表反转与排序</p>
<pre><code>list.reverse()    # 列表反转
list.sort() # 升序排列
list.sort(reverse=True) # 降序排列</code></pre><p>2、 列表常用操作</p>
<pre><code>list.append(new_element) # 在列表末尾添加元素
list.insert(index, new_element) # 在指定的index处加入一个元素，其后元素全部后移
list.remove(element) # 删除值为element的元素
list.pop(index) # 删除索引值为index的元素，无index则删除最后一个元素
list.clear() # 清空列表</code></pre><p>4、 列表其他操作（区别于append）</p>
<pre><code>list.extend([e1, e2]) # 将列表追加进list（区别于append）</code></pre><p>5、 <strong>列表的复制</strong>，想将一个列表赋值给另一个列表必须要使用.copy方法，否则修改其中一个表另一个也会变，如下：</p>
<pre><code>l1 = [1,2,3,4]
l2 = l1
print(id(l1))
print(id(l2))</code></pre><p>运行结果可以发现l1与l2指向了同一块内存，因此改变l1，l2也会相应改变。而copy()方法会重新创建一个空列表再将原列表的元素放进去。</p>
<pre><code>l2 = list.copy()</code></pre><p>6、列表元素直接的对应操作，以相加为例，使用列表生成器如下。其中zip函数为将a、b两个列表中的元素一一组合。</p>
<pre><code>a = [1,2,3,4]
b = [1,2,3,4]
c = [i+j for i, j in zip(a,b)]
########################################
[2, 4, 6, 8]</code></pre><h3 id="字典（dict）"><a href="#字典（dict）" class="headerlink" title="字典（dict）"></a>字典（dict）</h3><p>键值对（key-value），可修改。Python中的散列值函数<code>hash(data)</code>，字典存储根据其哈希值存储。</p>
<p>1、 创建</p>
<pre><code>dic = dict.fromkeys([&#39;school number&#39;, &#39;bala1&#39;, &#39;bala2&#39;])
print(dic)

# 输出
{&#39;school number&#39;: None, &#39;bala1&#39;: None, &#39;bala2&#39;: None}</code></pre><p>2、 取值</p>
<pre><code># 直接使用key获取value
dic[key]
# 使用get方法（可以为不存在的key赋默认值）
dic.get(key)</code></pre><p>3、 遍历字典</p>
<pre><code># 方案1
for key in dic:
    v = dic[key]

# 方案2（返回每一个键值对）
for key,value in dic.items():
</code></pre><p>4、 字典常用操作</p>
<pre><code>dic.update(k1 = new_value1, k2 = new_value2) # 对多个键值进行更新或新增
dic,pop(key) # 删除键值为key
dic.popitem() # 删除最后一个键值对，并返回该键值对的tuple
dic.clear() # 清空字典
dic.setdefault(&#39;key&#39;, &#39;value&#39;) # 设置默认值（如果没有该键值的话）

# 修改字典时下面三个值都会变
dic.keys()    # 返回所有键
dic.values() # 返回所有值
dic.items() # 返回所有键值对

# 格式化字符串，使用format_map
dic = {&#39;name&#39;:&#39;Curry&#39;,&#39;gg&#39;:&#39;no&#39;}
s = &quot;姓名:{name},瞎写:{gg}&quot;.format_map(dic)
print(s)
# 输出
姓名:Curry,瞎写:no</code></pre><h3 id="元组（tuple）"><a href="#元组（tuple）" class="headerlink" title="元组（tuple）"></a>元组（tuple）</h3><p>创建后不允许修改，当列表等可变对象为元组元素时，可以修改该元素的值。</p>
<h3 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h3><p>元素是无序的、可变的、元素不能重复，在内存中是分散保存的（存储方式与字典相似），缺点，浪费内存空间</p>
<p>1、 初始化</p>
<pre><code># 空集合的创建
# 不能使用s = {}，这样默认创建的是字典
set1 = set()</code></pre><p>2、 集合的常用运算</p>
<pre><code>set1 = {1,2,3,4,5}
set2 = {4,5,6,7,8}

# 交集运算
set3 = set1.intersection(set2)    # 产生新集合
# intersection_update为更新原有集合
print(set3)
# 输出
{4, 5}

# 并集运算
set3 = set1.union(set2)
print(set3)
# 输出
{1, 2, 3, 4, 5, 6, 7, 8}

# 差集运算
set3 = set1.difference(set2) # 得到set1中有，set2中没有的元素 
print(set3)
# 输出
{1, 2, 3}

# 双向差集
set3 = set1.symmetric_difference(set2)
print(set3)
# 输出
{1, 2, 3, 6, 7, 8}</code></pre><p>3、 集合间的关系操作</p>
<pre><code># 判断两个集合的元素是否完全相同
s1 = {1,2,3,4,5}
s2 = {5,4,3,2,1}
print(s1 == s2)
# 输出
True</code></pre><pre><code># 子集判断
# 父集判断，同理。 .issuperset()
s1 = {1,2,3,4,5}
s2 = {5,4,3,2}
print(s2.issubset(s1))
# 输出
True</code></pre><pre><code># 判断两个集合是否存在重复元素
# 返回False代表存在重复元素
s1 = {1,2,3,4,5}
s2 = {5,4,3,2}
print(s1.isdisjoint(s2))
# 输出
False</code></pre><pre><code># 新增数据
set.add(element) # 一次添加一个元素
set.update(列表或元组) # 一次添加多个元素
# 删除元素
set.remove(element) # 删除不存在的元素会报错
set.discard(element) # 删除不存在的元素会直接忽略</code></pre><h3 id="常用的转换函数"><a href="#常用的转换函数" class="headerlink" title="常用的转换函数"></a>常用的转换函数</h3><pre><code>list() # 转换为列表
tuple() # 转换为元组
join(), str() # 转换为字符串</code></pre><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>1、 <strong>列表生成器</strong>，常用形式如下</p>
<p>[数据 循环语句 循环或判断语句]</p>
<pre><code>l = [i**2 for i in range(10)]
# [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]

l = [i**2 for i in range(10) if i%2 ==0]
# [0, 4, 16, 36, 64]</code></pre><p>2、 字典生成器</p>
<pre><code>list1 = [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]
dic = {i:list1[i] for i in range(len(list1))}
# {0: &#39;A&#39;, 1: &#39;B&#39;, 2: &#39;C&#39;}</code></pre><p>3、 集合生成器（跟列表生成式类似）</p>
<pre><code>set1 = {i for i in range(10)}</code></pre>]]></content>
      <categories>
        <category>Python</category>
        <category>语言基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python装饰器、迭代器、生成器</title>
    <url>/page/python5.html</url>
    <content><![CDATA[<h3 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h3><p>用于拓展原来函数功能的一种函数，返回函数的函数，在不更改原函数代码的前提下给函数增加新的功能（易于代码重用）</p>
<pre><code># 装饰器的常用写法
# 输入函数，在函数内部定义返回函数
def decoratre(func):
    def wrapper():
        print(&#39;start&#39;)
        func()
        print((&#39;end&#39;))
    return wrapper

@decoratre
def func():
    print(&quot;原函数执行&quot;)


if __name__ == &#39;__main__&#39;:
    func()

##########################################
start
原函数执行
end</code></pre><h3 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h3><h4 id="装饰器参数的传入"><a href="#装饰器参数的传入" class="headerlink" title="装饰器参数的传入"></a>装饰器参数的传入</h4><pre><code>def gg(name):
    def decoratre(func):
        def wrapper():
            print(&#39;{}:start&#39;.format(name))
            func()
            print(&#39;{}:end&#39;.format(name))
        return wrapper
    return decoratre

@gg(&#39;func&#39;)
def func():
    print(&quot;原函数执行&quot;)


if __name__ == &#39;__main__&#39;:
    func()

#########################################
func:start
原函数执行
func:end</code></pre><h4 id="函数参数的传入"><a href="#函数参数的传入" class="headerlink" title="函数参数的传入"></a>函数参数的传入</h4><p>使用<code>*args, **kwargs</code></p>
<pre><code>def gg(name):
    def decoratre(func):
        def wrapper(*args, **kwargs):
            print(&#39;{}:start&#39;.format(name))
            res = func(*args, **kwargs)
            print(res)
            print(&#39;{}:end&#39;.format(name))
            return res
        return wrapper
    return decoratre

@gg(&#39;sum&#39;)
def sum(a, b):
    return a+b

if __name__ == &#39;__main__&#39;:
    sum(1, 2)

#############################################    
sum:start
3
sum:end</code></pre><p>装饰器对函数进行封装时改变了原函数的名称与说明文档等信息，如下：</p>
<pre><code>def gg(name):
    def decoratre(func):
        def wrapper():
            print(&#39;{}:start&#39;.format(name))
            func()
            print(&#39;{}:end&#39;.format(name))
        return wrapper
    return decoratre

@gg(&#39;func&#39;)
def func():
    print(&quot;原函数执行&quot;)

if __name__ == &#39;__main__&#39;:
    print(func.__name__)

###################################################
wrapper</code></pre><p>为解决这个问题，可使用<code>@wraps(func)</code>方法，具体如下。</p>
<pre><code>from functools import wraps

def gg(name):
    def decoratre(func):
        @wraps(func)
        def wrapper():
            print(&#39;{}:start&#39;.format(name))
            func()
            print(&#39;{}:end&#39;.format(name))
        return wrapper
    return decoratre

@gg(&#39;func&#39;)
def func():
    print(&quot;原函数执行&quot;)

if __name__ == &#39;__main__&#39;:
    print(func.__name__)

####################################################
func</code></pre><h3 id="类的装饰器"><a href="#类的装饰器" class="headerlink" title="类的装饰器"></a>类的装饰器</h3><p>对一些类都需要添加一些共有的方法，可以用类的装饰器实现</p>
<p>基本使用方法如下：</p>
<pre><code>def decorate(cls):
    cls.func = lambda self: print(&quot;新方法&quot;)
    return cls

@decorate
class Pig():
    pass

if __name__ == &#39;__main__&#39;:
    pig = Pig()
    pig.func()

##########################################
新方法</code></pre><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>迭代器是一个可以<strong>记住遍历的位置的对象</strong>。迭代器对象从集合的第一个元素开始访问，直到所有的元素被访问完结束。迭代器只能往前不会后退。字符串，列表或元组对象都可用于创建迭代器。同时，迭代器有两个基本的方法：<strong>iter()</strong> 和 <strong>next()</strong>。</p>
<p>把一个类作为一个迭代器使用需要在类中实现两个方法<code>__iter__</code>和<code>__next__</code>。<code>__iter__()</code>方法返回一个特殊的迭代器对象。<code>__next__()</code> 方法会返回下一个迭代器对象。</p>
<p>以下代码实现了一个计算平方的迭代器。</p>
<pre><code>class Square():
    value = 0

    def __iter__(self):
        return self

    def __next__(self):
        self.value += 1
        return self.value ** 2

if __name__ == &#39;__main__&#39;:
    test = Square()
    print(test.__next__())
    print(test.__next__())
    print(next(test))</code></pre><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>在 Python 中，使用了<code>yield</code> 的函数被称为生成器（generator）。在调用生成器运行的过程中，每次遇到<code>yield</code> 时函数会暂停并保存当前所有的运行信息，返回 <code>yield</code>的值, 并在下一次执行<code>next()</code>方法时从当前位置继续运行。</p>
<pre><code>def square():
    for i in range(5):
        yield i ** 2</code></pre>]]></content>
      <categories>
        <category>Python</category>
        <category>语言基础</category>
      </categories>
  </entry>
  <entry>
    <title>Python函数相关内容</title>
    <url>/page/python2.html</url>
    <content><![CDATA[<h3 id="Python函数的基本特性"><a href="#Python函数的基本特性" class="headerlink" title="Python函数的基本特性"></a>Python函数的基本特性</h3><h4 id="Python函数为对象"><a href="#Python函数为对象" class="headerlink" title="Python函数为对象"></a>Python函数为对象</h4><p>Python中的函数都是对象，这也使得其具备了一些对象的通用特性。</p>
<ul>
<li><p>可作为<strong>值传递</strong>，赋值给另一个对象；</p>
</li>
<li><p>可以作为元素添加到集合对象中；</p>
</li>
<li><p>可以作为参数传递给其他函数；</p>
</li>
<li><p>可以作为函数的返回值。</p>
</li>
</ul>
<p>1、函数赋值给变量，通过变量可以调用。且传递方法为<strong>值传递</strong>，这也就意味着即使删除函数f1，temp仍然能够正常运行。</p>
<pre><code>def f1(str):
  return len(str)
temp=f1    # 函数赋值给对象
del f1    # 删除函数
print temp(&#39;hello&#39;)    # 仍然正常调用</code></pre><p>2、作为元素添加进入容器。</p>
<pre><code>def f2(str1,str2):
   return str1+str2
a=[]
a.append(f1)
a.append(f2)
print a[0](&#39;hello&#39;)
print a[1](&#39;hello&#39;,&#39;world&#39;)</code></pre><p>3、作为函数参数</p>
<pre><code>def func(f,str):
  return f(str)
print func(f1,&#39;hello&#39;)</code></pre><p>4、作为函数返回值</p>
<pre><code>def mutiply(x,y):
  reutrn x*y
def sub(x,y):return x-y
def func2(i):if i==1: return mutiplyelse:return sub
temp=func2(2)
print temp(2,4)</code></pre><p><strong>Python函数是最高级别的对象，而不仅仅为一小段代码</strong>。一个函数是一个被其自己定义和执行的对象，参数是一种“成员数据”，所以它们的状态和其他对象一样，会随着每一次调用而改变。</p>
<h4 id="嵌套与闭包"><a href="#嵌套与闭包" class="headerlink" title="嵌套与闭包"></a>嵌套与闭包</h4><p>1、函数的嵌套</p>
<pre><code>def fun1():
    def fun2():
        def fun3():
            print(&quot;Hello world!&quot;)
        return fun3
    return fun2
fun1()()()
##########################################
Hello world!</code></pre><p>2、函数的闭包</p>
<p><strong>闭包函数就是函数可以读取到与自己不是一个作用域的局部变量</strong></p>
<ol>
<li>必须有一个内嵌函数</li>
<li>内嵌函数必须引用外部函数中的变量</li>
<li>外部函数的返回值必须是内嵌函数</li>
</ol>
<pre><code>def fun1(x):
    def fun2(y):
        print(x+y)
    return fun2
fun1(2)(3)
#############################
5</code></pre><p><strong>装饰器，匿名函数，map函数等都是函数的变体，都是通过这些基本特性来实现的</strong></p>
<p><strong>装饰器</strong>：使用函数的嵌套，外层函数传进来的参数为一个函数对象，里层函数对传进来的函数进行加工处理后再返回处理的函数</p>
<h3 id="函数的一些传参方法"><a href="#函数的一些传参方法" class="headerlink" title="函数的一些传参方法"></a>函数的一些传参方法</h3><h4 id="关键字传参"><a href="#关键字传参" class="headerlink" title="关键字传参"></a>关键字传参</h4><p>可以增强代码可读性，每次传参都需要指定形参名，以下就是关键字传参。</p>
<pre><code>def func(a,b):
    pass
func(a=1,b=2)</code></pre><p><strong>Tip：</strong> * 代表之后所有参数传参时必须使用关键字传参（混合形式传参）</p>
<pre><code>def func(p1,*,p2,p3):
    print(p2+p3)
func(1,p2=2,p3=3)

# 输出
5</code></pre><p>以下代码中p2、p3不使用关键字传参即会报错。</p>
<pre><code>def func(p1,*,p2,p3):
    print(p2+p3)
func(1,2,3)

# 输出（报错）
TypeError                                 Traceback (most recent call last)
&lt;ipython-input-17-83e9b0e5315e&gt; in &lt;module&gt;
      1 def func(p1,*,p2,p3):
      2     print(p2+p3)
----&gt; 3 func(1,2,3)

TypeError: func() takes 1 positional argument but 3 were given</code></pre><h4 id="列表传参"><a href="#列表传参" class="headerlink" title="列表传参"></a>列表传参</h4><p>将列表传入函数，只要在列表名前面加上*即可传入</p>
<pre><code>def func(a, b):
    print(a+b)
l = [1, 2]
func(*l)

# 输出
3</code></pre><h4 id="字典传参"><a href="#字典传参" class="headerlink" title="字典传参"></a>字典传参</h4><p>将字典你传入函数，只需要在字典名前面加上**即可，这种方法可以先将参数写为json格式之后进行传入。</p>
<pre><code>def func(a,b,c):
    print(a+b+c)
param = {&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3}
func(**param)

# 输出
6</code></pre><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>很好理解，在定义函数时指定该参数的值即可。</p>
<pre><code># 参数a默认为1
def func(a=1):
    pass</code></pre><h3 id="可变参数（重要特性）"><a href="#可变参数（重要特性）" class="headerlink" title="可变参数（重要特性）"></a>可变参数（重要特性）</h3><p>在定义函数时，不限定参数的个数，而使用<em>args和*</em>kwargs表示。<em>args为元组，*</em>kwargs为字典。</p>
<p>*args将参数打包为tuple给函数体使用，实例如下：</p>
<pre><code>def func(a, *args):
    print(a)
    print(type(a))
    print(args)
    print(type(args))
func(&#39;gg&#39;, 1, 2, &#39;gg3&#39;)

######################################
gg
&lt;class &#39;str&#39;&gt;
(1, 2, &#39;gg3&#39;)
&lt;class &#39;tuple&#39;&gt;</code></pre><p>**kwargs将参数打包为dict给函数使用，调用时实参为key=value的形式。</p>
<pre><code>def func(a, **kwargs):
    print(a)
    print(type(a))
    print(kwargs)
    print(type(kwargs))
func(&#39;gg&#39;, b=1, c=1)

############################################
gg
&lt;class &#39;str&#39;&gt;
{&#39;b&#39;: 1, &#39;c&#39;: 1}
&lt;class &#39;dict&#39;&gt;</code></pre><h4 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h4><p>当多种参数组合使用时，参数定义顺序为必选参数、默认参数、可变参数。</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>可以简单理解为调用函数的函数。</p>
<h4 id="lambda表达式"><a href="#lambda表达式" class="headerlink" title="lambda表达式"></a><code>lambda</code>表达式</h4><p>lambda是python中的一种表达式，创建内嵌的简单<strong>匿名函数</strong>。可以避免取函数名</p>
<pre><code>f = lambda i:i**2
f(2)
# 4</code></pre><h4 id="filter函数"><a href="#filter函数" class="headerlink" title="filter函数"></a>filter函数</h4><p>filter(func, seq)     返回seq中所有满足func结果为真的对象，可以简单理解为一个过滤器。</p>
<pre><code># 找到所有奇数
l = range(10)
a = filter(lambda n: n%2!=0, l)
print(list(a))
# [1, 3, 5, 7, 9]</code></pre><h4 id="map函数"><a href="#map函数" class="headerlink" title="map函数"></a>map函数</h4><p>map (func, seq) 返回对seq执行func后的值，可以简单理解为一个映射。</p>
<pre><code># 找到数的所有平方
l = range(5)
a = map(lambda n: n**2, l)
print(list(a))
# [0, 1, 4, 9, 16]</code></pre>]]></content>
      <categories>
        <category>Python</category>
        <category>语言基础</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python类的使用</title>
    <url>/page/python3.html</url>
    <content><![CDATA[<h3 id="一些基本内容"><a href="#一些基本内容" class="headerlink" title="一些基本内容"></a>一些基本内容</h3><p>_name：单前置下划线，私有化属性或方法，类对象和子类可以访问，from somemodule import *禁止导入</p>
<p>__name：双前置下划线，私有化属性或方法，无法在外部直接访问（名字重整所以访问不到）</p>
<p>__name__：系统定义的名字，自己不要创建</p>
<p>Python的析构函数<code>__del__(self)</code>。默认会直接进行操作。</p>
<pre><code># 判断是否为子类
issubclass(cat, animal)</code></pre><h3 id="调用父类方法"><a href="#调用父类方法" class="headerlink" title="调用父类方法"></a>调用父类方法</h3><p><code>super()</code>方法</p>
<p>若方法重名，先继承的优先调用</p>
<pre><code>class A():
    def test(self):
        print(&quot;我是爸爸&quot;)

class B(A):
    def test(self):
        super().test()
        print(&quot;我是儿子&quot;)

if __name__ == &#39;__main__&#39;:
    b = B()
    b.test()

#############################################
我是爸爸
我是儿子</code></pre><h3 id="property"><a href="#property" class="headerlink" title="@property"></a>@property</h3><p>@property：将类的方法当做属性来使用（可以简单理解为调用时可以将函数的括号去掉）</p>
<p>一般用来获取某些数据（如获取私有变量），不会向函数中传递参数</p>
<pre><code>class pig():
    def __init__(self, name):
        self.__name = name

    @property
    def name(self):
        return self.__name

p = pig(&quot;猪&quot;)
print(p.name) # 等价于不加@property时的，p.name()

# 猪</code></pre><p>@*.setter 表示可读可写，可以向该函数中传递参数，使用方法为<code>对象.函数名 = 参数值</code>。一般用来设置某些数据。</p>
<pre><code>class Pig():
    def __init__(self, name):
        self.__name = name

    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, name):
        # 在这即可对需要设置的值进行类型判断等操作
        self.__name = name

if __name__ == &#39;__main__&#39;:
    p = Pig(&#39;pig1&#39;)
    print(p.name)
    p.name = &#39;pig2&#39; # 可进行更改
    print(p.name)

​```
pig1
pig2
​```</code></pre><h3 id="slots-lt-限制类中的属性-gt"><a href="#slots-lt-限制类中的属性-gt" class="headerlink" title="_slots_&lt;限制类中的属性&gt;"></a>_<em>slots_</em>&lt;限制类中的属性&gt;</h3><p>为指定的类设置一个静态属性列表，为属性很少的类节约内存空间，同时提供更快的属性访问速度</p>
<p>使用<code>__slots__</code>后<strong>不允许给类添加新的属性与方法</strong>（对其子类也适用，子类新加的会拼接到后面）。示例如下：</p>
<pre><code># 不加__slots__
class B():
    pass

b = B()
b.gg = 1
print(b.gg)

###############################
1</code></pre><pre><code># 加上__slots__
class A():
    __slots__ = (&#39;name&#39;)
    def __init__(self, name):
        self.name = name

if __name__ == &#39;__main__&#39;:
    a = A(&#39;aa&#39;)
    a.gg = 1
    print(a.gg)

###############################################
Traceback (most recent call last):
  File &quot;C:/Users/lenovo/Desktop/python学习/decorate.py&quot;, line 13, in &lt;module&gt;
    a.gg = 1
AttributeError: &#39;A&#39; object has no attribute &#39;gg&#39;</code></pre><p>可见，使用__slots__指定了类的属性后就无法对实例添加属性了</p>
<h3 id="Python类中的方法"><a href="#Python类中的方法" class="headerlink" title="Python类中的方法"></a>Python类中的方法</h3><p>Python类中的方法主要可以分为以下三种：</p>
<ul>
<li>实例方法：需要绑定要一个对象上，第一个参数默认使用self，会把对象作为第一个参数传递进来</li>
<li>静态方法：使用装饰器@staticmethod进行定义，类和对象都可以调用，不需要默认参数</li>
<li>类方法：使用装饰器@classmethod进行定义，类和对象都可以调用，第一个参数默认使用cls，会把类作为第一个参数传递进来</li>
</ul>
<h4 id="staticmethod，静态方法"><a href="#staticmethod，静态方法" class="headerlink" title="@staticmethod，静态方法"></a>@staticmethod，静态方法</h4><p>静态方法，可以直接通过类名对其进行调用（类的实例也可以调用 ）。相当于变为了”类的方法”。&lt;类和对象都可以调用，不需要默认参数（如self等）&gt;</p>
<pre><code>class Pig():
    @staticmethod
    def func():
        print(&quot;聪明的猪&quot;)

Pig()

#############################################
聪明的猪</code></pre><h4 id="classmethod，类方法"><a href="#classmethod，类方法" class="headerlink" title="@classmethod，类方法"></a>@classmethod，类方法</h4><p>用于表示类的方法，可以<strong>不实例化调用类的属性和方法</strong>。有一个<code>cls</code>参数用于表示类本身。&lt;类和对象都可以调用，第一个参数默认使用cls，会把类作为第一个参数传递进来&gt;</p>
<pre><code>class A():
    def test(self):
        print(&quot;test&quot;)

    @classmethod
    def gg(cls):
        cls().test()

A.gg()

############################################
test</code></pre><h4 id="动态添加实例方法"><a href="#动态添加实例方法" class="headerlink" title="动态添加实例方法"></a>动态添加实例方法</h4><pre><code>class A():
    pass

def func(self):
    pass

a = A()
a.func = types.MethodType(func, a)    # 给实例添加方法</code></pre><p>如上，可以使用types.MethodType的方式给类的实例添加其实例方法，但该对象的另一个实例则不具备该方法。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>语言基础</category>
      </categories>
  </entry>
  <entry>
    <title>Python模块与文件读写</title>
    <url>/page/python4.html</url>
    <content><![CDATA[<h2 id="模块与包"><a href="#模块与包" class="headerlink" title="模块与包"></a>模块与包</h2><h3 id="导入模块时Python的操作"><a href="#导入模块时Python的操作" class="headerlink" title="导入模块时Python的操作"></a>导入模块时Python的操作</h3><p>当程序导入一个模块时，Python解析器对模块位置的搜索顺序为：</p>
<ol>
<li>当前目录</li>
<li>若当前目录搜索不到，Python则搜索在shell变量PYTHONPATH下的每个目录。</li>
<li>若都找不到，Python会察看默认路径。UNIX下，默认路径一为/usr/local/lib/python/。</li>
</ol>
<p>模块搜索路径存储在 system 模块的<strong>sys.path</strong> 变量中。变量里包含当前目录、PYTHONPATH和由安装过程决定的默认目录。</p>
<h3 id="模块常用函数"><a href="#模块常用函数" class="headerlink" title="模块常用函数"></a>模块常用函数</h3><p>1、<strong>dir()——列出对象的所有属性和方法</strong>。dir() 函数返回一个排好序的字符串列表，内容是一个模块里定义过的名字。返回的列表容纳了在一个模块里定义的所有<strong>模块</strong>，<strong>变量</strong>和<strong>函数</strong>。</p>
<p>2、<strong>help()——查看类、方法的帮助信息</strong></p>
<p>3、<strong>_<em>name_</em> ——模块的名称</strong></p>
<p>4、_<em>file_</em> ——文件全路径</p>
<h2 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h2><h3 id="open函数及其他基本操作"><a href="#open函数及其他基本操作" class="headerlink" title="open函数及其他基本操作"></a>open函数及其他基本操作</h3><p>Python使用<strong>open()</strong>打开文件，并返回文件的一个句柄。具体的参数为<strong>文件句柄 = open(‘文件路径’,打开模式, 编码方式)</strong>。其中编码方式encoding如果没有指定，将采用系统自带的编码方式。</p>
<pre><code>f = open(&#39;aa.txt&#39;)
print(f)
f.close()
####################################################
&lt;_io.TextIOWrapper name=&#39;aa.txt&#39; mode=&#39;r&#39; encoding=&#39;cp936&#39;&gt;</code></pre><p>由以上输出可以看到，没指定打开模式时文件默认为只读模式（r），这时使用写入操作就会出错，常用的文件打开方式主要有以下几个。</p>
<p>1、<strong>r</strong>，只读的方式打开（文件必须存在，若文件不存在会抛出异常）。文件以什么编码写就以什么编码打开。</p>
<p>2、<strong>w</strong>，只写模式（文件不可读，若文件不存在，则创建一个新的文件，如果文件存在，则会清空里面的内容）</p>
<p>3、<strong>a</strong>，只追加写的模式 （文件不可读，不存在则创建新的文件，文件存在的话，可在后面追加内容）</p>
<p>4、<strong>b</strong>，对于非文本的文件，使用b的模式。’b’表示以字节的方式进行操作 如：rb,wb,ab 分别对应以上内容，如果以b的方式打开，读取到的内容是字节类型</p>
<pre><code># aa.txt文件中为一行字符串“hello world!”
f = open(&#39;aa.txt&#39;, mode=&#39;rb&#39;)
print(f.read())
f.close()
####################################
b&#39;hello world!&#39;</code></pre><p>5、<strong>’+‘模式</strong>，r+: 读写模式  w+:写读模式  a+：写读模式。在 <strong>r+</strong> 模式下，应该先读，后写，如果先写，后读，同样的道理，光标移动到了文件末尾，将读取不到内容。</p>
<p>同时使用<strong>open</strong>打开了一个文件操作完成后必须进行关闭，关闭文件使用<strong>close()</strong>。由于文件操作的这一性质，可以使用<strong>with</strong>关键字进行操作，如下：</p>
<p><strong>with 上下文管理器（到达语句末尾，将自动关闭文件）</strong></p>
<pre><code>with open(&quot;*.txt&quot;) as f
    pass</code></pre><h3 id="与文件读写相关的一些功能函数"><a href="#与文件读写相关的一些功能函数" class="headerlink" title="与文件读写相关的一些功能函数"></a>与文件读写相关的一些功能函数</h3><p>1、读取文件的操作</p>
<pre><code># 读取文件，可以输入读取几个字符
read()
# 读取一行数据，也可以读取参数
readline()
# 读取所有行，并返回列表，之后可以通过对列表进行遍历得到数据
readlines()</code></pre><p>2、写入文件的操作</p>
<pre><code># 向文件中写入内容
write()
# 输入一个列表，将列表内容分别写入
wirtelines([])</code></pre><p>3、其他操作（文件定位操作）</p>
<p><strong>tell()</strong>方法告诉你文件内的当前位置, 换句话说，下一次的读写会发生在文件开头这么多字节之后。</p>
<p><strong>seek(offset [,from])</strong>方法改变当前文件的位置。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>语言基础</category>
      </categories>
  </entry>
  <entry>
    <title>Python异常处理</title>
    <url>/page/python6.html</url>
    <content><![CDATA[<h3 id="异常基本概述"><a href="#异常基本概述" class="headerlink" title="异常基本概述"></a>异常基本概述</h3><ol>
<li>每个异常都是某个类的实例</li>
<li>发生了异常如果不捕获，程序将终止执行</li>
<li>有一些内置的异常类（Exception等）</li>
</ol>
<h3 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h3><p> <code>try except</code>句式</p>
<pre><code>def test(a, b):
    return a/b

if __name__ == &#39;__main__&#39;:
    try:
        print(test(2, 0))
    except:
        print(&quot;出错了&quot;)

#############################
出错了</code></pre><p>检测出错类型的方法</p>
<pre><code>def test(a, b):
    return a/b

if __name__ == &#39;__main__&#39;:
    try:
        print(test(2, &#39;a&#39;))
    except ZeroDivisionError:
        print(&quot;除数为0&quot;)
    except TypeError:
        print(&quot;类型出错&quot;)

#######################################
类型出错</code></pre><p>获取出错信息</p>
<pre><code>def test(a, b):
    return a/b

if __name__ == &#39;__main__&#39;:
    try:
        print(test(2, &#39;a&#39;))
    except (ZeroDivisionError, TypeError) as e:
        print(e)

############################################
unsupported operand type(s) for /: &#39;int&#39; and &#39;str&#39;</code></pre><p>处理必须处理的语句（finally中的语句不管有没有问题都会执行）</p>
<p><code>try except finally</code>语句</p>
<pre><code>def test(a, b):
    return a/b

if __name__ == &#39;__main__&#39;:
    try:
        print(test(2, &#39;a&#39;))
    except (ZeroDivisionError, TypeError) as e:
        print(e)
    finally:
        print(&quot;我必须处理&quot;)

#################################################
unsupported operand type(s) for /: &#39;int&#39; and &#39;str&#39;
我必须处理</code></pre><h3 id="自定义异常和抛出异常"><a href="#自定义异常和抛出异常" class="headerlink" title="自定义异常和抛出异常"></a>自定义异常和抛出异常</h3><p>通过继承<strong>Exception类</strong>来定义异常，通过使用<strong>raise</strong>关键字来抛出异常。</p>
<p>1、<strong>自定义异常</strong>。通过创建一个继承自Exception类的新的异常类来记录自己的异常</p>
<pre><code>class test(Exception):
    pass

if __name__ == &#39;__main__&#39;:
    if True:
        raise test(&#39;出现了自定义的测试错误&#39;)

######################################################
Traceback (most recent call last):
  File &quot;C:/Users/lenovo/Desktop/python学习/decorate.py&quot;, line 7, in &lt;module&gt;
    raise test(&#39;出现了自定义的测试错误&#39;)
__main__.test: 出现了自定义的测试错误</code></pre>]]></content>
      <categories>
        <category>Python</category>
        <category>语言基础</category>
      </categories>
  </entry>
  <entry>
    <title>python常见问题</title>
    <url>/page/python-common-method.html</url>
    <content><![CDATA[<h2 id="项目常用"><a href="#项目常用" class="headerlink" title="项目常用"></a>项目常用</h2><h3 id="生成requirements-txt"><a href="#生成requirements-txt" class="headerlink" title="生成requirements.txt"></a>生成requirements.txt</h3><p>使用<code>pipreqs</code>生成requirements</p>
<pre><code># 安装
pip install pipreqs
# 在当前目录生成（若存在即覆盖）
pipreqs . --encoding=utf8 --force</code></pre><p>使用requirement.txt安装依赖：</p>
<pre><code class="\">pip install -r requirements.txt</code></pre>
<h2 id="pythonic的编码方式"><a href="#pythonic的编码方式" class="headerlink" title="pythonic的编码方式"></a>pythonic的编码方式</h2><h3 id="变量的交换"><a href="#变量的交换" class="headerlink" title="变量的交换"></a>变量的交换</h3><pre><code>a, b = b, a</code></pre><h3 id="利用百分号语法进行字符串格式化"><a href="#利用百分号语法进行字符串格式化" class="headerlink" title="利用百分号语法进行字符串格式化"></a>利用百分号语法进行字符串格式化</h3><pre><code>a = &#39;Curry&#39;
b = &#39;Player&#39;
print(&quot;%s is the best %s&quot; % (a,b))
#################
Curry is the best Player</code></pre><h3 id="将两个字典合并（解包操作）"><a href="#将两个字典合并（解包操作）" class="headerlink" title="将两个字典合并（解包操作）"></a>将两个字典合并（解包操作）</h3><pre><code>a = {}
b = {}
c = {**a, **b}    # 解包</code></pre>]]></content>
      <categories>
        <category>Python</category>
        <category>语言基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python的一些语言特性与机制</title>
    <url>/page/python8.html</url>
    <content><![CDATA[<p>代码高效、程序健壮</p>
<p>值的类型，引用类型</p>
<p>内存共享机制</p>
<p>垃圾回收机制</p>
<p>以引用计数为主，分代收集为辅</p>
<p>每个对象都有指向该对象的引用总数</p>
<pre><code>sys.getrefcount()</code></pre><p>满足特定条件，自动启动垃圾回收</p>
<p>Python运行时，会记录分配对象与取消分配对象的次数。当两者差值高过阈值时。</p>
<pre><code># 查看阈值
gc.get_threshold()</code></pre><p>所有新建对象都是0代对象。所有对象分为0，1，2代。当某一代对象经历过垃圾回收，依然存活，则被归入下一代</p>
<p>若一个对象的引用数为0，Python虚拟机就会回收这个对象的内存</p>
<p>引用计数的缺陷是循环引用的问题</p>
<p>递归运行时报错“RecursionError”。这是python默认的递归深度是很有限的（默认是1000），因此当递归深度超过999的样子，就会引发这样的一个异常。</p>
<p>解决方法：首先考虑对代码进行优化，其次也可以考虑将递归深度的数值调大一些。</p>
<pre><code>import sys
sys.setrecursionlimit(100000) #你想设置的递归深度（可为任意值）</code></pre>]]></content>
      <categories>
        <category>Python</category>
        <category>语言基础</category>
      </categories>
  </entry>
  <entry>
    <title>Python的线程与进程</title>
    <url>/page/python7.html</url>
    <content><![CDATA[<p>内存池机制：当创建大量消耗小内存的对象时，频繁调用new/malloc会导致大量的内存碎片，使效率降低。</p>
<p>内存池就是预先在内存中申请一定数量的、大小相等的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了再申请新的内存，这样做最显著的优势就是能够减小内存碎片，提升效率</p>
<p>pymalloc</p>
<p>针对小对象，pymalloc会在内存池中申请内存空间</p>
<p>大对象，申请新的内存空间</p>
<h3 id="Python多线程"><a href="#Python多线程" class="headerlink" title="Python多线程"></a>Python多线程</h3><p>进程：一个执行中的程序，每个进程都拥有自己的地址空间、内存、数据栈以及其他用于跟踪执行的辅助数据。操作系统管理其上所有进程，并为这些进程合理分配时间。</p>
<p>threading模块</p>
<p>线程：在同一个进程下执行，并共享相同的上下文。一个进程中的各个线程与主线程共享同一片数据空间。</p>
<p>线程包括开始、执行顺序、结束三部分</p>
<p>可以被抢占（中断）和临时挂起（睡眠）</p>
<p>一般以并发方式执行（是一种属性，并行只是并发问题的可能方法之一，若两个事件互不影响，则两个事件是并发的）</p>
<p>对多核CPU的应用</p>
<p>GIL——全局解释器锁（强制在任何时候只有一个线程可以执行python代码）</p>
<p>I/O密集型应用（如网页之类），CPU密集型应用（数据分析，可借助C或CPP的拓展）</p>
<p>GIL执行顺序</p>
<p>实现一个线程</p>
<pre><code>import threading
import time

class LoopThread(threading.Thread):
    n = 0
    def run(self) -&gt; None:
        while self.n &lt; 5:
            now_thread = threading.current_thread()
            print(&#39;loop now: {0}&#39;.format(now_thread.name))
            print(self.n)
            time.sleep(1)
            self.n += 1

if __name__ == &#39;__main__&#39;:
    now_thread = threading.current_thread()
    print(&#39;now: {0}&#39;.format(now_thread.name))

    t = LoopThread(name=&#39;loop_thread&#39;)
    t.start()
    t.join()

############################################
now: MainThread
loop now: loop_thread
0
loop now: loop_thread
1
loop now: loop_thread
2
loop now: loop_thread
3
loop now: loop_thread
4</code></pre><p>多线程并发</p>
<pre><code>import threading
import time

num = 0

def test(n):
    global num
    num += n
    time.sleep(2)
    num -= n
    time.sleep(1)
    print(&#39;----------------{0}&#39;.format(num))

class testThread(threading.Thread):
    def __init__(self, n, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.n = n

    def run(self) -&gt; None:
        for i in range(1000):
            test(self.n)

if __name__ == &#39;__main__&#39;:
    t1 = testThread(1)
    t2 = testThread(2)
    t1.start()
    t2.start()
    t1.join()
    t2.join()

############################################
----------------0
----------------2
----------------0
----------------2
----------------0
----------------1
----------------0
----------------1</code></pre><p>多线程中的锁</p>
<p><code>RLock</code>在一个线程中锁住了还能够再锁</p>
<p>不能重复锁，否则资源被死锁</p>
<pre><code>import threading
import time

num = 0
lock = threading.Lock()

def test(n):
    global num
    num += n
    time.sleep(2)
    num -= n
    time.sleep(1)
    print(&#39;----------------{0}&#39;.format(num))

class testThread(threading.Thread):
    def __init__(self, n, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.n = n

    def run(self) -&gt; None:
        for i in range(1000):
            lock.acquire()
            try:
                test(self.n)
            finally:
                lock.release()

if __name__ == &#39;__main__&#39;:
    t1 = testThread(1)
    t2 = testThread(2)
    t1.start()
    t2.start()
    t1.join()
    t2.join()

###########################################
----------------0
----------------0
----------------0
----------------0
----------------0
----------------0</code></pre><p>产生死锁</p>
<pre><code>def run(self) -&gt; None:
    for i in range(1000):
        print(&#39;start lock&#39;)
        lock.acquire()
        print(&#39;lock again&#39;)
        lock.acquire()
        print(&#39;lock end&#39;)
        try:
            test(self.n)
        finally:
            lock.release()

###########################################
start lock
lock again
start lock</code></pre><p>线程的调度与优化</p>
<pre><code>import threading, time
from multiprocessing.dummy import Pool as ThreadPool

def run(n):
    time.sleep(1)
    print(threading.current_thread().name, n)

def test():
    t1 = time.time()
    for n in range(10):
        run(n)
    print(time.time() - t1)


if __name__ == &#39;__main__&#39;:
    test()

########################################
MainThread 0
MainThread 1
MainThread 2
MainThread 3
MainThread 4
MainThread 5
MainThread 6
MainThread 7
MainThread 8
MainThread 9
10.0053870677948</code></pre><p>快了很多</p>
<pre><code>import threading, time
from multiprocessing.dummy import Pool as ThreadPool

def run(n):
    time.sleep(1)
    print(threading.current_thread().name, n)

def test_use_thread():
    t1 = time.time()
    ls = []
    for i in range(10):
        t = threading.Thread(target=run, args=(i,))
        ls.append(t)
        t.start()

    for l in ls:
        l.join()
    print(time.time() - t1)

def test():
    t1 = time.time()
    for n in range(10):
        run(n)
    print(time.time() - t1)


if __name__ == &#39;__main__&#39;:
    test_use_thread()

###############################################
Thread-2 1
Thread-3 2
Thread-1 0
Thread-5 4
Thread-4 3
Thread-6 5
Thread-10 9
Thread-8 7
Thread-9 8
Thread-7 6
1.0038871765136719</code></pre><pre><code>def test_use_pool():
    t1 = time.time()
    n_list = range(100)
    pool = Pool(10)
    pool.map(run, n_list)
    pool.close()
    pool.join()
    print(time.time() - t1)</code></pre><p>达到了线程的复用</p>
<h3 id="Python进程"><a href="#Python进程" class="headerlink" title="Python进程"></a>Python进程</h3><p>进程的实现</p>
<pre><code>import time
from multiprocessing import Process

def run(name):
    &quot;&quot;&quot;
    name: 进程名称
    &quot;&quot;&quot;
    print(&quot;进程名称：{}&quot;.format(name))
    time.sleep(5)
    print(&quot;进程完成&quot;)

if __name__ == &#39;__main__&#39;:
    p = Process(target=run, args=(&#39;my process&#39;,))
    p.start()
    p.join()

##############################################
进程名称：my process
进程完成</code></pre><p>使用过os模块下的<code>os.getpid()</code>可以得到当前进程的ID</p>
<p>进程间的通信</p>
<p>多进程中的锁：</p>
]]></content>
      <categories>
        <category>Python</category>
        <category>语言基础</category>
      </categories>
  </entry>
  <entry>
    <title>pygame基础</title>
    <url>/page/pygame-basic-knowledge.html</url>
    <content><![CDATA[<p>官方文档：<a href="https://www.pygame.org/docs/" target="_blank" rel="noopener">https://www.pygame.org/docs/</a></p>
<h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol>
<li>引入相关的包</li>
<li>初始化，pygame.init()</li>
<li>得到屏幕对象，<code>screen = pygame.display.set_mode((320, 240))</code></li>
<li>游戏主循环<ul>
<li>处理游戏事件</li>
<li>更新游戏状态</li>
<li>屏幕重新绘制</li>
</ul>
</li>
</ol>
<p>基本代码框架</p>
<pre><code>import pygame
# 初始化
pygame.init()
# 获取屏幕对象
screen = pygame.display.set_mode((width, height))
# 游戏主循环
while True:
    # 处理游戏事件
    for event in pygame.event.get():
        pass
    # 更新游戏状态（游戏逻辑）

    # 重新绘制屏幕</code></pre><h3 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h3><p>基本流程如下</p>
<pre><code># 加载图片
ball = pygame.image.load(&#39;assets/images/background.png&#39;)

# 图片绘制
    screen.blit(ball, ball.get_rect)
    pygame.display.flip()</code></pre><p>其中<code>get_rect</code>返回值为（left, top, width, height）。前者为图片显示的左上角坐标，后者为图片的长与宽。</p>
<p>绘制其他模块自带的图形</p>
<pre><code>red = pygame.Color(255, 0, 0)
# 画线
pygame.draw.line(screen, red, (10,10), (200, 200),10)
# 画矩形
pygame.draw.rect(screen,red,(10,20,200,300),10)
# 画圆
pygame.draw.circle(screen, red, (100, 100),50,5)</code></pre><h3 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h3><p>可以使用系统默认的字体进行加载，也可以在项目中使用ttf文件作为资源进行加载。</p>
<pre><code># 加载字体（使用系统默认字体进行加载）
red = pygame.Color(255, 0, 0)
fonts = pygame.font.SysFont(&#39;宋体&#39;, 40)
text = fonts.render(&#39;Scores:&#39;, True, red)

# 写于游戏主循环
screen.blit(text, (20, 20))
pygame.display.flip()</code></pre><p>加载项目中所带的ttf文件</p>
<pre><code>fonts = pygame.font.Font(&#39;*.ttf&#39;, 40)</code></pre><h3 id="游戏音效"><a href="#游戏音效" class="headerlink" title="游戏音效"></a>游戏音效</h3><pre><code># 加载音乐
bgm = pygame.mixer_music.load(&#39;assets/sounds/game_bg_music.mp3&#39;)
# 循环播放
pygame.mixer_music.play(-1)</code></pre><p>设置音量大小</p>
<pre><code>pygame.mixer_music.set_volume(0.1) 输入值为（0，1）</code></pre><h3 id="动画切换"><a href="#动画切换" class="headerlink" title="动画切换"></a>动画切换</h3><p>两张图片的切换（pygame貌似不支持使用gif之类的动图）</p>
<p>思路：通过设置帧率进行切换，<code>pygame.time.Clock</code></p>
<pre><code>import sys, pygame
# 初始化
pygame.init()
# 屏幕对象
screen = pygame.display.set_mode((320, 800))

image1 = pygame.image.load(&#39;assets/images/hero1.png&#39;)
image2 = pygame.image.load(&#39;assets/images/hero2.png&#39;)
count = 0
clock = pygame.time.Clock()

# 游戏主循环
while True:

    count += 1
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            sys.exit()
    screen.fill(pygame.Color(255, 255, 255))
    # 每秒60次
    clock.tick(60)
    if count % 5 == 0:
        screen.blit(image1, (20, 20))
    else:
        screen.blit(image2, (20, 20))

    pygame.display.update()</code></pre><h3 id="精灵及精灵组"><a href="#精灵及精灵组" class="headerlink" title="精灵及精灵组"></a>精灵及精灵组</h3><p><strong>精灵</strong>：可以理解为需要操纵的图片（飞机大战中的飞机），一种可以在屏幕上移动的图形对象，并且可以和其他图形对象交互。可以使用pygame绘制，也可以是资源图片。</p>
<p><strong>精灵组</strong>：是一个容器，用于管理组内精灵的绘制与更新，精灵加入精灵组，精灵组会自动调用每一个精灵的方法。</p>
<p>基本使用方法就是，对自己的精灵类继承自<code>pygame.sprite.Sprite</code>，然后填补update之类的方法即可。</p>
<p><strong>碰撞检测</strong>：检测两个精灵有没有重叠的部分</p>
<pre><code># 输入两个精灵，输出为布尔值
res = pygame.sprite.collide_rect(sprite1, sprite2)
# 指定碰撞精度
res = pygame.sprite.collide_rect_ratio(0.5)(sprite1, sprite2)</code></pre>]]></content>
      <categories>
        <category>Python</category>
        <category>游戏</category>
      </categories>
      <tags>
        <tag>pygame</tag>
      </tags>
  </entry>
  <entry>
    <title>Python操作MySQL数据库</title>
    <url>/page/python-mysql-handle.html</url>
    <content><![CDATA[<p><strong>使用<code>mysql.connector</code>模块实现MySQL与Python的交互</strong></p>
<h3 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h3><p>代码示例如下</p>
<pre><code>import mysql.connector

config = {
    &quot;host&quot;: &quot;localhost&quot;,
    &quot;port&quot;: &quot;3306&quot;,
    &quot;user&quot;: &quot;root&quot;,
    &quot;password&quot;: &quot;password&quot;,
    &quot;database&quot;: &quot;demo&quot;
}

con = mysql.connector.connect(**config)

con.close()</code></pre><h3 id="游标（Cursor）"><a href="#游标（Cursor）" class="headerlink" title="游标（Cursor）"></a>游标（Cursor）</h3><p><code>mysql.connector</code>中使用游标来执行SQL语句，并且查询结果也会保存在游标中</p>
<h4 id="执行SQL语句"><a href="#执行SQL语句" class="headerlink" title="执行SQL语句"></a>执行SQL语句</h4><pre><code>curser = con.cursor()
curser.execute()</code></pre><p>示例</p>
<pre><code>curser = con.cursor()
sql = &quot;SELECT ename FROM t_emp;&quot;
curser.execute(sql)
for one in curser:
    print(one[0])</code></pre><p>事务控制</p>
<pre><code>con.start_transaction()
con.commit()
con.rollback()</code></pre><p>异常处理</p>
<pre><code>try:
    con = mysql.connector.connect(**config)
    con.start_transaction()
    con.commit()
except Exception as e:
    con.rollback()
finally:
    if &quot;con&quot; in dir():
        con.close()</code></pre><p>数据库连接池</p>
<pre><code>pool = mysql.connector.pooling.MySQLConnectionPool(
    **config,
    pool_size=10
)
con = pool.get_connection()</code></pre><h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3>]]></content>
      <categories>
        <category>Python</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的魔法方法（Magic Method）</title>
    <url>/page/python-magic-method.html</url>
    <content><![CDATA[<h3 id="什么是魔法函数"><a href="#什么是魔法函数" class="headerlink" title="什么是魔法函数"></a>什么是魔法函数</h3><p>所谓魔法函数（Magic Methods），是Python的一种高级语法，允许你在类中自定义函数（函数名格式一般为__xx__），并绑定到类的特殊方法中。比如在类A中自定义<code>__str__()</code>函数，则在调用<code>str(A())</code>时，会自动调用<code>__str__()</code>函数，并返回相应的结果。在我们平时的使用中，可能经常使用<code>__init__</code>函数和<code>__del__</code>函数，其实这也是魔法函数的一种。</p>
<p>Python中每一个魔法函数都对应了一个Python内置函数或操作。比如<code>__str__</code>对应str函数。</p>
<h3 id="构造与析构"><a href="#构造与析构" class="headerlink" title="构造与析构"></a>构造与析构</h3><p>当创建一个对象时，<code>__new__</code>被调用创建类并返回这个类的实例，<code>__init__</code>将传入的参数来初始化该实例。</p>
<blockquote>
<ol>
<li><code>__new__</code>是一个静态方法，而<code>__init__</code>是一个实例方法.</li>
<li><code>__new__</code>方法会返回一个创建的实例，而<code>__init__</code>什么都不返回.</li>
<li>只有在<code>__new__</code>返回一个cls的实例时后面的<code>__init__</code>才能被调用.</li>
<li>当创建一个新实例时调用<code>__new__</code>，初始化一个实例时用<code>__init__</code>.</li>
</ol>
</blockquote>
<p>当对象生命周期结束时，<code>__del__</code>会被调用（作为析构函数）</p>
<h3 id="二元操作符"><a href="#二元操作符" class="headerlink" title="二元操作符"></a>二元操作符</h3><pre><code>+    object.__add__(self, other)
-    object.__sub__(self, other)
*    object.__mul__(self, other)
//    object.__floordiv__(self, other)
/    object.__div__(self, other)
%    object.__mod__(self, other)
**    object.__pow__(self, other[, modulo])
&lt;&lt;    object.__lshift__(self, other)
&gt;&gt;    object.__rshift__(self, other)
&amp;    object.__and__(self, other)
^    object.__xor__(self, other)
|    object.__or__(self, other)</code></pre><h3 id="扩展二元操作符"><a href="#扩展二元操作符" class="headerlink" title="扩展二元操作符"></a>扩展二元操作符</h3><pre><code>+=    object.__iadd__(self, other)
-=    object.__isub__(self, other)
*=    object.__imul__(self, other)
/=    object.__idiv__(self, other)
//=    object.__ifloordiv__(self, other)
%=    object.__imod__(self, other)
**=    object.__ipow__(self, other[, modulo])
&lt;&lt;=    object.__ilshift__(self, other)
&gt;&gt;=    object.__irshift__(self, other)
&amp;=    object.__iand__(self, other)
^=    object.__ixor__(self, other)
|=    object.__ior__(self, other)</code></pre><h3 id="比较方法"><a href="#比较方法" class="headerlink" title="比较方法"></a>比较方法</h3><pre><code>&lt;    object.__lt__(self, other)
&lt;=    object.__le__(self, other)
==    object.__eq__(self, other)
!=    object.__ne__(self, other)
&gt;=    object.__ge__(self, other)
&gt;    object.__gt__(self, other)</code></pre><h3 id="类的表示、输出"><a href="#类的表示、输出" class="headerlink" title="类的表示、输出"></a>类的表示、输出</h3><pre><code>str()    object.__str__(self) 
repr()    object.__repr__(self)
len()    object.__len__(self)
hash()    object.__hash__(self) 
bool()    object.__nonzero__(self) 
dir()    object.__dir__(self)
sys.getsizeof()    object.__sizeof__(self)</code></pre><h3 id="类容器"><a href="#类容器" class="headerlink" title="类容器"></a>类容器</h3><pre><code>len()    object.__len__(self)
self[key]    object.__getitem__(self, key)
self[key] = value    object.__setitem__(self, key, value)
del[key] object.__delitem__(self, key)
iter()    object.__iter__(self)
reversed()    object.__reversed__(self)
in操作    object.__contains__(self, item)
字典key不存在时    object.__missing__(self, key)</code></pre><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://zhuanlan.zhihu.com/p/24567545" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/24567545</a></p>
<p><a href="https://www.cnblogs.com/jhao/p/6022928.html" target="_blank" rel="noopener">https://www.cnblogs.com/jhao/p/6022928.html</a></p>
]]></content>
      <categories>
        <category>Python</category>
        <category>语言基础</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS基础</title>
    <url>/page/css-basic-knowledge.html</url>
    <content><![CDATA[<h2 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><pre><code>选择器{
    k:v;
    k:v;
    k:v;
    k:v;
}

/*
    注释内容
*/</code></pre><h3 id="引用方式"><a href="#引用方式" class="headerlink" title="引用方式"></a>引用方式</h3><h4 id="1、行内样式"><a href="#1、行内样式" class="headerlink" title="1、行内样式"></a>1、行内样式</h4><p>在HTML标签里写</p>
<h4 id="2、内部样式"><a href="#2、内部样式" class="headerlink" title="2、内部样式"></a>2、内部样式</h4><p>在页面的head里采用<code>&lt;style&gt;</code>写</p>
<h4 id="3、链入外部样式：页面加载时，同时加载CSS样式"><a href="#3、链入外部样式：页面加载时，同时加载CSS样式" class="headerlink" title="3、链入外部样式：页面加载时，同时加载CSS样式"></a>3、链入外部样式：页面加载时，同时加载CSS样式</h4><pre><code>&lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; href = &quot;a.css&quot;&gt;&lt;/link&gt;</code></pre><h4 id="4、导入式（-import）：读取完html文件后加载"><a href="#4、导入式（-import）：读取完html文件后加载" class="headerlink" title="4、导入式（@import）：读取完html文件后加载"></a>4、导入式（@import）：读取完html文件后加载</h4><p>写在<code>&lt;style&gt;</code>标签中，且必须是第一句。<code>@import url(a.css);</code></p>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="1、标签选择器"><a href="#1、标签选择器" class="headerlink" title="1、标签选择器"></a>1、标签选择器</h4><pre><code>p {
}</code></pre><h4 id="2、ID选择器"><a href="#2、ID选择器" class="headerlink" title="2、ID选择器"></a>2、ID选择器</h4><pre><code># id1 {
}</code></pre><h4 id="3、类选择器"><a href="#3、类选择器" class="headerlink" title="3、类选择器"></a>3、类选择器</h4><pre><code>.class1 {
}</code></pre><h4 id="4、通用选择器（通配符）"><a href="#4、通用选择器（通配符）" class="headerlink" title="4、通用选择器（通配符）"></a>4、通用选择器（通配符）</h4><p>在初始化时常常使用该选择器将整个网页的边距等去掉</p>
<pre><code>* {
}</code></pre><h4 id="其他组合"><a href="#其他组合" class="headerlink" title="其他组合"></a>其他组合</h4><p>在父子间加上一个空格，如下表示设置div元素的p子元素的样式</p>
<pre><code>&lt;div&gt; &lt;p&gt;&lt;/p&gt; &lt;/div&gt;

div p {
}</code></pre><p>还有交集和并集，分别使用 . 与 , 进行分隔</p>
<h4 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h4><p>同一个标签，根据其<strong>不同的种状态，有不同的样式</strong>。这就叫做“伪类”。伪类用冒号来表示。</p>
<p>比如div是属于box类，这一点很明确，就是属于box类。但是a属于什么类？不明确。因为需要看用户点击前是什么状态，点击后是什么状态。所以，就叫做“伪类”。</p>
<p>1、<strong>静态伪类：</strong>只能用于超链接的样式</p>
<ul>
<li><code>:link</code> 超链接点击之前</li>
<li><code>:visited</code> 链接被访问过之后</li>
</ul>
<p>2、<strong>动态伪类</strong>：针对<strong>所有标签</strong>都适用的样式。如下：</p>
<ul>
<li><code>:hover</code> “悬停”：鼠标放到标签上的时候</li>
<li><code>:active</code>    “激活”： 鼠标点击标签，但是不松手时。</li>
<li><code>:focus</code> 是某个标签获得焦点时的样式（比如某个输入框获得焦点）</li>
</ul>
<h3 id="继承与层叠"><a href="#继承与层叠" class="headerlink" title="继承与层叠"></a>继承与层叠</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>如文字样式等能够继承，如盒子、定位等不能继承</p>
<h4 id="层叠"><a href="#层叠" class="headerlink" title="层叠"></a>层叠</h4><p>层叠性就是css处理冲突的能力。</p>
<p><img src="http://cdn.ziyedy.top/image/CSS%E5%9F%BA%E7%A1%80/%E5%B1%82%E5%8F%A0.jpg" alt=""></p>
<p><strong>以下为计算权重的方法，即优先级</strong>，实际时分别查看以下有没有定义样式，如果有，比较优先级，如果优先级一致，<strong>就近原则（即最后一个进行覆盖）</strong></p>
<p>1、行内样式优先于内部样式，内部样式与链接样式取决于书写先后顺序（后定义覆盖新定义）</p>
<p>2、id选择器&gt;class选择器&gt;标签选择器</p>
<p>3、选择器有权值 ，使用<code>!important;</code>标记优先级最高</p>
<h2 id="盒子模型"><a href="#盒子模型" class="headerlink" title="盒子模型"></a>盒子模型</h2><p>盒子模型如下，即包含外边距（margin）、边界（border）、内边距（padding）和内容的一种模型。</p>
<p><img src="http://cdn.ziyedy.top/image/CSS%E5%9F%BA%E7%A1%80%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3><p>padding为内边距，其区域有背景颜色（与内容区域相同），background-color将填充所有border以内的区域</p>
<h4 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h4><p>四个值：上、右、下、左</p>
<pre><code>padding:30px 40px 30px 40px;</code></pre><p>三个值：上、右、下、（左与右一样）</p>
<p>上下、左右</p>
<pre><code>padding:30px 40px;</code></pre><h3 id="margin"><a href="#margin" class="headerlink" title="margin"></a>margin</h3><p>注意：<strong><code>&lt;body&gt;</code>标签默认有margin，为8px，因此很多情况下都需要加上以下语句清除margin。</strong></p>
<pre><code>* {
    margin: 0;
    padding: 0;
}</code></pre><p>其余操作与padding中差不多</p>
<h3 id="border"><a href="#border" class="headerlink" title="border"></a>border</h3><p>边框主要有三个要素：像素（粗细）、线型、颜色</p>
<pre><code>border: 2px solid red;</code></pre>]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS3：transition与transform</title>
    <url>/page/css3-transition-transform.html</url>
    <content><![CDATA[<h2 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h2><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p><strong>transition实现元素不同状态间的平滑过渡</strong>，可以用来制作动画效果</p>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><pre><code class="css">/* 让哪些属性发生过渡，all表示所有属性 */
transition-property: all;

/*过渡的持续时间*/
transition-duration: 1s;

/*过渡的运动曲线
linear表示线性，ease表示减速，ease-in表示加速
也可以使用cubic-bezier，自定义曲线*/
transition-timing-function: linear;

/*多长时间后执行过渡*/
transition-delay: 1s;

/*综合写法*/
transition: 让哪些属性进行过度 过渡的持续时间 运动曲线 延迟时间;</code></pre>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>给<code>&lt;div class=&quot;box&quot;&gt;&lt;/div&gt;</code>添加如下css代码。</p>
<pre><code>&lt;style&gt;
    .box {
        width: 200px;
        height: 200px;
        background-color: greenyellow;
        margin: 100px auto;
        /* 只渐变宽度，不渐变颜色 */
        transition: width 2s linear 0s;
    }
    .box:hover {
        width: 500px;
        background-color: blue;
    }
&lt;/style&gt;</code></pre><h3 id="transitionend（过渡完成事件）"><a href="#transitionend（过渡完成事件）" class="headerlink" title="transitionend（过渡完成事件）"></a>transitionend（过渡完成事件）</h3><p>transitionend 事件在 CSS <strong>完成过渡后触发</strong>。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>在过渡事件的代码中添加如下代码</p>
<pre><code>&lt;script&gt;
    const div = document.querySelector(&quot;.box&quot;);
    div.addEventListener(&quot;transitionend&quot;, function() {
        alert(&quot;过渡已完成！&quot;);
    })
&lt;/script&gt;</code></pre><h2 id="转换（transform）"><a href="#转换（transform）" class="headerlink" title="转换（transform）"></a>转换（transform）</h2><h3 id="缩放：scale"><a href="#缩放：scale" class="headerlink" title="缩放：scale"></a>缩放：scale</h3><p>参数解释：</p>
<p> x：表示水平方向的缩放倍数；y：表示垂直方向的缩放倍数。大于1表示放大，小于1表示缩小</p>
<pre><code>transform: scale(x, y);
transform: scale(0.8, 1.2)</code></pre><h3 id="位移：translate"><a href="#位移：translate" class="headerlink" title="位移：translate"></a>位移：translate</h3><p>参数为百分比，相对于自身移动。正值为向右和向下，只写一个值代表水平移动</p>
<pre><code>transform: translate(水平位移, 垂直位移);
transform: translate(-30%, 30%);</code></pre><h3 id="旋转：rotate"><a href="#旋转：rotate" class="headerlink" title="旋转：rotate"></a>旋转：rotate</h3><p>正值代表顺时针。</p>
<pre><code>transform: rotate(角度);
transform: rotate(45deg);</code></pre><h4 id="旋转的坐标原点"><a href="#旋转的坐标原点" class="headerlink" title="旋转的坐标原点"></a>旋转的坐标原点</h4><p>参数可为百分比、长度以及定位位置的词（如left，center等）</p>
<pre><code>transform-origin: x-axis y-axis z-axis;</code></pre><h3 id="3D转换"><a href="#3D转换" class="headerlink" title="3D转换"></a>3D转换</h3><h3 id="使用rotateX、rotateY、rotateZ进行旋转"><a href="#使用rotateX、rotateY、rotateZ进行旋转" class="headerlink" title="使用rotateX、rotateY、rotateZ进行旋转"></a>使用rotateX、rotateY、rotateZ进行旋转</h3><pre><code>transform: rotateX(360deg);</code></pre>]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS定位与浮动</title>
    <url>/page/css-float-position.html</url>
    <content><![CDATA[<p>c</p>
<p>传统布局方式：</p>
<blockquote>
<p>display + position + float</p>
</blockquote>
<h2 id="Web标准文档流"><a href="#Web标准文档流" class="headerlink" title="Web标准文档流"></a>Web标准文档流</h2><h3 id="行内元素与块级元素"><a href="#行内元素与块级元素" class="headerlink" title="行内元素与块级元素"></a>行内元素与块级元素</h3><h4 id="行内元素（p、span、a、b、i、u、em等）"><a href="#行内元素（p、span、a、b、i、u、em等）" class="headerlink" title="行内元素（p、span、a、b、i、u、em等）"></a>行内元素（p、span、a、b、i、u、em等）</h4><ul>
<li>与其他行内元素并排；</li>
<li>不能设置宽、高。默认的宽度，就是文字的宽度。</li>
</ul>
<h4 id="块级元素（div等）"><a href="#块级元素（div等）" class="headerlink" title="块级元素（div等）"></a>块级元素（div等）</h4><ul>
<li>霸占一行，不能与其他任何元素并列；</li>
<li>能接受宽、高。如果不设置宽度，那么宽度将默认变为父亲的100%。</li>
</ul>
<h4 id="块级元素转行内元素"><a href="#块级元素转行内元素" class="headerlink" title="块级元素转行内元素"></a>块级元素转行内元素</h4><pre><code>display: inline;</code></pre><h4 id="行内元素转块级元素"><a href="#行内元素转块级元素" class="headerlink" title="行内元素转块级元素"></a>行内元素转块级元素</h4><pre><code>display: block;</code></pre><h3 id="标准文档流"><a href="#标准文档流" class="headerlink" title="标准文档流"></a>标准文档流</h3><p>Web界面可以视为一个流，从上往下，主要有以下特性。</p>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p><strong>1、空白折叠</strong></p>
<p>无论多少个空格、换行、tab，都会折叠为一个空格。</p>
<p><strong>2、同行的元素底边对齐</strong></p>
<p><strong>3、一行空间不够，自动换行</strong></p>
<h4 id="使元素脱离标准文档流的方法"><a href="#使元素脱离标准文档流的方法" class="headerlink" title="使元素脱离标准文档流的方法"></a>使元素脱离标准文档流的方法</h4><ul>
<li>浮动</li>
<li>绝对定位</li>
<li>固定定位</li>
</ul>
<h2 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h2><pre><code>float: left;</code></pre><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>1、浮动元素脱标</p>
<p>2、浮动元素相互贴靠（改变窗口大小即可看到，窗口够大，就会自动贴靠）</p>
<p>3、文字会自动包围浮动元素</p>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><p>避免如下情况导致的布局问题，应当进行浮动清除</p>
<img src="http://cdn.ziyedy.top/image/%E5%89%8D%E7%AB%AF/CSS/CSS%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8/%E6%B5%AE%E5%8A%A8%E5%87%BA%E9%94%99.png" style="zoom: 67%;" />

<h4 id="1、给浮动元素的祖先设置合适的高度（大于孩子的高度）"><a href="#1、给浮动元素的祖先设置合适的高度（大于孩子的高度）" class="headerlink" title="1、给浮动元素的祖先设置合适的高度（大于孩子的高度）"></a>1、给浮动元素的祖先设置合适的高度（大于孩子的高度）</h4><p>缺点：不能适应页面的快速变化</p>
<pre><code>&lt;div&gt;     //设置height
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div&gt;    //设置height
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;</code></pre><h4 id="2、clear-both-（即不允许左侧和右侧有浮动对象）"><a href="#2、clear-both-（即不允许左侧和右侧有浮动对象）" class="headerlink" title="2、clear: both; （即不允许左侧和右侧有浮动对象）"></a>2、clear: both; （即不允许左侧和右侧有浮动对象）</h4><p>缺点：margin失效，两个div之间没有间隙</p>
<pre><code>&lt;div&gt;
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;

&lt;div&gt;   //clear:both;
    &lt;p&gt;&lt;/p&gt;
&lt;/div&gt;</code></pre><h4 id="3、在两个浮动元素之间插入一个div"><a href="#3、在两个浮动元素之间插入一个div" class="headerlink" title="3、在两个浮动元素之间插入一个div"></a>3、在两个浮动元素之间插入一个div</h4><h4 id="4、overflow-hidden"><a href="#4、overflow-hidden" class="headerlink" title="4、overflow: hidden;"></a>4、overflow: hidden;</h4><p>推荐使用，在父元素上添加该元素。</p>
<h2 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h2><h3 id="相对定位"><a href="#相对定位" class="headerlink" title="相对定位"></a>相对定位</h3><p>即相对于元素自己<strong>原来的位置</strong>，进行位置调整。</p>
<p>相对定位<strong>不脱标</strong>，即相对定位的真实位置还在元素的原始位置，只不过影子出去了，可以到处飘。</p>
<h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><pre><code>position: relative;</code></pre><ul>
<li><p>left：盒子右移</p>
</li>
<li><p>right：盒子左移</p>
</li>
<li><p>top：盒子下移</p>
</li>
<li><p>bottom：盒子上移</p>
</li>
</ul>
<p>负数表示相反的方向</p>
<h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><p>1、微调元素</p>
<p>2、作为绝对定位的参考，子绝父相</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>HTML元素</p>
<pre><code>    &lt;div class=&quot;div1&quot;&gt;原始状态&lt;/div&gt;
    &lt;div class=&quot;div2&quot;&gt;绝对定位left40px,top40px&lt;/div&gt;
    &lt;div class=&quot;div3&quot;&gt;原始状态&lt;/div&gt;</code></pre><p>CSS样式</p>
<pre><code class="css">div {
    width: 200px;
    height: 200px;
    background-color: red;
}
.div2{
    position: relative;
    left: 40px;
    top: 40px;
}
.div3{
    background-color: aqua;
}</code></pre>
<p>表现：</p>
<img src="http://cdn.ziyedy.top/image/%E5%89%8D%E7%AB%AF/CSS/CSS%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8/%E7%BB%9D%E5%AF%B9%E5%AE%9A%E4%BD%8D.png" style="zoom: 67%;" />



<h3 id="绝对定位"><a href="#绝对定位" class="headerlink" title="绝对定位"></a>绝对定位</h3><p>定义横纵坐标。原点在父容器的左上角或左下角。横坐标用left表示，纵坐标用top或者bottom表示。</p>
<pre><code>    position: absolute;  /*绝对定位*/
    left: 10px;  /*横坐标*/
    top/bottom: 20px;  /*纵坐标*/</code></pre><h4 id="脱标特性"><a href="#脱标特性" class="headerlink" title="脱标特性"></a>脱标特性</h4><p>即所有的标准文档流的性质，绝对定位之后都不遵守了，标签也不区分所谓的行内元素、块级元素了</p>
<h4 id="参考点"><a href="#参考点" class="headerlink" title="参考点"></a>参考点</h4><p>（1）如果用<strong>top描述</strong>，那么参考点就是<strong>页面的左上角</strong>，而不是浏览器的左上角</p>
<img src="http://cdn.ziyedy.top/image/%E5%89%8D%E7%AB%AF/CSS/CSS%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8/%E5%AE%9A%E4%BD%8D1.png" style="zoom:75%;" />

<p>（2）如果用<strong>bottom描述</strong>，那么参考点就是<strong>浏览器首屏窗口尺寸</strong>（好好理解“首屏”二字），对应的页面的左下角</p>
<img src="http://cdn.ziyedy.top/image/%E5%89%8D%E7%AB%AF/CSS/CSS%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8/%E5%AE%9A%E4%BD%8D2.png" style="zoom:75%;" />

<p>（3）一个绝对定位的元素，如果父辈元素中也出现了已定位（无论是绝对定位、相对定位，还是固定定位）的元素，那么将以父辈这个元素，为参考点。</p>
<img src="http://cdn.ziyedy.top/image/%E5%89%8D%E7%AB%AF/CSS/CSS%E5%AE%9A%E4%BD%8D%E4%B8%8E%E6%B5%AE%E5%8A%A8/%E5%AE%9A%E4%BD%8D3.png" style="zoom:75%;" />

<p>子绝父相：使得整体不脱离文档流</p>
<p>同时，<strong>绝对定位是从父元素的border内侧为参考点，而不是以内容</strong></p>
<h3 id="固定定位"><a href="#固定定位" class="headerlink" title="固定定位"></a>固定定位</h3><p>相对浏览器窗口进行定位。<strong>无论页面如何滚动，这个盒子显示的位置不变</strong>。</p>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>1、网页右下角的“返回到顶部”</p>
<p>2、顶部导航栏（假设顶部导航条的高度是60px，那么，为了防止其他的内容被导航条覆盖，我们要给body标签设置60px的padding-top）</p>
<h3 id="z-index属性"><a href="#z-index属性" class="headerlink" title="z-index属性"></a>z-index属性</h3><p>表示谁压着谁，数值大的压盖住数值小的。</p>
<p>1、默认的z-index值是0</p>
<p>2、定位了的元素，永远能够压住没有定位的元素</p>
<p>3、从父现象：父亲怂了，儿子再牛逼也没用</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客部署到腾讯云服务器全流程</title>
    <url>/page/hexo2.html</url>
    <content><![CDATA[<p>Hexo署到Githubpage上在国内访问速度很慢，正好前段时间买了一个腾讯云服务器，就干脆把hexo生成的博客文件直接放到云上跑算了，本文记录将hexo同时部署到GitHub与腾讯云服务器的过程。参考博客<a href="https://blog.csdn.net/StaunchKai/article/details/82878928" target="_blank" rel="noopener">https://blog.csdn.net/StaunchKai/article/details/82878928</a></p>
<h2 id="部署环境"><a href="#部署环境" class="headerlink" title="部署环境"></a>部署环境</h2><ul>
<li>本地环境<ul>
<li>Ubuntu 18.04（64bit）</li>
<li>所需环境：git，Node.js，hexo</li>
</ul>
</li>
<li>服务器环境<ul>
<li>腾讯云（CentOS 7.6 64bit）</li>
<li>所需环境：git，Nginx</li>
</ul>
</li>
</ul>
<h2 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h2><h3 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h3><p>安装依赖包：</p>
<pre><code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel
yum install  gcc perl-ExtUtils-MakeMaker</code></pre><p>卸载旧版本git（如果服务器自带git太旧的话）</p>
<pre><code>cd /usr/local/src   // 选择文件保存位置
wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.19.0.tar.gz   // 下载链接
tar -zxvf git-2.19.0.tar.gz   // 解压</code></pre><p>具体的版本选择可在<a href="https://mirrors.edge.kernel.org/pub/software/scm/git/" target="_blank" rel="noopener">https://mirrors.edge.kernel.org/pub/software/scm/git/</a> 查看。</p>
<p>编译安装</p>
<pre><code>cd git-2.19.0   // 进入文件夹
make prefix=/usr/local/git all  // 编译源码
make prefix=/usr/local/git install  // 安装至 /usr/local/git 路径</code></pre><p>之后正常的话<code>git --version</code>就可以看到git的版本了，如果在终端输入git没反应，则应该将git的安装位置加入环境变量中。</p>
<h3 id="创建git用户"><a href="#创建git用户" class="headerlink" title="创建git用户"></a>创建git用户</h3><pre><code>adduser git
passwd git
chmod 740 /etc/sudoers
vim /etc/sudoers</code></pre><p>找到以下内容</p>
<pre><code>## Allow root to run any commands anywhere
root    ALL=(ALL)       ALL</code></pre><p>在root的下面添加一行</p>
<pre><code>git ALL=(ALL) ALL</code></pre><p>保存退出后将权限改回来</p>
<pre><code>chmod 400 /etc/sudoers</code></pre><h3 id="密匙配置"><a href="#密匙配置" class="headerlink" title="密匙配置"></a>密匙配置</h3><p>与将本地博客文件连接至GitHub一样，将本地的<code>id_rsa.pub</code>复制好，在服务器创建.ssh下的文件，粘贴进去。</p>
<pre><code>su git
mkdir ~/.ssh
vim ~/.ssh/authorized_keys</code></pre><p>修改权限</p>
<pre><code>cd ~
chmod 600 .ssh/authorzied_keys
chmod 700 .ssh</code></pre><h3 id="测试连接"><a href="#测试连接" class="headerlink" title="测试连接"></a>测试连接</h3><p>在本地终端输入</p>
<pre><code>ssh -v git@SERVER</code></pre><p>SERVER为你的服务器的公网地址，在控制台可以找到，如果成功连接说明服务器git配置成功。</p>
<h3 id="创建网站根目录"><a href="#创建网站根目录" class="headerlink" title="创建网站根目录"></a>创建网站根目录</h3><p>网站根目录就是之后存放博客静态文件与资源的位置，你可以自己挑选位置创建你的根目录，之后再赋予权限。</p>
<pre><code>su root
mkdir /home/myblog    # 此目录为网站的根目录
chown git:git -R /home/myblog</code></pre><h3 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h3><pre><code>yum install -y nginx    // 安装
systemctl start nginx.service     // 启动服务</code></pre><p>此时访问<strong>公网ip/80</strong>应该就能看到nginx的初始界面。</p>
<h3 id="配置Nginx"><a href="#配置Nginx" class="headerlink" title="配置Nginx"></a>配置Nginx</h3><p>使用<code>nginx -t</code>查看配置文件位置，一般为<code>/etc/nginx/nginx.conf</code></p>
<p>打开nginx.conf文件，修改配置文件如下</p>
<pre><code>server {
    listen       80 default_server;
    listen       [::]:80 default_server;
    server_name  www.ziyedy.top;    # 修改为自己的域名
    root         /home/myblog;    # 修改为网站的根目录

    # Load configuration files for the default server block.
    include /etc/nginx/default.d/*.conf;

    location / {
        index index.html    # 设置自己的index网页
    }

    error_page 404 /404.html;
        location = /40x.html {
    }

    error_page 500 502 503 504 /50x.html;
        location = /50x.html {
    }
}
</code></pre><p>之后可以使用<code>nginx -t</code>检查配置文件中是否有语法错误，之后重启服务即可。</p>
<h2 id="hexo自动部署"><a href="#hexo自动部署" class="headerlink" title="hexo自动部署"></a>hexo自动部署</h2><h3 id="建立git裸库"><a href="#建立git裸库" class="headerlink" title="建立git裸库"></a>建立git裸库</h3><p>在与文件同一根目录下建立裸库</p>
<pre><code>su root
git init --bare blog.git</code></pre><p>这时，<code>git</code> 用户的 <code>~</code> 目录下就存在一个 <code>blog.git</code> 文件夹，可使用 <code>ls</code> 命令查看。再修改 <code>blog.git</code> 的权限。</p>
<pre><code>chown git:git -R blog.git</code></pre><h3 id="使用git-hooks同步网站根目录"><a href="#使用git-hooks同步网站根目录" class="headerlink" title="使用git-hooks同步网站根目录"></a>使用git-hooks同步网站根目录</h3><p>在这使用的是 <code>post-receive</code> 这个钩子，当 <code>git</code> 有收发的时候就会调用这个钩子。 在 <code>blog.git</code> 裸库的 hooks 文件夹中，新建 <code>post-receive</code> 文件。</p>
<pre><code>vim blog.git/hooks/post-receive</code></pre><p>填入以下内容，注意myblog应该填入自己的根目录文件名</p>
<pre><code>#!/bin/sh
git --work-tree=/home/hexo --git-dir=/home/git/blog.git checkout -f</code></pre><p>保存后，赋予该文件可执行权限</p>
<pre><code>chmod +x /home/git/blog.git/hooks/post-receive</code></pre><h3 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h3><p>与部署到GitHub相同，在本地博客文件根目录下的<code>_config.yml</code> 文件中修改<code>deploy</code>设置如下。SERVER为服务器的公网ip，如果不想部署到GitHub了将<code>github</code>一行删去即可。</p>
<pre><code>deploy:
  type: git
  repo:
    github: git@github.com:xxxx/xxxx.github.io.git
    git1: git@SERVER:/home/git/blog.git 
  branch: master</code></pre><p>之后正常配置</p>
<pre><code>hexo clean
hexo g
hexo d</code></pre><p>这是输入你的公网ip即可进入你的博客，要实现域名访问，在你的域名内解析你的公网ip即可。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>云服务器</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建</title>
    <url>/page/hexo1.html</url>
    <content><![CDATA[<p>hexo是一个基于Node.js的静态网页生成器，能直接将markdown文件生成为html文件，部署起来十分方便且有许多丰富的开源主题，是搭建博客的不二选择，具体可见<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo官网</a>，本文主要记录在Ubuntu 18.04下的Hexo博客的搭建过程。</p>
<h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><h4 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h4><pre><code>sudo apt-get install git</code></pre><p>可以直接使用命令行进行安装，但这种情况git版本往往较低，因此推荐前往<a href="https://git-scm.com/" target="_blank" rel="noopener">git官网</a>进行下载安装。安装完成后可以使用<code>git --version</code>查看一下版本。</p>
<h4 id="安装Node-js"><a href="#安装Node-js" class="headerlink" title="安装Node.js"></a>安装Node.js</h4><p>进入<a href="http://nodejs.cn/download/" target="_blank" rel="noopener">官网</a>选择下载相关版本的Linux二进制文件（Hexo官网建议使用10.0及以上版本，而apt-get下载版本过老因此此处建议在官网下载最新版本），输入以下命令</p>
<pre><code>tar xf  node-yourversion-linux-x64.tar.xz
cd node-yourversion-linux-x64/
./bin/node -v</code></pre><p>如果显示了版本，说明解压安装成功，但此时在命令行输入node是没有反应的，因此还要输入以下命令设置软连接</p>
<pre><code>ln -s /yourlocation/nodejs/bin/npm /usr/local/bin/ 
ln -s /yourlocation/nodejs/bin/node /usr/local/bin/ </code></pre><p>之后在命令行调用npm与node的相关命令，如果未显示“未找到命令”则说明安装成功。</p>
<h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><pre><code>npm install -g hexo-cli</code></pre><p>在命令行输入以上命令即可安装hexo，但安装过后在命令行输入hexo显示未找到命令（hexo默认安装在与npm相同的位置），因此也要输入以下命令建立软链接。</p>
<pre><code>ln -s /yourlocation/nodejs/bin/hexo /usr/local/bin/ </code></pre><p>之后在命令行测试无误，即安装成功。</p>
<h4 id="初始化博客本地目录"><a href="#初始化博客本地目录" class="headerlink" title="初始化博客本地目录"></a>初始化博客本地目录</h4><p>在你打算作为博客本地目录的文件夹下打开终端输入以下命令即可完成对hexo博客的初始化。</p>
<pre><code>hexo init
npm install</code></pre><p>此时文件夹下会出现如下目录：</p>
<pre><code>.
├── _config.yml     //配置文件，用于配置网站基本信息
├── package.json    //安装相关插件的信息，一般可以忽略其内容
├── scaffolds   //模板文件夹，里面可以更改之后构建相关md文件的模板
├── source  //存放文章与各类资源的地方，被解析后相关内容会被放到生成的public文件夹内
|   ├── _drafts
|   └── _posts
└── themes  //存放主题的地方，可以自己选择或开发主题放进来</code></pre><p>此时在终端输入</p>
<pre><code>hexo s</code></pre><p>如果不出bug，在<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 便能访问到博客的初始界面了。</p>
<h4 id="Windows下的安装方法"><a href="#Windows下的安装方法" class="headerlink" title="Windows下的安装方法"></a>Windows下的安装方法</h4><p>Windows下的安装方法更简单，到相关依赖项的官网上下载一直确定就能够安装成功。之后在git bash下的操作就与Linux基本一致了。</p>
<h3 id="网站部署"><a href="#网站部署" class="headerlink" title="网站部署"></a>网站部署</h3><h4 id="GithubPage"><a href="#GithubPage" class="headerlink" title="GithubPage"></a>GithubPage</h4><ol>
<li><p>创建github账户并在本地创建ssh密匙，之后在github网站中的<strong>setting</strong>中找到SSH相关选项，将本地的ssh密匙添加进去即可（本地的ssh密匙都是在<code>.ssh\id_rsa.pub</code>中可以找到）。</p>
</li>
<li><p>在github下新建仓库，仓库命名必须为<code>&lt;账户名称&gt;.github.io</code></p>
</li>
<li><p>修改本地博客文件中_config.yml中的设置如下</p>
<pre><code>deploy:
type: git
repo: git@github.com:&lt;Github账号名称&gt;/&lt;Github账号名称&gt;.github.io.git
branch: master</code></pre></li>
<li><p>在博客本地目录下使用如下命令即可完成网页的生成与部署。之后在https://&lt;Github账号名称&gt;.github.io即可访问到自己的页面了。</p>
<pre><code>hexo g  //生成
hexo d  //部署</code></pre></li>
</ol>
<h4 id="云服务器"><a href="#云服务器" class="headerlink" title="云服务器"></a>云服务器</h4>]]></content>
      <categories>
        <category>前端</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo实现多台机器同时编写博客</title>
    <url>/page/hexo3.html</url>
    <content><![CDATA[<p>正常情况下，只在一台电脑上使用hexo编写部署博客非常方便，但多台电脑进行部署就需要云盘等媒介进行md文件的传输了。我的电脑是双系统，因此如果要部署的话还得重启，比较麻烦，因此干脆实现一个博客多设备管理，方便快捷。</p>
<p>实现多设备的博客管理关键就是要实现本地hexo源文件的多台设备传输与修改，首先想到的当然是使用git了。本地的<code>_config.yml</code>文件中默认使用<code>hexo d</code>进行部署是部署在GitHub相应项目（也就是以用户名命名的博客项目）的<code>master</code>分支上的，因此，只需要在同一项目上新建一个存储源文件的分支即可解决问题。</p>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>在已经作为博客本地文件的地方打开终端输入以下命令</p>
<pre><code>git branch &lt;hexo&gt;    //hexo处为你想建立的分支的名字</code></pre><p>之后在github中博客仓库的<code>-&gt;Settings-&gt;Branches-&gt;Default branch</code>下将默认分支改为新建的分支，并保存更新。</p>
<h3 id="分支连接本地文件"><a href="#分支连接本地文件" class="headerlink" title="分支连接本地文件"></a>分支连接本地文件</h3><ol>
<li><p>最简单且有效的方法就是将新建的<code>hexo</code>分支<code>git clone</code>到本地文件夹内，输入<code>git branch</code>即可看到当前分支为<code>hexo</code>。</p>
</li>
<li><p>再将之前新建的博客文件复制到以上文件夹中，注意将<code>themes</code>文件中隐藏的<code>.git</code>文件等与git有关的文件删除，否则主题文件会默认为是整个项目的一个子模块而不被上传到你的GitHub。</p>
</li>
<li><p>将之前部署生成的<code>.deploy_git</code>文件删除，否则由于之前删去了部分原来的git信息部署时有可能会发生错误。</p>
</li>
<li><p>输入如下命令你的博客的源码分支hexo就建立好了。</p>
</li>
</ol>
<pre><code>git add .
git commit -m &quot;first push&quot;
git push origin hexo</code></pre><ol start="5">
<li>想在另一台电脑上写博客时。只要确保该电脑安装了hexo所需要的各种环境（再在GitHub上加入ssh密匙），只需要在本地建立一个文件夹将博客源文件<code>clone</code>下来即可。而每次更新上传后，在另一台计算机上只需每次使用<code>git pull</code>更新一下源文件即可十分方便。</li>
</ol>
<h3 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h3><p>多机同时管理博客其实就是在一个github仓库的<code>master</code>分支存储网页静态文件，在<code>hexo</code>分支存储博客源文件。由于hexo进行部署时默认是在<code>master</code>分支上部署（<code>_config.yml</code>文件中可见），因此部署博客时还是输入以下代码即可</p>
<pre><code>hexo g
hexo d</code></pre><p>同时应该注意的是，这样做会使得源文件开源，不想开源的话可以在github仓库中设置该仓库为private。这样该仓库就不可见但gitpage的功能也使用不了了，所以要怎样做仁者见仁智者见智吧。</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>1.1、JS基本数据类型</title>
    <url>/page/js-basic-datatype.html</url>
    <content><![CDATA[<h2 id="字符串：String"><a href="#字符串：String" class="headerlink" title="字符串：String"></a>字符串：String</h2><p>js中的字符串使用” “或者’ ‘进行包裹（跟python相同）。</p>
<pre><code>str1 = &quot;str&quot;;
str2 = &#39;str&#39;;</code></pre><h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h3><p>字符串里面的值不可被改变。虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间（与Java中的String类很像）。</p>
<p>如下，看上去str 的值变了，其实’aaaa’仍然保存在内存中，str只是改为指向了’bbbb’。</p>
<pre><code>var str = &#39;aaaa&#39;;
str = &#39;bbbb&#39;;</code></pre><h3 id="字符串常用操作（长度、拼接）"><a href="#字符串常用操作（长度、拼接）" class="headerlink" title="字符串常用操作（长度、拼接）"></a>字符串常用操作（长度、拼接）</h3><pre><code>// 获取长度
str.length</code></pre><p>拼接字符串使用 “+”即可，很方便。</p>
<h3 id="字符串的查找与替换"><a href="#字符串的查找与替换" class="headerlink" title="字符串的查找与替换"></a>字符串的查找与替换</h3><pre><code>// 返回子字符串的位置，若没有，返回-1
str.indexOf(&quot;char&quot;)

// 从后向前检索
str.lastIndexOf(&quot;char&quot;)

// 替换字符串，将a替换为b
str.replace(a,b)</code></pre><h3 id="子字符串的截取"><a href="#子字符串的截取" class="headerlink" title="子字符串的截取"></a>子字符串的截取</h3><pre><code>str.slice(start, end) // 截取字符串（end索引不在截取范围之内）

str.substring(start, end) // 功能与slice一致

str.substr(start, len) // 从start处截取长为len的字符串</code></pre><h3 id="字符串分割为数组"><a href="#字符串分割为数组" class="headerlink" title="字符串分割为数组"></a>字符串分割为数组</h3><pre><code>str.split(separate) // 把字符串分割为字符串数组，参数为分隔符</code></pre><p>示例</p>
<pre><code>a = &quot;a,b,b,df,s&quot;;
console.log(a);
b = a.split(&#39;,&#39;);
console.log(b);</code></pre><h2 id="数值型：Number"><a href="#数值型：Number" class="headerlink" title="数值型：Number"></a>数值型：Number</h2><h3 id="最大值与最小值"><a href="#最大值与最小值" class="headerlink" title="最大值与最小值"></a>最大值与最小值</h3><pre><code>max = Number.MAX_VALUE;
min = Number.MIN_VALUE;</code></pre><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p>1、使用 Number 表示的变量超过了最大值，则会返回Infinity。<code>typeof Infinity</code>的返回结果是number。</p>
<p>2、<strong>NaN（Not a Number）</strong>，非数值</p>
<pre><code>console.log(&quot;a&quot; / 10);    // NaN
console.log(typeof NaN);    // number</code></pre><p>3、在JS中，<strong>浮点数的运算无法保证较高的精度</strong></p>
<h2 id="布尔型：Boolean"><a href="#布尔型：Boolean" class="headerlink" title="布尔型：Boolean"></a>布尔型：Boolean</h2><p>就是简单的true与false，与数字相加时，<strong>true为1，false为0</strong></p>
<h2 id="Null和Undefined"><a href="#Null和Undefined" class="headerlink" title="Null和Undefined"></a>Null和Undefined</h2><h3 id="Null：空值"><a href="#Null：空值" class="headerlink" title="Null：空值"></a>Null：空值</h3><p>专门用来表示空对象，同时<code>typeof null</code>会返回object。（<strong>null视为空对象</strong>）</p>
<h3 id="undefined：未定义"><a href="#undefined：未定义" class="headerlink" title="undefined：未定义"></a>undefined：未定义</h3><h4 id="1、变量已声明，但是没有赋值"><a href="#1、变量已声明，但是没有赋值" class="headerlink" title="1、变量已声明，但是没有赋值"></a>1、变量已声明，但是没有赋值</h4><pre><code>var a;
console.log(typeof a); // undefined</code></pre><h4 id="2、变量未定义"><a href="#2、变量未定义" class="headerlink" title="2、变量未定义"></a>2、变量未定义</h4><pre><code>console.log(typeof a);    // undefined
console.log(a); // 打印结果：Uncaught ReferenceError: a is not defined</code></pre><h4 id="3、函数无返回值"><a href="#3、函数无返回值" class="headerlink" title="3、函数无返回值"></a>3、函数无返回值</h4><p>如果一个函数没有返回值，那么，这个函数的返回值就是 undefined。</p>
<p>或者，也可以这样理解：在定义一个函数时，如果末尾没有 return 语句，那么，其实就是 <code>return undefined</code>。</p>
<pre><code>function foo() {}
console.log(foo()); // 打印结果：undefined</code></pre><h4 id="4、调用函数时，未传参"><a href="#4、调用函数时，未传参" class="headerlink" title="4、调用函数时，未传参"></a>4、调用函数时，未传参</h4><p>调用函数时，如果没有传参，那么，这个参数的值就是 undefined。</p>
<pre><code>function foo(name) {
    console.log(name);
}

foo(); // 调用函数时，未传参。执行函数后的打印结果：undefined</code></pre><h3 id="两者之间的差别"><a href="#两者之间的差别" class="headerlink" title="两者之间的差别"></a>两者之间的差别</h3><pre><code>console.log(null == undefined);        // true
console.log(null === undefined);    // false</code></pre><p><strong>和数字运算时，null相当于0，而undefined相当于NaN</strong></p>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="其他类型–-gt-String"><a href="#其他类型–-gt-String" class="headerlink" title="其他类型–&gt;String"></a>其他类型–&gt;String</h3><h4 id="1、通过字符串拼接隐式转换"><a href="#1、通过字符串拼接隐式转换" class="headerlink" title="1、通过字符串拼接隐式转换"></a>1、通过字符串拼接隐式转换</h4><pre><code>var a = 1;
a = a + &#39;&#39;;
console.log(typeof a);    // string</code></pre><h4 id="2、调用toString-方法"><a href="#2、调用toString-方法" class="headerlink" title="2、调用toString()方法"></a>2、调用toString()方法</h4><pre><code>变量.toString()</code></pre><p>该方法不会影响到原变量，它会将转换的结果返回，同时，null与undefined没有toString方法。</p>
<h4 id="3、使用String-函数强制转换"><a href="#3、使用String-函数强制转换" class="headerlink" title="3、使用String()函数强制转换"></a>3、使用String()函数强制转换</h4><pre><code>String(变量)</code></pre><ul>
<li><p>对于 Number 和 Boolean 而言，本质上就是调用 toString()方法。</p>
</li>
<li><p>对于 null 和 undefined，它会将 null 直接转换为 “null”。将 undefined 直接转换为 “undefined”。</p>
</li>
</ul>
<h3 id="其他类型–-gt-Number"><a href="#其他类型–-gt-Number" class="headerlink" title="其他类型–&gt;Number"></a>其他类型–&gt;Number</h3><pre><code>parseInt(&quot;str&quot;);
parseFloat(&quot;str&quot;);</code></pre><h3 id="typeof总结"><a href="#typeof总结" class="headerlink" title="typeof总结"></a>typeof总结</h3><table>
<thead>
<tr>
<th align="left">typeof 的代码写法</th>
<th align="center">返回结果</th>
</tr>
</thead>
<tbody><tr>
<td align="left">typeof 数字</td>
<td align="center">number</td>
</tr>
<tr>
<td align="left">typeof 字符串</td>
<td align="center">string</td>
</tr>
<tr>
<td align="left">typeof 布尔型</td>
<td align="center">boolean</td>
</tr>
<tr>
<td align="left">typeof 对象</td>
<td align="center">object</td>
</tr>
<tr>
<td align="left">typeof 方法</td>
<td align="center">function</td>
</tr>
<tr>
<td align="left">typeof null</td>
<td align="center">object</td>
</tr>
<tr>
<td align="left">typeof undefined</td>
<td align="center">undefined</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>1.2、JS内置对象使用</title>
    <url>/page/js-buildin-obj.html</url>
    <content><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组（Array）是内置对象（typeof返回值为object）。数组中的元素可以是任意的数据类型，也可以是对象，也可以是函数，也可以是数组</p>
<h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><pre><code>var arr = [];
var arr = [1, 2];

var arr = new Array();    // 创建一个空数组
var arr = new Array(2);    // 创建一个长度为2的数组
var arr = new Array(1,2,3)    // 创建一个经过初始化的数组</code></pre><h3 id="元素的添加与删除"><a href="#元素的添加与删除" class="headerlink" title="元素的添加与删除"></a>元素的添加与删除</h3><p>在最后添加与删除（<strong>push  pop</strong>）</p>
<pre><code>// 向数组后插入一个或多个元素
新数组长度 = 数组.push(元素);

// 删除数组中最后一个元素
被删除的元素 = 数组.pop();</code></pre><p>在最前添加与删除（<strong>unshift  shift</strong>）</p>
<pre><code>新数组的长度 = 数组.unshift(元素);

被删除的元素 = 数组.shift();</code></pre><h3 id="数组的合并与拆分"><a href="#数组的合并与拆分" class="headerlink" title="数组的合并与拆分"></a>数组的合并与拆分</h3><p>数组的合并（使用cancat函数或使用…语法）</p>
<pre><code>// 连接数组1和作为参数的数组
新数组 = 数组1.concat(数组2, 数组3 ...);</code></pre><pre><code>a = [1,2,3]
b = [3,4,5,...a]
alert(b)    // [3,4,5,1,2,3]</code></pre><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><pre><code>// 颠倒数组
array.reverse()    

// 对数组进行排序（默认升序）
array.sort()

// 传入比较函数，变为降序
// 作为参数的函数返回值大于0，则元素会交换位置
array.sort(function(a, b) {return b-a})
array.slice(start, end)    // 从[start, end)的切片</code></pre><p>转化为字符串，默认无参数则用逗号“,”连接。</p>
<pre><code>str = array.join()
str = array.join(&quot;&quot;)    // 无连接符号直接连接</code></pre><pre><code>// 删除从index处开始的零个或多个元素
array.splice(index, count)
// 在index后插入值
array.splice(index, 0, item1.....)
// 替换
array.splice(index, count, item1.....)</code></pre><h3 id="元素的查找"><a href="#元素的查找" class="headerlink" title="元素的查找"></a>元素的查找</h3><pre><code>// 查找值为value的索引，没有则返回-1
array.indexOf(value)

// 找出第一个满足「指定条件返回 true」的元素
find(func)

// 找出第一个满足「指定条件返回 true」的元素的 index
findIndex(func)</code></pre><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><pre><code></code></pre><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p>Math 和其他的对象不同，它不是一个构造函数，不需要创建对象。所以我们不需要 通过 new 来调用，而是<strong>直接使用里面的属性和方法</strong>即可（数学工具类）。</p>
<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
<th align="left">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Math.PI</td>
<td align="left">圆周率</td>
<td align="left">Math对象的属性</td>
</tr>
<tr>
<td align="left">Math.abs()</td>
<td align="left"><strong>返回绝对值</strong></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Math.random()</td>
<td align="left">生成0-1之间的<strong>随机浮点数</strong></td>
<td align="left">取值范围是 [0，1)</td>
</tr>
<tr>
<td align="left">Math.floor()</td>
<td align="left"><strong>向下取整</strong>（往小取值）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Math.ceil()</td>
<td align="left"><strong>向上取整</strong>（往大取值）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Math.round()</td>
<td align="left">四舍五入取整（正数四舍五入，负数五舍六入）</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Math.max(x, y, z)</td>
<td align="left">返回多个数中的最大值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Math.min(x, y, z)</td>
<td align="left">返回多个数中的最小值</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Math.pow(x,y)</td>
<td align="left">乘方：返回 x 的 y 次幂</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">Math.sqrt()</td>
<td align="left">开方：对一个数进行开方运算</td>
<td align="left"></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>1.3、JS中的类与对象</title>
    <url>/page/js-class-object.html</url>
    <content><![CDATA[<h2 id="创建自定义对象"><a href="#创建自定义对象" class="headerlink" title="创建自定义对象"></a>创建自定义对象</h2><h3 id="使用键值对创建"><a href="#使用键值对创建" class="headerlink" title="使用键值对创建"></a>使用键值对创建</h3><p>举例如下</p>
<pre><code>var obj1 = {
    // 成员
    name: &quot;ziye&quot;,
    // 嵌套的对象
    obj2: {
        name: &quot;gg&quot;
    }
    // 方法
    func1: function() {
        alert(&quot;gg&quot;)
    }
}</code></pre><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>即<strong>使用一个函数将创建好的对象作为返回值</strong>，举例如下</p>
<pre><code>function createObj(name) {
    // 创建一个对象
    var obj = new Object();
    // 向对象中添加属性
    obj.name = name;
    obj.func = function() {
        alert(this.name);
    }
    // 将创建的对象返回
    return obj;
}</code></pre><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>是一种特殊的函数，主要用来创建和初始化对象，也就是为对象的成员变量赋初始值。它与 <strong>new</strong> 一起使用才有意义。是js中从前最通用的构建构造函数的方法，<strong>其中this指的是当前对象的实例</strong></p>
<pre><code>function Obj(name) {
    this.name = name;
    this.func = function() {
        alert(this.name);
    };
}

var o1 = new Obj(&quot;xxx&quot;);</code></pre><h2 id="JS原型对象（prototype）"><a href="#JS原型对象（prototype）" class="headerlink" title="JS原型对象（prototype）"></a>JS原型对象（prototype）</h2><p>所有的 JavaScript 对象都会从一个 prototype（原型对象）中继承属性和方法。</p>
<h3 id="添加属性和方法"><a href="#添加属性和方法" class="headerlink" title="添加属性和方法"></a>添加属性和方法</h3><pre><code>Obj.prototype.attr = newValue;
Obj.prototype.func = function() {}</code></pre>]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>2.1、JS事件处理</title>
    <url>/page/js-event-handle.html</url>
    <content><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件指的是一些特定的交互瞬间，如点击某个元素等等</p>
<p>JavaScript 是以<strong>事件驱动为核心</strong>的一门语言。JavaScript 与 HTML 之间的交互是通过事件实现的。</p>
<h3 id="事件的基本要素"><a href="#事件的基本要素" class="headerlink" title="事件的基本要素"></a>事件的基本要素</h3><ul>
<li><p>事件源：引发后续事件的html标签。</p>
</li>
<li><p>事件：js中已经定义好了（见下图）。</p>
</li>
<li><p>事件驱动程序：对样式和html的操作。也就是DOM。</p>
</li>
</ul>
<p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/js%E4%BA%8B%E4%BB%B6.png" alt=""></p>
<h3 id="事件程序的基本书写"><a href="#事件程序的基本书写" class="headerlink" title="事件程序的基本书写"></a>事件程序的基本书写</h3><h4 id="1、获取事件源"><a href="#1、获取事件源" class="headerlink" title="1、获取事件源"></a>1、获取事件源</h4><p>详见DOM操作中的相关操作，主要有<code>document.getElementById()</code>等方法</p>
<h4 id="2、绑定事件"><a href="#2、绑定事件" class="headerlink" title="2、绑定事件"></a>2、绑定事件</h4><p>以onclick事件为例：</p>
<p><strong>方法1（绑定匿名函数）：</strong></p>
<pre><code>element.onclick = function () {

}</code></pre><p><strong>方法2（addEventListener）：</strong></p>
<pre><code>element.addEventListener(&#39;click&#39;, function () {

}, false);</code></pre><ul>
<li><p>参数1：事件名的字符串(注意，没有on)</p>
</li>
<li><p>参数2：回调函数：当事件触发时，该函数会被执行</p>
</li>
<li><p>参数3：<strong>true表示捕获阶段触发，false表示冒泡阶段触发（默认）</strong>。如果不写，则默认为false。【重要】</p>
</li>
</ul>
<p><strong>方法3（行内绑定）：</strong></p>
<pre><code>&lt;!--行内绑定--&gt;
&lt;div id=&quot;box1&quot; onclick=&quot;fn()&quot;&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    function fn() {
        alert(&quot;我是弹出的内容&quot;);
    }
&lt;/script&gt;</code></pre><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>当事件的响应函数被触发时，会产生一个事件对象<code>event</code>。浏览器每次都会将这个事件<code>event</code>作为实参传进之前的响应函数。</p>
<p>这个对象中包含了与当前事件相关的一切信息。比如鼠标的坐标、键盘的哪个按键被按下、鼠标滚轮滚动的方向等。</p>
<p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/event%E4%BF%A1%E6%81%AF.png" alt=""></p>
<h3 id="获取event对象"><a href="#获取event对象" class="headerlink" title="获取event对象"></a>获取event对象</h3><p>除去以上直接使用event外，标准兼容写法如下</p>
<pre><code>&lt;script&gt;
    //点击页面的任何部分
    document.onclick = function (event) {
        event = event || window.event; //兼容性写法
    }
&lt;/script&gt;</code></pre><h3 id="event属性"><a href="#event属性" class="headerlink" title="event属性"></a>event属性</h3><p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/event%E5%B1%9E%E6%80%A7.png" alt=""></p>
<p>除此之外，还有以下等信息：</p>
<pre><code>keyCode    // 返回响应的键盘信息</code></pre><h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>事件传播的三个阶段是：事件捕获、事件冒泡和目标。</p>
<ul>
<li>事件捕获阶段：事件从祖先元素往子元素查找（DOM树结构），直到捕获到事件目标 target。在这个过程中，默认情况下，事件相应的监听函数是不会被触发的。</li>
<li>事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。</li>
<li>事件冒泡阶段：事件从事件目标 target 开始，从子元素往冒泡祖先元素冒泡，直到页面的最上一级标签。</li>
</ul>
<p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%86%92%E6%B3%A1.png" alt=""></p>
<h3 id="捕获与冒泡实验"><a href="#捕获与冒泡实验" class="headerlink" title="捕获与冒泡实验"></a>捕获与冒泡实验</h3><p>addEventListener函数最后一个参数为true代表事件在捕获阶段执行，为false代表在冒泡阶段进行</p>
<pre><code>&lt;body&gt;
    &lt;div&gt;&lt;p&gt;click here&lt;/p&gt;&lt;/div&gt;
    &lt;script&gt;
        var div = document.getElementsByTagName(&quot;div&quot;)[0];
        var p = document.getElementsByTagName(&quot;p&quot;)[0];
        div.addEventListener(&quot;click&quot;, function() {
            console.log(&quot;div&quot;);
        }, true);
        p.addEventListener(&quot;click&quot;, function() {
            console.log(&quot;p&quot;);
        }, true);
    &lt;/script&gt;
&lt;/body&gt;</code></pre><p><strong>实验结果</strong></p>
<p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/%E5%86%92%E6%B3%A1%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C.png" alt=""></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>1、JS基础</title>
    <url>/page/js-basic-grammer.html</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h3><p>1、解释性语言</p>
<p>2、单线程</p>
<p>3、遵从ECMAScript标准</p>
<p>对换行、缩进、空格不敏感。每一条语句以分号结尾。（分号不是必须加，如果不写分号，浏览器会自动添加，但是会消耗一些系统资源）</p>
<h3 id="JavaScript组成"><a href="#JavaScript组成" class="headerlink" title="JavaScript组成"></a>JavaScript组成</h3><p>JavaScript基础分为三个部分：</p>
<ul>
<li><p><strong>ECMAScript</strong>：JavaScript的语法标准。包括变量、表达式、运算符、函数、if语句、for语句等。</p>
</li>
<li><p><strong>DOM</strong>：文档对象模型（Document object Model），操作<strong>网页上的元素</strong>的API。比如让盒子移动、变色、轮播图等。</p>
</li>
<li><p><strong>BOM</strong>：浏览器对象模型（Browser Object Model），操作<strong>浏览器部分功能</strong>的API。比如让浏览器自动滚动。</p>
</li>
</ul>
<h3 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h3><p>JavaScript中的输入输出主要用于调试</p>
<p>1、弹出警告框：<strong>alert(“str”)</strong></p>
<p>2、控制台输出：<strong>console.log(“str”)</strong></p>
<p>3、弹出输入框：<strong>var a = prompt(“str”)</strong></p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><h3 id="变量基本类型"><a href="#变量基本类型" class="headerlink" title="变量基本类型"></a>变量基本类型</h3><p>ES6前，使用<code>var</code>关键字来声明一个变量</p>
<p><strong>JS中一共有六种数据类型：</strong></p>
<ul>
<li><strong>基本数据类型（值类型，传值）</strong>：String 字符串、Number 数值、Boolean 布尔值、Null 空值、Undefined 未定义。</li>
<li><strong>引用数据类型（引用类型，传址）</strong>：Object 对象（除去五种基本数据类型之外，其他的，都称之为 Object类型）。</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>JS中运算符比较特殊的是<code>==</code>与<code>===</code>。</p>
<p>其中，<code>==</code>这个符号会自动进行隐式转换，将不同的数据类型，转为相同类型进行比较（大部分情况下，都是转换为数字）。而<code>===</code>这个符号在进行比较时不会进行类型转换，是绝对等于。</p>
<h3 id="debug方法"><a href="#debug方法" class="headerlink" title="debug方法"></a>debug方法</h3><p>JavaScript程序中添加断点，使用debugger。示例如下：</p>
<pre><code>&lt;script&gt;
    var a = [1,2,3,4,5];
    for(i=0;i&lt;5;i++){
        console.log(a[i]);
        debugger;
    }
&lt;/script&gt;</code></pre><p>刷新Google页面即可进行debug</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>2、DOM节点基本操作</title>
    <url>/page/js-dom-basic-handle.html</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p><strong>节点</strong>（Node）：构成 HTML 网页的最基本单元。网页中的每一个部分都可以称为是一个节点，比如：html标签、属性、文本、注释、整个文档等都是一个节点。</p>
<h3 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h3><p><strong>DOM</strong>：Document Object Model，文档对象模型。DOM 为文档提供了结构化表示，并定义了如何通过脚本来访问文档结构。目的其实就是为了能让js操作html元素而制定的一个规范。</p>
<p><strong>解析过程</strong>：HTML加载完毕，渲染引擎会在内存中把HTML文档，生成一个DOM树。</p>
<h3 id="文档的加载"><a href="#文档的加载" class="headerlink" title="文档的加载"></a>文档的加载</h3><p>浏览器在加载一个页面时，是按照自上向下的顺序加载的，读取到一行就运行一行。如果将script标签写到页面的上边，在代码执行时，页面及DOM对象还没有加载，会导致无法获取到DOM对象。</p>
<p>onload 事件会在整个页面加载完成之后才触发。为 window 绑定一个onload事件，该事件对应的响应函数将会在页面加载完成之后执行，这样可以确保我们的代码执行时所有的DOM对象已经加载完毕了。</p>
<pre><code>window.onload = function() {
}</code></pre><h2 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h2><h3 id="通过元素获取节点"><a href="#通过元素获取节点" class="headerlink" title="通过元素获取节点"></a>通过元素获取节点</h3><pre><code>// 获取id为“id1”的元素（id唯一）
var id1 = document.getElementById(&quot;id1&quot;);</code></pre><h3 id="通过标签名获取节点"><a href="#通过标签名获取节点" class="headerlink" title="通过标签名获取节点"></a>通过标签名获取节点</h3><pre><code>// 获取标签名为div的 元素节点数组（标签名不唯一）
var div1 = document.getElementsByTagName(&quot;div&quot;);
// 获取该数组中第一个元素
document.getElementsByTagName(&quot;div1&quot;)[0]; </code></pre><h3 id="通过类名获取节点"><a href="#通过类名获取节点" class="headerlink" title="通过类名获取节点"></a>通过类名获取节点</h3><pre><code>// 获取类名为 class1 的元素节点数组
var class1 = document.getElementsByClassName(&quot;class1&quot;);
document.getElementsByClassName(&quot;class1&quot;)[0];</code></pre><h3 id="querySelector-方法"><a href="#querySelector-方法" class="headerlink" title="querySelector()方法"></a>querySelector()方法</h3><pre><code>document.querySelector(css选择器);

// 获取文档中有 &quot;target&quot; 属性的第一个 &lt;a&gt; 元素
document.querySelector(&quot;a[target]&quot;);

// 找到符合条件的所有元素
document.querySelectorAll(css选择器);</code></pre><h2 id="遍历节点"><a href="#遍历节点" class="headerlink" title="遍历节点"></a>遍历节点</h2><p>遍历操作如下，用红框圈起来的方法功能是一样的，只是在不同版本的浏览器中兼容不同，建议使用红框中第二种方法</p>
<p><img src="http://cdn.ziyedy.top/image/DOM%E8%8A%82%E7%82%B9%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/%E9%81%8D%E5%8E%86%E8%8A%82%E7%82%B9.png" alt=""></p>
<h3 id="获取父节点"><a href="#获取父节点" class="headerlink" title="获取父节点"></a>获取父节点</h3><pre><code>节点.parentNode</code></pre><h3 id="获取兄弟节点"><a href="#获取兄弟节点" class="headerlink" title="获取兄弟节点"></a>获取兄弟节点</h3><h4 id="下一个兄弟节点"><a href="#下一个兄弟节点" class="headerlink" title="下一个兄弟节点"></a>下一个兄弟节点</h4><pre><code>下一个兄弟节点 = 节点.nextElementSibling || 节点.nextSibling</code></pre><h4 id="上一个兄弟节点"><a href="#上一个兄弟节点" class="headerlink" title="上一个兄弟节点"></a>上一个兄弟节点</h4><pre><code>上一个兄弟节点 = 节点.previousElementSibling || 节点.previousSibling</code></pre><h4 id="任意兄弟节点"><a href="#任意兄弟节点" class="headerlink" title="任意兄弟节点"></a>任意兄弟节点</h4><pre><code>节点.parentNode.children[index];</code></pre><h3 id="获取子节点"><a href="#获取子节点" class="headerlink" title="获取子节点"></a>获取子节点</h3><h4 id="第一个-最后一个"><a href="#第一个-最后一个" class="headerlink" title="第一个/最后一个"></a>第一个/最后一个</h4><pre><code>第一个子元素节点 = 节点.firstElementChild || 节点.firstChild

最后一个子元素节点 = 节点.lastElementChild || 节点.lastChild</code></pre><h4 id="获取所有子节点"><a href="#获取所有子节点" class="headerlink" title="获取所有子节点"></a>获取所有子节点</h4><pre><code>子节点数组 = 父节点.childNodes; 

子节点数组 = 父节点.children;</code></pre><h2 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h2><h3 id="创建节点"><a href="#创建节点" class="headerlink" title="创建节点"></a>创建节点</h3><pre><code>新的标签(元素节点) = document.createElement(&quot;标签名&quot;);

文本节点 = document.createTextNode(文本)

文本片段 = document.createDocumentFragment();</code></pre><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code>&lt;body&gt;
    &lt;ul id=&quot;myList&quot;&gt;&lt;/ul&gt;
    &lt;script&gt;
        var fragment = document.createDocumentFragment();
        var ul = document.getElementById(&quot;myList&quot;);
        var li = null;
        for(var i=0; i&lt;3; i++) {
            li = document.createElement(&quot;li&quot;);
            li.appendChild(document.createTextNode(&quot;Item&quot; + (i+1)));
            fragment.appendChild(li);
        }
        ul.appendChild(fragment);
    &lt;/script&gt;
&lt;/body&gt;</code></pre><p><img src="http://cdn.ziyedy.top/image/DOM%E8%8A%82%E7%82%B9%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/%E5%88%9B%E5%BB%BA%E8%8A%82%E7%82%B9.png" alt=""></p>
<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><h4 id="在最后插入一个子节点"><a href="#在最后插入一个子节点" class="headerlink" title="在最后插入一个子节点"></a>在最后插入一个子节点</h4><pre><code>父节点.appendChild(新的子节点);</code></pre><h4 id="在参考节点前插入一个新的节点"><a href="#在参考节点前插入一个新的节点" class="headerlink" title="在参考节点前插入一个新的节点"></a>在参考节点前插入一个新的节点</h4><pre><code>父节点.insertBefore(新的子节点,作为参考的子节点)</code></pre><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><pre><code>父节点.removeChild(子节点);</code></pre><h2 id="操作节点属性"><a href="#操作节点属性" class="headerlink" title="操作节点属性"></a>操作节点属性</h2><p>操作节点属性都有以下两种方法，但一定不能混用，</p>
<h3 id="获取节点的属性值"><a href="#获取节点的属性值" class="headerlink" title="获取节点的属性值"></a>获取节点的属性值</h3><pre><code>元素节点.属性名;
元素节点[属性名];

元素节点.getAttribute(&quot;属性名称&quot;);</code></pre><h3 id="设置节点属性值"><a href="#设置节点属性值" class="headerlink" title="设置节点属性值"></a>设置节点属性值</h3><pre><code>元素节点.属性名 = 新属性值;
元素节点[属性名] = 新属性值;

元素节点.setAttribute(&quot;属性名&quot;, &quot;新的属性值&quot;);</code></pre><h3 id="删除节点的属性"><a href="#删除节点的属性" class="headerlink" title="删除节点的属性"></a>删除节点的属性</h3><pre><code>元素节点.removeAttribute(属性名);</code></pre><h3 id="类名的增删操作"><a href="#类名的增删操作" class="headerlink" title="类名的增删操作"></a>类名的增删操作</h3><pre><code>Node.classList.add(&quot;class&quot;) // 添加class

Node.classList.remove(&quot;class&quot;) // 移除class

Node.classList.toggle(&quot;class&quot;) // 切换class，有则移除，无则添加

Node.classList.contains(&quot;class&quot;) // 检测是否存在class</code></pre><h2 id="DOM的一些常见属性"><a href="#DOM的一些常见属性" class="headerlink" title="DOM的一些常见属性"></a>DOM的一些常见属性</h2><h3 id="nodeType属性"><a href="#nodeType属性" class="headerlink" title="nodeType属性"></a>nodeType属性</h3><ul>
<li><p>nodeType == 1  表示的是元素节点（标签） 。记住：在这里，元素就是标签。</p>
</li>
<li><p>nodeType == 2  表示是属性节点。</p>
</li>
<li><p>nodeType == 3  是文本节点。</p>
</li>
</ul>
<h3 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML"></a>innerHTML</h3><p>获取标签本身的html，也可以<strong>通过赋值变相的添加节点</strong></p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><pre><code>&lt;body&gt;
    &lt;div id=&quot;content&quot;&gt;&lt;/div&gt;
    &lt;script&gt;
        var content = document.getElementById(&quot;content&quot;);
        var str = &quot;ui * 2 li&quot;
                    + &quot;&lt;ul&gt;&quot;
                    + &quot;&lt;li&gt; Item 1 &lt;/li&gt;&quot;
                    + &quot;&lt;li&gt; Item 2 &lt;/li&gt;&quot;
                    + &quot;&lt;/ul&gt;&quot;;
        content.innerHTML = str;
        alert(content.innerHTML);
    &lt;/script&gt;
&lt;/body&gt;</code></pre><p>如图可见，div内部已经多出了我们添加的元素</p>
<p><img src="http://cdn.ziyedy.top/image/DOM%E8%8A%82%E7%82%B9%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/innerHTML.png" alt=""></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>conda产生的bug处理</title>
    <url>/page/conda-debug.html</url>
    <content><![CDATA[<h2 id="没有写权限"><a href="#没有写权限" class="headerlink" title="没有写权限"></a>没有写权限</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><pre><code>EnvironmentNotWritableError: The current user does not have write permissions to the target environment.
  environment location: /opt/anaconda3
  uid: 1000
  gid: 1000</code></pre><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>将anconda及其子文件赋予最高权限</p>
<pre><code>sudo chmod 777 -R /opt/anaconda3/</code></pre><h2 id="下载源问题"><a href="#下载源问题" class="headerlink" title="下载源问题"></a>下载源问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="http://cdn.ziyedy.top/conda%E4%BA%A7%E7%94%9F%E7%9A%84bug%E5%A4%84%E7%90%86/%E4%B8%8B%E8%BD%BD%E6%BA%90%E9%97%AE%E9%A2%98.png" alt=""></p>
<h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>换源或者直接采用conda默认的源（以下换回conda的默认源）</p>
<pre><code>conda config --remove-key channels</code></pre><p>换成清华源或中科大源，将以下配置文件写入<code>~/.condarc</code>中</p>
<pre><code>channels:
  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main/
  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/
  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/
  - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/pytorch/
ssl_verify: true</code></pre><h2 id="异常关机导致的conda异常中断"><a href="#异常关机导致的conda异常中断" class="headerlink" title="异常关机导致的conda异常中断"></a>异常关机导致的conda异常中断</h2><h3 id="问题描述-2"><a href="#问题描述-2" class="headerlink" title="问题描述"></a>问题描述</h3><p><img src="http://cdn.ziyedy.top/conda%E4%BA%A7%E7%94%9F%E7%9A%84bug%E5%A4%84%E7%90%86/%E5%BC%82%E5%B8%B8%E5%85%B3%E6%9C%BA%E5%AF%BC%E8%87%B4%E7%9A%84conda%E5%BC%82%E5%B8%B8%E4%B8%AD%E6%96%AD.png" alt=""></p>
<h3 id="解决方法-2"><a href="#解决方法-2" class="headerlink" title="解决方法"></a>解决方法</h3><p>将所有出问题的文件移除</p>
<pre><code>rm -rf &quot;出错文件路径&quot;</code></pre><h2 id="创建新环境报错"><a href="#创建新环境报错" class="headerlink" title="创建新环境报错"></a>创建新环境报错</h2><h3 id="报错信息"><a href="#报错信息" class="headerlink" title="报错信息"></a>报错信息</h3><pre><code>Collecting package metadata (current_repodata.json): failed

NotWritableError: The current user does not have write permissions to a required path.
  path: /home/ziyedy/.conda/pkgs/urls.txt
  uid: 1000
  gid: 1000

If you feel that permissions on this path are set incorrectly, you can manually
change them by executing

  $ sudo chown 1000:1000 /home/ziyedy/.conda/pkgs/urls.txt

In general, it&#39;s not advisable to use &#39;sudo conda&#39;.
</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>按照提示尝试操作没用，解决方法是命令行输入如下：</p>
<pre><code>sudo chown -R ziyedy anaconda3 # ziyedy is user name.</code></pre><p>参考：<a href="https://blog.csdn.net/PecoHe/article/details/104578700" target="_blank" rel="noopener">https://blog.csdn.net/PecoHe/article/details/104578700</a></p>
<h2 id="无法改变环境"><a href="#无法改变环境" class="headerlink" title="无法改变环境"></a>无法改变环境</h2><p>正常情况下输入<code>conda activate &lt;env_name&gt;</code>时，python应该改变为该环境下的python版本，可以使用<code>python -V</code>查看，但有时命令行显示上环境已经更改但实际上所使用的python解释器没有更换，解决方法如下：</p>
<ol>
<li>使用记事本打开编辑环境（该目录下的.bashrc存储的为个人的一些配置文件，如别名路径）</li>
</ol>
<pre><code>sudo gedit ~/.bashrc</code></pre><ol start="2">
<li>在末尾按照规律添加如下内容</li>
</ol>
<pre><code>export PATH=&quot;export PATH=&quot;~/anaconda3/bin:$PATH&quot;   #base环境下的python，已有的
alias python1=&quot;~/anaconda3/bin/python   # 你需要添加的</code></pre><p><code>alias</code>用于设置指令的别名，下面一条语句的意思就算你输入python1就会自动指向后面</p>
<ol start="3">
<li>使得修改生效</li>
</ol>
<pre><code>source ~/.bashrc</code></pre>]]></content>
      <categories>
        <category>其他</category>
        <category>debug</category>
      </categories>
      <tags>
        <tag>conda</tag>
      </tags>
  </entry>
  <entry>
    <title>Git出现的报错合集</title>
    <url>/page/git_error.html</url>
    <content><![CDATA[<h3 id="Git-fatal-refusing-to-merge-unrelated-histories解决"><a href="#Git-fatal-refusing-to-merge-unrelated-histories解决" class="headerlink" title="Git: fatal: refusing to merge unrelated histories解决"></a>Git: fatal: refusing to merge unrelated histories解决</h3><p>今天<code>git pull</code>时出现这个错误（在连接远程库与本地库时在远程库上进行了一些删除操作）。原因是两个分支为两个不同的版本，有不同的提交历史，使用以下语句进行强制合并即可解决这个问题。</p>
<pre><code>$git pull origin master --allow-unrelated-histories</code></pre><h3 id="fatal-remote-origin-already-exists"><a href="#fatal-remote-origin-already-exists" class="headerlink" title="fatal: remote origin already exists"></a>fatal: remote origin already exists</h3><p>先将存在的库删除，再进行连接</p>
<pre><code>git remote rm origin</code></pre><h3 id="non-fast-forward"><a href="#non-fast-forward" class="headerlink" title="non-fast-forward"></a>non-fast-forward</h3><p>没有对代码进行及时的同步产生的问题，应该先合并之前的历史，再进行提交</p>
<pre><code>git fetch origin master
git merge origin FETCH_HEAD </code></pre>]]></content>
      <categories>
        <category>其他</category>
        <category>debug</category>
      </categories>
  </entry>
  <entry>
    <title>BOM基本内容</title>
    <url>/page/js-bom-basic-handle.html</url>
    <content><![CDATA[<h2 id="常见的BOM对象"><a href="#常见的BOM对象" class="headerlink" title="常见的BOM对象"></a>常见的BOM对象</h2><p>BOM可以让我们通过JS来操作浏览器。BOM中为我们提供了一些对象，来完成对浏览器相关的操作。</p>
<p>常见的 BOM对象有：</p>
<ul>
<li><p>Window：代表整个浏览器的窗口，同时 window 也是<strong>网页中的全局对象</strong>。</p>
</li>
<li><p>Navigator：代表当前浏览器的信息，通过该对象可以识别不同的浏览器。</p>
</li>
<li><p>Location：代表当前浏览器的地址栏信息，通过 Location 可以获取地址栏信息，或者操作浏览器跳转页面。</p>
</li>
<li><p>History：代表浏览器的历史记录，通过该对象可以操作浏览器的历史记录。由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页，而且该操作只在当次访问时有效。</p>
</li>
<li><p>Screen：代表用户的屏幕信息，通过该对象可以获取用户的显示器的相关信息。</p>
</li>
</ul>
<p>备注：这些 BOM 对象都是<strong>作为 window 对象的属性</strong>保存的，可以通过window对象来使用，也可以直接使用。比如说，我可以使用 <code>window.location.href</code>，也可以直接使用 <code>location.href</code>，二者是等价的。</p>
<p>备注2：不要忘了，之前学习过的<code>document</code>也是在<code>window</code>中保存的。</p>
<h2 id="Navigator"><a href="#Navigator" class="headerlink" title="Navigator"></a>Navigator</h2><p>Navigator代表当前浏览器的信息，通过该对象可以识别不同的浏览器。</p>
<p>通常使用<code>navigator.userAgent</code>来获取浏览器信息</p>
<h2 id="History"><a href="#History" class="headerlink" title="History"></a>History</h2><p>History对象：可以用来操作浏览器的向前或向后翻页。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>获取浏览器历史列表中的 url 数量。注意，只是统计当次的数量，如果浏览器关了，数量会重置为1。</p>
<pre><code>history.length</code></pre><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>回退到上一个页面，作用和浏览器的「回退按钮」一样。</p>
<pre><code>history.back();</code></pre><p>跳转下一个页面，作用和浏览器的「前进按钮」一样。</p>
<pre><code>history.forward();</code></pre><p><strong>go方法</strong></p>
<pre><code>// 向前跳转2个页面
history.go( 2 );

// 向后跳转2个页面
history.go( -2 );

// 刷新当前页面
history.go( 0 );</code></pre><h2 id="Location"><a href="#Location" class="headerlink" title="Location"></a>Location</h2><p>Location 对象：封装了浏览器地址栏的 URL 信息。</p>
<h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><p>获取当前页面的 url 路径</p>
<pre><code>location.href</code></pre><p>也可以通过设置该属性的方法使页面跳转</p>
<pre><code>location.href = &#39;ziyedy.top&#39;;</code></pre><h3 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h3><p>用来跳转到其他的页面，作用和直接修改<code>location.href</code>一样。</p>
<pre><code>location.assign(str);</code></pre><p>用于重新加载当前页面，作用和刷新按钮一样。在方法的参数中传递一个true，则会强制清空缓存刷新页面.</p>
<pre><code>location.reload();
location.reload(true);</code></pre><p>使用一个新的页面替换当前页面，调用完毕也会跳转页面。但不会生成历史记录，不能使用「后退按钮」后退。</p>
<pre><code>location.replace();</code></pre>]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu常用快捷键</title>
    <url>/page/ubuntu-common-shortcut.html</url>
    <content><![CDATA[<p>记录一些比较常用的快捷键，一些如切屏之类的太常用的就没有记录</p>
<h3 id="系统操作"><a href="#系统操作" class="headerlink" title="系统操作"></a>系统操作</h3><p>Ctrl + Alt + T 启用终端：</p>
<p>Alt + F2 输入命令、启动程序（可以用于启动一些必须命令行启用的程序，网易云等）</p>
<p>Super + F10 打开程序菜单（用于退出程序等操作）</p>
<p>Super + A 展示所有程序及搜索框</p>
<p>Super + V 展示上方的日历和提醒列表</p>
<p>Super + L 锁定屏幕</p>
<h3 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h3><p>Super + H 隐藏窗口</p>
<p>Super + Up Arrow 最大化窗口</p>
<p>Super + Down Arrow 恢复窗口</p>
<p>Super + Right Arrow 将窗口置于屏幕右半侧</p>
<p>Super + Left Arrow 将窗口置于屏幕左半侧</p>
<p>Alt + F4 关闭当前窗口</p>
<p>Ctrl + W 关闭当前窗口</p>
<p>Alt + F7 移动窗口（用的比较少）</p>
<p>Alt + F8 改变窗口大小（用的比较少）</p>
<p>Alt + Space 激活窗口菜单</p>
<h3 id="桌面操作"><a href="#桌面操作" class="headerlink" title="桌面操作"></a>桌面操作</h3><p>Alt + Shift+ Up/Down Arrow 切换桌面</p>
<p>Ctrl + Alt + D 类似Windows下的Win + D组合键，显示桌面 ，隐藏全部窗口</p>
<h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><p>Alt + Enter – 查看选择文件/文件夹的属性，代替单击右键选择属性</p>
<p>Alt + Up/Down Arrow – 移动到父文件夹/选择的文件夹（左右的用的多一些）</p>
<p>Alt + Left/Right Arrow – 在文件夹中后退/前进</p>
<p>Ctrl + L - 得到文件路径</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>工作效率</category>
      </categories>
      <tags>
        <tag>工作效率</tag>
      </tags>
  </entry>
  <entry>
    <title>2.1、JS事件处理</title>
    <url>/page/event-obj.html</url>
    <content><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件指的是一些特定的交互瞬间，如点击某个元素等等</p>
<p>JavaScript 是以<strong>事件驱动为核心</strong>的一门语言。JavaScript 与 HTML 之间的交互是通过事件实现的。</p>
<h3 id="事件的基本要素"><a href="#事件的基本要素" class="headerlink" title="事件的基本要素"></a>事件的基本要素</h3><ul>
<li><p>事件源：引发后续事件的html标签。</p>
</li>
<li><p>事件：js中已经定义好了（见下图）。</p>
</li>
<li><p>事件驱动程序：对样式和html的操作。也就是DOM。</p>
</li>
</ul>
<p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/js%E4%BA%8B%E4%BB%B6.png" alt=""></p>
<h3 id="事件程序的基本书写"><a href="#事件程序的基本书写" class="headerlink" title="事件程序的基本书写"></a>事件程序的基本书写</h3><h4 id="1、获取事件源"><a href="#1、获取事件源" class="headerlink" title="1、获取事件源"></a>1、获取事件源</h4><p>详见DOM操作中的相关操作，主要有<code>document.getElementById()</code>等方法</p>
<h4 id="2、绑定事件"><a href="#2、绑定事件" class="headerlink" title="2、绑定事件"></a>2、绑定事件</h4><p>以onclick事件为例：</p>
<p><strong>方法1（绑定匿名函数）：</strong></p>
<pre><code>element.onclick = function () {

}</code></pre><p><strong>方法2（addEventListener）：</strong></p>
<pre><code>element.addEventListener(&#39;click&#39;, function () {

}, false);</code></pre><ul>
<li><p>参数1：事件名的字符串(注意，没有on)</p>
</li>
<li><p>参数2：回调函数：当事件触发时，该函数会被执行</p>
</li>
<li><p>参数3：<strong>true表示捕获阶段触发，false表示冒泡阶段触发（默认）</strong>。如果不写，则默认为false。【重要】</p>
</li>
</ul>
<p><strong>方法3（行内绑定）：</strong></p>
<pre><code>&lt;!--行内绑定--&gt;
&lt;div id=&quot;box1&quot; onclick=&quot;fn()&quot;&gt;&lt;/div&gt;

&lt;script type=&quot;text/javascript&quot;&gt;
    function fn() {
        alert(&quot;我是弹出的内容&quot;);
    }
&lt;/script&gt;</code></pre><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>当事件的响应函数被触发时，会产生一个事件对象<code>event</code>。浏览器每次都会将这个事件<code>event</code>作为实参传进之前的响应函数。</p>
<p>这个对象中包含了与当前事件相关的一切信息。比如鼠标的坐标、键盘的哪个按键被按下、鼠标滚轮滚动的方向等。</p>
<p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/event%E4%BF%A1%E6%81%AF.png" alt=""></p>
<h3 id="获取event对象"><a href="#获取event对象" class="headerlink" title="获取event对象"></a>获取event对象</h3><p>除去以上直接使用event外，标准兼容写法如下</p>
<pre><code>&lt;script&gt;
    //点击页面的任何部分
    document.onclick = function (event) {
        event = event || window.event; //兼容性写法
    }
&lt;/script&gt;</code></pre><h3 id="event属性"><a href="#event属性" class="headerlink" title="event属性"></a>event属性</h3><p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/event%E5%B1%9E%E6%80%A7.png" alt=""></p>
<p>除此之外，还有以下等信息：</p>
<pre><code>keyCode    // 返回响应的键盘信息</code></pre><h2 id="DOM事件流"><a href="#DOM事件流" class="headerlink" title="DOM事件流"></a>DOM事件流</h2><p>事件传播的三个阶段是：事件捕获、事件冒泡和目标。</p>
<ul>
<li>事件捕获阶段：事件从祖先元素往子元素查找（DOM树结构），直到捕获到事件目标 target。在这个过程中，默认情况下，事件相应的监听函数是不会被触发的。</li>
<li>事件目标：当到达目标元素之后，执行目标元素该事件相应的处理函数。如果没有绑定监听函数，那就不执行。</li>
<li>事件冒泡阶段：事件从事件目标 target 开始，从子元素往冒泡祖先元素冒泡，直到页面的最上一级标签。</li>
</ul>
<p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/%E6%8D%95%E8%8E%B7%E4%B8%8E%E5%86%92%E6%B3%A1.png" alt=""></p>
<h3 id="捕获与冒泡实验"><a href="#捕获与冒泡实验" class="headerlink" title="捕获与冒泡实验"></a>捕获与冒泡实验</h3><p>addEventListener函数最后一个参数为true代表事件在捕获阶段执行，为false代表在冒泡阶段进行</p>
<pre><code>&lt;body&gt;
    &lt;div&gt;&lt;p&gt;click here&lt;/p&gt;&lt;/div&gt;
    &lt;script&gt;
        var div = document.getElementsByTagName(&quot;div&quot;)[0];
        var p = document.getElementsByTagName(&quot;p&quot;)[0];
        div.addEventListener(&quot;click&quot;, function() {
            console.log(&quot;div&quot;);
        }, true);
        p.addEventListener(&quot;click&quot;, function() {
            console.log(&quot;p&quot;);
        }, true);
    &lt;/script&gt;
&lt;/body&gt;</code></pre><p><strong>实验结果</strong></p>
<p><img src="http://cdn.ziyedy.top/image/JS%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/%E5%86%92%E6%B3%A1%E5%AE%9E%E9%AA%8C%E7%BB%93%E6%9E%9C.png" alt=""></p>
]]></content>
      <categories>
        <category>前端</category>
        <category>JS</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>vi基本用法</title>
    <url>/page/vim-basic-use.html</url>
    <content><![CDATA[<h3 id="启动vi"><a href="#启动vi" class="headerlink" title="启动vi"></a>启动vi</h3><pre><code>vi</code></pre><h3 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h3><p>退出vi，出现未保存文件等情况会无法退出</p>
<pre><code>:q</code></pre><p>强制退出</p>
<pre><code>:q!</code></pre><h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><pre><code>:w</code></pre><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h3 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a>插入模式</h3><p>要在文件中添加文本，我们需要先进入插入模式。按下”i”键进入插入模式。</p>
<p>若要退出插入模式返回命令模式，按下 Esc 按键。</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>工作效率</category>
      </categories>
  </entry>
  <entry>
    <title>git的基本命令</title>
    <url>/page/git1.html</url>
    <content><![CDATA[<h2 id="Git-小记"><a href="#Git-小记" class="headerlink" title="Git 小记"></a>Git 小记</h2><p>Git是使用最广泛的版本控制系统，加上GitHub如此闻名（假笑），所以学习Git的一些基本命令还是很重要的，本人是学习了廖雪峰老师的Git相关教程，并将其中Git的一些相关命令记录下来，方便查找，也算一个笔记（本人原来从不记笔记，现在改过自新了）。嘻嘻。<br>廖雪峰老师的Git学习<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">传送门</a><br>首先应该明确的我认为有这么两个东西，即<em>工作区（Working Directory）</em>与<em>版本库（Repository）</em>。工作区可以简单理解成存放你工作内容的文件夹（本地），版本库则可以简单理解为记录你修改等操作内容的git生成的一个文件。版本库中又主要包含<em>暂存区</em>以及<em>分支结构master（默认）</em>。通过git提交项目修改之类的过程，可以简单理解为在本地进行修改后通过<strong>git add</strong>与<strong>git commit</strong>两个命令步骤，由本地到暂存区再到分支结构，这个命令的具体使用，后续会说明，这儿只对原理做一些粗略阐述。<br>同时分支结构有啥用呢？我觉得不必细谈，反正就理解为n个人可以一起工作还不会乱的一种机制吧，有Git需求的人想必能够理解，在此不做赘述（三言两语我也讲不清楚嘻嘻）</p>
<h2 id="Git-常用命令"><a href="#Git-常用命令" class="headerlink" title="Git 常用命令"></a>Git 常用命令</h2><p>选中文件夹不用一个个cd输入路径，选中相应文件夹鼠标右键选择<em>Git Bash Here</em>就行。<br><strong>PS：以下说明中&lt;&gt;括号内表示是你要输入的信息</strong></p>
<h3 id="初始化git仓库"><a href="#初始化git仓库" class="headerlink" title="初始化git仓库"></a>初始化git仓库</h3><p>即将你选中的目录变为git管理的仓库</p>
<pre><code>$ git init</code></pre><h3 id="提交你的修改"><a href="#提交你的修改" class="headerlink" title="提交你的修改"></a>提交你的修改</h3><p>提交单个文件，记得加后缀。同时file后用空格分割可以一次add很多文件</p>
<pre><code>$ git add &lt;file&gt;</code></pre><p>提交一个文件夹</p>
<pre><code>$ git add &lt;foldname&gt;/</code></pre><p>把暂存区的内容提交到当前分支（Git小记中的第二过程哦），<message>表示的是你对这此提交做的说明，类似于备忘录，方便你以后查看，同时每次使用<em>commit</em>命令后系统会生成一个id来记录这次提交，亦能方便查找</p>
<pre><code>$ git commit -m &lt;yourmessage&gt;</code></pre><h3 id="查看仓库中文件修改的信息"><a href="#查看仓库中文件修改的信息" class="headerlink" title="查看仓库中文件修改的信息"></a>查看仓库中文件修改的信息</h3><p>查看仓库当前的状态（文件增删，文件内容改变等）</p>
<pre><code>$ git status</code></pre><p>查看相应文件修改的具体内容</p>
<pre><code>$ git diff &lt;file&gt;</code></pre><p>显示从最近到最远的提交日志（包括上一节中你输入的说明，时间等内容），较为详细。在其之后加上相应备注后（行二），可以简略输出（id号码等等）</p>
<pre><code>$ git log
$ git log --pretty=oneline</code></pre><p>显示你的每一次命令（可以用来查看之前的每一步操作）</p>
<pre><code>$ git reflog</code></pre><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>Git中有一个HEAD指针指向当前版本，而HEAD^表示上个版本，HEAD^^表示上上个版本，HEAD~n表示第n个版本。<br>回退到之前的版本于回退到相应版本的命令如下，其中<commit id>相信你已经明白了，这个就是上一节信息当中的版本号。</p>
<pre><code>$ git reset --hard HEAD^
$ git reset --hard &lt;commit id&gt;</code></pre><p>撤销工作区的修改，请注意这里的关键词<em>工作区</em>，也就是说这个操作只能将你还没有执行<strong>add</strong>命令的文件修改去除。</p>
<pre><code>$ git checkout -- &lt;file&gt;</code></pre><p>要去除已经使用add进入暂存区的修改，请使用以下命令命令。第一行是将暂存区的修改撤销掉（unstage），第二行就接着使用上面的命令就好，不重复写了。</p>
<pre><code>$ git reset HEAD &lt;file&gt;</code></pre><p>以上便是应对“工作区修改”、“暂存区修改”、“已提交”这三种情况的版本回退命令，足够应付大部分时间了。</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>第一行命令：删除本地文件。<br>第二行命令：从版本库中删除文件(删除后记得再使用commit命令提交一次)<br>至于删错了恢复，请见上一节。</p>
<pre><code>$ rm &lt;file&gt;
$ git &lt;file&gt;</code></pre><h3 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h3><p>分支在第一大节也有提到，这里列出一些常用操作<br>第一行为创建名称为<name>的分支，并将当前分支切换为<name>。第二行为切换当前分支为<name>。（同时，master为默认主分支）</p>
<pre><code>$ git checkout -b &lt;name&gt;
$ git checkout &lt;name&gt;</code></pre><p>查看所有分支</p>
<pre><code>$ git branch</code></pre><p>第一行为把分支<name>合并到当前分支中。第二行为删除<name>分支。第三行为强行删除未进行合并操作的<name>分支。</p>
<pre><code>$ git merge &lt;name&gt;
$ git branch -d &lt;name&gt;
$ git branch -D &lt;name&gt;</code></pre><p>查看分区合并历史以及合并图</p>
<pre><code>$ git log --graph --pretty=oneline --abbrev-commit</code></pre><p><strong>PS：</strong>同时应注意，当你在master分支与新建的分支上都进行了修改并执行了commit命令时，直接合并可能会把报错，然后你得去相关文件中手动修改一下再commit。git会在相应文件中给你进行两次修改的醒目标注，很方便</p>
<h3 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h3><p>大家都知道软件会有版本，比如adobe公司的一堆CS和CC，tag在Git中就起到给一个commit设定一个除去id外更容易记住的别名的作用，方便查找。默认设置tag是设置在最近一次commit上。<br>以下第一行为设置一个标签；第二行为在id为commit_id的commit上设置标签；第三行在第二行的基础上给tag一点说明；第四行为查看现有所有标签；第五行查看相应标签详细信息；第六行删除一个本地标签。</p>
<pre><code>$ git tag &lt;tagname&gt;
$ git tag &lt;tagname&gt; &lt;commit_id&gt;
$ git tag -a &lt;tagname&gt; -m &lt;message&gt; &lt;commit_id&gt;
$ git tag
$ git show &lt;tagname&gt;
git tag -d &lt;tagname&gt;</code></pre><h3 id="远程操作"><a href="#远程操作" class="headerlink" title="远程操作"></a>远程操作</h3><p>前面提到了GitHub，自然学git远程操作（或者理解成跟GitHub玩游戏也成）是必不可少的，本地下载了git咋和GitHub扯上关系就略过不谈了，以下记录一些相关常用操作。<br>刚下好git打开就会有以下这些玩意，你也可以随时使用相应命令查看相应配置，使用<strong>git config -1</strong>可以查看很多信息，试试就知道。</p>
<pre><code>$ git config --global user.email &quot;your_email@qq.com&quot;
$ git config __global user.name &quot;your_github_name&quot;</code></pre><p>将本地库与远程库相关联（origin是远程库的默认名称）</p>
<pre><code>$ git remote add origin git@&lt;server-name:path/repo-name.git&gt;</code></pre><p>使用<em>push</em>命令，将本地库的内容推送到远程库上(第一次)，之后每次本地修改后若要推送可用第二行命令</p>
<pre><code>$ git push -u origin master
$ git push origin master</code></pre><p>将GitHub上的内容克隆到本地（注意你要是想对其有修改并推送，应先fork到自己的库里，再克隆）。输入git clone后将你所要克隆的网址复制后加上就好。</p>
<pre><code>$ git clone &lt;http:~&gt;</code></pre><p>查看远程库详细相关信息</p>
<pre><code>$ git remote -v</code></pre><p>建立远程库dev分支与本地dev的链接</p>
<pre><code>$ git branch --set-upstream-to=origin/dev dev</code></pre><p>把最新的提交抓取下来</p>
<pre><code>$ git pull</code></pre><h3 id="有关参考"><a href="#有关参考" class="headerlink" title="有关参考"></a>有关参考</h3><p>其实很多命令压根不用记，但要去看每个操作下来git给的提示，很多后续如何操作已经写好了，你所需的往往只是做一做英语阅读。</p>
]]></content>
      <categories>
        <category>其他</category>
        <category>工作效率</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>改变</title>
    <url>/page/the_change.html</url>
    <content><![CDATA[<p>时光本身没有魔力，它的奇妙来自于人们很容易愣神。</p>
<p>当你发呆的时候，当你全身心地在做一件事的时候，当你摊在沙发上消磨时光的时候，它总会轻而易举地从你的指尖溜走。“溜”，这是个形容时光已经用烂了的动词，但大可不必对这种形容做一些所谓老生常谈的说教，因为这在汉语中确实用的很妙。</p>
<p>小学生用文字形容时光是一把好手，因为似乎我们的教育自小到大一个很大的主题就是劝人切莫虚度时光。所谓“少壮不努力，老大徒伤悲”也可以视为是对时光的隐喻，这种隐喻隐藏在许许多多与时光本身看似并不相关的事物上，但作为两种状态之间的对比却往往体现出时光的作用来。从这个角度来看，也许本身就没有什么隐喻不隐喻的吧，毕竟活在时光长河里的生物，怎么可能规避的了时光二字呢。如此看来“时光”这两个汉字也着实幸运，明明是人造出的东西，表达的却是一种任何人也捉摸不透却又身在其中的感觉。</p>
<p>现在已经五月份了，其实我也很纳闷怎么就五月份了。我不记得上一次愣神是在什么时候，大概是今年二月？或者是去年的什么时间，或许是十年前？总之现在已经快要接近我生命中的第21个年头了。我在愣神当中曾经说过我才18，也曾经说过我才20，但我现在快满21了。这是一种相当奇妙的感觉，你不知道起点在哪，也无法推算终点何在，你一次又一次的愣神，又一次又一次地回过神来开始思考，可每次回忆起自己上一次的思考，又会发现那不过是无数次愣神递归过程之中的某个终止条件。人的一生永远是在愣神中度过，而时光却又如此狡猾，永远会在你愣神的时候从你的指尖溜走。</p>
<p>仿佛避开守卫出逃的囚犯，仿佛透过缝隙射入的阳光。</p>
<p>今年的五一假期，武汉的阳光十分强烈，但温度并不高，是让人很舒服的那种天气，但又给人以预示，夏天显然快要来了。</p>
<p>我很喜欢夏天，现在回想起来也许是因为夏天是成长过程中唯一可以自由自在的季节吧。庐山上的夏天并不热，反而充满着慵懒的感觉。其他地方的夏天虽然普遍地能够被称为酷暑，但酷热之中却又蕴含了随意与激情，透露着狄俄倪索斯的气息，我很喜欢去品尝这种缺乏理性的味道，它会让愣神与发呆变得顺理成章。</p>
<p>这不是我今年第一次感到夏天要来了。我依稀可以记得，度过清明节假期之后的那天，很热。在回汉的路上，高铁里那种通过机器进行流通的空气的味道。呆板，麻木，但每每闻到它我总能想起旅行的过程，想起我四处寻找不同城市中别样的迪厄尼多斯的故事。这种感觉将过去的我和现在的我融为一体，时刻提醒从前的我与现在的我还是同一个人。这种非人的物质不断地通过嗅觉神经冲击你的大脑，一遍又一遍地通过一种缺乏科学与理性的方法强迫你去相信一个没有理性能够论证的哲学命题，强行告诉你你已经惫藾了多久以及你是否将永远以这种状态惫藾下去。</p>
<p>我还能够记得，从学校南二门回寝室的路上，四月的空气显得过于闷热了，给了我一种很不舒服的感觉。仿佛我还在去年的6月，大病初愈在六月的烈阳下回寝室收拾东西回家，我无法形容那是一种什么感觉，大病过后精神似乎由于充裕的休息变得很好，但总给人以一种缺憾的感觉。就像六月的阳光除去酷热以外似乎于我而言少了一层意义，但少的是什么呢？我苦苦思索也得不到答案。也许今年的夏天我能够找到它，也许永远也找不到了，也许它将被我遗忘，这也是大概率的事情了，也许这种缺憾感只是因为我对阳光多了一层理解而产生的错觉，也许缺憾的感觉与获得的感觉纠缠一起令我无法区分。但不论产生这种感觉的机理是什么，我只知道那时的我与现在的我多少有些不同了，也许是去年躺在病床上痛苦地享受闲暇时光以及六月的天气造成的，也许是命中注定在这个年龄会产生的改变，也许只是一个发展趋势附着于生病这件事情上带给我的错觉。我能写下很多种也许，但也许它们没有一个是答案。</p>
<p>从前有一段时间我热衷于探讨“Riddles of Existence”这个永远也不会有答案的形而上学问题，里面有一种支持宿命论的观点。如果加上空间三维与时间一维的话，在我们的生活中每一个结点的坐标都是固定的，一切事情都是一定会发生的。具体的证明方法我已经记不清了，但的的确确，我们的每一秒，每一个抉择，每一个时间节点上发生的事，都在我们愣神之后被一笔带过，被时光这个东西窃取而空。而下一个时间节点当我们思虑从前那些改变的时候，这种思虑又成为了下下个节点思考的素材。我们就如俄罗斯套娃一般死死地在时光的长河之中套下过去的自己，再被将来的自己套下，无穷无尽。而在我们执着于套娃本身的方法时，时光流逝，间断性地带给我们套下过去自己的满足感，告诉我们有些东西从未改变，就如木制娃娃用颜料画上的微笑的脸庞。</p>
<p>五月出头，这几天天气很好，阳光明媚却不毒辣，路边的梧桐树重新长出了夏天最亮眼的绿，我于道中抬头，看见阳光透过树叶缝隙泛起的柔和的光。</p>
<p>我感觉并不舒服，就像感受到了从前的自己。傍晚看到了属于夏天独有的那种灿烂的夕阳，我于美感之中蹉跎，我想起了海，想起了很多年前在海边的自己，想起了自己惫藾的时光，亦美亦不美，两个时空的我产生了龃龉，这是很难用理性判断的事情。</p>
<p>改变是必然的，“往者不可谏，来者犹可追”这句话永远是苍白无力的，但也没有多少人会纠结于改变本身而放弃对这句话的追求。</p>
<p>毕竟，人们在愣神之时总会开始学会欣赏从前的自己，总会以最柔和的方法面对改变所带来的龃龉。</p>
<p>就像俄罗斯套娃，大的娃娃总会接纳小的，尽管它们是那么不同。</p>
<blockquote>
<p>记于19.5.5  武汉</p>
</blockquote>
]]></content>
      <categories>
        <category>瞎侃</category>
        <category>散文</category>
      </categories>
      <tags>
        <tag>散文</tag>
      </tags>
  </entry>
  <entry>
    <title>The Long Night（权力的游戏 S8E3）</title>
    <url>/page/GOT_S8E3.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>长夜将至，当许多交交合合的命运汇集到临冬城的那刻，我知道在压抑的北境风雪之下会诞生许许多多有质感的能量，那是人性所带来的温度。不论命运如何曲折，是凛冬还是盛夏，依靠所谓魔法还是普普通通的脆弱不堪的人的身躯，这都有别于没有质感的所谓邪恶，因为这是生与死的区别。<br>从S1E01开始，异鬼就是几乎凌驾于所有故事线之外的一个主线，因为它没有邪恶、暴力的划分，它既不比像小剥皮那样纯粹的人之恶要更邪恶，也谈不上比瑟曦·兰尼斯特的野心更极端。用形容词与名词界定夜王及他所创造的异鬼和尸鬼们是很困难的，就像百万年前极地的风，当死寂无人之时，没有语言，没有人声，谈不上形容。这是夜王所要带来的，所要抹去的，所谓世界记忆过的东西。也许那些歌谣、传记、语言乃至人类统统不曾出现过，比十万光年外的宇宙深处还要寂静空旷。<br>无法形容的东西，这是汇集在临冬城的人们所要面对的。在漫天寒风的怒吼之中，一丝人性的传达都足以消弭一方冰雪，在世界崩溃的边缘，在死亡降临的前夜，在《Jenny of Oldstones》的歌声中，他们知道下半夜所要面对的是什么。<br>“诚既勇兮又以武，终刚强兮不可凌”，献给所有直面过死亡的角色。</p>
<h2 id="悼词"><a href="#悼词" class="headerlink" title="悼词"></a>悼词</h2><h3 id="席恩·葛雷乔伊"><a href="#席恩·葛雷乔伊" class="headerlink" title="席恩·葛雷乔伊"></a>席恩·葛雷乔伊</h3><p>Born as a Greyjoy, die as a Stark. “You are a good man, thank you, Theon.”<br>这也许是席恩这一生最好的写照了吧，也是这个人物最好的归宿，此刻他为保护布兰而死，作为一名史塔克，作为临冬城的一员，作为一个铁种，作为布兰的兄弟。<br>“You father raises me as an honorable man”,”My your brother, now and always”,”My sword is yours, from this day, until the last day”。隔了这么久，我依然能记得席恩对罗柏·史塔克发过的誓言，直到罗柏死在血色婚礼上，直到席恩被小剥皮折磨到成为臭佬，直到他带着珊莎跳下临冬城开始自我救赎的那一刻。<br>作为一个质子，当他想在史塔克家族找到自己一席之地的时候，罗柏总会提醒他“It’s not your home, you are not a Stark”。当他作为罗柏的兄弟迫切想证明自己的时候，以“铁屿继承人”的身份回到铁群岛时，却发现自己已经不被父亲与姐姐认可。他一直想假装强大，一直想找到自己的身份，一直想做一个英雄，但最后却成了臭佬，忘记了自己的姓名，苟活于世。<br>直到他带着珊莎跳下临冬城开始逃亡之路，直到他被铁民殴打倒地仍然从地上爬起，直到他回到临冬城对珊莎说“I want fight for Winterfall lady Sansa if you’ll have me”，直到他弹尽粮绝拿着龙晶长枪独身冲向夜王，直到他倒地看着夜王却再也无力爬起，直到他作为史塔克为临冬城拼尽全力。<br>让我身为席恩而死，不是臭佬。我是铁种，来自群屿，是派克岛的传人。<br>What is dead may never die</p>
<h3 id="莱安娜·莫尔蒙"><a href="#莱安娜·莫尔蒙" class="headerlink" title="莱安娜·莫尔蒙"></a>莱安娜·莫尔蒙</h3><p>We are not a large house, but we’re a proud one, and every man from Bear Island, fights with the strength of 10 mainlanders.<br>就像莫尔蒙家族的箴言“Here we stand”，一个10岁的小女孩，表现出来的刚强果断足以让所有展现出怯懦的大人脸红。她在整个剧中从来不是个重要的人物，熊岛也只是封地在北境西北方一个贫瘠岛屿的普通家族。但其所展现出来的忠贞不二却是维斯特洛大陆上的一道绝对靓丽的风景，使得为了铁王座尔虞我诈的那些大家族变得如飘零柳絮般苍白。<br>战斗前夜乔拉与莱安娜的对话令人心碎<br>Listen to me, you are the future of our house.<br>I don’t need you to remind me of that.<br>You’ll be safer in the crypt…<br>I will not hide underground, I pledged to fight for the North and I will fight.<br>以及小熊转身对大熊说的那句”I wish you good fortune, cousin.”。这句话现在已经成为绝唱，他们一个为保卫北境而死，一个为守护所爱力竭身亡。<br>一个10岁的小女孩，在大战前后指挥若定。城池已破之时仍然毫无畏惧，用着还是孩子的嗓音怒吼着冲向巨人尸鬼，在能够感受的到的骨骼碎裂鲜血涌出之时，仍奋力将龙晶匕首插向巨人，在那一刻，她比巨人还要高大。<br>我一直在想事情是不是还有转机，也许她还没死，直到夜王抬手，她睁开蓝色的眼睛作为尸鬼再次站起来。<br>多希望她能听从乔拉的建议躲到地穴，也许熬过了这场生死之战若干年后她会是熊岛的一个年轻美丽的Lady Mormont。<br>但也许那个人就不是她了，她是来自熊岛的莱安娜。</p>
<h3 id="乔拉·莫尔蒙"><a href="#乔拉·莫尔蒙" class="headerlink" title="乔拉·莫尔蒙"></a>乔拉·莫尔蒙</h3><p>年轻的乔拉，在铁群岛平叛时一战成名，受封骑士。<br>之后为了所谓的爱情，他违反禁令偷卖奴隶，在逃亡途中却被“爱情”抛弃。<br>在峡海对岸为了王国的赦免，他作为间谍接近塔格利安兄妹。<br>他以为通过出卖他们他会回到从前。<br>但当他开始熟悉丹妮，他明白他错了。<br>从此不论经历什么，他知道，他会永远站在丹妮的身边。<br>在生命的最后一刻，他依然想站起来为丹妮阻挡一切伤害。<br>他想告诉丹妮他只是受伤了，他没事。<br>但他却连话都没说出口就走了。<br>他虽然浑身是血，但却很安详。<br>因为他的身边。<br>有丹妮，有卓戈。<br>就像他们相遇时的模样。<br>纯粹是很难定义的，但这一刻它有个别名。<br>叫做乔拉。</p>
<h3 id="忧郁的艾迪"><a href="#忧郁的艾迪" class="headerlink" title="忧郁的艾迪"></a>忧郁的艾迪</h3><p>人性是复杂的，从来没有两个人会是相同的，哪怕类似都很难。但有时却有一些精神可以很好地概括一群人，在异鬼侵袭之时，长城上的守夜人是王国的坚盾。<br>“长夜将至，我从现在开始守望，至死方休”<br>“我是黑暗中的利剑，长城上的守卫，守卫王国的坚盾”<br>“我将生命与荣耀献给守夜人”<br>守夜人的精神是什么？是一边背诵誓词一边冲向巨人的葛兰们，是放弃王位只为坚守誓言的伊蒙·塔格利安，是为了目标孤独地在北境之北骑行的班杨·史塔克。<br>“今夜如此，夜夜皆然”。<br>随着艾迪的倒下，也许往后再也不会有人再说出这些誓词了。</p>
<h3 id="夜王"><a href="#夜王" class="headerlink" title="夜王"></a>夜王</h3><p>行走了整整7季，却在预料之中的一集中以一种戏剧性的方法“死去”。<br>你有多少故事，我曾经幻想能够听到答案，<br>直到你在“The Night King”的乐曲中被匕首洞穿。<br>全片无言，你的故事也许永远是一个谜。<br>有人将你比作现实当中的那些自然灾害。<br>讽刺五大洲的人们如维斯特洛大陆上的人们一样。<br>在内斗中迷失、消亡。<br>也有人认为你只是你。<br>带着小说与剧集当中的某种隐喻。<br>等待有一天编剧或马丁能够给我们答案。<br>维斯特洛大陆上无人会喜欢你，<br>但也许将来吟游歌者会将你提起。<br>因为在生与死，冰与火的交织中，<br>你让我们看到了人性。</p>
<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>从S8前两集的命运交合开始，这一集生与死、冰与火的战争战前的气氛烘托可谓做到了极致。从大战开头，多斯拉克骑兵的龙晶弯刀开始熊熊燃烧，战斗的气氛似乎被一下扬起，直到骑兵冲向死亡军团，燃烧的火点开始逐渐熄灭直到消失殆尽，一种冰冷的肃杀与绝望的气息瞬间充满了每个人的内心。再到之后的空战，以及夜王带来的暴雪，无法阻挡尸鬼的燃烧的木栅，每个人物的特写，都使这场长达80分钟的战争刻画无比成功。<br>但同时，细细思考战术，确实有蛮多地方值得吐槽。</p>
<h3 id="战术槽点"><a href="#战术槽点" class="headerlink" title="战术槽点"></a>战术槽点</h3><ol>
<li>为什么要怒送多斯拉克骑兵？<br>在临冬城大战之前，琼雪等人对异鬼以及尸鬼明显可以说是知根知底了，制定的战术也是以斩杀夜王为根本目的，因为没杀掉夜王尸鬼是杀不完的。那么临冬城保卫战的主要目的显然就应该是保证临冬城守住较长的时间而不是为了斩杀多少异鬼、尸鬼了。一个以拖延时间为目的的守城战，有什么理由让多斯拉克人在战前对杀不尽的异鬼进行冲锋？这支游牧民族骑兵在日后的内战当中是一个战斗力堪称bug的军队，异鬼没有攻来，你等着就好了，凭什么让自己最嫡系的军队先发起进攻？多斯拉克人即使不参加这场战争的效果也远好于上去送。理想的多斯拉克骑兵使用方法应该是在尸鬼冲锋与无垢者纠缠在一起时从侧面进行冲击，或者等两条龙喷火将尸鬼冲散之时进行收割减轻步兵的压力。导演的目的当然是为了表现如上所述的绝望的气息，但这波操作实在是可以说是一个败笔，为从峡海对岸远道而来的多斯拉克人感到不值。</li>
<li>守城器械准备的不充分<br>如上所述，这是一个以拖延时间为目的的守城战，那么所依仗的应该是各种诸如燃烧油之类的守城器械。作为集合全北境以及龙妈力量的庞大军队，我认为装备这些显然不是问题，有了这些东西，守城战至少可以再多坚持一倍的时间。再其次就是木栅的设置了，明显可以很好地减缓尸鬼冲锋的速度，必要时还可以点燃（别说暴雪看不见信号了，这个在准备当中并不需要考虑），那么为什么只在临冬城外设置一圈的木栅就十分奇怪了。还有就是弓箭的问题，尸鬼是被夜王魔法复活的，只要被龙晶戳到就会倒下，那么也就意味着一支弓箭至少能杀死一只尸鬼，为什么不多备弓箭手也很古怪了，一轮弓箭齐射就可以给底下步兵和无垢者减小巨大的压力。当然这些都没有1中的错误致命，毕竟都可以归结为物资的紧缺与准备时间的不充分。</li>
<li>为什么不准备用来射龙的强弩？<br>前面说过，尸鬼虽然疯狂，但其实远比人脆弱，只要被龙晶戳到就会“死去”，那么使用科本的那种强弩显然足够杀死被夜王转化的“韦赛里斯”。就算射不了龙，用重弩清兵也是极好的。当然硬要说的话可以归结于山姆没有那个技术。</li>
<li>为什么不派骑兵后排切割异鬼<br>一个异鬼死后，由他转化的所有尸鬼都会失去“生命”，因此减缓守城压力的有效办法就是让多斯拉克骑兵去切割异鬼。洞悉了异鬼怕瓦哥利亚钢与龙晶之后，就应该知道除去死亡本身带来的恐惧外，异鬼并没有那么强大。派遣骁勇的多斯拉克骑兵在大战时绕后切割，即使不能成功，也能够吸引尸鬼的注意力，大大减轻守城压力，比直接冲锋效果要好的多。</li>
</ol>
<p>总结一下，和异鬼讲排兵布阵，脑子大概是瓦特了，论指挥，我觉得“私生子之战”中的小剥皮要优越的多，此战能胜，也是光之王显灵了。</p>
<h3 id="人物吐槽"><a href="#人物吐槽" class="headerlink" title="人物吐槽"></a>人物吐槽</h3><ul>
<li>囧雪<br>囧雪是主角相信在第六季的时候就能够看出来了，但我觉得相对于其他角色的立体与丰满程度，剧本对囧雪（或说伊耿·塔格利安）的塑造实在有些苍白。并没有体现出这个角色应有的包括外交、军事等等方面的智慧。这也是其得名囧·you know nothing·雪诺的一个重要原因。在本次冰与火、生与死之战中，除去空战当中的一点点表现，别的时间基本都在打酱油，要不是二丫神来一笔，满盘皆输。</li>
<li>布兰·史塔克<br>作为现在在场的究极神棍，打了全场的酱油，不知道他操控乌鸦去干了什么，本来三眼乌鸦的神棍属性应该是一个大挂之前也很期待在大战中能有所表现，结果啥事都没有发生。</li>
<li>山姆<br>山姆为什么不躲进地窖我觉得没太交代清楚，而且他在这次大战中存活下来完全是因为主角光环，但说好的《权力的游戏》没有主角光环呢？</li>
</ul>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这次大战静下来细细品味的话槽点很多，也有很多朋友认为这有点烂尾。但不得不承认，电视剧也是视觉艺术的一种，而这场大战无论是在视觉上还是情感上做的都很到位，算是战争戏中的标杆了。至于烂尾，其实我早就做好这个打算了，我认为一部剧的跨度达到接近10年的情况下，不烂尾是不可能的。毕竟，一百个读者心中有一百个哈姆雷特。剧中的角色经过这些年的沉淀，在不同的观众眼中早已千差万别，每个人所希望的结局都不同，每个人所想看到的情节都有差异，每个人对待情节逻辑的解读都会有偏差。在这样的情况下，剧的走向只有一条，而观众希望的走向却有千万条，因此，也许在你眼中这儿烂尾了，在他眼中情节涉及却恰到好处，我想说的是，享受这部剧融入我们这些年时光的那一部分，看看他带给了我们自己多少变化，享受精彩的表演即可。茶余饭后吵吵闹闹完全可以，顿生龃龉则无必要。<br>享受最后的那三集，希望能带给我们一些惊喜<br>子夜dy记于19年五一之前。</p>
]]></content>
      <categories>
        <category>瞎侃</category>
        <category>剧评</category>
      </categories>
      <tags>
        <tag>剧评</tag>
      </tags>
  </entry>
  <entry>
    <title>latex基本用法</title>
    <url>/page/latex1.html</url>
    <content><![CDATA[<p>谈到码字与排版大家首先想到的一定是word等办公软件，即一些“所见即所得”的排版与“码字”软件，这些软件功能强大足够应付日常的一切工作。<br>但当大家有英文论文的写作与排版需求时，尤其是面对美赛这种“英文写作比赛”时，输出的PDF文件的美观性就尤其重要了（本人也是因为美赛才接触了latex这个让人又爱又恨的软件）。出于实用与给自己进行用法记录的目的，我也就不拿软件的历史之类的凑字数了，直接上可以产生效果的东西。<br><strong>PS：</strong>我个人认为latex 与HTML之类的标签语言十分相似，学习成本低，易用难精（也没必要精），因此本文只针对相应排版的具体问题，不涉及任何latex的理论与底层问题，想精学的朋友建议移步刘海洋的《LaTeX入门》（可以联系本人电子版），同时有其他问题建议百度搜索或混混相应论坛，这儿给一个tackle problems的<a href="http://www.latexstudio.net/" target="_blank" rel="noopener">传送门</a>,下载TEXLive请移步<a href="http://tug.org/texlive/" target="_blank" rel="noopener">传送</a>,选择相应版本后耐心等待。<br><strong>以下未经说明使用TeXworks编辑器，编译方式选择XELaTeX</strong></p>
<h2 id="目录及其相关设置"><a href="#目录及其相关设置" class="headerlink" title="目录及其相关设置"></a>目录及其相关设置</h2><pre><code>\tableofcontents            %插入目录，由于latex的“交叉引用”，注意应编译两次
\thispagestyle{empty}       %设置目录页不计入页码，用于文章其他部位亦可
\clearpage                  %该语句使得文章后面内容另起一页显示，此处使得目录单独写在一页
\setcounter{page}{1}        %设置目录后正文第一页目录计数为1</code></pre><h2 id="正文文章结构的设置"><a href="#正文文章结构的设置" class="headerlink" title="正文文章结构的设置"></a>正文文章结构的设置</h2><pre><code>\section{一级标题内容}
正文
\subsection{二级标题内容}
正文
\subsubsection{三级标题内容}
正文</code></pre><p>以上模式相信用过word的朋友都很容易理解了，同时通过上一条所述的目录内容会根据正文中的\section{}等标签自动生成文章目录，十分方便。</p>
<h2 id="字体字号的常用设置"><a href="#字体字号的常用设置" class="headerlink" title="字体字号的常用设置"></a>字体字号的常用设置</h2><p>latex中包含了很多种字体，但如果没有特殊需求，我认为以下内容完全能够满足需要了</p>
<pre><code>\textbf{内容}       %将大括号内字体加粗
\textit{内容}       %将大括号内字体变为斜体
\emph{内容}         %强调括号内字体内容</code></pre><h2 id="列表环境"><a href="#列表环境" class="headerlink" title="列表环境"></a>列表环境</h2><h3 id="有计数的列表"><a href="#有计数的列表" class="headerlink" title="有计数的列表"></a>有计数的列表</h3><pre><code>\begin{enumerate}
    \item 内容1
    \item 内容2
\end{enumerate}</code></pre><h3 id="无计数的列表（bulleted-list）"><a href="#无计数的列表（bulleted-list）" class="headerlink" title="无计数的列表（bulleted list）"></a>无计数的列表（bulleted list）</h3><pre><code>\begin{itemize}
    \item 内容1
    \item 内容2
\end{itemize}</code></pre><h3 id="复杂列表"><a href="#复杂列表" class="headerlink" title="复杂列表"></a>复杂列表</h3><p>同时上述各个列表可以相互嵌套，如下即为在一个bulleted list下又嵌套了一个计数列表。</p>
<pre><code>\begin{itemize}
    \item 内容1
    \begin{enumerate}
        \item 内容1.1
        \item 内容1.2
    \end{enumerate}
\end{itemize}</code></pre><h2 id="插入图片"><a href="#插入图片" class="headerlink" title="插入图片"></a>插入图片</h2><p>在正文中插入图片很简单，如果你没有特殊的需求copy下面这段代码并且更改里面一些参数完全够用了，图片的资源文件和其他开发都是一样的，建议在根目录下建立一个img文件夹专门存放，同时记得将文件的命名与格式搞清楚。</p>
<pre><code>%下行代码中[]内为可选项意义分别为
%h 代表here,将表格排在当前文字位置
%t 表示将表格放在下一页的 top (页首)
%b 表示将表格放在当前页的 bottom (底部)
%! 表示忽略美观因素，尽可能按照参数指定的方式来处理表格浮动位置
\begin{figure}[h]
    \centering      %使图片居中
    %下面这行可以简单理解为载入图片的函数，width=0.6\textwidth是将图片等比例设为宽度为0.6个间页长（排版的名词不大记得可以简单这么理解），你也可以使用px之类的将其设置为定宽。后面大括号内一定得是如image1.jpg这种格式，后缀不能漏
    \includegraphics[width=0.6\textwidth]{加后缀的图片名}
    \caption{图片的名称}    %大括号内为页面显示的图片的名称
    \label{fig:1}          %设置图片的标签方便交叉引用
\end{figure}</code></pre><h2 id="插入表格"><a href="#插入表格" class="headerlink" title="插入表格"></a>插入表格</h2><p>表格是一切论文或其他议论文体中非常常见的数据表达形式，由于数据的不同各种类型多种多样，不想上节所述的图片那么一段代码打天下，所以表格内容较多，我尽量将我认为的常用的表格形式的通用代码附上，同时也列举一下表格的基本形式，方便读者进行变换。</p>
<h3 id="普通表格"><a href="#普通表格" class="headerlink" title="普通表格"></a>普通表格</h3><p>普通表格是指一个没有任何改动的最基本的表格（参考word你便知道样式），我也可以借由此说明一下表格中的一些常用参数<br>同时，如\centering；\caption{};\label{}等操作，与上一节所述关于图片相同</p>
<pre><code>\begin{table}[!htb] %[]内与上一节所述图片相同
    \begin{tabular}{|c|r|l|}    %后一个括号内c代表居中，r代表靠右，l代表靠左，|为表格竖线，可以舍去
        \hline  %为表格横线，可以舍去
        内容1 &amp; 内容2 &amp; 内容3 \\    %每个单元格间由&amp;分开，\\表示换行
        \hline
        内容4 &amp; 内容5 &amp; 内容6 \\
        \hline
    \end{tabular}
\end{table}</code></pre><h3 id="表格其他的常用设置"><a href="#表格其他的常用设置" class="headerlink" title="表格其他的常用设置"></a>表格其他的常用设置</h3><p>重新定义表格线的宽度代码如下，可随意更改使用相应代号的名称。使用时找到代码相应位置进行相应更改即可。<br>注意：<strong>以下内容要放在导言区</strong></p>
<pre><code>%定义表格横线\ttline的线宽为1.4pt，使用时用\ttline代替上一节中的\hline即可
\newcommand{\ttline}{
    \noalign {\ifnum 0=`}\fi \hrule height 1.4pt
    \futurelet \reserved@a \@xhline
}
%重定义表格竖线！的线宽为2pt，使用时用！代替上一节中的|即可
\newcolumntype{!}{@{\hskip\tabcolsep\vrule width 2pt\hskip\tabcolsep}}
\makeatother</code></pre><p>剩下的一些小功能如下：</p>
<pre><code>%设置表格标题置于表格上面（默认置于下面）
\setlength{\belowcaptionskip}{6pt}  %置于表格上面6pt

%如果想单独使一个单元格居中，可以这么写
\multicolumn{1}{c}{content}

%想调整表格上下间距，可以在\begin{table}前加（同样适用于更改正文行距）
\linespread{倍数} %更改后值为 倍数*默认间距

%合并单元格，合并行列可以使用以下公式进行嵌套
\multicolumn{项数}{新列格式}{单元格内容} %合并列
\multirow{项数}{新列格式}{单元格内容} %合并行

\cline{2-3} %表示画出一条位于第2列到第3列的横线段，其他列将不会有横线段</code></pre><h3 id="几种特殊表格代码"><a href="#几种特殊表格代码" class="headerlink" title="几种特殊表格代码"></a>几种特殊表格代码</h3><p>下面是几种相对特殊的表格的代码，根据这些代码结合前两小节的内容更改相应部分即可完成自己的制定。</p>
<pre><code>\linespread{1.1}
\begin{table}[h]
\setlength{\belowcaptionskip}{6pt}\centering\caption{dia test}\label{tab:dia}
\begin{tabular}{ccc}\ttline
\diagbox{test1}{test2} &amp; altitude &amp; vavlue \\ \tline
testa &amp; $22.2$ &amp; $22.1$ \\ 
testb &amp; $1.22$ &amp; $2.22$ \\
\end{tabular}
\end{table}</code></pre><p>此种表格应记住在导言区加上 <strong>\usepackage{diagbox}</strong><br><img src="/assets/BlogPic/2.1/t1.png" alt="示例1"><br>三线表是各种论文中较为常用的部分，代码与示例见下</p>
<h2 id="插入公式及其他数学式"><a href="#插入公式及其他数学式" class="headerlink" title="插入公式及其他数学式"></a>插入公式及其他数学式</h2><p>公式环境与图片和表格类似，也可以自动编号以及使用交叉引用，只需设置好\label{}内容即可，具体如下：</p>
<h3 id="公式环境"><a href="#公式环境" class="headerlink" title="公式环境"></a>公式环境</h3><p>一般公式编辑：</p>
<pre><code>\begin{equation}
    公式内容
    \label{eq:1}
\end{equation}</code></pre><p>分段函数模板：</p>
<pre><code>\begin{equation}
p_{j}=\begin{cases} 
    0,j=2\\
    1,j=1
\end{cases}
\label{}
\end{equation}</code></pre><h3 id="常见数学公式的编辑"><a href="#常见数学公式的编辑" class="headerlink" title="常见数学公式的编辑"></a>常见数学公式的编辑</h3>]]></content>
      <categories>
        <category>其他</category>
        <category>工作效率</category>
      </categories>
      <tags>
        <tag>latex</tag>
        <tag>论文</tag>
      </tags>
  </entry>
  <entry>
    <title>雨与晴</title>
    <url>/page/the_rain_and_the_shine.html</url>
    <content><![CDATA[<p>今天早上8点半左右，我像往常一样上三楼接水，在楼梯间的窗户向外瞥，围墙外的篮球场的塑胶地上湿了一片。围墙略显斑驳，是本来就不那么年经了的建筑被大水冲洗过后的一种自然姿态，带着一些年迈的美丽。</p>
<p>没事的时候我很喜欢透过这里向外望，但这次不是，因为我的眼光里多少带了些形色匆匆的味道。被水洗过的塑胶绿和围墙这边的绿色的植物，与其说是我看到了她们，不如说是她们的颜色主宰了那一秒内我的视神经。现在窗外夜色朦胧，是置身城市里很少见到的那种纯粹的墨蓝，纯粹的证明也并非是我自情自愿，是因为我抬头能看到星星。</p>
<p>不对，在东边的天空，还有一轮月亮，也许足够用皓月来形容。</p>
<p>我并不像一些下午一样，站在那个楼梯间的窗户面前带着什么思考或者纯粹性的发呆向外望。清晨的我手里拿着洗面奶和脸盆毛巾经过了那里，我现在也只能以上帝的姿态回顾那个瞬间我究竟是迈开了左腿还是右腿，脑子中想的究竟是窗外的绿还是一些什么别的乱七八糟的东西。这到底是模拟，有一万种不同的可能，这花了我很长的时间，沉淀了许多情感。我并不喜欢喝白酒，事实上也的确没怎么喝过，但我觉得所谓后劲，就是如此吧。在张开嘴的瞬间，咽下的酒精会让觥筹交错之后的你花上几个小时醉在自己的梦里，所需要的契机也只是热闹向平淡的自然转变。</p>
<p>雨是早就要下的了，昨晚睡前就已经开始了，但我并没有太在意，只记得它很大，像是夏天的雷雨，全然不同于上个月那阴雨绵绵的枯燥，倒是热烈洒脱，干脆利落。昨晚12点左右的时候，我躺在床上，感觉很累很累。我不知道“累”这种感觉的产生是基于什么，也许是某种激素，那我觉得自己想必是有些内分泌失调了。我并没有什么能过得去的让我感觉到疲惫的理由，但我就是很累。这一个月来我思考了很多，这个多也只是相对于我某种程度上放弃思考开始自欺欺人的那大段时间而已，只是一个正常水平，就像冬末的阴雨只要地球还在正常的轨道上，只要太阳不出什么问题，就一定会消散一样。阴天和晴天，只不过是地球表面的两种正常状态，但其微小的不同，的确会对地表的生物造成一些困扰，这我想是肯定的。</p>
<p>半夜的时候我被雨声惊醒了，这很少见，除去呼噜声与钟表的滴答，我是很难被别的声音惊醒的。半夜醒来的人对时间是没法计数的，一切理性和情感都处于朦胧的状态，也许这道朦胧会在大脑留下沙滩上城堡般的记忆，也许不会。但我却记得，那算是雨后的阴沉的味道吧。翠绿的世界总是会给人一种虽然充满生气但却脆弱稚嫩的感觉，在这脆弱稚嫩之下不知纯粹为何物，但被大雨蹂躏过后的植物的墨绿虽然给人阴沉郁结之感，却又十足纯粹。淅沥小雨下的天空阴沉混沌，赶时间的人会痛恨这种“欲擒故纵”般的感觉，世界并不是在接受清洗，而是在把污浊借雨水之名平摊到各地，也许是为了遮瑕，但却使原来作为“瑜”的部分都消失殆尽，纯粹一词无处藏身。而大雨磅礴的天空也许更是阴沉可怖，但却给人以十足的命令感，再赶时间你也不会为“走”或“不走”而面露难色，只有在屋檐下耐心等待。等待的过程也许是生活中难得的纯粹的仪式，因为静坐听雨的意境在当代实在是少的可怜，就连裤腿被大雨淋湿的触感都变得弥足珍贵。</p>
<p>雨后，空气中会有清爽的纯粹，世界接受清洗之后，无论是借着日光还是霓虹，路面倒映出的射影，是世界的另一种面貌，印着纯粹二字。</p>
<p>但我并不知道纯粹为何物，它是最狡诈多变的一个词。在我有不同的情感时，思考不同的问题时，面临不同的选择时，它是我最后的仪仗，是我追求的东西，尽管为此我注定没有方向。</p>
<p>我不知道小时候庐山上的蓝天白云与我的无忧无虑算不算纯粹，也许无忧无虑只是假象，是人丢掉一段时间内的大部分记忆的一种自然而然的感受。我马上21了，在我以1开头的年岁里，我的确很少看到记忆中的那种蓝天了。在熬过二月的阴雨之后，最近武汉的天气晴空万里，就连今天早上阴沉潮湿的墨绿在我中午再一次以相同的视角观望时都已经消失殆尽了，但蓝天上仍然有一层阴霾，蓝的并不纯粹，而我已经习惯了这种蓝，并且也开始用湛蓝形容它。没事的时候我也会在教五门口的广场上休息，或者在万林艺术馆的天台上坐着以一个不至于让太阳抢去风头的角度欣赏蓝天，我为这种天气而欣喜，但内心中又似乎对一场夏天的雷雨更为期待。我不知道是因为暴雨真的能够洗刷世界，还是因为我仅仅期待那雨声给我带来的视觉、听觉再到触觉的全方位的模拟，能够带我回到小时候，或者说情感更加纯粹的年岁。</p>
<p>现在外面天很黑，皓月当空，高悬东方，在宿舍门口我看到有人在用微单拍摄。我很遗憾单反不在身边，同时又很庆幸单反不在身边。我尝试用手机对这个美丽的夜色进行记录，但最后发现它只属于我的眼睛，属于在我记忆中注定渐渐消散的那一块区域。我很快会把昨晚的雨、清晨的绿以及东方的月这些印记着今天的一切特征给淡忘，因为未来还会有无数个相同的日子，武大的樱花会一直开下去，我的路，我的追求，我的思考也不会停下，至死方休。时不时想想上一个今天自己对纯粹的定义，也许会发现愚蠢，也许会发现美丽，但更重要的是找到不同日子纯粹变化的轨迹。文字的意义总会是虚无缥缈的，但追求的东西如果套用一个词来表达的话我认为总不至于两个时间的方向会是南北迥异的吧。</p>
<p>说句实话，我想家了。</p>
<p>人只有在意识到自己脆弱的时候才会顿生羁旅之情。</p>
<p>但也从来没有用羁旅表达自己状态的人会停下脚步。</p>
<blockquote>
<p>记于 19.3.20 武汉</p>
</blockquote>
]]></content>
      <categories>
        <category>瞎侃</category>
        <category>散文</category>
      </categories>
      <tags>
        <tag>散文</tag>
        <tag>日志</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行基础</title>
    <url>/page/linux-terminal-1.html</url>
    <content><![CDATA[<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><h3 id="命令怎么理解"><a href="#命令怎么理解" class="headerlink" title="命令怎么理解"></a>命令怎么理解</h3><p>shell 就是一个程序，它接受从键盘输入的命令，  然后把命令传递给操作系统去执行。几乎所有的 Linux 发行版都提供一个名为 bash 的 来自 GNU 项目的 shell 程序。</p>
<ol>
<li><p>是一个可执行程序，就像我们所看到的位于目录/usr/bin 中的文件一样。这一类程序可以是用诸如 C 和 C++语言写成的程序编译的二进制文件,也可以是由诸如shell，perl，python，ruby等等脚本语言写成的程序 。</p>
</li>
<li><p>是一个内建于 shell 自身的命令。bash 支持若干命令，内部叫做 shell 内部命令(builtins)。例如，cd 命令，就是一个 shell 内部命令。</p>
</li>
<li><p>是一个 shell 函数。这些是小规模的 shell 脚本，它们混合到环境变量中。在后续的章节里，我们将讨论配置环境变量以及书写 shell 函数。但是现在，仅仅意识到它们的存在就可以了。</p>
</li>
<li><p>是一个命令别名。我们可以定义自己的命令，建立在其它命令之上。</p>
</li>
</ol>
<h3 id="命令基本格式"><a href="#命令基本格式" class="headerlink" title="命令基本格式"></a>命令基本格式</h3><pre><code>command -options arguments</code></pre><p>大多数命令使用的选项，是由一个中划线加上一个字符组成，例如，“-l”，但是许多命令，包括来自于GNU 项目的命令，也支持长选项，长选项由两个中划线加上一个字组成。当然，许多命令也允许把多个短选项串在一起使用。下面这个例子，ls 命令有两个选项，“l” 选项产生长格式输出，“t”选项按文件修改时间的先后来排序。</p>
<pre><code>ls -lt --reverse</code></pre><h3 id="命令行鼠标操作"><a href="#命令行鼠标操作" class="headerlink" title="命令行鼠标操作"></a>命令行鼠标操作</h3><h4 id="复制、粘贴"><a href="#复制、粘贴" class="headerlink" title="复制、粘贴"></a>复制、粘贴</h4><p>按下鼠标左键，沿着文本拖动鼠标（或者双击一个单词）高亮了一些文本，  那么这些高亮的文本就被拷贝到了一个由 X 管理的缓冲区里面。然后按下鼠标中键，  这些文本就被粘贴到光标所在的位置</p>
<h3 id="创建与删除别名"><a href="#创建与删除别名" class="headerlink" title="创建与删除别名"></a>创建与删除别名</h3><h4 id="创建别名"><a href="#创建别名" class="headerlink" title="创建别名"></a>创建别名</h4><pre><code>alias name=&#39;string&#39;</code></pre><h4 id="删除别名"><a href="#删除别名" class="headerlink" title="删除别名"></a>删除别名</h4><pre><code>unalias name</code></pre><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>shell 在环境中存储了两种基本类型的数据，虽然对于 bash 来说，很大程度上这些类型是不可辨别的。它们是<strong>环境变量</strong>和 <strong>shell 变量</strong>。Shell 变量是由 bash 存放的少量数据，而剩下的基本上都是环境变量。除了变量，shell 也存储了一些可编程的数据，即别名和 shell 函数。</p>
<h3 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h3><p>两者的区别为，printenv只显示环境变量，而set同时显示shell和环境变量两者。</p>
<pre><code>printenv | less
set | less</code></pre><p>也可以查看特定的环境变量</p>
<pre><code>printenv PATH</code></pre><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><h3 id="clear-－-清空屏幕"><a href="#clear-－-清空屏幕" class="headerlink" title="clear － 清空屏幕"></a>clear － 清空屏幕</h3><h3 id="history-－-显示历史列表内容"><a href="#history-－-显示历史列表内容" class="headerlink" title="history － 显示历史列表内容"></a>history － 显示历史列表内容</h3><p>更方便的进行浏览：</p>
<pre><code>history | less</code></pre><h3 id="type-－-显示命令的类型"><a href="#type-－-显示命令的类型" class="headerlink" title="type － 显示命令的类型"></a>type － 显示命令的类型</h3><p>type 命令是 shell 内部命令，它会显示命令的类别，给出一个特定的命令名（做为参数）。</p>
<pre><code>type command</code></pre><h3 id="which-－-显示一个可执行程序的位置"><a href="#which-－-显示一个可执行程序的位置" class="headerlink" title="which － 显示一个可执行程序的位置"></a>which － 显示一个可执行程序的位置</h3><p>有时候在一个操作系统中，不只安装了可执行程序的一个版本（如各种python）。为了确定所给定的执行程序的准确位置，使用 which 命令：</p>
<p>这个命令只对可执行程序有效，不包括内建命令和命令别名（如cd等命令）</p>
<h3 id="help-－-得到-shell-内建命令的帮助文档"><a href="#help-－-得到-shell-内建命令的帮助文档" class="headerlink" title="help － 得到 shell 内建命令的帮助文档"></a>help － 得到 shell 内建命令的帮助文档</h3><p>只对内建命令有效（如cd），对诸如ls等命令则无效。</p>
<h3 id="help-显示用法信息"><a href="#help-显示用法信息" class="headerlink" title="--help - 显示用法信息"></a>--help - 显示用法信息</h3><p>与help类似，但个人认为更实用一些。</p>
<h3 id="whatis-－-显示非常简洁的命令说明"><a href="#whatis-－-显示非常简洁的命令说明" class="headerlink" title="whatis － 显示非常简洁的命令说明"></a>whatis － 显示非常简洁的命令说明</h3><p>whatis 程序显示匹配特定关键字的手册页的名字和一行命令说明</p>
<pre><code>$ whatis mkdir
mkdir (1)            - make directories
mkdir (2)            - create a directory</code></pre><h2 id="命令行常用快捷键"><a href="#命令行常用快捷键" class="headerlink" title="命令行常用快捷键"></a>命令行常用快捷键</h2><p>列出了本人常用的命令，感觉也是平时能用的上的全部命令了。一些与常规计算机操作相同的方法就没写进去了。</p>
<h3 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h3><table class="multi">
<tr>
<th class="title">按键</th>
<th class="title">行动</th>
</tr>
<tr>
<td valign="top" width="25%">Ctrl-a</td>
<td valign="top">移动光标到行首。</td>
</tr>
<tr>
<td valign="top">Ctrl-e</td>
<td valign="top">移动光标到行尾。</td>
</tr>
<tr>
<td valign="top">Ctrl-l</td>
<td valign="top">清空屏幕，移动光标到左上角。clear 命令完成同样的工作。</td>
</tr>
</table>



<h3 id="剪切和粘贴文本"><a href="#剪切和粘贴文本" class="headerlink" title="剪切和粘贴文本"></a>剪切和粘贴文本</h3><table class="multi">
<tr>
<th class="title"> 按键</th>
<th class="title"> 行动</th>
</tr>
<tr>
<td valign="top" width="25%">Ctrl-k</td>
<td valign="top"> 剪切从光标位置到行尾的文本。</td>
</tr>
<tr>
<td valign="top">Ctrl-u</td>
<td valign="top"> 剪切从光标位置到行首的文本。</td>
</tr>
<tr>
<td valign="top">Ctrl-y</td>
<td valign="top"> 把剪切环中的文本粘贴到光标位置。</td>
</tr>
</table>



]]></content>
      <categories>
        <category>计算机基础</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>命令行IO重定向</title>
    <url>/page/linux-io-redirection.html</url>
    <content><![CDATA[<p>I/O 重定向。”I/O”代表输入/输出，<br>通过这个工具，你可以重定向命令的输入输出，命令的输入来自文件，而输出也存到文件。</p>
<h3 id="重定向标准输出"><a href="#重定向标准输出" class="headerlink" title="重定向标准输出"></a>重定向标准输出</h3><p>I/O 重定向允许我们来重定义标准输出的地点。我们使用 “&gt;” 重定向符后接文件名来重定向标准输出到除屏幕</p>
<p>如下，ls 命令的运行结果输送到文件 ls-output.txt 中去，由文件代替屏幕。</p>
<pre><code>ls -l /usr/bin &gt; ls-output.txt</code></pre><h4 id="创建文件或删除文件内容"><a href="#创建文件或删除文件内容" class="headerlink" title="创建文件或删除文件内容"></a>创建文件或删除文件内容</h4><p>如果没有该文件则为创建一个新文件，如果文件已存在，则删除文件内容（由于目标文件总是从开头被重写）</p>
<pre><code>&gt; output.txt</code></pre><h4 id="将结果追加到内容后面"><a href="#将结果追加到内容后面" class="headerlink" title="将结果追加到内容后面"></a>将结果追加到内容后面</h4><p>使用”&gt;&gt;“操作符，将导致输出结果添加到文件内容之后。如果文件不存在，文件会被创建。</p>
<p>如下，ls-output.txt中的内容是正常输出的两倍。</p>
<pre><code>ls -l /usr/bin &gt;&gt; ls-output.txt
ls -l /usr/bin &gt;&gt; ls-output.txt</code></pre><h2 id="重定向标准输入"><a href="#重定向标准输入" class="headerlink" title="重定向标准输入"></a>重定向标准输入</h2><h3 id="cat-－-读取、连接、输出文件"><a href="#cat-－-读取、连接、输出文件" class="headerlink" title="cat － 读取、连接、输出文件"></a>cat － 读取、连接、输出文件</h3><h4 id="1、cat读取一个或多个文件，然后复制它们到标准输出"><a href="#1、cat读取一个或多个文件，然后复制它们到标准输出" class="headerlink" title="1、cat读取一个或多个文件，然后复制它们到标准输出"></a>1、cat读取一个或多个文件，然后复制它们到标准输出</h4><pre><code>cat filename
cat f1 f2 f3 &gt; output.txt</code></pre><h4 id="2、cat从键盘读取数据并输出"><a href="#2、cat从键盘读取数据并输出" class="headerlink" title="2、cat从键盘读取数据并输出"></a>2、cat从键盘读取数据并输出</h4><pre><code>cat &gt; output.txt</code></pre><p>之后在键盘输入内容，按下Ctrl-d表示到达文件末尾，输入的数据就被写入了output.txt</p>
<h3 id="sort-－-排序文本行"><a href="#sort-－-排序文本行" class="headerlink" title="sort － 排序文本行"></a>sort － 排序文本行</h3><h3 id="uniq-－-报道或省略重复行"><a href="#uniq-－-报道或省略重复行" class="headerlink" title="uniq － 报道或省略重复行"></a>uniq － 报道或省略重复行</h3><h3 id="grep-－-打印匹配行"><a href="#grep-－-打印匹配行" class="headerlink" title="grep － 打印匹配行"></a>grep － 打印匹配行</h3><p>如下，即为答应当前目录下包含.log的文件名</p>
<pre><code>ls | grep .log</code></pre><h3 id="wc-－-打印文件中换行符，字，和字节个数"><a href="#wc-－-打印文件中换行符，字，和字节个数" class="headerlink" title="wc － 打印文件中换行符，字，和字节个数"></a>wc － 打印文件中换行符，字，和字节个数</h3><h3 id="head-－-输出文件第一部分"><a href="#head-－-输出文件第一部分" class="headerlink" title="head － 输出文件第一部分"></a>head － 输出文件第一部分</h3><h3 id="tail-输出文件最后一部分"><a href="#tail-输出文件最后一部分" class="headerlink" title="tail - 输出文件最后一部分"></a>tail - 输出文件最后一部分</h3><h3 id="tee-从标准输入读取数据，并同时写到标准输出和文件"><a href="#tee-从标准输入读取数据，并同时写到标准输出和文件" class="headerlink" title="tee - 从标准输入读取数据，并同时写到标准输出和文件"></a>tee - 从标准输入读取数据，并同时写到标准输出和文件</h3><h3 id="管道线"><a href="#管道线" class="headerlink" title="管道线"></a>管道线</h3><h4 id="管道操作符"><a href="#管道操作符" class="headerlink" title="管道操作符 |"></a>管道操作符 |</h4><p>命令从标准输入读取数据并输送到标准输出的能力被一个称为管道线的 shell 特性所利用。使用管道操作符”|”（竖杠），一个命令的标准输出可以通过管道送至另一个命令的标准输入：</p>
<pre><code>command1 | command2</code></pre><p>如下，ls -l 的输出就直接输入到 less命令</p>
<pre><code>ls -l | less</code></pre><h4 id="过滤器，使用多个"><a href="#过滤器，使用多个" class="headerlink" title="过滤器，使用多个 |"></a>过滤器，使用多个 |</h4><p>如下，即将当前目录文件名排序去重后输出</p>
<pre><code>ls | sort | uniq | less</code></pre>]]></content>
      <categories>
        <category>计算机基础</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>权限</title>
    <url>/page/linux-temp.html</url>
    <content><![CDATA[<h3 id="id-–-显示用户身份号"><a href="#id-–-显示用户身份号" class="headerlink" title="id – 显示用户身份号"></a>id – 显示用户身份号</h3><p>显示系统给用户分配的uid与系统与用户分配的组id（gid）</p>
<p>用户帐户定义在/etc/passwd 文件里面，用户组定义在/etc/group 文件里面。当用户帐户和用户组创建以后，这些文件随着文件/etc/shadow 的变动而修改，文件/etc/shadow 包含了关于用户密码的信息</p>
<p>对于每个用户帐号，文件/etc/passwd 定义了用户（登录）名、uid、gid、帐号的真实姓名、家目录和登录 shell。如果你查看一下文件/etc/passwd 和文件/etc/group 的内容，你会注意到除了普通用户帐号之外，还有超级用户（uid 0）帐号，和各种各样的系统用户。</p>
<p>chmod – 更改文件模式</p>
<p>更改文件或目录的模式（权限），可以利用 chmod 命令。注意只有文件的所有者或者超级用户才<br>能更改文件或目录的模式。chmod 命令支持两种不同的方法来改变文件模式：八进制数字表示法或<br>符号表示法。</p>
<p>umask – 设置默认的文件权限</p>
<h3 id="su-–-以另一个用户的身份来运行-shell"><a href="#su-–-以另一个用户的身份来运行-shell" class="headerlink" title="su – 以另一个用户的身份来运行 shell"></a>su – 以另一个用户的身份来运行 shell</h3><p>以超级用户身份来允许shell（提示符的末尾字符是”#”而不是”$”）。当工作完成后，输入”exit”，则返回到原来的 shell:</p>
<p>也可以使su只执行单个命令</p>
<pre><code>su -c &#39;command&#39;

su -c &#39;ls&#39;</code></pre><h3 id="sudo-–-以另一个用户的身份来执行命令"><a href="#sudo-–-以另一个用户的身份来执行命令" class="headerlink" title="sudo – 以另一个用户的身份来执行命令"></a>sudo – 以另一个用户的身份来执行命令</h3><p>与su命令大体上相似。与su命令相比一个重要差异是 sudo 命令不要求超级用户的密码，而只是使用当前用户的密码即可。</p>
<h3 id="chown-–-更改文件所有者"><a href="#chown-–-更改文件所有者" class="headerlink" title="chown – 更改文件所有者"></a>chown – 更改文件所有者</h3><h3 id="chgrp-–-更改文件组所有权"><a href="#chgrp-–-更改文件组所有权" class="headerlink" title="chgrp – 更改文件组所有权"></a>chgrp – 更改文件组所有权</h3><h3 id="passwd-–-更改用户密码"><a href="#passwd-–-更改用户密码" class="headerlink" title="passwd – 更改用户密码"></a>passwd – 更改用户密码</h3><p>输入passwd命令，就能够更改密码，shell会自动提示你相关信息</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>文件路径操作命令</title>
    <url>/page/linux-terminal-file-path.html</url>
    <content><![CDATA[<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><table class="multi">
<caption class="cap">Linux 系统中的目录</caption>
<tr>
<th class="title">目录</th>
<th class="title">评论</th>
</tr>
<tr>
<td valign="top">/</td>
<td valign="top">根目录，万物起源。</td>
</tr>
<tr>
<td valign="top">/bin</td>
<td valign="top">包含系统启动和运行所必须的二进制程序。</td>
</tr>
<tr>
<td valign="top">/boot</td>
<td valign="top"><p>包含 Linux 内核、初始 RAM 磁盘映像（用于启动时所需的驱动）和
启动加载程序。</p>
<p>有趣的文件：</p>
<ul>
<li>/boot/grub/grub.conf or menu.lst， 被用来配置启动加载程序。</li>
<li>/boot/vmlinuz，Linux 内核。</li>
</ul>
</td>
</tr>
<tr>
<td valign="top">/dev</td>
<td valign="top">这是一个包含设备结点的特殊目录。“一切都是文件”，也适用于设备。
在这个目录里，内核维护着所有设备的列表。</td>
</tr>
<tr>
<td valign="top">/etc</td>
<td valign="top"><p>这个目录包含所有系统层面的配置文件。它也包含一系列的 shell 脚本，
在系统启动时，这些脚本会开启每个系统服务。这个目录中的任何文件应该是可读的文本文件。</p>
<p>有趣的文件：虽然/etc 目录中的任何文件都有趣，但这里只列出了一些我一直喜欢的文件：</p>
<ul>
<li>/etc/crontab， 定义自动运行的任务。</li>
<li>/etc/fstab，包含存储设备的列表，以及与他们相关的挂载点。</li>
<li>/etc/passwd，包含用户帐号列表。 </li>
</ul>
</td>
</tr>
<tr>
<td valign="top">/home</td>
<td valign="top">在通常的配置环境下，系统会在/home 下，给每个用户分配一个目录。普通用户只能
在自己的目录下写文件。这个限制保护系统免受错误的用户活动破坏。</td>
</tr>
<tr>
<td valign="top">/lib </td>
<td valign="top">包含核心系统程序所使用的共享库文件。这些文件与 Windows 中的动态链接库相似。</td>
</tr>
<tr>
<td valign="top">/lost+found </td>
<td valign="top">每个使用 Linux 文件系统的格式化分区或设备，例如 ext3文件系统，
都会有这个目录。当部分恢复一个损坏的文件系统时，会用到这个目录。除非文件系统
真正的损坏了，那么这个目录会是个空目录。</td>
</tr>
<tr>
<td>/media </td>
<td>在现在的 Linux 系统中，/media 目录会包含可移动介质的挂载点，
例如 USB 驱动器，CD-ROMs 等等。这些介质连接到计算机之后，会自动地挂载到这个目录结点下。
</td>
</tr>
<tr>
<td>/mnt</td>
<td>在早些的 Linux 系统中，/mnt 目录包含可移动介质的挂载点。</td>
</tr>
<tr>
<td>/opt</td>
<td>这个/opt 目录被用来安装“可选的”软件。这个主要用来存储可能
安装在系统中的商业软件产品。</td>
</tr>
<tr>
<td>/proc</td>
<td>这个/proc 目录很特殊。从存储在硬盘上的文件的意义上说，它不是真正的文件系统。
相反，它是一个由 Linux 内核维护的虚拟文件系统。它所包含的文件是内核的窥视孔。这些文件是可读的，
它们会告诉你内核是怎样监管计算机的。</td>
</tr>
<tr>
<td>/root</td>
<td>root 帐户的家目录。</td>
</tr>
<tr>
<td>/sbin</td>
<td>这个目录包含“系统”二进制文件。它们是完成重大系统任务的程序，通常为超级用户保留。</td>
</tr>
<tr>
<td>/tmp</td>
<td>这个/tmp 目录，是用来存储由各种程序创建的临时文件的地方。一些配置导致系统每次
重新启动时，都会清空这个目录。</td>
</tr>
<tr>
<td>/usr</td>
<td>在 Linux 系统中，/usr 目录可能是最大的一个。它包含普通用户所需要的所有程序和文件。</td>
</tr>
<tr>
<td>/usr/bin</td>
<td>/usr/bin 目录包含系统安装的可执行程序。通常，这个目录会包含许多程序。</td>
</tr>
<tr>
<td>/usr/lib</td>
<td>包含由/usr/bin 目录中的程序所用的共享库。 </td>
</tr>
<tr>
<td>/usr/local</td>
<td>这个/usr/local 目录，是非系统发行版自带，却打算让系统使用的程序的安装目录。
通常，由源码编译的程序会安装在/usr/local/bin 目录下。新安装的 Linux 系统中，会存在这个目录，
但却是空目录，直到系统管理员放些东西到它里面。</td>
</tr>
<tr>
<td>/usr/sbin</td>
<td>包含许多系统管理程序。 </td>
</tr>
<tr>
<td>/usr/share</td>
<td>/usr/share 目录包含许多由/usr/bin 目录中的程序使用的共享数据。
其中包括像默认的配置文件、图标、桌面背景、音频文件等等。</td>
</tr>
<tr>
<td>/usr/share/doc</td>
<td>大多数安装在系统中的软件包会包含一些文档。在/usr/share/doc 目录下，
我们可以找到按照软件包分类的文档。</td>
</tr>
<tr>
<td>/var</td>
<td>除了/tmp 和/home 目录之外，相对来说，目前我们看到的目录是静态的，这是说，
它们的内容不会改变。/var 目录是可能需要改动的文件存储的地方。各种数据库，假脱机文件，
用户邮件等等，都位于在这里。</td>
</tr>
<tr>
<td>/var/log</td>
<td>这个/var/log 目录包含日志文件、各种系统活动的记录。这些文件非常重要，并且
应该时时监测它们。其中最重要的一个文件是/var/log/messages。注意，为了系统安全，在一些系统中，
你必须是超级用户才能查看这些日志文件。</td></tr>
</table>



<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="pwd-—-打印出当前工作目录名"><a href="#pwd-—-打印出当前工作目录名" class="headerlink" title="pwd — 打印出当前工作目录名"></a>pwd — 打印出当前工作目录名</h3><h3 id="cd-—-更改目录"><a href="#cd-—-更改目录" class="headerlink" title="cd — 更改目录"></a>cd — 更改目录</h3><table class="multi">
<caption class="cap">cd 快捷键</caption>
<thead>
<tr>
<th class="title">快捷键</th>
<th class="title">运行结果</th>
</tr>
</thead>
<tbody>
<tr>
<td >cd</td>
<td >更改工作目录到你的家目录。</td>
</tr>
<tr>
<td > cd -</td>
<td > 更改工作目录到先前的工作目录。</td>
</tr>
<tr>
<td id="tdlist">cd ~user_name</td>
<td> 更改工作目录到用户家目录。例如, cd ~bob 会更改工作目录到用户“bob”的家目录。</td>
</tr>
</tbody>
</table>



<h3 id="ls-—-列出目录内容"><a href="#ls-—-列出目录内容" class="headerlink" title="ls — 列出目录内容"></a>ls — 列出目录内容</h3><pre><code>ls
ls /usr
ls ~ /usr
ls -l    使用长模式进行输出</code></pre><h3 id="file-—-确定文件类型"><a href="#file-—-确定文件类型" class="headerlink" title="file — 确定文件类型"></a>file — 确定文件类型</h3><pre><code>file filename</code></pre><h3 id="less-—-浏览文件内容"><a href="#less-—-浏览文件内容" class="headerlink" title="less — 浏览文件内容"></a>less — 浏览文件内容</h3><p>less 命令是一个用来浏览文本文件的程序。纵观 Linux 系统，有许多人类可读的文本文件。less 程序为我们检查文本文件 提供了方便。一旦 less 程序运行起来，我们就能浏览文件内容了。如果文件内容多于一页，那么我们可以上下滚动文件。按下“q”键，</p>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><ol>
<li>cd 到给定目录</li>
<li>列出目录内容 ls -l</li>
<li>如果看到一个有趣的文件，用 file 命令确定文件内容</li>
<li>如果文件看起来像文本，试着用 less 命令浏览它</li>
</ol>
<h2 id="操作文件和目录"><a href="#操作文件和目录" class="headerlink" title="操作文件和目录"></a>操作文件和目录</h2><h3 id="cp-—-复制文件和目录"><a href="#cp-—-复制文件和目录" class="headerlink" title="cp — 复制文件和目录"></a>cp — 复制文件和目录</h3><table class="multi">
<caption class="cap">cp 选项</caption>
<tr>
<th class="title">选项</th>
<th class="title">意义</th>
</tr>
<tr>
<td valign="top" width="25%">-a, --archive</td>
<td valign="top">复制文件和目录，以及它们的属性，包括所有权和权限。
通常，复本具有用户所操作文件的默认属性。</td>
</tr>
<tr>
<td valign="top">-i, --interactive</td>
<td valign="top">在重写已存在文件之前，提示用户确认。如果这个选项不指定，
cp 命令会默认重写文件。</td>
</tr>
<tr>
<td valign="top">-r, --recursive</td>
<td valign="top">递归地复制目录及目录中的内容。当复制目录时，
需要这个选项（或者-a 选项）。</td>
</tr>
<tr>
<td valign="top">-u, --update </td>
<td valign="top">当把文件从一个目录复制到另一个目录时，仅复制
目标目录中不存在的文件，或者是文件内容新于目标目录中已经存在的文件。</td>
</tr>
<tr>
<td valign="top">-v, --verbose</td>
<td valign="top">显示翔实的命令操作信息</td>
</tr>
</table>



<h3 id="mv-—-移动-重命名文件和目录"><a href="#mv-—-移动-重命名文件和目录" class="headerlink" title="mv — 移动/重命名文件和目录"></a>mv — 移动/重命名文件和目录</h3><table class="multi">
<caption class="cap">mv 选项</caption>
<tr>
<th class="title">选项</th>
<th class="title">意义</th>
</tr>
<tr>
<td valign="top" width="25%">-i --interactive</td>
<td valign="top">在重写一个已经存在的文件之前，提示用户确认信息。
<b>如果不指定这个选项，mv 命令会默认重写文件内容。</b></td>
</tr>
<tr>
<td valign="top">-u --update</td>
<td valign="top">当把文件从一个目录移动另一个目录时，只是移动不存在的文件，
或者文件内容新于目标目录相对应文件的内容。</td>
</tr>
<tr>
<td valign="top">-v --verbose</td>
<td valign="top">当操作 mv 命令时，显示翔实的操作信息。</td>
</tr>
</table>



<h3 id="mkdir-—-创建目录"><a href="#mkdir-—-创建目录" class="headerlink" title="mkdir — 创建目录"></a>mkdir — 创建目录</h3><p>可跟多个参数创建多个目录</p>
<pre><code>mkdir dir1 dir2 dir3</code></pre><h3 id="rm-—-删除文件和目录"><a href="#rm-—-删除文件和目录" class="headerlink" title="rm — 删除文件和目录"></a>rm — 删除文件和目录</h3><table class="multi">
<caption class="cap">rm 选项</caption>
<tr>
<th class="title">选项</th>
<th class="title">意义</th>
</tr>
<tr>
<td valign="top" width="25%">-i, --interactive </td>
<td
valign="top">在删除已存在的文件前，提示用户确认信息。
<b>如果不指定这个选项，rm 会默默地删除文件</b>
</td>
</tr>
<tr>
<td valign="top">-r, --recursive</td>
<td valign="top">递归地删除文件，这意味着，如果要删除一个目录，而此目录
又包含子目录，那么子目录也会被删除。要删除一个目录，必须指定这个选项。</td>
</tr>
<tr>
<td valign="top">-f, --force</td>
<td valign="top">忽视不存在的文件，不显示提示信息。这选项覆盖了“--interactive”选项。</td>
</tr>
<tr>
<td valign="top">-v, --verbose</td>
<td valign="top">在执行 rm 命令时，显示翔实的操作信息。</td>
</tr>
</table>



<h3 id="ln-—-创建硬链接和符号链接"><a href="#ln-—-创建硬链接和符号链接" class="headerlink" title="ln — 创建硬链接和符号链接"></a>ln — 创建硬链接和符号链接</h3><h4 id="创建硬链接"><a href="#创建硬链接" class="headerlink" title="创建硬链接"></a>创建硬链接</h4><ol>
<li>一个硬链接不能关联它所在文件系统之外的文件。这是说一个链接不能关联<br>与链接本身不在同一个磁盘分区上的文件。</li>
<li>一个硬链接不能关联一个目录。</li>
</ol>
<h4 id="创建符号链接"><a href="#创建符号链接" class="headerlink" title="创建符号链接"></a>创建符号链接</h4><p>创建符号链接是为了克服硬链接的局限性。符号链接生效，是通过创建一个特殊类型的文件，这个文件包含一个关联文件或目录的文本指针。在这一方面，它们和 Windows 的快捷方式差不多</p>
<p>一个符号链接指向一个文件，而且这个符号链接本身与其它的符号链接几乎没有区别。<br>例如，如果你往一个符号链接里面写入东西，那么相关联的文件也被写入。然而，<br>当你删除一个符号链接时，只有这个链接被删除，而不是文件自身。如果先于符号链接删除文件，这个链接仍然存在，但是不指向任何东西。在这种情况下，这个链接被称为坏链接。在许多实现中，ls 命令会以不同的颜色展示坏链接，比如说红色，来显示它们的存在。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>控制台进程管理</title>
    <url>/page/terminal-process-manage.html</url>
    <content><![CDATA[<h2 id="进程工作"><a href="#进程工作" class="headerlink" title="进程工作"></a>进程工作</h2><p>当系统启动的时候，内核先把一些它自己的活动初始化为进程，然后运行一个叫做 init 的程序。init，依次地，再运行一系列的称为 init 脚本的 shell 脚本（位于/etc），它们可以启动所有的系统服务。其中许多系统服务以守护（daemon）程序的形式实现，守护程序仅在后台运行，没有任何用户界面。这样，即使我们没有登录系统，至少系统也在忙于执行一些例行事务。</p>
<p>内核维护每个进程的信息，以此来保持事情有序。例如，系统分配给每个进程一个数字，这个数字叫做进程 ID 或 PID。PID 号按升序分配，init 进程的 PID 总是1。内核也对分配给每个进程的内存和就绪状态进行跟踪以便继续执行这个进程。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="ps-–-报告当前进程快照"><a href="#ps-–-报告当前进程快照" class="headerlink" title="ps – 报告当前进程快照"></a>ps – 报告当前进程快照</h3><h4 id="不带任何参数"><a href="#不带任何参数" class="headerlink" title="不带任何参数"></a>不带任何参数</h4><p>默认情况下，ps 不会显示很多进程信息，只是列出与当前终端会话相关的进程</p>
<pre><code>$ ps
  PID TTY          TIME CMD
 3471 pts/1    00:00:00 bash
12266 pts/1    00:00:00 ps</code></pre><h4 id="加上-x-，展示所有进程"><a href="#加上-x-，展示所有进程" class="headerlink" title="加上 x ，展示所有进程"></a>加上 x ，展示所有进程</h4><pre><code>ps x</code></pre><p>输出中”TTY”中的？表示没有控制终端。而新增的STAT表示进程的状态，状态如下。出去这些基本的状态，进程之后还会跟随其他字符，表示各种外来进程的特性</p>
<table class="multi">
<caption class="cap">进程状态</caption>
<thead>
<tr>
<th class="title">状态</th>
<th class="title">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td valign="top" width="15%">R</td>
<td valign="top">运行中。这意味着，进程正在运行或准备运行。
</td>
</tr>
<tr>
<td valign="top">S</td>
<td valign="top">正在睡眠。进程没有运行，而是，正在等待一个事件，
比如说，一个按键或者网络分组。
</td>
</tr>
<tr>
<td valign="top">D</td>
<td valign="top">不可中断睡眠。进程正在等待 I/O，比方说，一个磁盘驱动器的 I/O。</td>
</tr>
<tr>
<td valign="top">T</td>
<td valign="top">已停止. 已经指示进程停止运行。稍后介绍更多。</td>
</tr>
<tr>
<td valign="top">Z</td>
<td
valign="top">一个死进程或“僵尸”进程。这是一个已经终止的子进程，但是它的父进程还没有清空它。
（父进程没有把子进程从进程表中删除）</td>
</tr>
<tr>
<td valign="top"><</td>
<td
valign="top">一个高优先级进程。这可能会授予一个进程更多重要的资源，给它更多的 CPU 时间。
进程的这种属性叫做 niceness。具有高优先级的进程据说是不好的（less nice），
因为它占用了比较多的 CPU 时间，这样就给其它进程留下很少时间。
</td>
</tr>
<tr>
<td valign="top">N</td>
<td valign="top">低优先级进程。
一个低优先级进程（一个“好”进程）只有当其它高优先级进程被服务了之后，才会得到处理器时间。
</td>
</tr>
</tbody>
</table>



<h3 id="top-–-显示任务"><a href="#top-–-显示任务" class="headerlink" title="top – 显示任务"></a>top – 显示任务</h3><p>ps只显示ps执行那一个瞬间的信息，而top 程序以进程活动顺序显示连续更新的系统进程列表（默认情况下，每三秒钟更新一次）</p>
<h3 id="jobs-–-列出活跃的任务"><a href="#jobs-–-列出活跃的任务" class="headerlink" title="jobs – 列出活跃的任务"></a>jobs – 列出活跃的任务</h3><p>如在当前窗口后台运行的进程，<strong>可用来查看PID等信息</strong></p>
<h3 id="bg-–-把一个任务放到后台执行"><a href="#bg-–-把一个任务放到后台执行" class="headerlink" title="bg – 把一个任务放到后台执行"></a>bg – 把一个任务放到后台执行</h3><h3 id="fg-–-把一个任务放到前台执行"><a href="#fg-–-把一个任务放到前台执行" class="headerlink" title="fg – 把一个任务放到前台执行"></a>fg – 把一个任务放到前台执行</h3><h3 id="kill-–-给一个进程发送信号"><a href="#kill-–-给一个进程发送信号" class="headerlink" title="kill – 给一个进程发送信号"></a>kill – 给一个进程发送信号</h3><h4 id="默认中止程序"><a href="#默认中止程序" class="headerlink" title="默认中止程序"></a>默认中止程序</h4><pre><code>kill PID</code></pre><h4 id="发送信号"><a href="#发送信号" class="headerlink" title="发送信号"></a>发送信号</h4><p>查看所有信号</p>
<pre><code>kill -l</code></pre><p>如下，是对PID为13546的进程发送了1号信号（HUP，挂起）。注意，信号既可以用号码，也可以用名字来指定，包括在前面加上字母 “SIG” 的名字</p>
<pre><code>kill -1 13546</code></pre><h4 id="常见信号"><a href="#常见信号" class="headerlink" title="常见信号"></a>常见信号</h4><table class="multi">
<caption class="cap">常用信号</caption>
<tr>
<th class="title">编号</th>
<th class="title">名字</th>
<th class="title">含义</th>
</tr>
<tr>
<td valign="top" width="10%">1</td>
<td valign="top" width="10%">HUP</td>
<td valign="top">挂起。这是美好往昔的残留部分，那时候终端机通过电话线和调制解调器连接到
远端的计算机。这个信号被用来告诉程序，控制的终端机已经“挂起”。
通过关闭一个终端会话，可以展示这个信号的作用。在当前终端运行的前台程序将会收到这个信号并终止。
<p>许多守护进程也使用这个信号，来重新初始化。这意味着，当一个守护进程收到这个信号后，
这个进程会重新启动，并且重新读取它的配置文件。Apache 网络服务器守护进程就是一个例子。</p>
</td>
</tr>
<tr>
<td valign="top">2</td>
<td valign="top">INT</td>
<td valign="top">中断。实现和 Ctrl-c 一样的功能，由终端发送。通常，它会终止一个程序。
</td>
</tr>
<tr>
<td valign="top">9</td>
<td valign="top">KILL</td>
<td
valign="top">杀死。这个信号很特别。尽管程序可能会选择不同的方式来处理发送给它的
信号，其中也包含忽略信号，但是 KILL 信号从不被发送到目标程序。而是内核立即终止
这个进程。当一个进程以这种方式终止的时候，它没有机会去做些“清理”工作，或者是保存工作。
因为这个原因，把 KILL 信号看作最后一招，当其它终止信号失败后，再使用它。
</td>
</tr>
<tr>
<td valign="top">15</td>
<td valign="top">TERM</td>
<td valign="top">终止。这是 kill 命令发送的默认信号。如果程序仍然“活着”，可以接受信号，那么
这个它会终止。 </td>
</tr>
<tr>
<td valign="top">18</td>
<td valign="top">CONT</td>
<td valign="top">继续。在一个停止信号后，这个信号会恢复进程的运行。</td>
</tr>
<tr>
<td valign="top">19</td>
<td valign="top">STOP</td>
<td
valign="top">停止。这个信号导致进程停止运行，而不是终止。像 KILL 信号，它不被
发送到目标进程，因此它不能被忽略。
</td>
</tr>
</table>

<h3 id="killall-–-杀死指定名字的进程、给多个进程发送信号"><a href="#killall-–-杀死指定名字的进程、给多个进程发送信号" class="headerlink" title="killall – 杀死指定名字的进程、给多个进程发送信号"></a>killall – 杀死指定名字的进程、给多个进程发送信号</h3><h3 id="shutdown-–-关机或重启系统"><a href="#shutdown-–-关机或重启系统" class="headerlink" title="shutdown – 关机或重启系统"></a>shutdown – 关机或重启系统</h3><h2 id="控制进程的基本使用"><a href="#控制进程的基本使用" class="headerlink" title="控制进程的基本使用"></a>控制进程的基本使用</h2><h3 id="中断一个进程"><a href="#中断一个进程" class="headerlink" title="中断一个进程"></a>中断一个进程</h3><p>按下 Ctrl-c</p>
<h3 id="将一个进程放置到后台"><a href="#将一个进程放置到后台" class="headerlink" title="将一个进程放置到后台"></a>将一个进程放置到后台</h3><p>为了启动一个程序并让它立即在后台运行，我们在程序命令之后，加上”&amp;”字符。如下</p>
<pre><code>xlogo &amp;
[1] 12453</code></pre><p>执行命令之后，这个 xlogo 窗口出现，并且 shell 提示符返回，同时打印一些有趣的数字。这条信息是 shell 特性的一部分，叫做任务控制。通过这条信息，shell 告诉我们，已经启动了任务号为1（“［1］”），PID 为12453的程序</p>
<p>此时使用<strong>jobs</strong>命令即可看到后台运行的进程的信息</p>
<h3 id="将一个进程返回到前台"><a href="#将一个进程返回到前台" class="headerlink" title="将一个进程返回到前台"></a>将一个进程返回到前台</h3><p>如下，将任务序号为1的进程返回前台。之后Ctrl-c即可中断进程</p>
<pre><code>fg %1</code></pre><h3 id="停止一个进程"><a href="#停止一个进程" class="headerlink" title="停止一个进程"></a>停止一个进程</h3><p>使用Ctrl-z停止一个进程，目的是允许前台进程被移动到后台（处理忘记加”&amp;”的情况）。</p>
<p>将任务序号为1的进程放置在后台</p>
<pre><code>bg %1</code></pre><h3 id="信号"><a href="#信号" class="headerlink" title="信号"></a>信号</h3><p>综上所述的各种操作进程的命令，本质上是给程序发送信号。信号是操作系统与程序之间进行通信时所采用的几种方式中的一种</p>
<h2 id="命令行启动程序"><a href="#命令行启动程序" class="headerlink" title="命令行启动程序"></a>命令行启动程序</h2><ol>
<li>想要启动的程序，可能没有在窗口管理器的菜单中列出来（xlogo、typora等等）</li>
<li>从命令行启动一个程序，能够看到一些错误信息</li>
</ol>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL的一些机制</title>
    <url>/page/mysql3.html</url>
    <content><![CDATA[<p>123</p>
<p>事务机制</p>
<p>事务是一个或多个SQL语句组成的整体，要么全部执行成功，要么全部执行失败</p>
<pre><code>START TRANSACTION
SQL语句
[COMMIT | ROLLBACK]</code></pre><p>导出SQL文件</p>
<pre><code></code></pre><p>导出</p>
<p>SQL注入攻击：</p>
<p>SQL预编译机制</p>
<p>数据加密</p>
<p>对称加密（DES加密、AES加密）</p>
<p>AES加密函数：<code>AES_ENCRYPT(原始数据，密钥字符串)</code></p>
<p>AES解密函数：<code>AES_DECRYPT(加密结果，密钥字符串)</code></p>
<p>非对称加密（RSA加密、DSA加密、ECC加密）</p>
<p>数据库连接池（Connection Pool）：预先创建一些数据库连接，然后缓存起来，避免了程序语言反复创建和销毁连接的昂贵代价</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>第一章：计算机网络与英特网</title>
    <url>/page/no1-computer-network-and-the-internet.html</url>
    <content><![CDATA[<h2 id="什么是Internet"><a href="#什么是Internet" class="headerlink" title="什么是Internet"></a>什么是Internet</h2><p>计算机网络：通过<strong>通信信道</strong>，将地理上分布的多个计算机系统连接起来，在相应<strong>网络协议</strong>的支持下，实现信息传送、资源共享和网络计算功能的系统</p>
<h3 id="分类依据"><a href="#分类依据" class="headerlink" title="分类依据"></a>分类依据</h3><p>1、根据覆盖范围（Coverage）</p>
<p>2、根据节点移动性（Node Mobility）</p>
<h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p><strong>端系统（End System）</strong>：与因特网相连的计算机和其它设备，往往处于网络的边缘，因此称为端系统，也被称为<strong>主机（host）</strong>，主机有时可以进一步被划分为<strong>客户（client）</strong>和<strong>服务器（server）</strong></p>
<h3 id="两种模型"><a href="#两种模型" class="headerlink" title="两种模型"></a>两种模型</h3><p>1、client/server model</p>
<p>2、peer-peer model</p>
<h3 id="接入网"><a href="#接入网" class="headerlink" title="接入网"></a>接入网</h3><p><strong>接入网</strong>：是指将端系统连入到边缘路由器的物理链路</p>
<p><strong>边缘路由器</strong>：是指端系统到任何其他远程端系统路径上的第一台路由器</p>
<h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><blockquote>
<p> 网络核心即由网端系统的<strong>分组交换机（主要有路由器（router）和链路层交换机（link-layer switch））</strong>和<strong>链路</strong>构成的网状网络</p>
</blockquote>
<h3 id="网络核心两个主要功能"><a href="#网络核心两个主要功能" class="headerlink" title="网络核心两个主要功能"></a>网络核心两个主要功能</h3><ol>
<li><p><strong>路由（Routing）</strong>决定包的路径，包括路由算法等</p>
</li>
<li><p><strong>转发（Forwarding）</strong>将数据包从路由器的输入转移到输出</p>
</li>
</ol>
<p><img src="http://cdn.ziyedy.top/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E8%8B%B1%E7%89%B9%E7%BD%91/%E6%95%B0%E6%8D%AE%E7%9A%84%E7%A7%BB%E5%8A%A8.png" alt=""></p>
<h3 id="网络核心的数据传输模式"><a href="#网络核心的数据传输模式" class="headerlink" title="网络核心的数据传输模式"></a>网络核心的数据传输模式</h3><h4 id="电路交换（circuit-switching）"><a href="#电路交换（circuit-switching）" class="headerlink" title="电路交换（circuit switching）"></a>电路交换（circuit switching）</h4><blockquote>
<p>在电路交换网络中，在端系统通信会话期间，交换机会预留端系统间通信路径上的相关资源（缓存，链路传输速率），即先建立连接，然后通信；而在分组交换网络中，这些资源没有被预留；也就是说，在端系统进行通信时，其所需要的资源是被保持的，其他通信是无法使用这一部分资源的；也就说，端系统间真正建立了一条“连接”；而这一连接，用电话的术语被称为“电路”。传统的电话网络就是电路交换网络的例子。</p>
</blockquote>
<h4 id="分组交换（packet-switching）"><a href="#分组交换（packet-switching）" class="headerlink" title="分组交换（packet switching）"></a>分组交换（packet switching）</h4><p>从源端系统向目的端系统发送一个报文（message），要先<strong>将长报文划分为较小的数据块</strong>，称为分组（packet）。在传输过程中，每个分组都<strong>通过链路和分组交换机传送</strong>。</p>
<p><strong>存储转发</strong></p>
<blockquote>
<p> 存储转发是指<strong>交换机在收到一个完成的分组，才会向链路输出转发分组，否则就将收到的部分分组缓存起来（因为需要缓存分组，所以分组交换机需要一个缓冲队列）</strong>；因为缓存等待一个分组的全部数据而导致的时间开销被称为存储转发时延</p>
</blockquote>
<p><strong>排队时延与分组丢失</strong></p>
<p>发生在缓冲队列满的情况，具体见下一节</p>
<p><strong>转发表与路由选择协议</strong></p>
<p>实际上，分组交换机之所以能够知道往哪去是因为其内部有一个<strong>转发表</strong>，这个表维护了一个IP地址和链路的对应关系，所以处理流程为：</p>
<ol>
<li>通过分组的必要信息，获得目的端系统的<em>IP地址</em></li>
<li>通过IP地址<em>索引转发表</em>，从而确定输出链路</li>
</ol>
<h3 id="分组交换和电路交换的对比"><a href="#分组交换和电路交换的对比" class="headerlink" title="分组交换和电路交换的对比"></a>分组交换和电路交换的对比</h3><h4 id="分组交换的优点"><a href="#分组交换的优点" class="headerlink" title="分组交换的优点"></a>分组交换的优点</h4><p>提供了比电路交换更好的带宽共享；</p>
<p>比电路交换更简单、更有效、实现成本更低；</p>
<h4 id="分组交换的缺点"><a href="#分组交换的缺点" class="headerlink" title="分组交换的缺点"></a>分组交换的缺点</h4><p>分组交换不适合实时服务，因为端到端的时延是可变、不可预测的，这和整个网络的情况相关</p>
<h4 id="电路交换的优点"><a href="#电路交换的优点" class="headerlink" title="电路交换的优点"></a>电路交换的优点</h4><p>提供了端对端传输数据的速率保证</p>
<h4 id="电路交换的缺点"><a href="#电路交换的缺点" class="headerlink" title="电路交换的缺点"></a>电路交换的缺点</h4><p>电路交换存在静默期，这是指专用电路空闲时，其占用的资源并没有得到充分的利用</p>
<p>建立连接的过程比较复杂</p>
<p>总体上来说，分组交换的性能要好于电路交换的性能，但是不同类型的分组交换方式有不同的应用场景；比如一些对最低速率有着严格要求的应用，比如实时服务等，为了获得速率保证，牺牲网络的效率也是可以接受的。趋势向着分组交换发展</p>
<h2 id="分组交换中的时延、丢包、吞吐量"><a href="#分组交换中的时延、丢包、吞吐量" class="headerlink" title="分组交换中的时延、丢包、吞吐量"></a>分组交换中的时延、丢包、吞吐量</h2><h3 id="时延（delay）"><a href="#时延（delay）" class="headerlink" title="时延（delay）"></a>时延（delay）</h3><blockquote>
<p>一个分组在沿途<strong>每个节点</strong>承受不同类型的时延，这些时延中最为重要有四个的是：结点处理时延、排队时延、传输时延和传播时延.这些时延总体累加起来是结点总时延</p>
</blockquote>
<h4 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h4><p>处理时延是由于节点需要解析分组的必要信息然后<strong>决定其出链路</strong>而产生的，通常在微秒或者更低数量级。</p>
<p>常用耗时在查找比特错误、索引转发表等操作</p>
<h4 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h4><p>排队时延是因为分组所对应的出链路前面有其他分组正在传输，所以分组需要该链路的缓冲队列里等待其他分组传输完毕而产生的（即在分组交换机中<strong>等待其他分组处理发送完成</strong>造成的时延）；一般来说，排队时延是到达该队列的<strong>流量强度</strong>和性质的函数，通常可以达到毫秒级到微秒级。</p>
<blockquote>
<p>R：带宽</p>
<p>L：数据报长</p>
<p>a：平均到达速率</p>
</blockquote>
<h4 id="传输时延"><a href="#传输时延" class="headerlink" title="传输时延"></a>传输时延</h4><p>传输时延是将所有分组的比特推向链路所有需要的时间（<strong>即向外推的动作</strong>），实际的传输时延通常在毫秒到微秒数量级。用L（bit）表示分组的长度，用R（bps，b/s）表示从路由器A到B的链路传输速率。传输时延是<strong>L/R</strong>。影响因素也就是L与R的大小了</p>
<h4 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h4><p>传播时延是指比特进入链路后，从该链路的起点到下一个结点所用的时间（<strong>即在向外推之后，借链路速度到答下一个节点的事件</strong>）；一旦分组中的最后一个比特到达路由器就意味着该分组的所有比特都已到达路由器；广域网中，传播时延一般是毫秒级的。传播时延是d/s。d是路由器A到B的距离。s是链路的传播速率。</p>
<p>影响因素也就是物理链路的长度以及使用的介质的传播速度了</p>
<h4 id="端到端时延"><a href="#端到端时延" class="headerlink" title="端到端时延"></a>端到端时延</h4><p>假设源主机与目的地主机之间有N-1台路由器，且无拥塞（排队时延微不足道），则节点累计起来，得到端到端时延D=N(d)</p>
<h3 id="丢包（loss）"><a href="#丢包（loss）" class="headerlink" title="丢包（loss）"></a>丢包（loss）</h3><blockquote>
<p>到达的分组发现一个满的队列。由于没有地方存储这个分组，路由器将丢弃该分组，该分组将会丢失（<strong>即当分组交换机缓存满的情况</strong>）</p>
</blockquote>
<p>排队时延和丢包与网络的状况和结点的缓冲空间大小、处理速度相关；如果分组到达的速度高于结点的处理速度，那么分组就会在缓冲队列里排队等待。当缓冲空间用完后，如果还有到的分组，那么该分组将被迫丢弃，产生丢包</p>
<p><strong>流量强度 = 分组到达的速度 / 结点的处理速度，当流量强度大于1时，会出现丢包现象</strong></p>
<p>为降低丢包率，使用决定每个节点buffer的大小也需要进行考量</p>
<h3 id="吞吐量（throughput）"><a href="#吞吐量（throughput）" class="headerlink" title="吞吐量（throughput）"></a>吞吐量（throughput）</h3><blockquote>
<p>计算机网络的吞吐量实际上是一个<strong>速度指标</strong>，它描述了比特经过某个节点的速度（单位时间传输的文件bit/time）。网络的吞吐量可以衡量网络的性能。通常有<strong>瞬时吞吐量</strong>和<strong>平均吞吐量</strong>两个指标进行评价，在今天，因特网对吞吐率的限制因素通常是接入网。</p>
</blockquote>
<p>对于某条路径上的<strong>结点</strong>来说，和该结点有关的速度有两个：接收数据的速度和发送数据的速度，而该结点的吞吐量是这两个速度中较小的一个；</p>
<p>对于某条<strong>路径</strong>来说，该路径的吞吐量可以近似是<strong>所有节点的吞吐量的最小值（瓶颈）</strong>，该最小传输速率的链路为<strong>瓶颈链路</strong>。</p>
<h2 id="协议层次及服务模型"><a href="#协议层次及服务模型" class="headerlink" title="协议层次及服务模型"></a>协议层次及服务模型</h2><h3 id="分层体系结构"><a href="#分层体系结构" class="headerlink" title="分层体系结构"></a>分层体系结构</h3><p>计算机网络中的协议可以简单理解为两个端系统交流的语法与语义，即交流的规范。</p>
<p>总体来说，将各层的所有协议组合起来，称为<strong>协议栈</strong>。因特网的协议栈有5个层次组成<strong>：物理层、链路层、网络成、传输层、应用层</strong>（OSI七层模型相比之下还在应用层下添加了<strong>表示层、会话层</strong>两层）</p>
<p>同时，网络传输过程中，<strong>对等层间使用协议关系（Protocol），上下层间使用接口关系（Interface）</strong></p>
<h4 id="应用层（进程-进程process）"><a href="#应用层（进程-进程process）" class="headerlink" title="应用层（进程-进程process）"></a>应用层（进程-进程process）</h4><p>应用层协议分布在多个端系统，端系统中的应用程序使用该协议与另一个端系统中的应用程序通信。处于应用层的分组称为<strong>报文（message）</strong></p>
<ul>
<li>FTP、SMTP、HTTP</li>
</ul>
<h4 id="传输层（端-端end）"><a href="#传输层（端-端end）" class="headerlink" title="传输层（端-端end）"></a>传输层（端-端end）</h4><p>传输层在应<strong>用程序端点</strong>之间传输应用层报文，因特网中有两个传输层协议：TCP和UDP。处于传输层的分组称为<strong>报文段（segment）</strong>。TCP提供确保传递、流量控制、拥塞控制机制。UDP提供无连接服务，即不提供不必要服务的服务。没有可靠性、没有流量和拥塞控制。</p>
<ul>
<li>TCP、UDP</li>
</ul>
<h4 id="网络层（主机-主机host）"><a href="#网络层（主机-主机host）" class="headerlink" title="网络层（主机-主机host）"></a>网络层（主机-主机host）</h4><p>网络层将称为数据报的网络层分组从<strong>一台主机移动到另一台主机（任意两台机器）</strong>。网络层协议包含著名的IP协议以及其他一些路由选择协议。<strong>数据报</strong></p>
<ul>
<li>IP、routing protocols</li>
</ul>
<h4 id="数据链路层（节点-节点point）"><a href="#数据链路层（节点-节点point）" class="headerlink" title="数据链路层（节点-节点point）"></a>数据链路层（节点-节点point）</h4><p>链路层将称为<strong>帧（frame）</strong>的链路层分组从一个<strong>节点移动到路径上的下一个节点（两个节点要相邻）</strong>。一个帧可能被沿途不同链路上的不同链路层协议处理。</p>
<ul>
<li>PPP</li>
</ul>
<h4 id="物理层（比特流）"><a href="#物理层（比特流）" class="headerlink" title="物理层（比特流）"></a>物理层（比特流）</h4><p>物理层的任务是将<strong>帧中的比特</strong>从一个结点移动到下一个节点，它提供了传输信息的实际物理通道；</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>一个分组，在不同的层次有不同的称谓，是因为它们经过每一层的时候就被该层<strong>封装上了属于该层的相关信息</strong>，也就是前面提到的必要信息；于是，每一分层的分组有两种类型的字段：<strong>首部字段</strong>和<strong>有效负载</strong>；其中有效负载即为来自上一层的分组数据，而首部字段就是该层加上的必要信息；分组不断被封装以实现各层协议规定的相关功能</p>
<p><img src="http://cdn.ziyedy.top/%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%8E%E8%8B%B1%E7%89%B9%E7%BD%91/%E7%BD%91%E7%BB%9C%E5%B1%82%E6%AC%A1%E6%8E%A5%E5%8F%A3%E6%A8%A1%E5%9E%8B.png" alt=""></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>《计算机网络——自顶向下方法》</p>
<p><a href="https://blog.csdn.net/qq_39326472/article/details/88089747" target="_blank" rel="noopener">https://blog.csdn.net/qq_39326472/article/details/88089747</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计网-topdown</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章：应用层</title>
    <url>/page/no2-application-llayer.html</url>
    <content><![CDATA[<h2 id="应用层内容架构"><a href="#应用层内容架构" class="headerlink" title="应用层内容架构"></a>应用层内容架构</h2><p><img src="http://cdn.ziyedy.top/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/%E5%BA%94%E7%94%A8%E5%B1%82%E5%86%85%E5%AE%B9.png" alt=""></p>
<p>图源：<a href="https://blog.csdn.net/qq_39326472/article/details/88089747" target="_blank" rel="noopener">https://blog.csdn.net/qq_39326472/article/details/88089747</a></p>
<h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><blockquote>
<p>网络核心设备并不在应用层上起作用，而仅在较低层起作用</p>
<p>设计核心思想：<strong>将应用软件限制在端系统</strong></p>
</blockquote>
<h3 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h3><h4 id="客户-服务器体系结构"><a href="#客户-服务器体系结构" class="headerlink" title="客户-服务器体系结构"></a>客户-服务器体系结构</h4><p>在该体系结构中，有一个<strong>总是打开</strong>的主机，即服务器，它接收和服务来自其他许多被称为客户的主机请求；值得注意的是，在该体系结构中，<strong>客户之间是不直接通信</strong>的；该服务器具有固定的、周知的地址（IP地址）</p>
<h4 id="P2P体系结构"><a href="#P2P体系结构" class="headerlink" title="P2P体系结构"></a>P2P体系结构</h4><p>应用程序在间断连接的<strong>主机对之间使用直接通信</strong>，这些主机被称为<strong>对等方</strong></p>
<p>该体系结构下，对位于数据中心的专用服务器有着最小（或者没有）依赖。</p>
<p>P2P体系结构最引人入胜的特性之一就是它们的<strong>自扩展性（self-scalability）</strong>（即对等方通过为其他对等方传送文件而为原始拥有者分担压力）</p>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><blockquote>
<p>即<strong>运行在不同端系统上的进程</strong>之间的通信，运行在不同端系统上的进程对之间通过计算机网络来实现通信</p>
</blockquote>
<h4 id="客户与服务器进程"><a href="#客户与服务器进程" class="headerlink" title="客户与服务器进程"></a>客户与服务器进程</h4><p>首先发起通信的进程被标记为客户，在会话开始时等待联系的进程被称为服务器。</p>
<h4 id="进程与计算机网络之间的接口"><a href="#进程与计算机网络之间的接口" class="headerlink" title="进程与计算机网络之间的接口"></a>进程与计算机网络之间的接口</h4><blockquote>
<p>进程通过一个称为<strong>套接字（socket）</strong>的软件接口向网络发送和接收报文。（套接字是同一台主机内应用层与传输层之间的接口）</p>
</blockquote>
<p>应用程序开发者可以控制套接字在应用层的一切内容，但是对于运输层的相关部分，几乎没有控制权<em>（能控制传输层协议的选择，以及设定最大缓存和最大报文长度等几个传输层参数）</em></p>
<h4 id="进程寻址（标识接收方的地址）"><a href="#进程寻址（标识接收方的地址）" class="headerlink" title="进程寻址（标识接收方的地址）"></a>进程寻址（标识接收方的地址）</h4><blockquote>
<p>主机地址（<strong>IP地址</strong>） + 目的主机接收进程的标识符（<strong>端口号</strong>）</p>
</blockquote>
<h3 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h3><blockquote>
<p>传输层协议的特点大致可以从以下这四个方面考量：可靠数据传输、吞吐量、定时和安全性</p>
</blockquote>
<p>从可靠数据传输、吞吐量、定时、安全性等四个角度来看传输层提供的服务，传输层无法对吞吐量和定时做出保证。但是，今天的因特网能够为时间敏感的应用提供满意的服务，尽管它并不提供任何定时或者带宽保证</p>
<h3 id="因特网提供的传输层服务"><a href="#因特网提供的传输层服务" class="headerlink" title="因特网提供的传输层服务"></a>因特网提供的传输层服务</h3><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul>
<li><strong>面向连接的服务</strong></li>
<li><strong>可靠的数据传输</strong></li>
<li>提供了<strong>拥塞控制</strong>机制（不一定会给通行双方带来好处，但是会给网络带来整体好处）</li>
</ul>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><blockquote>
<p>UDP是无连接的也就是说通信之前没有握手；UDP不提供数据的可靠传输；UDP也没有拥塞控制机制。有些应用场景下，UDP协议将带来更多的便利和效率</p>
</blockquote>
<h2 id="WEB和HTTP"><a href="#WEB和HTTP" class="headerlink" title="WEB和HTTP"></a>WEB和HTTP</h2><h3 id="HTTP概述"><a href="#HTTP概述" class="headerlink" title="HTTP概述"></a>HTTP概述</h3><blockquote>
<p>HTTP（HyperText Transfer Protocol）是WEB的应用层协议，它是Web的核心；HTTP有两部分实现，一个客户端程序一个服务器程序；HTTP定义了客户和服务器进行报文交换的方法；</p>
</blockquote>
<p>HTTP服务器不存储任何关于该客户的状态信息，因此HTTP被称为<strong>无状态协议</strong></p>
<h3 id="持续连接和非持续连接"><a href="#持续连接和非持续连接" class="headerlink" title="持续连接和非持续连接"></a>持续连接和非持续连接</h3><p>持续连接即<strong>多个对象，一次连接</strong>，HTTP既可使用持续连接也可以使用非持续连接。尽管<strong>HTTP在静默情况下使用持续连接</strong></p>
<p>非持续连接可以理解为<strong>多个对象，多个连接</strong>（比如一个HTML中有10个图片，即需对10个图片均进行一次TCP连接）</p>
<h3 id="HTTP报文格式：请求报文和响应报文"><a href="#HTTP报文格式：请求报文和响应报文" class="headerlink" title="HTTP报文格式：请求报文和响应报文"></a>HTTP报文格式：请求报文和响应报文</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p><img src="http://cdn.ziyedy.top/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt=""></p>
<blockquote>
<p>报文第一行：<strong>请求行</strong>（包括：方法字段、URL字段、HTTP版本），其中方法字段可为：GET、POST、PUT、DELETE、HEAD等</p>
<p>后继各行：<strong>首部行</strong>（包含是否在发送完响应报文后关闭TCP连接的Connection；请求的主机地址（该头部信息被Web高速缓存所要求）；浏览器版本；可接受的语言等头部信息；）</p>
<p>空行（用于分隔）</p>
<p><strong>实体行</strong>：该实体体可以在POST方法里传递Form表单内容或者传递其它一些二进制流数据等</p>
</blockquote>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p><img src="http://cdn.ziyedy.top/%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%BA%94%E7%94%A8%E5%B1%82/HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png" alt=""></p>
<blockquote>
<p><strong>状态行</strong>：（HTTP版本、状态码、状态信息）</p>
<p><strong>首部行</strong>：（发送日期、服务器类型、上一次修改请求资源的时间、内容的类型）</p>
<p><strong>实体体</strong>：<strong>实体包含请求对象本身（HTML文件等）</strong>。</p>
</blockquote>
<h3 id="用户与服务器的交互：Cookie"><a href="#用户与服务器的交互：Cookie" class="headerlink" title="用户与服务器的交互：Cookie"></a>用户与服务器的交互：Cookie</h3><p>HTTP是无状态协议，但是Web站点可以使用Cookie技术对用户进行跟踪。Web站点生成一个<strong>唯一标识码</strong>，下次访问该站点时，浏览器就会查询cookie文件并抽取识别码</p>
<p>Cookie技术包含4个组件</p>
<ol>
<li>HTTP响应报文里增加一个关于Cookie的首部行；</li>
<li>HTTP请求报文里增加一个关于Cookie的首部行；</li>
<li>用户端系统保留一个Cookie文件，由浏览器保存维护；</li>
<li>Web站点建立Cookie和用户身份的关联；</li>
</ol>
<h3 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h3><p>Web缓存器（Web cache）也被称为<strong>代理服务器</strong>（proxy server），能够代表初始Web服务器来满足部分HTTP请求的网络实体</p>
<p>当代理服务器收到一个HTTP请求后，它将<em>检查本地是否缓存过该对象</em>，如果缓存过该对象，将<em>检查是否过期</em>（<strong>条件GET方法</strong>，使用GET方法的时候，增加一个<code>If-Modified-Since</code>首部行，其对应的内容是一个时间），如果没有过期，则直接将该对象返回给浏览器；如果本地不存在或者存在已过期，则代理服务器将根据请求报文里的Host首部行以及请求行里的URL字段向初始服务器发出请求，然后将响应对象返回给浏览器并缓存在本地。</p>
<p>因此，<strong>Web缓存器既是服务器又是客户</strong></p>
<h4 id="使用Web缓存器的原因"><a href="#使用Web缓存器的原因" class="headerlink" title="使用Web缓存器的原因"></a>使用Web缓存器的原因</h4><ol>
<li>大大减少对用户请求的响应时间（规避瓶颈带宽）</li>
<li>大大减少一个机构的接入链路到因特网的通行量（节省成本）</li>
</ol>
<h2 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h2><blockquote>
<p>因特网电子邮件系统有三个核心组件：<strong>用户代理</strong>、<strong>邮件服务器</strong>、<strong>SMTP</strong>（简单邮件传输协议，Simple Mail Transfer Protocol）</p>
</blockquote>
<h3 id="SMTP（25号端口）"><a href="#SMTP（25号端口）" class="headerlink" title="SMTP（25号端口）"></a>SMTP（25号端口）</h3><p><strong>传输的三个阶段</strong>：握手、传输、关闭连接</p>
<p>SMTP是<strong>持续连接</strong>的，同时由于继承的问题，它限制邮件报文的所有部分只能使用<strong>7比特的ASCII</strong>表示（导致一些多媒体文件在发送方需要编码，接收方则需要解码）</p>
<h4 id="与HTTP对比"><a href="#与HTTP对比" class="headerlink" title="与HTTP对比"></a>与HTTP对比</h4><p>HTTP和SMTP都是用TCP协议；持续的HTTP和SMTP都是用持续连接；但是两者也有区别：</p>
<ul>
<li>HTTP被设计为一个Pull协议而SMTP被设计为一个Push协议。即用户通过HTTP主动向服务器请求内容，而SMTP则是客户将内容推向服务器端；</li>
<li>HTTP传输的数据不一定是用ASCII字符，但是SMTP则只能使用ASCII字符；</li>
<li>HTTP将每个对象封装在自己的响应报文里，而SMTP则将所有的报文对象放到一个报文之中；</li>
</ul>
<h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><p>需要注意的是，<strong>SMTP是邮件服务器之间发送邮件报文</strong>的协议，并不是用户通过代理和邮件服务器之间通信的协议；用户代理使用邮件访问协议来从邮件服务器上获取邮件信息；目前常用的邮件访问协议有<strong>POP3</strong>（Post Office Protocol-Version 3）、<strong>因特网邮件访问协议</strong>（<strong>IMAP</strong>，Internet Mail Access protocol）和<strong>HTTP</strong></p>
<h2 id="DNS：因特网的目录服务"><a href="#DNS：因特网的目录服务" class="headerlink" title="DNS：因特网的目录服务"></a>DNS：因特网的目录服务</h2><blockquote>
<p>DNS（Domain Name System）域名系统，用于处理<strong>主机名和IP地址的转换问题</strong>。</p>
<p><strong>DNS是一个由分层的DNS服务器组成的分布式数据库和一个使得主机可以查询分布式数据库的应用层协议组成</strong></p>
<p>DNS运行在UDP之上，使用53号端口</p>
</blockquote>
<h3 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h3><h3 id="DNS工作机理概述"><a href="#DNS工作机理概述" class="headerlink" title="DNS工作机理概述"></a>DNS工作机理概述</h3><blockquote>
<p><strong>DNS采用分布式的设计方案</strong></p>
<p>因为单一的DNS服务器无法解决<em>单点故障</em>、<em>保证通信容量</em>、<em>邻近所有的查询主机</em>和<em>维护困难</em>等问题</p>
</blockquote>
<h4 id="分布式层次的数据库"><a href="#分布式层次的数据库" class="headerlink" title="分布式层次的数据库"></a>分布式层次的数据库</h4><p>为了处理扩展性问题，DNS服务器采用层次式组织，并且分布在全世界范围内；大致来说，存在三种DNS服务器：<strong>根DNS服务器</strong>、<strong>顶级域DNS服务器</strong>和<strong>权威DNS服务器</strong></p>
<ul>
<li>根DNS服务器：因特网上有13个根DNS服务器</li>
<li>顶级域DNS服务器：负责顶级域名，如com，org，net，edu，gov以及各个国家的顶级域名的转换</li>
<li>权威DNS服务器：如大学、公司等公共可访问的DNS记录</li>
<li><strong>本地DNS服务器（除去上面三个外重要的DNS服务器）</strong>：<strong>邻近</strong>其所在网络的其他主机。当主机发出DNS请求时，该请求被发往本地DNS服务器，它起着代理的作用，并将请求转发到DNS服务器层次结构中。</li>
</ul>
<blockquote>
<p>解析<code>www.baidu.com</code>的IP地址的过程</p>
<ol>
<li>返回负责解析顶级域名<code>com</code>的服务器的IP地址</li>
<li>顶级域DNS服务器建返回<code>baidu.com</code>的权威服务器的IP集合</li>
<li>与这些服务器之一取得联系，获得<code>www.baidu.com</code>的IP地址</li>
</ol>
</blockquote>
<p>DNS查询有两种，一种是<strong>递归查询</strong>一种是<strong>迭代查询</strong>；实践中，查询通常满足这样的模式：<strong>从请求主机到本地DNS服务器的查询是递归的，其余查询是迭代的</strong>。</p>
<h4 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h4><blockquote>
<p>当某DNS服务器接收一个DNS回答时，其将映射缓存到本地存储器中</p>
<p><strong>由于缓存，除了少数DNS查询以外，根服务器被绕过了</strong></p>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>《计算机网络——自顶向下方法》</p>
<p><a href="https://blog.csdn.net/qq_39326472/article/details/88089747" target="_blank" rel="noopener">https://blog.csdn.net/qq_39326472/article/details/88089747</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>计网-topdown</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章：传输层</title>
    <url>/page/null.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>SQL语句——查</title>
    <url>/page/mysql2.html</url>
    <content><![CDATA[<h3 id="SELECT语句"><a href="#SELECT语句" class="headerlink" title="SELECT语句"></a>SELECT语句</h3><p>1、基本使用框架</p>
<pre><code>SELECT * FROM 数据表
[WHERE]
[LIMIT]
[OFFSET]</code></pre><p>2、使用别名</p>
<pre><code>SELECT
    字段名 AS 别名
FROM 数据表</code></pre><p>3、查询语句的执行顺序：</p>
<p>先进行语法分析和优化，找到关键字优先级，先执行FROM，再执行SELECT</p>
<h3 id="查询相关功能"><a href="#查询相关功能" class="headerlink" title="查询相关功能"></a>查询相关功能</h3><p>1、<strong>ORDER BY</strong>子句功能，对查询的结果进行<strong>排序</strong>，示例如下</p>
<pre><code>// 按照相关信息进行排序
SELECT * FROM * ORDER BY 列名 [ASC|DESC]
// 多个排序信息
SELECT * FROM * ORDER BY 列名 [ASC|DESC],列名 [ASC|DESC]</code></pre><p>2、去除结果中的<strong>重复记录</strong>，在字段名称前加上<strong>DISTINCT</strong>字段，只支持一个字段名。</p>
<pre><code>SELECT DISTINCT 字段名 FROM *;</code></pre><p>3、<strong>条件查询</strong>，使用<strong>WHERE</strong>语句指定查询的条件逻辑，中间使用AND|OR等逻辑连接符连接，同时注意判断相等的条件是“=”而不是“==”。</p>
<pre><code>SELECT * FROM * WHERE 条件1 [AND|OR] 条件2 ......;</code></pre><p>4、使用<strong>聚合函数</strong>。所谓聚合函数，也就是平均值、最大值等函数，以下为求该字段名下的平均值函数（AVG），其他函数使用方法与此类似。该类方法在实际使用时可以将统计结果作为一个子表进行查询。</p>
<pre><code>SELECT AVG(字段名) FROM 表名</code></pre><p><strong>COUNT(*)</strong>用于获得包含空值的记录数，<strong>COUNT(字段名)</strong>用于获取包含非空值的记录数。</p>
<p>5、<strong>分组查询</strong>，使用<strong>GROUP BY</strong>字句。即通过一定规则将数据集分为若干个部分进行查询处理。以下即为使用字段1进行分组统计每一组中字段2的平均值。</p>
<pre><code>SELECT 字段1,AVG(字段2) FROM 表名 GROUP BY 字段1;</code></pre><p>使用分组查询SELECT语句中只能出现用以分组的字段以及其他字段的聚合函数，否则会报错（由于产生了<strong>一对多</strong>的关系）。为解决这个问题，可以使用<code>GROUP_CONCAT</code>函数，这个函数可以将符合条件的值连接起来进行输出，可以理解为将“多”的部分进行了字符串拼接。</p>
<pre><code>SELECT 字段1,GROUP_CONCAT(字段2) FROM 表名 GROUP BY 字段1;</code></pre><p>同时可以加上<code>WITH ROLLUP</code>再进行一次汇总运算（即在返回的查询结果之下再加上一条汇总记录）。</p>
<pre><code>SELECT 字段1,AVG(字段2) FROM 表名 GROUP BY 字段1 WITH ROLLUP;</code></pre><p>6、<strong>HAVING</strong>子句，以及为何要使用HAVING子句</p>
<p>由于WHERE子句执行在GROUP BY子句之前，因此如果WHERE子句中出现了如平均值等信息时SQL会不知道在哪个范围内进行平均，因此会出错，如以下代码即为错误的（聚合函数作为判断条件）。所以需要使用<code>HAVING</code>子句。</p>
<pre><code># 使用错误
SELECT f1
FROM table
WHERE AVG(f2) &gt; 10
GROUP BY f1;</code></pre><pre><code># 使用正确
SELECT f1
FROM table
GROUP BY f1 HAVING AVG(f2) &gt; 10;</code></pre><h3 id="表的连接"><a href="#表的连接" class="headerlink" title="表的连接"></a>表的连接</h3><p>表的连接很重要，具体有内外两种连接构成。</p>
<p>1、<strong>内连接</strong>：结果集中只保留符合连接条件的记录</p>
<pre><code>SELECT * FROM 表1 [INNER] JOIN 表2 ON 连接条件;

SELECT * FROM 表1 [INNER] JOIN 表2 WHERE 连接条件;

SELECT * FROM 表1, 表2 WHERE 连接条件;</code></pre><p>2、<strong>外连接</strong>：不管是否符合连接条件，记录都要保留在结果集里</p>
<pre><code>// 右表出NULL值和左表连接
LEFT JOIN </code></pre><p>3、<strong>内外连接的区别</strong>。具体如图所示（图片摘自LeetCode）</p>
<p>1）左联结（left join），联结结果保留左表的全部数据<br>2）右联结（right join），联结结果保留右表的全部数据<br>3）内联结（inner join），取两表的公共数据</p>
<p><img src="%5CSQL%E8%AF%AD%E5%8F%A5%E2%80%94%E2%80%94%E6%9F%A5%5Csql%E8%BF%9E%E6%8E%A5.png" alt=""></p>
<p>应用在<a href="https://leetcode-cn.com/problems/combine-two-tables/" target="_blank" rel="noopener">175.组合两个表中</a>。该题需要满足“无论 person 是否有地址信息，都需要基于上述两表提供 person 的以下信息”，所以当person表在左时采用左连接。</p>
<h3 id="一些注意事项"><a href="#一些注意事项" class="headerlink" title="一些注意事项"></a>一些注意事项</h3><p>1、<strong>表连接时on和where的区别</strong></p>
<p>以下不推荐，因为查询速度会很慢，每一次都会执行WHERE语句中的内容。</p>
<pre><code>SELECT ename 
FROM t_emp
WHERE deptno = (SELECT deptno FROM t_emp WHERE ename=&quot;SCOTT&quot;)</code></pre><pre><code>SELECT e2.ename
FROM t_emp e1 JOIN t_emp e2 ON e1.deptno=e2.deptno
WHERE e1.ename = &quot;SCOTT&quot;</code></pre><p>将AVG的结果视为一个表，与原表进行连接。</p>
<p>错误</p>
<pre><code>SELECT e2.ename
FROM t_emp e1 JOIN t_emp e2 ON e2.sal &gt;= AVG(e1.sal)</code></pre><p>正确</p>
<pre><code>SELECT e.ename
FROM t_emp e 
JOIN (SELECT AVG(sal) avg FROM t_emp) t
ON e.sal &gt;= t.avg;</code></pre>]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>3、队列</title>
    <url>/page/ds-queue.html</url>
    <content><![CDATA[<h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>与栈相反，队列的基本特性为<strong>先入先出（FIFO）</strong>。</p>
<p>其与栈相同，也是一种线性表，允许在队尾插入元素，在队头删除元素。</p>
<h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><p>首先想到的就是操作系统中的进程调度方法？还有当然就是广度优先遍历了。</p>
<h4 id="需要实现的基本内容"><a href="#需要实现的基本内容" class="headerlink" title="需要实现的基本内容"></a>需要实现的基本内容</h4><p>实现队列可以构建相应的接口，其需要实现的方法如下：</p>
<pre><code>public interface Queue&lt;E&gt; {
    int getSize();
    boolean isEmpty();
    void enqueue(E e);    // 入队列
    E dequeue();    // 出队列
    E getFront();    // 获取队首元素
}</code></pre><p>队列有三种实现方法，分别是线性存储（底层数据结构为动态数组，根据实现思路区别可分为<strong>顺序队列</strong>与<strong>循环队列</strong>），链式存储（底层数据结构为链表）</p>
<h3 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h3><p>与栈的相应实现方法相同。</p>
<pre><code>public class ArrayQueue&lt;E&gt; implements Queue&lt;E&gt; {

    private Array&lt;E&gt; array;

    public ArrayQueue(int capacity) {
        array = new Array&lt;&gt;(capacity);
    }

    public ArrayQueue() {
        array = new Array&lt;&gt;();
    }

    @Override
    public int getSize() {
        return array.getSize();
    }

    @Override
    public boolean isEmpty() {
        return array.isEmpty();
    }

    @Override
    public void enqueue(E e) {
        array.addLast(e);
    }

    @Override
    public E dequeue() {
        return array.removeFirst();
    }

    @Override
    public E getFront() {
        return array.getFirst();
    }

}</code></pre><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><h4 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h4><p>顺序队列有一个弊端，就是当出队列操作后，动态数组的前面会产生很大的空隙，造成内存的浪费。为了解决这个问题，提出了循环队列的思想，其核心思想就是分别使用<strong>front</strong>和<strong>tail</strong>记录队列的队头和队尾，具体思路见如下示意图（图来源于网上）。</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3%E3%80%81%E9%98%9F%E5%88%97%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97.jpg" alt=""></p>
<p>其中，为避免队列为空与队列为满产生的条件判断重叠（即都为front==tail），我们可以将队列满的条件设置为tail+1==front（即留出一个空间不进行使用）。</p>
<p>除此之外，由于是“循环”队列，因此tail可能小于front，因此需要使用(tail) % (data.length)的形式对相关逻辑进行判断</p>
<h4 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h4><p>具体实现如下</p>
<pre><code>public class LoopQueue&lt;E&gt; implements Queue&lt;E&gt; {

    private E[] data;
    private int front, tail;
    private int size;

    public LoopQueue(int capacity) {
        data = (E[])new Object[capacity+1];
        front = 0;
        tail = 0;
        size = 0;
    }

    public LoopQueue() {
        this(10);
    }

    public int getCapacity() {
        return data.length - 1;
    }


    @Override
    public int getSize() {
        return size;
    }

    @Override
    public boolean isEmpty() {
        return front==tail;
    }

    @Override
    public void enqueue(E e) {
        // 判断队列满了的条件
        if((tail+1)%data.length == front) {
            resize(getCapacity() * 2);
        }
        data[tail] = e;
        tail = (tail + 1) % data.length;    // 对tail进行更新
        size++;
    }

    @Override
    public E dequeue() {
        if(isEmpty()) {
            throw new IllegalArgumentException(&quot;Queue is empty&quot;);
        }
        E res = data[front];
        data[front] = null;
        front = (front+1) % data.length;
        size--;
        if(size == getCapacity() / 4 &amp;&amp; getCapacity() / 2 != 0) {
            resize(getCapacity() / 2);
        }
        return res;
    }

    @Override
    public E getFront() {
        return data[front];
    }

    private void resize(int newCapacity) {
        E[] newData = (E[])new Object[newCapacity + 1];
        for(int i=0;i&lt;size;i++) {
            newData[i] = data[(i + front) % data.length];
        }
        data = newData;
        front = 0;
        tail = size;
    }
}</code></pre><h3 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h3><h4 id="实现分析"><a href="#实现分析" class="headerlink" title="实现分析"></a>实现分析</h4><p>需要记录队列的队首head与队尾tail。其中队首对应链表头（删除方便），队尾对应链表尾。</p>
<h4 id="具体实现-1"><a href="#具体实现-1" class="headerlink" title="具体实现"></a>具体实现</h4><p>1、类中基础属性</p>
<pre><code>public class LinkedListQueue&lt;E&gt; implements Queue&lt;E&gt; {

    // 定义链表的节点，作为内部类
    private class Node {
        public E e;
        public Node next;

        public Node(E e, Node next) {
            this.e = e;
            this.next = next;
        }

        public Node(E e) {
            this(e, null);
        }

        public Node() {
            this(null, null);
        }
    }

    private Node head, tail;
    private int size;

    public LinkedListQueue() {
        head = null;
        tail = null;
        size = 0;
    }
}</code></pre><p>2、入队列</p>
<pre><code>@Override
public void enqueue(E e) {
    if(tail==null) {
        tail = new Node(e);
        head = tail;
    }
    else {
        tail.next = new Node(e);
        tail = tail.next;
    }
    size++;
}</code></pre><p>3、出队列</p>
<pre><code>@Override
public E dequeue() {
    if(isEmpty()) {
        throw new IllegalArgumentException(&quot;Can not&quot;);
    }
    Node res = head;
    head = head.next;
    res.next = null;
    if(head == null) {
        tail = null;
    }
    size--;
    return res.e;
}</code></pre><p>其余方法略</p>
<h3 id="复杂度分析与测试"><a href="#复杂度分析与测试" class="headerlink" title="复杂度分析与测试"></a>复杂度分析与测试</h3><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>不同队列实现方式的差距主要体现在出队中。</p>
<p>其中顺序队列的出队的时间复杂度为O(n)，而循环队列与链接队列出队的时间复杂度为O(1)。</p>
<h4 id="复杂度测试"><a href="#复杂度测试" class="headerlink" title="复杂度测试"></a>复杂度测试</h4><pre><code>import java.util.Random;

public class Main {

    // 用于计算运行时间
    private static double testQueue(Queue&lt;Integer&gt; q, int opCount)        {
        long startTime = System.nanoTime();

        Random random = new Random();
        for(int i=0; i&lt;opCount;i++) {
            q.enqueue(random.nextInt(Integer.MAX_VALUE));
        }
        for(int i=0; i&lt;opCount;i++) {
            q.dequeue();
        }

        long endTime = System.nanoTime();
        return (endTime - startTime) / 1000000000.0;
    }

    public static void main(String[] args) {
        int opCount = 100000;
        ArrayQueue&lt;Integer&gt; arrayQueue = new ArrayQueue&lt;&gt;();
        double time1 = testQueue(arrayQueue, opCount);
        LoopQueue&lt;Integer&gt; loopQueue = new LoopQueue&lt;&gt;();
        double time2 = testQueue(loopQueue,opCount);
        LinkedListQueue&lt;Integer&gt; linkedListQueue = new LinkedListQueue&lt;&gt;();
        double time3 = testQueue(linkedListQueue,opCount);
        System.out.println(&quot;ArrayQueue: &quot;+time1+&quot; s&quot;);
        System.out.println(&quot;LoopQueue: &quot;+time2+&quot; s&quot;);
        System.out.println(&quot;LinkListQueue: &quot;+time3+&quot; s&quot;);
    }
}
///////////////////////////////////////////
ArrayQueue: 45.9780233 s
LoopQueue: 0.0132119 s
LinkListQueue: 0.0092766 s</code></pre><p>由此可以看出，当操作数达到一定级别时，顺序队列的实现方式的速度要远小于其他两种实现方法。这与之前的分析是吻合的。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL的增删改等语句</title>
    <url>/page/mysql1.html</url>
    <content><![CDATA[<p>逻辑库</p>
<pre><code>CREATE DATABASE; 逻辑库名称
SHOW DATABASES;
DROP DATABASE 逻辑库名称;
USE 逻辑库名称;</code></pre><p>数据表</p>
<pre><code>CREATE TABLE 数据表(
            列名 数据类型 [约束] [COMMENT 注释],
            列名 数据类型 [约束] [COMMENT 注释],
            )[COMMENT 注释];</code></pre><pre><code>SHOW 表名;
DESC 表名; // 查看表的情况
SHOW CREATE TABLE 表名;    // 查看创建该表时的SQL语句
DROP TABLEE 表名;    // 删除数据表</code></pre><p>添加字段</p>
<pre><code>ALTER TABLE 表名
ADD 列名 数据类型 [约束] [COMMENT 注释],
...
ADD 列名 数据类型 [约束] [COMMENT 注释];</code></pre><p>修改字段数据类型等信息</p>
<pre><code>ALTER TABLE 表名
MODIFY 列名 数据类型 [约束] [COMMENT 注释],
...
MODIFY 列名 数据类型 [约束] [COMMENT 注释];</code></pre><p>修改字段名称</p>
<pre><code>ALTER TABLE 表名
CHANGE 列名 新列名 数据类型 [约束] [COMMENT 注释],
...
CHANGE 列名 新列名 数据类型 [约束] [COMMENT 注释];</code></pre><p>删除字段</p>
<pre><code>ALTER TABLE 表名
DROP 字段名称,
...
DROP 字段名称;</code></pre><p>添加索引</p>
<pre><code>CREATE TABLE *(
        INDEX 索引名称 (字段名称),
        );</code></pre><p>添加、显示、删除索引</p>
<pre><code>CREATE INDEX 索引名称 ON 表名(字段);
ALTER TABLE 表名 ADD INDEX [索引名](字段);

SHOW INDEX FROM 表名;
DROP INDEX 索引名称 ON 表名;</code></pre><p>向数据表中写入记录</p>
<pre><code>INSERT INTO 表名(字段1,字段2......)
VALUES(值1,值2......);</code></pre><pre><code>// 当插入数据有问题时直接忽略
NSERT IGNORE INTO</code></pre><p>修改表的记录</p>
<pre><code>UPDATE [IGNORE] 表名
SET 字段1=值1, 字段2=值2 ......
WHERE
ORDER BY
LIMIT</code></pre><p>删除数据</p>
<pre><code>DELETE [IGNORE] FROM 表名
[WHERE]
[ORDER BY]
[LIMIT]</code></pre>]]></content>
      <categories>
        <category>计算机技术</category>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>2、栈</title>
    <url>/page/ds-stack.html</url>
    <content><![CDATA[<h3 id="基本特性"><a href="#基本特性" class="headerlink" title="基本特性"></a>基本特性</h3><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><p>栈的特性无非也就是<strong>后进先出（LIFO）</strong>。</p>
<p>其为操作受限的线性表，其主要特点就是栈的插入与删除只能在栈顶进行，分别对应进栈（push）与出栈（pop）两个操作。</p>
<h4 id="用处"><a href="#用处" class="headerlink" title="用处"></a>用处</h4><p>首先想到的当然就是系统栈、递归、深度优先搜索了，除此之外还有很多。</p>
<h4 id="需要实现的基本内容"><a href="#需要实现的基本内容" class="headerlink" title="需要实现的基本内容"></a>需要实现的基本内容</h4><p>在Java语言中，实现一个栈的接口表示一个栈需要的基本方法，如下：</p>
<pre><code>public interface Stack&lt;E&gt; {
    int getSize();    // 获取元素个数
    boolean isEmpty();    // 判断栈是否为空
    void push(E e);    // 入栈操作
    E pop();    // 出栈操作
    E peek();    // 获取栈顶元素
}</code></pre><p>栈主要有两种存储方法，即<strong>线性存储</strong>（底层是动态数组）与<strong>链接存储</strong>（底层为链表），之后分别记录这两种栈的实现方法。</p>
<h3 id="线性存储"><a href="#线性存储" class="headerlink" title="线性存储"></a>线性存储</h3><p>存储实现如下，直接套用之前在《1、动态数组》实现的动态数组即可，之后按照类的定义进行实现，代码如下：</p>
<pre><code>public class ArrayStack&lt;E&gt; implements Stack&lt;E&gt; {

    Array&lt;E&gt; array;

    public ArrayStack(int caoacity) {
        array = new Array&lt;&gt;(caoacity);
    }

    public ArrayStack() {
        array = new Array&lt;&gt;();
    }

    @Override
    public int getSize() {
        return array.getSize();
    }

    @Override
    public boolean isEmpty() {
        return array.isEmpty();
    }

    @Override
    public void push(E e) {
        array.addLast(e);
    }

    @Override
    public E pop() {
        return array.removeLast();
    }

    @Override
    public E peek() {
        return array.getLast();
    }

    public int getCapacity() {
        return array.getCapacity();
    }

}</code></pre><h3 id="链接存储"><a href="#链接存储" class="headerlink" title="链接存储"></a>链接存储</h3><p>套用在《4、链表》中实现的链表作为底层数据结构即可进行实现，代码如下：</p>
<p>使用链接存储时栈顶为链表的头，这是由于删除链表的头元素的时间复杂度为O(1)，而要删除链表最后一个元素时间复杂度为O(n)。</p>
<pre><code>public class LinkedListStack&lt;E&gt; implements Stack&lt;E&gt; {

    private LinkedList&lt;E&gt; list;

    public LinkedListStack() {
        list = new LinkedList&lt;&gt;();
    }

    @Override
    public int getSize() {
        return list.getSize();
    }

    @Override
    public boolean isEmpty() {
        return list.isEmpty();
    }

    @Override
    public void push(E e) {
        list.addFirst(e);
    }

    @Override
    public E pop() {
        return list.removeFirst();
    }

    @Override
    public E peek() {
        return list.getFirst();
    }

}</code></pre>]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>4、链表</title>
    <url>/page/ds_linked_list.html</url>
    <content><![CDATA[<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>链表是一个物理存储结构非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的引用链接次序实现，其示意图如下：</p>
<img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4%E3%80%81%E9%93%BE%E8%A1%A8/%E9%93%BE%E8%A1%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.png" style="zoom: 80%;" />

<p>数据存储在节点（Node）中，主要模型如下：包括该节点存储的<strong>元素</strong>以及下一个节点的<strong>地址</strong>。</p>
<pre><code>class Node {
    E e;
    Node next;
}</code></pre><h4 id="与顺序表的对比"><a href="#与顺序表的对比" class="headerlink" title="与顺序表的对比"></a>与顺序表的对比</h4><p><strong>1、顺序表</strong></p>
<p>优点：</p>
<p>a、空间利用率高。因为是连续存放，所以如果查找一个元素速度很快。</p>
<p>b、存取速度快，通过下标来直接存储。</p>
<p>缺点：</p>
<p>a、插入/删除比较麻烦。插入或者删除的时候，整个表需要遍历挪动元素来实现。</p>
<p>b、空间有限制。因为数组长度是固定的，当需要存取的元素个数多于顺序表的个数时，就会出现溢出问题，而当元素个数远远小于当初分配的空间时，又会造成空间的浪费（动态数组进行扩容同样消耗大量运算）。</p>
<p><strong>2、链表</strong></p>
<p>优点：相对于动态数组通过“扩容”等操作实现动态，链表是真正的动态，不需要处理固定容量的问题。</p>
<p>缺点：丧失了随机访问的能力（即无法通过索引进行访问）</p>
<h3 id="链表的实现"><a href="#链表的实现" class="headerlink" title="链表的实现"></a>链表的实现</h3><h4 id="类内基本元素"><a href="#类内基本元素" class="headerlink" title="类内基本元素"></a>类内基本元素</h4><pre><code>public class LinkedList&lt;E&gt; {
    private class Node {
        public E e;
        public Node next;

        public Node(E e, Node next) {
            this.e = e;
            this.next = next;
        }

        public Node(E e) {
            this(e, null);
        }

        public Node() {
            this(null, null);
        }
    }

    private Node dummyHead;    // 哑节点，指向链表头节点
    int size;

    public LinkedList() {
        dummyHead = new Node(null, null);
        size = 0;
    }</code></pre><h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><p>时间复杂度为O(n)。</p>
<pre><code>// 在链表中间添加元素
public void add(int index, E e) {
    if(index &lt; 0 || index &gt; size) {
        throw new IllegalArgumentException(&quot;Add failed&quot;);
    }
    Node prev = dummyHead;
    for (int i=0;i&lt;index;i++) {
        prev = prev.next;
    }
    prev.next = new Node(e, prev.next);
    size++;
}</code></pre><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>时间复杂度为O(n)</p>
<pre><code>// 删除索引为index的元素
public E remove(int index) {
    if(index &lt; 0 || index &gt; size) {
        throw new IllegalArgumentException(&quot;Add failed&quot;);
        }
    Node prev = dummyHead;
    for (int i=0;i&lt;index;i++) {
        prev = prev.next;
    }
    Node res = prev.next;
    prev.next = res.next;
    res.next = null;
    size--;
    return res.e;
}</code></pre><p>还有其他的一些诸如查找、修改等方法，均只需要通过遍历链表即可实现。</p>
<p>同时需要注意，<strong>在头部处不管插入还是删除元素都是O(1)级别</strong>。因此使用链表作为底层结构实现栈和队列是很优越的，这在之前已经提过了。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>5.1、树与二叉树</title>
    <url>/page/ds-tree-binarytree.html</url>
    <content><![CDATA[<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><h3 id="基本名词"><a href="#基本名词" class="headerlink" title="基本名词"></a>基本名词</h3><h4 id="1、度"><a href="#1、度" class="headerlink" title="1、度"></a>1、度</h4><p>节点拥有的子树的数目称为度</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.1%E3%80%81%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%BA%A6.png" alt=""></p>
<h4 id="4、层次与深度"><a href="#4、层次与深度" class="headerlink" title="4、层次与深度"></a>4、层次与深度</h4><p>从根开始定义，根为第一层，根的孩子为第二层，以此类推</p>
<p>树中结点的最大层次数称为树的深度或高度</p>
<h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><h3 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h3><h4 id="基本特点"><a href="#基本特点" class="headerlink" title="基本特点"></a>基本特点</h4><p>1、每个结点最多有两颗子树，所以二叉树中不存在度大于2的结点。</p>
<p>2、左子树和右子树是有顺序的，次序不能任意颠倒。</p>
<p>3、即使树中某结点只有一棵子树，也要区分它是左子树还是右子树。</p>
<h4 id="特殊的树"><a href="#特殊的树" class="headerlink" title="特殊的树"></a>特殊的树</h4><p>1、满二叉树：如果所有分支结点都存在左子树和右子树，并且所有叶子都在同一层上，这样的二叉树称为满二叉树。</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.1%E3%80%81%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt=""></p>
<p>2、完全二叉树：对一颗具有n个结点的二叉树按层编号，如果编号为i(1&lt;=i&lt;=n)的结点与同样深度的满二叉树中编号为i的结点在二叉树中位置完全相同，则这棵二叉树称为完全二叉树。</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.1%E3%80%81%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt=""></p>
<p>完全二叉树有以下特性（按层编号作为索引），可以用来构建堆结构:</p>
<blockquote>
<p>（1）父节点的编号为i/2。i为孩子节点的编号</p>
<p>（2）左子节点编号为2*i+1。i为父节点编号</p>
</blockquote>
<h4 id="数学性质"><a href="#数学性质" class="headerlink" title="数学性质"></a>数学性质</h4><p>1、在二叉树的第i层上最多有2i-1个节点 （i&gt;=1）</p>
<p>2、二叉树中如果深度为k，那么最多有2k-1个节点(k&gt;=1）</p>
<h3 id="基础实现"><a href="#基础实现" class="headerlink" title="基础实现"></a>基础实现</h3><p>二叉树的节点，与之前提到的链表的节点很相似，只不过有两个引用，在Java中可以作为一个类中类。</p>
<pre><code>class Node {
    E e;
    Node left;
    Node right;
}</code></pre><p>二叉树所需要的基础方法如下，该基础实现与之后要讲的二叉搜索树是一致的，因此此处类名直接采用BST。</p>
<pre><code>public class BST&lt;E extends Comparable&lt;E&gt;&gt; {
    private class Node {
        public E e;
        public Node left, right;

        public Node(E e) {
            this.e = e;
            left = null;
            right = null;
        }
    }

    private Node root;
    private int size;

    public BST() {
        root = null;
        size = 0;
    }

    public int getSize() {
        return size;
    }

    public boolean isEmpty() {
        return size==0;
    }
}</code></pre><h3 id="遍历操作"><a href="#遍历操作" class="headerlink" title="遍历操作"></a>遍历操作</h3><p>遍历操作就是把所有节点都访问一遍，由于树的定义天生就带有递归特性，因此使用递归进行遍历是最简单的，但也可以使用普通的迭代方法。</p>
<h4 id="二叉树中的几种遍历"><a href="#二叉树中的几种遍历" class="headerlink" title="二叉树中的几种遍历"></a>二叉树中的几种遍历</h4><p>PreOrder Traversal （前序遍历）<br>InOrder Traversal    （中序遍历）<br>PostOrder Traversal    （后序遍历）<br>LevelOrder Traversal    （层序遍历）</p>
<p><strong>规律：</strong>显然，中序遍历可以与其余三种遍历方法的任何一种完成对二叉树的重建（唯一），而其余三种遍历方法任何一种两两结合都无法构建唯一的二叉树。<br>这很好理解，其余三种遍历方法告知了我们根节点的位置，而根据这一点我们可以由中序遍历确定左右子树，然后根据二叉树的递归定义完成重建</p>
<p>前三种遍历方法可以依靠递归轻松实现，其不同之处仅在于递归语句中用于遍历当前节点的语句所处的位置，如下。</p>
<pre><code>// 前序遍历处理当前节点位置
递归（左子树）;
// 中序遍历处理当前节点位置
递归（右子树）;
// 后续遍历处理当前节点位置</code></pre><p>其中具体代码可见<strong>迭代实现</strong>中所示。</p>
<p>前三种遍历都可以依靠递归进行简单的实现，可以简单理解为<strong>深度优先</strong>，而最后一种层序遍历则为<strong>广度优先</strong>，依靠队列即可进行实现，其实现方法如下：</p>
<pre><code>public void levelOrder() {
    Queue&lt;Node&gt; q = new LinkedList&lt;&gt;();
    q.add(root);
    while (!q.isEmpty()) {
        Node cur = q.remove();
        System.out.println(cur.e);
        if(cur.left != null) q.add(cur.left);
        if(cur.right != null) q.add(cur.right);
    }
}</code></pre><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><p>具体可见（写的很详细）：<a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/binary-tree-preorder-traversal/solution/leetcodesuan-fa-xiu-lian-dong-hua-yan-shi-xbian-2/</a></p>
<p>1、前序遍历</p>
<pre><code>private void preOrder(Node node) {
    if(node == null) return;
    System.out.println(node.e);
    preOrder(node.left);
    preOrder(node.right);
}</code></pre><p>中序遍历和后序遍历如上所述，只是改变操作位置</p>
<h4 id="迭代实现"><a href="#迭代实现" class="headerlink" title="迭代实现"></a>迭代实现</h4><p>前序遍历</p>
<pre><code>public void preOrderNR() {
    Stack&lt;Node&gt; stack = new Stack&lt;&gt;();
    stack.push(root);
    while(!stack.isEmpty()) {
        Node cur = stack.pop();
        System.out.println(cur.e);
        if(cur.right != null) stack.push(cur.right);
        if(cur.left != null) stack.push(cur.left);
    }
}</code></pre><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://www.jianshu.com/p/bf73c8d50dc2" target="_blank" rel="noopener">https://www.jianshu.com/p/bf73c8d50dc2</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>1、动态数组</title>
    <url>/page/ds-dynamic-array.html</url>
    <content><![CDATA[<h3 id="数组的缺陷"><a href="#数组的缺陷" class="headerlink" title="数组的缺陷"></a>数组的缺陷</h3><h4 id="静态数组的缺陷"><a href="#静态数组的缺陷" class="headerlink" title="静态数组的缺陷"></a>静态数组的缺陷</h4><p>目前为止所实现的数组类，有一个非常严重的局限性，就是这个数组实际使用的还是一个静态数组，内部容量有限。在实际使用的时候，我们往往<strong>无法预估</strong>要在这个数组中存入<strong>多少个元素</strong>。</p>
<h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>构建动态数组，使得数组的容量能够随着存入的元素进行伸缩。其实现底层仍为<strong>静态数组</strong>。</p>
<p>即：当元素超过数组当前容量时，对数组进行<strong>扩容</strong>（重新声明一个更大的数组，并将原数组中的元素迁移过去）。当元素由于删除操作远小于当前容量时，对数组容量进行缩小。</p>
<h3 id="动态数组实现"><a href="#动态数组实现" class="headerlink" title="动态数组实现"></a>动态数组实现</h3><h4 id="类内基本信息"><a href="#类内基本信息" class="headerlink" title="类内基本信息"></a>类内基本信息</h4><p>类中使用泛型&lt;E&gt;，同时使用静态数组data作为底层容器，并记录数组中元素的个数size。</p>
<p>同时，构建实现一些基本的方法。</p>
<pre><code class="java">public class Array&lt;E&gt; {

    private E[] data;
    private int size;

    // 有参构造函数
    // 传入预先设置的容量
    public Array(int capacity) {
        data = (E[])new Object[capacity];
        size = 0;
    }

    // 无参构造函数，默认容量为10
    public Array() {
        this(10);
    }

    // 获取数组中元素个数
    public int getSize() {
        return size;
    }

    // 获取Array中数组容量
    public int getCapacity() {
        return data.length;
    }

    // 判断是否为空
    public boolean isEmpty() {
        return size == 0;
    }
}</code></pre>
<h4 id="实现数组的伸缩"><a href="#实现数组的伸缩" class="headerlink" title="实现数组的伸缩"></a>实现数组的伸缩</h4><p>实现数组的伸缩其实就是重新声明一个容量符合要求的数组，并将原数组中的元素拷贝进去，如下：</p>
<pre><code>// 改变数组中容量大小
// 传入新容量
private void resize(int newCapacity) {
    E[] newData = (E[])new Object[newCapacity];
    for (int i=0;i&lt;size;i++) {
        newData[i] = data[i];
    }
    data = newData;
}</code></pre><h4 id="向数组中添加元素"><a href="#向数组中添加元素" class="headerlink" title="向数组中添加元素"></a>向数组中添加元素</h4><p>1、对输入参数进行判断，不合理抛出异常</p>
<p>2、若原数组已经容纳不下新元素，进行上述resize操作，将新数组容量变为之前的2倍（可以指定为其他倍数）</p>
<p>3、进行添加操作</p>
<pre><code>// 向数组中index位置加入元素e
public void add(int index, E e) {
    if(index &lt; 0 || index &gt; size) {
        throw new IllegalArgumentException(&quot;Add failed.&quot;);
    }

    if(size == data.length) {
        resize(2 * data.length);
    }

    for (int i=size-1;i&gt;=index;i--) {
        data[i+1] = data[i];
    }
    data[index] = e;
    size++;
}

// 向最后添加一个元素
public void addLast(E e) {
    add(size, e);
}

// 向最前添加一个元素
public void addFirst(E e) {
    add(0, e);
}</code></pre><h4 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h4><p>1、对输入参数进行判断，不合理抛出异常</p>
<p>2、若删除元素后数组容量为含有元素个数的4倍，则使用resize将数组容量改为原来的1/2（与add中倍数不同是为了避免<strong>复杂度震荡</strong>）</p>
<p>3、进行删除操作</p>
<pre><code>// 删除索引为index的元素
public E remove(int index) {
    if(index&lt;0 || index &gt;= size) {
        throw new IllegalArgumentException(&quot;Set failed&quot;);
    }
    E res = data[index];
    for (int i=index+1;i&lt;size;i++) {
        data[i-1] = data[i];
    }
    size--;
    data[size] = null;

    if (size == data.length / 4) {
        resize(data.length / 2);
    }

    return res;
}

// 删除第一个元素
public E removeFirst() {
    return remove(0);
}

// 删除最后一个元素
public E removeLast() {
    return remove(size-1);
}</code></pre><h4 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h4><p>其余诸如查找索引等操作就是基本的数组操作了，直接进行实现即可。</p>
<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><h4 id="复杂度震荡"><a href="#复杂度震荡" class="headerlink" title="复杂度震荡"></a>复杂度震荡</h4><p>在之前提到过，在此进行记录其产生的具体过程：</p>
<p>1、假设现在我们有一个数组，容量是n，并且装满了元素。</p>
<p>2、这时候，我想添加一个元素，显然是需要进行扩容，容量变为2n，耗时O(n)的时间。</p>
<p>3、但是此时，我又删除了一个元素触发了缩容操作，耗时O(n)的时间。</p>
<p>4、当我们每次触发缩容或扩容操作，都会耗费O(n)额复杂度，那么这便是复杂度的震荡</p>
<p><strong>解决方法：</strong>即将缩容与扩容触发的阈值设置的不同即可。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>5.2、二叉搜索树</title>
    <url>/page/ds-bst.html</url>
    <content><![CDATA[<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>二叉搜索树（Binary Search Tree），即对任意节点，其值大于其左子树中任意一个节点的值，而小于其右子树中任意一个节点的值。</p>
<p>是一种特殊的二叉树，因此继承了二叉树的所有特性</p>
<p>二叉搜索树的相关分析见：<a href="https://www.jianshu.com/p/ff4b93b088eb" target="_blank" rel="noopener">https://www.jianshu.com/p/ff4b93b088eb</a></p>
<h2 id="操作实现"><a href="#操作实现" class="headerlink" title="操作实现"></a>操作实现</h2><h3 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h3><p>题目来源：<a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/</a></p>
<p>利用二叉树的递归特性可以很简单的构造出相应的递归函数。</p>
<pre><code>class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root==null) {
            root = new TreeNode(val);
            return root;
        }
        if(val&lt;root.val) {
            root.left = insertIntoBST(root.left, val);
        }
        else {
            root.right = insertIntoBST(root.right, val);
        }
        return root;
    }
}</code></pre><h3 id="查找某元素是否存在"><a href="#查找某元素是否存在" class="headerlink" title="查找某元素是否存在"></a>查找某元素是否存在</h3><p>使用递归进行判断，如果待判断元素比当前节点值小，则向左递归，否则向右递归。</p>
<pre><code>private boolean contains(Node node, E e) {
    if(node==null) return false;
    if(e.compareTo(node.e) == 0) return true;
    else if(e.compareTo(node.e) &lt; 0) return contains(node.left, e);
    else return contains(node.right, e);
}</code></pre><h3 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h3><p>这个思路很简单，使用递归与迭代都可以，就是向左或右一直搜索即可。</p>
<pre><code>// 寻找二分搜索树最小值
public E minimum() {
    if(size == 0) {
        throw new IllegalArgumentException(&quot;BST is empty&quot;);
    }
    return minimun(root).e;
}

private Node minimun(Node node) {
    if(node.left == null) return node;
    return minimun(node.left);
}</code></pre><p>其中若要删除最小值或最大值，就可以对应以下“删除元素”中的第一或者第二种情况，十分方便。</p>
<h3 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h3><p>图片来源：<a href="https://www.jianshu.com/p/ff4b93b088eb" target="_blank" rel="noopener">https://www.jianshu.com/p/ff4b93b088eb</a></p>
<p>对二叉搜索树进行删除主要要考虑以下三种情况。</p>
<p><strong>1、要删除的是叶子节点</strong></p>
<p>这种情况只需要直接将其设置为空即可</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.2%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/d1_1.png" alt="删除前"></p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.2%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/d1_2.png" alt="删除后"></p>
<p><strong>2、要删除的节点有左节点但没有右节点，或有右节点但没有左节点</strong></p>
<p>这种情况下只需要将其右（左）节点放置在要删除的节点的位置上即可。</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.2%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/d2_1.png" alt="删除前"></p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.2%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/d2_2.png" alt="删除后"></p>
<p><strong>3、要删除的节点既有左节点又有右节点</strong></p>
<p>这种情况下，只需要找到待删节点的右子树中最小的节点（或左子树最大的节点），将其删除并将其值赋给待删节点即可（直接操作相应的指针也行）</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.2%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/d3_1.png" alt="删除前"></p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.2%E3%80%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/d3_2.png" alt="删除后"></p>
<p>删除二叉搜索树的代码：来源于<a href="https://leetcode-cn.com/problems/delete-node-in-a-bst/submissions/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/delete-node-in-a-bst/submissions/</a></p>
<pre><code>class Solution {
    public TreeNode deleteNode(TreeNode root, int key) {
        if(root==null) return root;
        if(key &gt; root.val) {
            root.right = deleteNode(root.right, key);
        }
        else if(key &lt; root.val) {
            root.left = deleteNode(root.left, key);
        }
        else {
            if(root.left==null || root.right==null) {
                root = (root.left==null) ? root.right : root.left;
            }
            else {
                TreeNode temp = root.right;
                while(temp.left != null) {
                    temp = root.left;
                }
                root.val = temp.val;
                root.right = deleteNode(root.right, temp.val);
            }
        }
        return root;
    }
}</code></pre><p>其中可见：</p>
<p>若是上述第一种和第二种情况，则直接对二叉树节点进行赋值操作即可。</p>
<p>若是第三种情况，则将找到的节点的val值赋给对应“根”节点，之后对其子树进行递归，删除对应的节点即可（此时需要删除的节点必满足一二两种情况）</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>5.3、AVL树</title>
    <url>/page/ds-avl-tree.html</url>
    <content><![CDATA[<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><h3 id="AVL树（平衡二叉树）"><a href="#AVL树（平衡二叉树）" class="headerlink" title="AVL树（平衡二叉树）"></a>AVL树（平衡二叉树）</h3><p>平衡二叉树是一种二叉搜索树，对于其中任意一个节点，左子树和右子树的高度差不能超过1。</p>
<p>两位俄罗斯数学家共同发明了一种解决平衡二叉树的算法，所以这种树也称为AVL树（取其名称）。</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.3%E3%80%81AVL%E6%A0%91/AVL.png" alt=""></p>
<p>注意的地方：<strong>平衡二叉树从叶子节点向上记录节点的高度</strong>，即叶子节点高度为1，向上依次类推。而使用<strong>平衡因子</strong>用来表示左右子树高度差。</p>
<h3 id="平衡二叉树的作用"><a href="#平衡二叉树的作用" class="headerlink" title="平衡二叉树的作用"></a>平衡二叉树的作用</h3><p>根据之前对二叉搜索树的时间复杂度分析可知，其各项操作的时间复杂度介于O(log n)与O(n)之间，在节点足够多的情况下这两者的效率相差很大。O(n)复杂度的BST实际上已经退化成了一个链表，而复杂度接近O(log n)的情况则就是平衡二叉树的状态了，因此对二叉树进行“平衡处理”是很重要的。</p>
<h3 id="平衡性分析"><a href="#平衡性分析" class="headerlink" title="平衡性分析"></a>平衡性分析</h3><p>由于AVL树仍然是一个二叉搜索树，所以二叉搜索树的一切操作都可以进行调用，唯一需要注意的就是<strong>当有破坏平衡的操作发生时，需要进行对应操作维护树的平衡性</strong>。</p>
<p>显然，BST的相关操作中添加元素与删除元素这两个操作可能会破坏树的平衡性，因此在add与remove中递归实现的基础上，应该在递归完成之后沿着节点向上维护平衡性（有点后续遍历的味道）。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="1、右旋（左左）"><a href="#1、右旋（左左）" class="headerlink" title="1、右旋（左左）"></a>1、右旋（左左）</h4><p>这种情况发生在<strong>向左子树的左孩子添加一个元素，且正好打破了平衡时（即二叉树向左倾斜）</strong>。这种情况我们可以称为<strong>左左</strong>，需要进行<strong>右旋</strong>操作维持平衡</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.3%E3%80%81AVL%E6%A0%91/%E5%8F%B3%E6%97%8B1.png" alt=""></p>
<p>右旋操作简单来讲如下伪码：</p>
<pre><code>右旋(L):    
    temp = L.right;
    L.right = T;
    T.left = temp;</code></pre><p>如图所示：</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.3%E3%80%81AVL%E6%A0%91/%E5%8F%B3%E6%97%8B2.png" alt=""></p>
<h4 id="2、左旋（右右）"><a href="#2、左旋（右右）" class="headerlink" title="2、左旋（右右）"></a>2、左旋（右右）</h4><p>这种情况发生在<strong>向右子树的右孩子添加一个元素，且正好打破了平衡时（即二叉树向右倾斜）</strong>。这种情况我们可以称为<strong>右右</strong>，需要进行<strong>左旋</strong>操作维持平衡。</p>
<p><strong>左旋操作可以视为右旋的镜像</strong></p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.3%E3%80%81AVL%E6%A0%91/%E5%B7%A6%E6%97%8B1.png" alt=""></p>
<p>伪码如下：</p>
<pre><code>左旋(R):
    temp = R.left;
    R.left = T;
    T.right = temp;</code></pre><p>如图所示：</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.3%E3%80%81AVL%E6%A0%91/%E5%B7%A6%E6%97%8B2.png" alt=""></p>
<h3 id="3、左右"><a href="#3、左右" class="headerlink" title="3、左右"></a>3、左右</h3><p>顾名思义，也就是向左子树的右孩子插入一个节点。</p>
<p>这种情况下，我们需要<strong>先对右孩子进行一次左旋，再对对应的“根节点”进行一次右旋</strong>。如图所示：</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.3%E3%80%81AVL%E6%A0%91/%E5%B7%A6%E5%8F%B31.png" alt=""></p>
<p>伪码如下：</p>
<pre><code>左旋(R);
右旋(L);</code></pre><p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.3%E3%80%81AVL%E6%A0%91/%E5%B7%A6%E5%8F%B32.png" alt=""></p>
<h4 id="4、右左"><a href="#4、右左" class="headerlink" title="4、右左"></a>4、右左</h4><p>与“左右”是镜像操作，故不再赘述</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.3%E3%80%81AVL%E6%A0%91/%E5%8F%B3%E5%B7%A6.png" alt=""></p>
<h2 id="操作实现"><a href="#操作实现" class="headerlink" title="操作实现"></a>操作实现</h2><h3 id="node中新增height用于记录高度"><a href="#node中新增height用于记录高度" class="headerlink" title="node中新增height用于记录高度"></a>node中新增height用于记录高度</h3><pre><code>private class Node {
    public E e;
    public Node left, right;
    public int height;    // 记录高度

    public Node(E e) {
        this.e = e;
        left = null;
        right = null;
        height = 1;
    }
}</code></pre><h3 id="功能函数"><a href="#功能函数" class="headerlink" title="功能函数"></a>功能函数</h3><h4 id="获取节点的高度"><a href="#获取节点的高度" class="headerlink" title="获取节点的高度"></a>获取节点的高度</h4><pre><code>// 获取每个节点的高度
private int getHeight(Node node) {
    if(node == null)
        return 0;
    return node.height;
}</code></pre><h4 id="计算每个点的平衡因子"><a href="#计算每个点的平衡因子" class="headerlink" title="计算每个点的平衡因子"></a>计算每个点的平衡因子</h4><p>这个功能方法在AVL树的实现中至关重要，记住由于之后在维护平衡时需要判断是上述基本操作中的哪一种，因此<strong>该函数计算的平衡因子一定不能加上abs函数</strong>。</p>
<pre><code>// 计算每个点的平衡因子
    private int getBalenceFactor(Node node) {
        if(node == null)
            return 0;
        return getHeight(node.left) - getHeight(node.right);    // 不要加abs函数
    }</code></pre><h4 id="右旋操作"><a href="#右旋操作" class="headerlink" title="右旋操作"></a>右旋操作</h4><pre><code>// 对节点y进行向右旋转操作，返回旋转后新的根节点x
//        y                              x
//       / \                           /   \
//      x   T4     向右旋转 (y)        z     y
//     / \       - - - - - - - -&gt;    / \   / \
//    z   T3                       T1  T2 T3 T4
//   / \
// T1   T2
private Node rightRotate(Node y) {
    Node x = y.left;
    Node T3 = x.right;

    // 右旋转
    x.right = y;
    y.left = T3;

    // 更新height
    y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1;
    x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1;

    return x;
}</code></pre><h4 id="左旋操作"><a href="#左旋操作" class="headerlink" title="左旋操作"></a>左旋操作</h4><pre><code>// 对节点y进行向左旋转操作，返回旋转后新的根节点x
//    y                             x
//  /  \                          /   \
// T1   x      向左旋转 (y)       y     z
//     / \   - - - - - - - -&gt;   / \   / \
//   T2  z                     T1 T2 T3 T4
//      / \
//     T3 T4
private Node leftRotate(Node y) {
    Node x = y.right;
    Node T2 = x.left;

    x.left = y;
    y.right = T2;

    y.height = Math.max(getHeight(y.left), getHeight(y.right)) + 1;
    x.height = Math.max(getHeight(x.left), getHeight(x.right)) + 1;
    return x;
}</code></pre><h4 id="判断是否是平衡二叉树"><a href="#判断是否是平衡二叉树" class="headerlink" title="判断是否是平衡二叉树"></a>判断是否是平衡二叉树</h4><pre><code>// 判断是否是平衡二叉树
public boolean isBalanced() {
    return isBalanced(root);
}

private boolean isBalanced(Node node) {
    if(node == null)
        return true;
    int balanceFactor = getBalenceFactor(node);
    if(Math.abs(balanceFactor) &gt; 1)
        return false;
    return isBalanced(node.left) &amp;&amp; isBalanced(node.right);
}</code></pre><h3 id="维护平衡与更新高度"><a href="#维护平衡与更新高度" class="headerlink" title="维护平衡与更新高度"></a>维护平衡与更新高度</h3><pre><code>// 返回进行平衡维护后的节点
private Node keepBalence(Node node) {
    // 更新height
    node.height = 1 + Math.max(getHeight(node.left), getHeight(node.right));

    // 平衡维护
    int balanceFactor = getBalenceFactor(node);
    if(balanceFactor &gt; 1 &amp;&amp; getBalenceFactor(node.left) &gt;= 0) {
        return rightRotate(node);
    }
    if(balanceFactor &lt; -1 &amp;&amp; getBalenceFactor(node.right) &lt;=0) {
        return leftRotate(node);
    }
    // LR
    if(balanceFactor &gt; 1 &amp;&amp; getBalenceFactor(node.left) &lt; 0) {
        node.left = leftRotate(node.left);
        return rightRotate(node);
    }
    // RL
    if(balanceFactor &lt; -1 &amp;&amp; getBalenceFactor(node.right) &gt; 0) {
        node.right = rightRotate(node.right);
        return leftRotate(node);
    }
    return node;
}</code></pre><h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3><pre><code>private Node add(Node node, E e) {
    if(node == null) {
        size++;
        return new Node(e);
    }
    if(e.compareTo(node.e) &lt; 0) {
        node.left = add(node.left, e);
    }
    else if(e.compareTo(node.e) &gt;0) {
        node.right = add(node.right, e);
    }

    return keepBalence(node);
}</code></pre><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><pre><code class="java">private Node remove(Node node, E e) {
    if(node == null)
        return null;

    Node retNode;
    if(e.compareTo(node.e) &lt; 0) {
        node.left = remove(node.left, e);
        retNode = node;
    }
    else if(e.compareTo(node.e) &gt; 0) {
        node.right = remove(node.right, e);
        retNode = node;
    }
    else {
        if(node.left == null || node.right == null) {
            node = (node.left == null) ? node.right : node.left;
            retNode = node;
        }
        else {
            Node temp = node.right;
            while (temp.left != null)
                temp = temp.left;
            node.e = temp.e;
            node.right = remove(node.right, temp.e);
            retNode = node;
        }
    }

    // 当前节点被删除时
    if(retNode == null)
        return null;

    return keepBalence(retNode);
}</code></pre>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://www.cnblogs.com/linhaostudy/p/11300556.html" target="_blank" rel="noopener">https://www.cnblogs.com/linhaostudy/p/11300556.html</a>    （图画的相当清楚，点赞！）</p>
<p><a href="https://github.com/liuyubobobo/Play-with-Data-Structures" target="_blank" rel="noopener">https://github.com/liuyubobobo/Play-with-Data-Structures</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>6、集合与映射</title>
    <url>/page/ds-set-and-map.html</url>
    <content><![CDATA[<h2 id="集合特点"><a href="#集合特点" class="headerlink" title="集合特点"></a>集合特点</h2><p>集合通常由一组无序的，<strong>不能重复</strong>的元素构成。</p>
<p>封装的集合接口如下：</p>
<pre><code>public interface Set&lt;E&gt; {
    void add(E e);
    void remove(E e);
    boolean contains(E e);
    int getSize();
    boolean isEmpty();
}</code></pre><h2 id="集合实现"><a href="#集合实现" class="headerlink" title="集合实现"></a>集合实现</h2><p>基于BST实现的集合为有序集合，基于链表实现的集合为无序集合</p>
<h3 id="基于二叉树"><a href="#基于二叉树" class="headerlink" title="基于二叉树"></a>基于二叉树</h3><p>由之前构建二叉树可知，当元素数值在二叉树中存在时，我们并没有对其进行处理，因此利用二叉树（或者说二叉搜索树）构建集合具有天然的优势。Java代码实现如下：</p>
<pre><code>public class BSTSet&lt;E extends Comparable&lt;E&gt;&gt; implements Set&lt;E&gt; {

    private BST&lt;E&gt; bst;

    public BSTSet() {
        bst = new BST&lt;&gt;();
    }

    @Override
    public void add(E e) {
        bst.add(e);
    }

    @Override
    public void remove(E e) {
        bst.remove(e);
    }

    @Override
    public boolean contains(E e) {
        return bst.contains(e);
    }

    @Override
    public int getSize() {
        return bst.getSize();
    }

    @Override
    public boolean isEmpty() {
        return bst.isEmpty();
    }
}</code></pre><h4 id="基于链表等线性结构"><a href="#基于链表等线性结构" class="headerlink" title="基于链表等线性结构"></a>基于链表等线性结构</h4><pre><code>public class LinkedListSet&lt;E&gt; implements Set&lt;E&gt; {

    private LinkedList&lt;E&gt; list;

    public LinkedListSet() {
        list = new LinkedList&lt;&gt;();
    }

    @Override
    public void add(E e) {
        if(!list.contains(e)) {
            list.addFirst(e);   // 在头部添加复杂度为O(1)
        }
    }

    @Override
    public void remove(E e) {
        list.removeElement(e);
    }

    @Override
    public boolean contains(E e) {
        return list.contains(e);
    }

    @Override
    public int getSize() {
        return list.getSize();
    }

    @Override
    public boolean isEmpty() {
        return list.isEmpty();
    }
}</code></pre><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><p>基于链表的增删改查复杂度都为O(n)级别</p>
<p>而基于二叉搜索树的则为O(h)级别（h为二叉树的高度）。依据二叉树的性质，最好的情况（平衡）为O(log n) ，最差为O(n)。</p>
<h2 id="映射特点"><a href="#映射特点" class="headerlink" title="映射特点"></a>映射特点</h2><p>映射通俗来讲就是存储（键，值）数据对的数据结构，可以根据键（Key）来寻找值（Value）。</p>
<p>如下是映射的接口及需要实现的方法</p>
<pre><code>public interface Map&lt;K, V&gt; {
    void add(K key, V value);
    V remove(K key);
    boolean contains(K key);
    V get(K key);
    void set(K key, V newValue);
    int getSize();
    boolean isEmpty();
}</code></pre><h3 id="基于二叉树-1"><a href="#基于二叉树-1" class="headerlink" title="基于二叉树"></a>基于二叉树</h3><p>实现基本框架</p>
<pre><code>public class BSTMap&lt;K extends Comparable&lt;K&gt;, V&gt; implements Map&lt;K, V&gt; {

    private class Node {
        public K key;
        public V value;
        public Node left, right;

        public Node(K key, V value) {
            this.key = key;
            this.value = value;
            left = null;
            right = null;
        }
    }

    private Node root;
    private int size;

    public BSTMap() {
        root = null;
        size = 0;
    }
}</code></pre><p>其余诸如添加元素、删除元素等操作，与二叉搜索树中的相应操作完全一致，只是每个节点中有两个值而已。</p>
<h3 id="基于链表的实现"><a href="#基于链表的实现" class="headerlink" title="基于链表的实现"></a>基于链表的实现</h3><p>将链表中存储的值由一个变为两个，如下：</p>
<pre><code>private class Node {
    public K key;
    public V value;
    public Node next;

    public Node(K key, V value, Node next) {
        this.key = key;
        this.value = value;
        this.next = next;
    }

    public Node(K key, V value) {
        this(key, value, null);
    }

    public Node() {
        this(null, null, null);
    }
}</code></pre><p>其余增删操作与链表中逻辑一致，只是增加元素的时候需要判断元素是否存在。</p>
<h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>基于链表实现的映射的增删改查都为O(n)级别</p>
<p>基于BST实现的映射的增删改查为O(h)级别，这与集合中的复杂度分析是一致的。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>5.4、红黑树</title>
    <url>/page/ds-RBTree.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="红黑树的定义与性质"><a href="#红黑树的定义与性质" class="headerlink" title="红黑树的定义与性质"></a>红黑树的定义与性质</h3><p>红黑树与AVL树一样，也是一个自平衡的二叉搜索树，其中节点使用“红”与“黑”进行标注。</p>
<p>关于对红黑树的理解，根据23树的相关定义可以很快的认识。</p>
<h4 id="基本性质"><a href="#基本性质" class="headerlink" title="基本性质"></a>基本性质</h4><ol>
<li>每个节点或者是红色的，或者是黑色的。</li>
<li>根节点是黑色的。</li>
<li>每一个叶子节点（最后的空节点）是黑色的。</li>
<li>如果一个节点是红色的，那么他的孩子节点都是黑色的</li>
<li>从任意一个节点到叶子节点，经过的黑色节点是一样的。</li>
</ol>
<p>显然，根据第5条性质，可以知道<strong>红黑树是保持“黑平衡”的二叉树</strong>。因此严格意义上不是平衡二叉树，最大高度2log n（每个黑节点都带个红节点）</p>
<h3 id="与AVL树的比较"><a href="#与AVL树的比较" class="headerlink" title="与AVL树的比较"></a>与AVL树的比较</h3><p>显然，如果单纯按照树的高度这一标准看，红黑树似乎比不上AVL树的性能，但<strong>红黑树添加元素、删除元素较AVL树更快</strong>，在整体性能上优于AVL树，所以这是一个相当重要的数据结构。</p>
<p>当元素偏向于固定，主要进行查询等操作时，使用AVL树更优</p>
<p>当需要频繁的进行插入与删除操作时，则使用红黑树更优。</p>
<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><p>红黑树的操作绝大部分与二叉搜索树相同，不同的地方与AVL树相同，主要在维护自平衡上，集中表现在插入与删除的过程。<strong>维护的时机也与AVL树一致，在添加节点后回溯向上维护（简单来讲就是代码应该写在插入的递归业务之后，采用后序的思想）</strong></p>
<h3 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h3><h4 id="基本Node类"><a href="#基本Node类" class="headerlink" title="基本Node类"></a>基本Node类</h4><p>设置插入节点的初始颜色：<strong>红色</strong>。</p>
<p>理由：红色在父结点（如果存在）为黑色结点时，红黑树的黑色平衡没被破坏，不需要做自平衡操作。但如果插入结点是黑色，那么插入位置所在的子树黑色结点总是多1，必须做自平衡。（得时刻记住，红黑树是一个黑节点平衡的树）</p>
<pre><code>private static final boolean RED = true;
private static final boolean BLACK = false;

private class Node {
    public E e;
    public Node left, right;
    public boolean color;

    public Node(E e) {
        this.e = e;
        left = null;
        right = null;
        color = RED;    // 初始节点设置为红色
    }
}</code></pre><h4 id="判断当前节点是否为红色"><a href="#判断当前节点是否为红色" class="headerlink" title="判断当前节点是否为红色"></a>判断当前节点是否为红色</h4><pre><code>private boolean isRed(Node node) {
    if(node == null)
        return BLACK;
    return RED;
}</code></pre><h4 id="左旋"><a href="#左旋" class="headerlink" title="左旋"></a>左旋</h4><pre><code>//   node                     x
//  /   \     左旋转         /  \
// T1   x   ---------&gt;   node   T3
//     / \              /   \
//    T2 T3            T1   T2
private Node leftRotate(Node node) {
    Node x = node.right;

    node.right = x.left;
    x.left = node;

    x.color = node.color;
    node.color = RED;

    return x;
}</code></pre><h4 id="右旋"><a href="#右旋" class="headerlink" title="右旋"></a>右旋</h4><pre><code>//     node                   x
//    /   \     右旋转       /  \
//   x    T2   -------&gt;   y   node
//  / \                       /  \
// y  T1                     T1  T2
private Node rightRotate(Node node) {
    Node x = node.left;
    node.left = x.right;
    x.right = node;

    x.color = node.color;
    node.color = RED;

    return x;
}</code></pre><h4 id="颜色翻转"><a href="#颜色翻转" class="headerlink" title="颜色翻转"></a>颜色翻转</h4><pre><code>private void flipColors(Node node) {
    node.color = RED;
    node.left.color = BLACK;
    node.right.color = BLACK;
}</code></pre><h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><p>插入时可能会遇到的情况下图已经总结的很清楚了。主要考虑情景4</p>
<img src="http://cdn.ziyedy.top/%E7%BA%A2%E9%BB%91%E6%A0%91%E6%8F%92%E5%85%A5.png" style="zoom:;" />

<p>而情景4主要可以分为以下①②③三种插入情况，其实是可以分别转化的</p>
<img src="http://cdn.ziyedy.top/%E6%8F%92%E5%85%A5.jpg" style="zoom:80%;" />

<p>这三种操作具体可见辅助方法中的代码。同时应当注意，在这种代码实现下，<strong>红节点是只会出现在左孩子上的（由于颜色翻转的实现）</strong></p>
<h4 id="情况③"><a href="#情况③" class="headerlink" title="情况③"></a>情况③</h4><p>这种情况直接插入并进行<strong>颜色翻转</strong>操作。</p>
<h4 id="情况②"><a href="#情况②" class="headerlink" title="情况②"></a>情况②</h4><p>这种情况先进行右旋再进行颜色翻转</p>
<h4 id="情况①"><a href="#情况①" class="headerlink" title="情况①"></a>情况①</h4><p>先进行左旋转、再进行右旋转、最后进行颜色反转</p>
<pre><code>// 向红黑树中添加新元素
public void add(E e) {
    root = add(root, e);
    root.color = BLACK;    // 设置根节点为黑
}

private Node add(Node node, E e) {
    if(node == null) {
        size++;
        return new Node(e);
    }
    if(e.compareTo(node.e) &lt; 0) {
        node.left = add(node.left, e);
    }
    else if(e.compareTo(node.e) &gt;0) {
        node.right = add(node.right, e);
    }

    // 情况1
    if(isRed(node.right) &amp;&amp; !isRed(node.left))
        node = leftRotate(node);
    // 情况2
    if(isRed(node.left) &amp;&amp; isRed(node.left.left))
        node = rightRotate(node);
    // 情况3
    if(isRed(node.left) &amp;&amp; isRed(node.right))
        flipColors(node);

    return node;
}</code></pre><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.jianshu.com/p/e136ec79235c" target="_blank" rel="noopener">https://www.jianshu.com/p/e136ec79235c</a>    这篇文章对红黑树阐述的特别详细，其实要了解红黑树看这一篇就行了。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>8、哈希表</title>
    <url>/page/ds-hashtable.html</url>
    <content><![CDATA[<h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><p>哈希表可以理解为是通过一个映射函数（哈希函数）直接得到存储地址的数据结构，通常基于数组实现（<strong>容量通常采用质数</strong>）。</p>
<pre><code>存储地址 = f(关键字)    // f为哈希函数</code></pre><p>根据这一基本特征可以看出，哈希表可以提供非常快速的插入-删除操作，理想状况下时间复杂度为0(1)级别。</p>
<h3 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h3><p>哈希函数可以简单理解为是对需要存储的元素本身——&gt;存储下标的映射。</p>
<p>如对字符串可以分别取其符号进行运算（整型则通常使用取模得到），而对于相关类，也可以自己定义hashcode函数，来获取坐标方式。</p>
<h4 id="哈希函数的设计："><a href="#哈希函数的设计：" class="headerlink" title="哈希函数的设计："></a>哈希函数的设计：</h4><p>一致性：如果a==b,则hash(a)==hash(b)</p>
<p>高效性：计算高效简便</p>
<p>均匀性：哈希值均匀分布</p>
<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>比如我们的哈希函数是对7取余，那么元素14和元素77通过哈希函数得到的索引就是相同的，这种情况就叫哈希冲突。</p>
<p>解决哈希冲突的方法有很多，具体有：<strong>链地址法（数组中存链表、平衡二叉树等元素）</strong>、<strong>开放地址法（向下找没存元素的位置，个人认为很麻烦不适用）</strong>等方法。</p>
<p>也可以将实现哈希表的数组直接保存一个平衡二叉树，总之就是为了解决冲突问题。</p>
<h3 id="哈希表扩容"><a href="#哈希表扩容" class="headerlink" title="哈希表扩容"></a>哈希表扩容</h3><p>如果哈希函数设计的不好，很多元素都重叠在了一个地址，那么理论上O(1)的时间复杂度在以平衡二叉树为数组元素的哈希表中就会达到O(log n/m)，因此遇到这种时候，就应该对哈希表进行扩容。</p>
<p>平均每个地址承载的元素多过一定程度，就进行扩容，通常这个值是0.75。缩容同理。</p>
<p>由于哈希表的实现方法很多，而且并不算太难，所以不进行代码记录，主要思想就是<strong>以空间换时间</strong></p>
<h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://www.jianshu.com/p/6e88d63061f2" target="_blank" rel="noopener">https://www.jianshu.com/p/6e88d63061f2</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>堆与优先队列</title>
    <url>/page/priority-queue-and-heap.html</url>
    <content><![CDATA[<h2 id="堆的基本概念"><a href="#堆的基本概念" class="headerlink" title="堆的基本概念"></a>堆的基本概念</h2><p>堆（二叉堆）就是用数组实现的二叉树（完全二叉树），所以它没有使用父指针或者子指针。堆根据“堆属性”来排序，“堆属性”决定了树中节点的位置。</p>
<h3 id="堆的用处"><a href="#堆的用处" class="headerlink" title="堆的用处"></a>堆的用处</h3><ul>
<li>构建优先队列</li>
<li>支持堆排序（O(n log n)）</li>
<li>快速找出一个集合中的最小值（或者最大值）</li>
</ul>
<h3 id="堆属性"><a href="#堆属性" class="headerlink" title="堆属性"></a>堆属性</h3><p>堆可以分为最大堆与最小堆等等，差别只在于节点的排序方法。</p>
<p>以最大堆为例，<strong>堆中某个节点的值总是不大于其父亲节点的值</strong> 。也就是说，最大堆总将最大的值放在树的根节点（也就是数组索引为0的位置）。根据堆的这一特性，堆能够作为优先队列的实现。</p>
<blockquote>
<p><strong>注意：</strong>堆的根节点中存放的是最大或者最小元素，但是其他节点的排序顺序是未知的。例如，在一个最大堆中，最大的那一个元素总是位于 index 0 的位置，但是最小的元素则未必是最后一个元素。–唯一能够保证的是最小的元素是一个叶节点，但是不确定是哪一个。</p>
</blockquote>
<h3 id="堆与普通树的区别"><a href="#堆与普通树的区别" class="headerlink" title="堆与普通树的区别"></a>堆与普通树的区别</h3><p><strong>节点的顺序。</strong>在二叉搜索树中，左子节点必须比父节点小，右子节点必须必比父节点大。但是在堆中并非如此。在最大堆中两个子节点都必须比父节点小，而在最小堆中，它们都必须比父节点大。<strong>且以最大堆举例，最下层的节点值未必一定小于上层节点的值</strong></p>
<p><strong>内存占用。</strong>普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配内存。堆仅仅使用一个数据来存储数组，且不使用指针。</p>
<p><strong>平衡。</strong>二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到<strong>O(log n)</strong>。你可以按任意顺序位置插入/删除数据，或者使用 AVL 树或者红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足堆属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证<strong>O(log n)</strong> 的性能。</p>
<p><strong>搜索。</strong>在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入、删除操作。</p>
<h2 id="堆的实现"><a href="#堆的实现" class="headerlink" title="堆的实现"></a>堆的实现</h2><h3 id="实现基础"><a href="#实现基础" class="headerlink" title="实现基础"></a>实现基础</h3><p>堆的底层可以使用动态数组进行实现，由于完全二叉树的特性，按照层序遍历对二叉树进行存储时父节点与子节点之间有以下的规律：</p>
<pre><code>parent = i/2    // i为子节点在数组中的索引

leftChild = 2 * i + 1    // i为父节点

rightChild = 2 * i+ 2</code></pre><p>因此可基于之前实现的动态数组进行最大堆的基本实现：</p>
<pre><code>public class MaxHeap&lt;E extends Comparable&gt; {
    private Array&lt;E&gt; data;
    public MaxHeap(int capacity) {
        data = new Array&lt;&gt;(capacity);
    }

    public MaxHeap() {
        data = new Array&lt;&gt;();
    }

    public MaxHeap(E[] arr) {
        data = new Array&lt;&gt;(arr);
        for (int i=parent(arr.length - 1); i&gt;=0; i--) {
            siftDown(i);
        }
    }

    public int size() {
        return data.getSize();
    }

    public boolean isEmpty() {
        return data.isEmpty();
    }

    // 获得父节点索引
    private int parent(int index) {
        if(index == 0) {
            throw new IllegalArgumentException(&quot;Index 0 has no parent&quot;);
        }
        return (index - 1) / 2;
    }

    // 获得左子节点索引
    private int leftChild(int index) {
        return index * 2 + 1;
    }

    // 获得右子节点索引
    private int rightChild(int index) {
        return index * 2 + 2;
    }

}</code></pre><h3 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h3><p>向堆中添加元素首先将元素添加到数组最后，之后进行<strong>堆的上浮</strong>操作。</p>
<p>即当该元素的父节点值 &lt; 该元素值时：将这两个元素进行交换，知道到达根节点或不满足该条件。详见代码，复杂度为<strong>O(log n)</strong>。</p>
<pre><code>// 添加元素
public void add(E e) {
    data.addLast(e);
    shiftUp(data.getSize() - 1);
}

// 堆的上浮
private void shiftUp(int k) {
    while (k &gt; 0 &amp;&amp; data.get(parent(k)).compareTo(data.get(k)) &lt; 0 ) {
        data.swap(k, parent(k));
        k = parent(k);
    }
}</code></pre><h3 id="取出堆中最大元素"><a href="#取出堆中最大元素" class="headerlink" title="取出堆中最大元素"></a>取出堆中最大元素</h3><p>将第一个元素取出后，将最后一个元素放入根节点的位置（即将索引为0 与 索引为 size-1的元素互换），再进行<strong>堆的下沉</strong>的操作。</p>
<p>堆的下沉即为，如果当前节点小于其子节点中最大的那个，则将其替换。详见代码，复杂度为<strong>O(log n)</strong></p>
<pre><code>// 返回堆中最大元素
public E findMax() {
    if(data.getSize() == 0) {
        throw new IllegalArgumentException(&quot;heap is empty&quot;);
    }
    return data.getFirst();
}

// 取出堆中最大元素
public E extractMax() {
    E ret = findMax();
    data.swap(0, data.getSize()-1);
    data.removeLast();
    siftDown(0);
    return ret;
}

// 堆的下浮
private void siftDown(int k) {
    while (leftChild(k) &lt; data.getSize()) {
        int maxChild = leftChild(k);
        if(maxChild +1 &lt; data.getSize() &amp;&amp; data.get(maxChild +1).compareTo(data.get(maxChild)) &gt; 0) {
            maxChild++;
        }
        if(data.get(k).compareTo(data.get(maxChild)) &gt;= 0){
            break;
        }
        data.swap(k, maxChild);
        k = maxChild;
    }
}</code></pre><h3 id="将输入数组变为堆（heapify）"><a href="#将输入数组变为堆（heapify）" class="headerlink" title="将输入数组变为堆（heapify）"></a>将输入数组变为堆（heapify）</h3><p>将输入数组变为堆结构，首先找到最后一个非叶子节点（即最后一个叶子节点的父节点），之后向前遍历，并分别进行下沉操作，如代码所示（作为maxHeap类的构造函数）</p>
<p>这样做的好处是时间复杂度只有O(n)，而将数组元素分别插入进堆的时间复杂度为O(n log n)</p>
<pre><code>public MaxHeap(E[] arr) {
    data = new Array&lt;&gt;(arr);
    for (int i=parent(arr.length - 1); i&gt;=0; i--) {
        siftDown(i);
    }
}</code></pre><h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>优先队列也就是优先级最大的元素在队首的队列了，显而易见，其可以使用堆轻松实现，下面是简单的最大值在前的优先队列。</p>
<pre><code>public class PriorityQueue&lt;E extends Comparable&lt;E&gt;&gt; implements Queue&lt;E&gt; {

    private MaxHeap&lt;E&gt; maxHeap;

    public PriorityQueue() {
        maxHeap = new MaxHeap&lt;&gt;();
    }

    @Override
    public int getSize() {
        return maxHeap.size();
    }

    @Override
    public boolean isEmpty() {
        return maxHeap.isEmpty();
    }

    @Override
    public void enqueue(E e) {
        maxHeap.add(e);
    }

    @Override
    public E dequeue() {
        return maxHeap.extractMax();
    }

    @Override
    public E getFront() {
        return maxHeap.findMax();
    }
}</code></pre><h3 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h3><p><a href="https://www.jianshu.com/p/6b526aa481b1" target="_blank" rel="noopener">https://www.jianshu.com/p/6b526aa481b1</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>图的遍历及应用</title>
    <url>/page/graph-traverse-and-user.html</url>
    <content><![CDATA[<p>图的遍历思想是解决很多算法问题的关键，其中深度优先遍历可以使用栈（递归）进行实现，广度优先搜索可以使用队列进行实现。</p>
<p>图的遍历的实现其实和树基本一致，深度优先对应前序遍历，广度优先对应层序遍历</p>
<h2 id="遍历实现"><a href="#遍历实现" class="headerlink" title="遍历实现"></a>遍历实现</h2><h3 id="深度优先遍历（DFS）"><a href="#深度优先遍历（DFS）" class="headerlink" title="深度优先遍历（DFS）"></a>深度优先遍历（DFS）</h3><pre><code>import java.util.ArrayList;

public class GraphDFS {

    private Graph G;    // 使用邻接表实现的图结构，参考图的概念与存储结构中的实现
    private boolean[] visited;    // 记录是否访问过
    private ArrayList&lt;Integer&gt; order = new ArrayList&lt;&gt;();    // 存储遍历结果

    public GraphDFS(Graph G) {
        this.G = G;
        visited = new boolean[G.getVertex()];
        // 超过一个连通分量时，进行完全遍历
        for (int v=0; v&lt;G.getVertex(); v++) {
            if(!visited[v]) {
                dfs(v);
            }
        }
    }

    private void dfs(int v) {
        visited[v] = true;
        order.add(v);
        for (int w : G.adj(v)) {
            if (!visited[w]) {
                dfs(w);
            }
        }
    }

    public Iterable&lt;Integer&gt; order() {
        return order;
    }
}</code></pre><h3 id="广度优先遍历（BFS）"><a href="#广度优先遍历（BFS）" class="headerlink" title="广度优先遍历（BFS）"></a>广度优先遍历（BFS）</h3><p>广度优先遍历在图中有一条很重要的性质，即广度优先搜索能够直接得到<strong>无权图的最短路径</strong></p>
<pre><code>public class GraphBFS {

    private Graph G;
    private boolean[] visited;
    private ArrayList&lt;Integer&gt; order = new ArrayList&lt;&gt;();

    public GraphBFS(Graph G) {
        this.G = G;
        visited = new boolean[G.getVertex()];

        for (int v = 0; v&lt;G.getVertex(); v++) {
            if(!visited[v])
                bfs(v);
        }
    }

    private void bfs(int s) {
        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
        queue.add(s);
        visited[s] = true;
        while (!queue.isEmpty()) {
            int v = queue.remove();
            order.add(v);
            for (int w : G.adj(v)) {
                if (!visited[w]) {
                    queue.add(w);
                    visited[w] = true;
                }
            }
        }
    }

    public Iterable&lt;Integer&gt; order() {
        return order;
    }
}</code></pre><h2 id="利用遍历可以实现的简单操作"><a href="#利用遍历可以实现的简单操作" class="headerlink" title="利用遍历可以实现的简单操作"></a>利用遍历可以实现的简单操作</h2><p>利用遍历可以解决图结构中包括连通性等诸多问题，这些问题使用bfs和dfs都能够得到解决，以dfs为例。</p>
<h3 id="求图的连通分量"><a href="#求图的连通分量" class="headerlink" title="求图的连通分量"></a>求图的连通分量</h3><p>在遍历代码的基础上使用一个整型记录主函数调用dfs的次数即可（该类问题与常见的海岛个数问题&lt;floodfill算法&gt;思路完全一致）。思路如下</p>
<pre><code>int count = 0
for (int v=0; v&lt;G.getVertex(); v++) {
    if(!visited[v]) {
        dfs(v);
        count++;
    }
}</code></pre><h3 id="记录图中每个节点所属的连通分量"><a href="#记录图中每个节点所属的连通分量" class="headerlink" title="记录图中每个节点所属的连通分量"></a>记录图中每个节点所属的连通分量</h3><p>将记录是否访问过节点的boolean型数组visited改为整型数组，在不同连通分量递归时使用不同的值进行记录即可。大致思路如下半伪码。</p>
<pre><code>int[] visited;
// 遍历将visited的值全部设置为-1，表示没有进行访问
int record = 0;
for (int v=0; v&lt;G.getVertex(); v++) {
    if(!visited[v]) {
        dfs(v, record);    // 将record值用于标记已访问该节点
        record++;
    }
}
// 此时visited中就已经记录了每个节点所属连通分量的信息</code></pre><h3 id="求两点间是否可达"><a href="#求两点间是否可达" class="headerlink" title="求两点间是否可达"></a>求两点间是否可达</h3><p>若两点在同一个连通分量，则代表可达，在上一个问题的基础上进行一下判断就行了。</p>
<h3 id="求两点间的任意一条路径"><a href="#求两点间的任意一条路径" class="headerlink" title="求两点间的任意一条路径"></a>求两点间的任意一条路径</h3><p>使用一个数组存储当前节点前面一个节点，之后根据数组信息即可得到两点间的一条路径，伪码如下：</p>
<pre><code>int[] pre;
int target;
dfs(v, v);    // 求从v到target的任一路径

// v的上一个节点是parent
void dfs(v, parent) {
    if(v == target) return;
    visited[v] = true;
    pre[v] = parent;
    for(w : G.adj(v))
        if(!visited[w])
        dfs(w, v)
}</code></pre><h3 id="检查是否有环"><a href="#检查是否有环" class="headerlink" title="检查是否有环"></a>检查是否有环</h3><p>利用深度优先遍历，若访问到了一个已访问过的点，则有环，若遍历结束都没访问到，则无环。</p>
<h3 id="二分图检测"><a href="#二分图检测" class="headerlink" title="二分图检测"></a>二分图检测</h3><p>二分图就是<strong>顶点V可以分成不相交的两部分，且所有边的两个端点隶属于不同的部分</strong>的一种特殊图结构</p>
<p>二分图的检测也可以使用深度优先遍历进行检测，每遍历到一个点则对其进行染色操作，若相应点已染色，则检查其与其相邻顶点颜色是否匹配，若不匹配则直接返回false</p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集</title>
    <url>/page/ds-Union-Find.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="并查集定义"><a href="#并查集定义" class="headerlink" title="并查集定义"></a>并查集定义</h3><p><strong>并查集(Union-Find Set)</strong>，顾名思义，是实现快速合并集合与查询元素所在集合的数据结构。</p>
<h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><ol>
<li>合并两个不相交集合<strong>（Union）</strong></li>
<li>判断两个元素是否属于同一个集合<strong>（Find）</strong></li>
</ol>
<p>基于此，可以实现一个并查集的Java接口如下：</p>
<pre><code>public interface UF {
    int getSize();  // 获取元素个数
    boolean find(int p, int q); // 判断两个元素是否属于同一集合
    void union(int p, int q);   // 合并两个不相交的集合
}</code></pre><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><h3 id="Quick-Find概述"><a href="#Quick-Find概述" class="headerlink" title="Quick Find概述"></a>Quick Find概述</h3><p>如图，使用一个数组id标识不同元素所属的集合。</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/quickfind.jpg" alt=""></p>
<p>则并查集的实现逻辑如下。由于可以直接通过索引得到某元素所属的集合，则<strong>Find操作的时间复杂度为O(1)</strong>，但Union操作由于要遍历整个数组，因此<strong>时间复杂度为O(n)</strong>。</p>
<pre><code>public class UnionFind1 implements UF {

    private int[] id;

    public UnionFind1(int size) {
        id = new int[size];
        for(int i=0;i&lt;id.length;i++)
            id[i] = i;
    }

    @Override
    public int getSize() {
        return id.length;
    }

    // 获取元素所属集合
    private int getID(int p) {
        if (p &lt; 0 || p &gt;=id.length)
            throw new IllegalArgumentException(&quot;p is illegal&quot;);
        return id[p];
    }

    // 查看元素p和元素q是否所属同一个集合
    @Override
    public boolean find(int p, int q) {
        return getID(p) == getID(q);
    }

    // 合并元素p和元素q
    @Override
    public void union(int p, int q) {
        int pID = getID(p);
        int qID = getID(q);
        if(pID == qID)
            return;
        for (int i=0;i&lt;id.length;i++) {
            if(id[i] == qID)
                id[i] = pID;
        }
    }
}</code></pre><h3 id="Quick-Union概述"><a href="#Quick-Union概述" class="headerlink" title="Quick Union概述"></a>Quick Union概述</h3><p>很显然，之前的Quick Find中查找是否属于同一元素速度很快，而Quick Union则着重于合并的速度。</p>
<p>如图所示，Quick Union的设计思想采用树（森林）进行。每个集合都使用一个根节点进行标识（根节点的父节点为其自身），<strong>在具体存储时，也可以使用一个parent数组来标识其父节点的位置</strong>。因此：</p>
<p><strong>Find操作只需要找到对应节点的根节点判断是否相等即可；</strong></p>
<p><strong>Union操作只需要将一个元素的根节点指向Union操作的另一元素的根节点即可</strong>，具体如图将元素1与元素2进行合并的操作示意</p>
<p><img src="http://cdn.ziyedy.top/image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%B9%B6%E6%9F%A5%E9%9B%86/quickunion.jpg" alt=""></p>
<p>具体实现如下（略去了不关键的几个方法）：这种方法下，find与union操作的时间复杂度都为O(h)，h为树的深度。</p>
<pre><code>public class UnionFind2 implements UF {

    private int[] parent;

    public UnionFind2(int size) {
        parent = new int[size];

        for (int i=0;i&lt;size;i++) {
            parent[i] = i;
        }
    }

    private int getID(int p) {
        if (p &lt; 0 || p &gt;= parent.length)
            throw new IllegalArgumentException(&quot;p is out of bound&quot;);
        while (p != parent[p])
            p = parent[p];
        return p;
    }

    @Override
    public boolean find(int p, int q) {
        return getID(p) == getID(q);
    }

    @Override
    public void union(int p, int q) {
        int pRoot = getID(p);
        int qRoot = getID(q);

        if(pRoot == qRoot)
            return;

        parent[pRoot] = qRoot;
    }
}</code></pre><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>Quick Union的效率与树的深度有关，因此需要尽可能的缩短树的深度，从而提高效率。</p>
<h4 id="思路1：记录每棵树的节点个数"><a href="#思路1：记录每棵树的节点个数" class="headerlink" title="思路1：记录每棵树的节点个数"></a>思路1：记录每棵树的节点个数</h4><p>节点个数多的树<strong>大概率</strong>深度高，因此让节点个数少的集合的根节点指向节点个数大的根节点即可。代码逻辑如下（sz[i]表示以i为根的集合中元素个数）</p>
<pre><code>@Override
public void union(int p, int q) {
    int pRoot = getID(p);
    int qRoot = getID(q);

    if(pRoot == qRoot)
        return;

    if(sz[pRoot] &lt; sz[qRoot]) {
        parent[pRoot] = qRoot;
        sz[qRoot] += sz[pRoot];
    }
    else {
        parent[qRoot] = pRoot;
        sz[pRoot] += sz[qRoot];
    }
}</code></pre><h4 id="思路2：记录没棵树的深度"><a href="#思路2：记录没棵树的深度" class="headerlink" title="思路2：记录没棵树的深度"></a>思路2：记录没棵树的深度</h4><p>思路1的主要漏洞在于节点个数多的树未必深度大，因此可以通过记录树的深度来进行判断，代码逻辑如下（rank[i]表示以i为根的集合的层数）</p>
<pre><code>public void union(int p, int q) {
    int pRoot = getID(p);
    int qRoot = getID(q);

    if(pRoot == qRoot)
        return;

    if(rank[pRoot] &lt; rank[qRoot]) {
        parent[pRoot] = qRoot;
    }
    else if(rank[qRoot] &lt; rank[pRoot]){
        parent[qRoot] = pRoot;
    }
    else {
        parent[pRoot] = qRoot;
        rank[qRoot]++;
    }
}</code></pre><h4 id="思路3：路径压缩（Path-Compression）"><a href="#思路3：路径压缩（Path-Compression）" class="headerlink" title="思路3：路径压缩（Path Compression）"></a>思路3：路径压缩（Path Compression）</h4><p>使用<code>parent[p] = parent[parent[p]]</code>这种逻辑在每次获取根节点时将树的高度缩减。</p>
<pre><code>private int getID(int p) {
    if (p &lt; 0 || p &gt;= parent.length)
        throw new IllegalArgumentException(&quot;p is out of bound&quot;);
    while (p != parent[p]) {
        parent[p] = parent[parent[p]];  // 路径压缩
        p = parent[p];
    }
    return p;
}</code></pre><p>使用递归直接将，每个元素直接连接在集合的根节点上</p>
<pre><code>private int getID2(int p) {
    if (p &lt; 0 || p &gt;= parent.length)
        throw new IllegalArgumentException(&quot;p is out of bound&quot;);
    if(p != parent[p]) {
        parent[p] = getID2(p);
    }
    return parent[p];
}</code></pre>]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>图的概念与存储结构</title>
    <url>/page/graph-basic-knowledge.html</url>
    <content><![CDATA[<h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><p>图是由顶点的集合和顶点之间的边的集合组成的，通常表示为G(V, E)。其中G表示一个图，V是图G中的顶点的集合，E是图G中边的集合。</p>
<p>图按照<strong>边是否有方向</strong>和<strong>边是否带权重</strong>可以分为四类，即有向无权图、有向有权图、无向无权图、无向有权图。</p>
<p><strong>无向图的边</strong>通常使用“()”表示，如A与B之间的边就是(A, B)或(B, A)</p>
<p><strong>有向边</strong>则通常使用“&lt;&gt;”表示，如A到B的边就是&lt;A, B&gt;，这时边有方向性，字母不能够替换。</p>
<p>图按照边的多少分为<strong>稀疏图</strong>和<strong>稠密图</strong>。若任意两个顶点之间都存在边叫<strong>完全图</strong>（无向完全图有n(n-1)/2条边）。没有自环边、没有平行边的图称为<strong>简单图</strong>。</p>
<p>无向图顶点的边数叫做“度”，有向图分为出度和入度</p>
<h3 id="连通图"><a href="#连通图" class="headerlink" title="连通图"></a>连通图</h3><p>在无向图G中，如果对于图中任意两个顶点都是连通的，则称G为连通图。</p>
<p>无向图中极大连通子图称为<strong>连通分量</strong>。其实就是有几个可以互相连通的块，类似于树结构中定义的森林。</p>
<p><strong>连通图的生成树</strong>是一个极小的连通子图，其含有图中全部的V个节点，但只有足以构成一棵树的v-1条边</p>
<h2 id="图的存储方法与实现"><a href="#图的存储方法与实现" class="headerlink" title="图的存储方法与实现"></a>图的存储方法与实现</h2><h3 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h3><p>在邻接矩阵实现中，由行和列都表示顶点，由两个顶点所决定的矩阵对应元素表示这里两个顶点是否相连。如果是无权图的话相连为1，不相连为0，如果是有权图的话该处的数组则为边上所带的权重。</p>
<p><img src="http://cdn.ziyedy.top/image/%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5.png" alt=""></p>
<pre><code>public class AdjMatrix {
    private int V;  // 顶点集合
    private int E;  // 边集合
    private int[][] adj;    // 邻接矩阵

    // 读入数据，构建图
    // 先读入顶点数V，再读入边数E，最后读入边的信息
    public AdjMatrix(String filename) {
        File file = new File(filename);
        try(Scanner scanner = new Scanner(file)) {
            V = scanner.nextInt();
            if(V &lt; 0)
                throw new IllegalArgumentException(&quot;V must be non-negative&quot;);
            E = scanner.nextInt();
            if(E &lt; 0)
                throw new IllegalArgumentException(&quot;E must be non-negative&quot;);
            adj = new int[V][V];

            for (int i=0; i&lt;E; i++) {
                int a = scanner.nextInt();
                validateVertex(a);
                int b = scanner.nextInt();
                validateVertex(b);
                if(a == b)
                    throw new IllegalArgumentException(&quot;Self Loop is Detected&quot;);
                if(adj[a][b] == 1)
                    throw new IllegalArgumentException(&quot;Parallel Edge is Detected&quot;);
                adj[a][b] = 1;
                adj[b][a] = 1;
            }
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }

    // 判断输入数据是否合理
    private void validateVertex(int v) {
        if(v &lt; 0 || v &gt;=V)
            throw new IllegalArgumentException(&quot;Vertex&quot; + v + &quot;is valid&quot;);
    }

    // 输出顶点数
    public int getVertex() {
        return V;
    }

    // 输出边数
    public int getEdge() {
        return E;
    }

    // 判断v1与v2之间存不存在边
    public boolean hasEdge(int v1, int v2) {
        validateVertex(v1);
        validateVertex(v2);
        return adj[v1][v2] == 1;
    }

    // 获取所有邻接的顶点
    public ArrayList&lt;Integer&gt; adj(int v) {
        validateVertex(v);
        ArrayList&lt;Integer&gt; res = new ArrayList&lt;&gt;();
        for (int i=0; i&lt;V; i++) {
            if(adj[v][i] == 1)
                res.add(i);
        }
        return res;
    }

    // 获取顶点v的度
    public int degree(int v) {
        return adj(v).size();
    }
}</code></pre><h3 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h3><p>在邻接列表实现中，每一个顶点会存储一个从它这里开始的边的列表。这个“列表”的具体实现的数据结构可以是链表，也可以是红黑树与哈希表等等。</p>
<p><img src="http://cdn.ziyedy.top/image/%E5%9B%BE%E7%9A%84%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/%E9%82%BB%E6%8E%A5%E8%A1%A8.png" alt=""></p>
<pre><code>public class AdjList {
    private int V;  // 顶点集合
    private int E;  // 边集合
    private LinkedList&lt;Integer&gt;[] adj;  // 邻接表

    // 读入数据，构建图
    // 先读入顶点数V，再读入边数E，最后读入边的信息
    public AdjList(String filename) {
        File file = new File(filename);
        try(Scanner scanner = new Scanner(file)) {
            V = scanner.nextInt();
            if(V &lt; 0)
                throw new IllegalArgumentException(&quot;V must be non-negative&quot;);
            E = scanner.nextInt();
            if(E &lt; 0)
                throw new IllegalArgumentException(&quot;E must be non-negative&quot;);
            adj = new LinkedList[V];

            for (int i=0; i&lt;V; i++) {
                adj[i] = new LinkedList&lt;&gt;();
            }

            for (int i=0; i&lt;E; i++) {
                int a = scanner.nextInt();
                validateVertex(a);
                int b = scanner.nextInt();
                validateVertex(b);
                if(a == b)
                    throw new IllegalArgumentException(&quot;Self Loop is Detected&quot;);
                if(adj[a].contains(b))
                    throw new IllegalArgumentException(&quot;Parallel Edge is Detected&quot;);
                adj[a].add(b);
                adj[b].add(a);
            }
        }
        catch (IOException e) {
            e.printStackTrace();
        }
    }

    // 判断输入数据是否合理
    private void validateVertex(int v) {
        if(v &lt; 0 || v &gt;=V)
            throw new IllegalArgumentException(&quot;Vertex&quot; + v + &quot;is valid&quot;);
    }

    // 输出顶点数
    public int getVertex() {
        return V;
    }

    // 输出边数
    public int getEdge() {
        return E;
    }

    // 判断v1与v2之间存不存在边
    public boolean hasEdge(int v1, int v2) {
        validateVertex(v1);
        validateVertex(v2);
        return adj[v1].contains(v2);
    }

    // 获取所有邻接的顶点
    public LinkedList&lt;Integer&gt; adj(int v) {
        validateVertex(v);
        return adj[v];
    }

    // 获取顶点v的度
    public int degree(int v) {
        return adj(v).size();
    }
}</code></pre><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><table>
<thead>
<tr>
<th>操作</th>
<th>邻接矩阵</th>
<th>邻接表（链表）</th>
<th>邻接表（红黑树）</th>
</tr>
</thead>
<tbody><tr>
<td>空间复杂度</td>
<td>O(V^2)</td>
<td>O(V+E)</td>
<td>O(V+E)</td>
</tr>
<tr>
<td>建图</td>
<td>O(E)</td>
<td>O(E*V)</td>
<td>O(E*log V)</td>
</tr>
<tr>
<td>查看是否相邻</td>
<td>O(1)</td>
<td>O(degree(V))，最差时O(V)</td>
<td>O(log V)</td>
</tr>
<tr>
<td>返回该点的所有相邻节点</td>
<td>O(V)</td>
<td>O(degree(V))，最差时O(V)</td>
<td>O(degree(V))，最差时O(V)</td>
</tr>
</tbody></table>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://www.jianshu.com/p/bce71b2bdbc8" target="_blank" rel="noopener">https://www.jianshu.com/p/bce71b2bdbc8</a></p>
]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>务虚时代下的国贼——李鸿章</title>
    <url>/page/Li_Hongzhang.html</url>
    <content><![CDATA[<center>一</center>

<p>近日看老剧《走向共和》，其前半段多以李鸿章之视角演绎，李鸿章何许人也，若非要集这百年悠悠之口套出几个词来，想必就是汉奸卖国贼之类的了，至少用于普及基本历史常识的历史课本中，作为百年国耻代表的《马关条约》与《辛丑条约》之上，就铸着该君的名字，所以这样说也没错。</p>
<p>所谓汉奸，所谓卖国贼，这两个词至少在中华文化体系下是一种性质非常恶劣的词了吧，这与百年辛酸史，或者说在国家危亡之际国人对所谓“忠臣名将”的向往是分不开的，无论何人，无论何时，只要在身份认同上认为自己是中国人的，对待这些人都可以堂而皇之的啐一口唾沫，道一声“呸”。因为在我们中国人眼中，对历史的“通俗看法”（所谓通俗看法，是指不专门研究某一段历史的普通人，对身处该时段历史人物的主观看法，或说评价）是有底线和顶线的，底线想必就是卖国攘民等龌龊行径了，而顶线就是所谓为国请命的英雄们了，或者说以死明志的气节。当然除此之外，在看待历史人物时，顶线与底线往往还联络着主角道德的好与坏。</p>
<center>二</center>

<p>底线之下，无论之前干过什么，无论这个人作为一个人来讲怎么样，都不值得原谅，参考秦桧与汪精卫（前者还跪着呢）；而顶线之上，有所作为当然更好，但似乎事情做没做成也没有太大所谓，死谏，不趋附权贵，最好再带点文采写些个正气凛然的东西或者稀里糊涂的处在一段展现美好品行的故事中心，都值得树碑立传，万世景仰（至少在大部分国人心目中此类人物的形象是好的），参考孔融。</p>
<p>底线之下，无甚好说，做了过分引人注目的坏事情，难道还会有很多人愿意去考虑你干这坏事之前的心路？大部分人会憎恶你，少部分脑袋勤快点的人会在憎恶中加上一些同情，还有极小部分人会把你当成一个工具，表达他们“看清事实”与“与众不同”的工具，这一类人不谈也罢，他们不懂得当瑕疵多到一种程度时，瑕不掩瑜这个词是不适用的。</p>
<p>但顶线之上就会有一些问题了，在史书中活成这一类的人心念一动就能想出很多，他们大部分都可以作为鲁迅先生笔下我中华的脊梁，但我偏偏把孔融放在这里，为何呢？是因为我想说明这条适用于大众的对历史人物看法的惯性思维多半有些不客观。“孔四岁，能让梨”，这是大部分人都清楚的故事，别的不说，我在痴迷三国的那个年龄，总还是把孔融当成个人物的。但稍稍读点书，以今日之眼光，想瞧得上孔融这个人实在是难，可他却在未来的两千年里享尽英德之名，被无数父母当作启蒙孩子的一个典范，与古往今来无数仁人志士枭雄豪杰并排而立，我以为实在是忝列其中啊。</p>
<center>三</center>

<p>让一个梨便得以流芳千古，这个梨也实在是贵的很啊，让梨这个操作也算是东汉末年一个最成功的炒作了吧。但我实在是不明白大一点的梨子是孔融吃掉还是他哥哥吃掉到底对他们一家或者说对他们兄弟二人能有多大干系呢。非要说的话，难道梨子在东汉越大越香？而大到一定程度会产生口感上的质变？还是一个天生不太喜欢吃梨子的小孩在东汉不太常见？</p>
<p>我以为是后者，毕竟在一个百姓连饭都吃不饱的时代，产生一个类似孔融这种不喜欢梨的小孩实在是困难，这也是保证这件事合理性的唯一解释了，不然孔融一家想必都有癔症。</p>
<p>但遗憾的是，事实来看他们一家就是有癔症，也许是遗传的吧。毕竟硬要说的话，他们的老祖宗孔丘也有癔症，但孔夫子的癔症到底是在我这个两千多年后的后生眼里才能得见的，在孔夫子那个时代就算是癔症也多少有些可爱。但一种病毒也许两千年前无伤大雅甚至可以说是可爱，到一千年前病毒几经变异变成了值得称颂的一个身体特征，而到了一百多年前当一个群体把感染了这个病毒当成荣耀并认为人人便该如此的时候，来了另一群没得病且更强壮的人使得感染这个病毒变成了自然选择的一个逆选项时，有一些病人开始尝试治病但囿于同胞掣肘与病毒几经进化下的狡诈以及自身体内病毒的顽固，失败了，对于这种人，在考虑失败后果之前，我以为首先得感慨一下其知其不可而为之的勇气，至少这是我尊敬孔子的一个重要原因，也是我认为对卖国贼李鸿章，有必要进行另一番议论的原因。</p>
<center>四</center>

<p>以上所述的“癔症”，我想与今年的新冠肺炎多少有些类似，症状复杂容易变异，只是这癔症并不作用在生理上而是作用在精神上。其症状很多，五花八门，但我今天想谈谈的只有务虚。</p>
<p>就像孔融让梨得到赞扬一样，赞扬的不是让梨这个动作而是其谦让的品德。我从不否认谦让是个美德，但让一个历史上实实在在活生生的人，因为这样一个简单的动作就成为了根植一个名族内心千年的道德符号，我认为实在是荒谬了些，哲学上喜欢将一件事情推到极端而后再观察其是否仍然符合某一标准，而长大后的孔融倒着实使这个荒谬的意味更深了些。</p>
<p>几乎没有付出任何代价与个人的努力，一件名门世家随意记录的小小的事情，让一个人毫不费力收获了也许是古往今来来自孩子和家长们最多的赞誉，这不是偶然，而是自先秦到清末国人一直存在的务虚观念，几个小小的汉字，所谓仁义礼智信孝廉，都是好的优秀的修身品德，也从来都是封建时代的国人精英们竞相模仿参照的对象，可仔细想想，这几个字有所谓放之四海而皆准的具体的标准与定义吗？是所谓的标准管用还是历代大儒帝王的一声惊叹或者流传坊间的一段传奇更加管用呢？普通人是实实在在的做事更能得到赞扬还是卧冰求鲤式的“作秀”更能得到赞扬呢？</p>
<p>这些品德确立之初的好坏我无从得知，但由于上述文字解释权等原因，这几个字或者说我中华中世纪所追求的那些抽象的概念，渐渐变为了权力与利益的代言人，成为了统治者所谓推行“王治”的工具（与其说是王治，不如说是愚民）。而随着皇权的愈加集中，传播这些务虚概念的工具，即我们引以为傲的科举，使得无数中世纪乃至近代的国人精英沦为了务虚的奴隶，深陷囹圄而自以为自由（李鸿章有改变很多事物的资本，但他囿于所谓忠君之类的概念敷衍其事含糊其词，想必也是务虚已入骨髓矣）。在没有西方文化冲击的情况下，整个民族和国家都浸沐在这务虚的汤药中，难以自拔。</p>
<p>我本身是一个很懒惰的人，所谓磨洋工的一把好手，所以倘若我在百年千年前的话，肯定会变着花样以把自己弄死为标准去对应这些百姓追求统治者喜欢的概念，也许周围正好来了个大儒书圣，听说了我的故事的话还能把我的事迹记录一些，这样“流芳百世”的难度的确是大，但想必也比实干勤学的概率要大的多，还省去了不论是脑力还是体力带来的困难与麻烦，整不好运气更好点倒是能成为孔融一样的道德符号，实在是妙啊，妙不可言。</p>
<p>既然务虚便能带来一切能够自我宽慰还得社会认可的东西，那作为贵族官员干嘛要务实呢？留着指甲，以商贾为耻，以农桑为耻，以一切实干为耻（当然社会是需要人做实事的，但做实事在我们的文化里受待见吗？所谓君子远庖厨，历朝历代各个英雄豪杰当然也有很多实干的，但实干的基础仍然是这个务虚的社会，这本身就给这个实干抹上了一层务虚的阴影），专注虚妄的经学便能高人一等，有文才胸富万经的为官一处自是高高在上，没有这个本事的寒窗苦读一番也能落个“读书人的偷能叫偷吗”的阿Q式精神胜利，在精神上又是高高在上，都是高高在上，在1793年英国使团来华时是高高在上，在19世纪被英国揍、被日本揍之后还是高高在上。永远都是高高在上，这一词也许便能概括李鸿章一生大部分清廷官员的心理了吧，即使对洋人卑躬屈膝，对着百姓照样还是高高在上，照样是所谓“牧民于野”的当代俊杰。</p>
<p>欺民，罔民，愚民，却将这种行为解释为王化，“王化”过后便使牧民如放牧牛羊那般简单（如此看来儒家的王治倒是能够作为畜牧业一个很好的理论），古语中的这个“牧”字用的很是精髓啊。这也概括了务虚之道能够得以盛行，国人能够自欺欺人的原因，在这样一个务虚时代之末，则有国贼李鸿章。</p>
<center>五</center>

<p>梁任公先生在1901年为李鸿章做的传记里，有这样一段话：</p>
<blockquote>
<p><em>夫李鸿章果足称为中国第一人与否吾不敢知，而要之现今五十岁以上之人，三四品以上之官，无一可以望李之肩背者，则吾所能断言也。李之死，于中国全局有关系与否吾不敢知，而要之现在政府失一李鸿章，如虎之丧其伥，前途岌岌，愈益多事，此又吾所敢断言也</em></p>
</blockquote>
<p>加之记述一下李鸿章光绪元年所上之奏疏：</p>
<blockquote>
<p><em>近时拘谨之儒，多以交涉洋务为涴人之具；取巧之士，又以引避洋务为自便之图。若非朝廷力开风气，破拘挛之故习，求制胜之实际，天下危局，终不可支，日后乏才，且有甚于今日者。以中国之大，而无自立之时，非惟可忧，抑亦可耻</em></p>
</blockquote>
<p>摘录至此，不由扼腕感慨百多年前洋务之艰难，掣肘之猖獗。</p>
<p>引避洋务以自便，多轻松的自便之法啊，从前务虚以留其名，尚且还得付出诸多代价，而洋人来了后为一个高风亮节之名，却只需对奇技淫巧表达不屑，对操办洋务以自强求富之人以鄙夷眼光视之。多轻便啊，居庙堂之高则上书参劾，处江湖之远则煽民怨怼，永远站在务虚下道德的制高点，倒颇像今天的键盘侠，下笔滔滔如有千言，若问韬略胸无一策。可惜的是今天的键盘侠倒是稍讲道理的人就会心生厌恶，而那个时代做一个真正杀人的键盘侠倒成了政治正确。</p>
<p>而“求制胜之实际”这句话倒着实让我奇怪，我实在不知道制胜的实际为什么要求。在一个逝者如斯夫的三维世界，什么东西都是一锤子买卖，制胜难道还有实际与不实际的分别？一个管理着四亿五千万人口的朝廷，于国事竟要以“实际”与否为争论点，实在荒唐（也许以往务虚之实际对洋人不管用吧，毕竟洋人大部分人都不给你“牧”，明明这才是现在看来正常的表现到了晚清士大夫眼中成了蛮夷无廉耻的表现，估计他们也很苦恼吧），也难怪任公先生有以上断言了。</p>
<p>这就是那个时代我国的头号国贼了，倒不知他卖的国是虚妄概念上的国还是实际意义上的国了，不知道满清朝廷在马关之后的朝堂上有没有这一议论。</p>
<center>六</center>

<p>说李是国贼的论据，我以为归纳起来大约有四个大点。其一为边防塞防之争；其二为甲午战争之败；其三为辛丑条约之耻；其四为死后余产之巨。针对这几点，我也想简单谈谈我的看法。</p>
<p>关于边防塞防之争，以今日结果的眼光来看李鸿章所谓的“放弃新疆”自然是妥妥卖国行为，引述其作此决策的理由大致如下：</p>
<blockquote>
<p><em>历代备边，多在西北，其强弱之势，主客之形，皆适相埒，且犹有中外界限。今则东南海疆万余里，各国通商传教，往来自如，麇集京师，及各省腹地，阳托和好之名，阴怀吞噬之计，一国生事，诸国构煽，实为数千年来未有之变局。轮船、电报之速，瞬息千里，军器、机事之精，工力百倍，又为数千年来未有之强敌。外患之乘，变幻如此，而我犹以成法制之，譬如医者疗疾，不问何症，概投之以古方，诚未见其效也</em></p>
</blockquote>
<p>彼时背景正为日本寻衅侵略台湾，海防压力巨大，若忽略新疆一事，我以为兴建海防实在算是清末洋务少有的高瞻远瞩之举了，而对于新疆问题，李鸿章倒似乎想以外交途径解决（这也是他的惯用伎俩了，甲午之败这也是因素之一）。唉，彼时之人哪里懂得弱国无外交的道理呢，如此看来若无左宗棠收复新疆，也许新疆在那时候就成为了永远收不回的东三省了吧（九一八事变后民国政府也企图通过外交途径解决东北问题）。</p>
<p>也正应如此，世人往往厚左而薄李，但以我之见，左宗棠与李鸿章并无大分别，李并非一意放弃塞防而是以为边防更为紧迫，而左亦非务虚守旧之人，只是认为新疆之失已迫在眉睫而海上之难尚可以时日斡旋。边防塞防之争，与其说是善恶之争，倒不如说是厉害得失之争。可叹啊，百年后的课本中，左宗棠成了英雄，而李鸿章却成了国贼，实在只是命长与命短的分别啊。</p>
<p>而对甲午战争之败，我没有什么好说的，整个战争我仿佛看到的不是战争，而是一帮小孩在拿人命、鲜血与一个民族的尊严为筹码玩过家家，仿佛这个国，不是实际意义上的国。世人皆知甲午海战北洋水师全军覆没，是以为耻，却不知陆军在朝鲜更是一败涂地。对此战的总结梁任公先生在为李所作传记中已经分析的很透彻了，我不再赘言，遂摘录如下。</p>
<blockquote>
<p><em>当中日战事之际，李鸿章以一身为万矢之的，几于身无完肤，人皆欲杀。平心而论，李鸿章诚有不能辞其咎者，其始误劝朝鲜与外国立约，昧于公法，咎一；既许立约，默认其自主，而复以兵干涉其内乱，授人口实，咎二；日本既调兵，势固有进无退，而不察先机，辄欲倚赖他国调停，致误时日，咎三；聂士成请乘日军未集之时，以兵直捣韩城以制敌而不能用，咎四；高升事未起之前，丁汝昌请以北洋海军先鏖敌舰，而不能用，遂令反客为主，敌坐大而我愈危，综其原因，皆由不欲衅自我开，以为外交之道应尔，而不知当甲午五六月间，中日早成敌国，而非友邦矣，误以交邻之道施诸兵机，咎五；鸿章将自解曰：量我兵力不足以敌日本，故惮于发难也。虽然，身任北洋整军经武二十年，何以不能一战？咎六；彼又将自解曰：政府掣肘，经费不足也。虽然，此不过不能扩充已耳，何以其所现有者，如叶志超、卫汝贵诸军，素以久练著名，亦脆弱乃尔，且克减口粮盗掠民妇之事，时有所闻，乃并纪律而无之也，咎七；枪或苦窳，弹或赝物，弹不对枪，药不随械，谓从前管军械局之人皆廉明，谁能信之，咎八；平壤之役，军无统帅，此兵家所忌，李乃蹈之，咎九；始终坐待敌攻，致于人而不能致人，畏敌如虎，咎十；海军不知用快船快炮，咎十一；旅顺天险，西人谓以数百兵守之，粮食苟足，三年不能破，乃委之于所亲昵阘冗恇怯之人，闻风先遁，咎十二。此皆可以为李鸿章罪者。若夫甲午九十月以后，则群盲狂吠，筑室道谋，号令不出自一人，则责备自不得归于一点。若尽以为李鸿章咎，李固不任受也。又岂惟不任受而已，吾见彼责李罪李者，其可责可罪，更倍蓰于李而未有已也。是役将帅无一人不辱国，不待言矣。然比较于百步五十步之间，则海军优于陆军，李鸿章部下之陆军，又较优于他军也。</em></p>
</blockquote>
<p>战争之后，尚有广东水师向日本索要被俘舰只，理由竟是此次战役与广东无涉。荒唐至此，毫无国家民族观念，以五十步笑百步之典，李倒着实是那五十步之人，但一个国家只有五十步与百步的分别，岂不谬哉！</p>
<p>至于辛丑条约，我以为无甚好说，前两者对李都有切实可责可恨之处，凡是认为李无一点错误责任，无一点卖国嫌疑者都是巧言令色之人。惟此辛丑条约，说李是代国背锅言辞尚可牵强而去。只是可惜可恨啊，面对务实之世界，务虚者仍活在往日虚幻的天朝大国的旧梦里，可惜是针对那时被虚妄的概念奴役却自以为自由的愚民，可恨是针对朝堂上自私自利毫无理性的那几家几姓。</p>
<p>最后也就是死后遗产之巨了，关于这个我没有观点，也没做什么考证，四千万家产的言论没有什么根据，但清正廉洁的说法也就是自娱自乐了，而对于因为李鸿章财产甚多而输了甲午战争的言论，我也无话可说，见解如此，与键盘侠无异。以下摘录任公所作传记中的一段话，仁者见仁，智者见智吧。</p>
<blockquote>
<p><em>世人竞传李鸿章富甲天下，此其事殆不足信，大约数百万金之产业，意中事也。招商局、电报局、开平煤矿、中国通商银行，其股份皆不少，或言南京、上海各地之当铺银号，多属其管业云</em></p>
</blockquote>
<p>以上四点，第一、第三、第四点我认为以此为依据对李进行口诛笔伐只是视李为国贼带来的惯性思维所致，即在摆出论据之前心中已有答案，而后用这些论据中的点去套已有的结论。这样做虽然看起来不够客观，但我认为实在是人心所向。而第二点则是“国贼论”的核心，也是李鸿章以及所谓大清帝国的转折点吧，在这一点上李鸿章有直接责任。从前被英法等一流列强欺负，但装饰门面倒还对的起“帝国”这两个字的隐形含义，今而兴洋务练出的新军在日本人面前不堪一击，以使敌人在朝鲜都不相信战胜的就是所谓清廷按照西法练成的精锐部队。</p>
<p>由此看来，这些活在近代的中古士大夫在务虚本领之上倒还是实在的啊，能够做到让外人不辨雌雄。</p>
<center>七</center>

<p>对李鸿章，梁任公先生总结其为“时势所造之英雄，非造时势之英雄”，又对其一生事迹评价为“不学无术，不敢破格，是其所短也；不避劳苦，不畏谤言，是其所长也”。</p>
<p>是英雄造时势还是时势造英雄，这一直可以视为是一个悖论问题，这一问题有诸多解法的原因其实也只是因为对英雄与时势有诸多不同的定义与见解而已。</p>
<p>英雄是什么，一怒之下伏尸百万流血千里的应该能算，这是就其权威而论的；率性任侠义气为先的想必也能算，这是就其个性担当而言的；富国强兵振兴朝政的一定能算，这是就其能力而论的；而为国请命鞠躬尽瘁死而后已的也一定能算，这是就其一片赤子之心而论的。这四点似乎都没错，但偏偏国贼李鸿章似乎与后三点都沾些边，对部下讲情义，为国事不避艰难，临死之前尚在为国事操心，按这个道理，他该是英雄啊，在通俗历史评价上他该是顶线以上的人啊，怎么会落得底线以下的看法与待遇呢？还是引用任公先生的话。</p>
<blockquote>
<p><em>十九世纪列国皆有英雄，而我国独无一英雄，则吾辈安得不指鹿为马，聊自解嘲，翘李鸿章以示于世界曰，此我国之英雄也。呜呼！亦适我国之英雄而已矣，亦适成为我国十九世纪以前之英雄而已矣</em></p>
</blockquote>
<p>是啊，自始皇帝嬴政开创中央集权政体之日起，五经四书浸染之下的千年务虚时代，又哪有什么英雄造时势的事情呢？始皇殁后有项羽，一个勇武过人的英雄在乎的是如何让锦衣不夜行，在意这种虚妄的概念使他重新推行分封。后有刘邦，有曹操，有李世民，有赵匡胤，有朱洪武，再有所谓康乾盛世，有所谓同治中兴，那么多个皇帝之下有那么多个能人猛士堪称英雄，可有谁真正造就过时势吗？似乎有，如周瑜赤壁的那一把火，似乎又没有，因为我只看到了一个个朝代的更替与牧民锁链的加重。也许以百年局部的眼光来看，总有公瑾一般的豪杰改造时势，但以千年民族国家的眼光来看，十九世纪前所谓的英雄，不过是在同一片天空之下翻手为云覆手为雨罢了，他们从没有改天换日的见识与气魄。</p>
<p>话虽这样说，但英雄在他们的时代仍然是英雄，非要以今日之眼光视昨日之旧人未免落入历史虚无主义的窠臼。而对李鸿章以国贼的态度进行苛责，与此同理，无非是以今日之评价观点视旧时之英雄罢了。在对李一系列失误的讨论之外，我认为不应该让一个旧时代的先行者为他所处的整个时代背锅。</p>
<p>但话又说回来，这样一个不避劳苦的旧时代先行者，究其一生却为何在历史上仍落个身败名裂的下场呢？</p>
<p>千年务虚时代，治经论典自然是务虚，可人毕竟是活在现实世界的啊，“务实”必不可少，闻鸡起舞者有之，改政变法者有之，“格物致知”者亦有之，为何集数千年这亿万之人，却无一个堪当变务虚时势为务实的英雄呢？自是千年务虚痼疾已深，不彻底打碎更变实在是无从谈起啊。否定了这一点，就是对20世纪我们中国人长达一个世纪的更革奋斗视而不见。</p>
<p>而以李鸿章为汉奸国贼者，必为甲午之败辛丑之耻痛惜扼腕，仿佛杀李则能改变战局避免国耻，而清廷则仍是堂堂正正的大清帝国，这实在是癔梦啊。想当造时势之英雄，则必须要能真正的打破务虚学而有术，这在当时几乎是与整个千年文化积习为敌，事实证明李鸿章这种务虚时代的实干家不行，翁同龢这种务虚时代的所谓君子、康有为这种务虚时代所谓的改革家都不行，那些务虚时代的小人就更不必说了。</p>
<p>以李鸿章之务实敢干不辞辛劳生于务虚时代都难以学而有术，洋务半生尚“不识国民之原理，不通世界之大势，不知政治之本原”，一生兢兢业业如履薄冰都难以在后世摆脱一个“国贼”的骂名，可见务虚痼疾程度之深了。以务虚时代之英雄而成务实时代之国贼，英雄和国贼果然有所谓巨大的间隙吗？还是李鸿章生平前后的主流文化之间有这般巨大的间隙呢？这百年来，那么多只如鲁迅先生般的如椽巨笔，才堪堪扭转千年痼疾在人心中的荼毒之深，将这种荼毒所表现出的后果让李一人一力承担，我觉得实在是肤浅过分的言论。</p>
<p>唉，以旧英雄之身份而成新时代之国贼，以今日之眼光，到底该视为李鸿章的过错还是千年务虚文化的过错呢？</p>
<center>八</center>

<p>作为一个中国人，对历史总会心存一些假如（毕竟有强汉盛唐，现在的口号也还是复兴）。总有人会说满清误国，认为遇上19世纪那千年未有之变局的假如不是满清朝廷而是汉人王朝情况会完全不同；也有人会想若遭遇此事的中国统治者不是咸丰，不是光绪，不是慈禧，而是秦皇汉武唐宗宋祖，结局也会不一样；还有人说明朝的资本主义萌芽是被满清给消灭的，否则中国也会自然而然的成为近代西方那样发达的资本主义国家。</p>
<p>诸如此类的想法很多，但历史没有偶然，即使有偶然，在一个模拟器中能够重现历史，让那些明君圣君放弃一家一姓特权，让那些世家门阀放弃所有地方权益的概率能有多少呢？即使有人真的愿意，他能够扳的过整个旧文化的手腕吗？（过继当上皇帝的想尊自己的生父历朝历代士大夫都会罗里吧嗦的，没有点手腕的皇帝连这种事都搞不定，即使手腕通天难道能搞定整个文化变革的事情吗？因此在中国这种务虚文化的千年体系下，自上而下的改革是不可能行的通的，想变革只有改变一个民族的思想，这又哪里是一个人能够办得到的呢），孟子说过“人之所以异于禽兽者几希，庶民去之，君子存之”，孟子当然是惯于骂人禽兽，而放弃他这种庶民君子的成见，还智于百姓，让“君子”与“禽兽”平起平坐，历代有君王与权臣能够做到吗？（也许中国能够依赖如明治天皇那样的明君通过变革依靠广阔的土地在19世纪成为列强，但这种强国方式与英美等国还是有根本区别，日本明治维新后是变强了，但仍然有华族这种旧时代产物，我以为仍然带着野蛮不理性的气息，以中国之大，如此，更甚矣，仍然只会成为如沙皇俄国那样的纸老虎）王莽的改制引来了千古骂名只是因为其制过激而使掣肘过厉，而“科举”的产生也只是得益于旧门阀势力的削弱，而这种削弱，无不是血与铁的结果，而后再看19世纪末李鸿章所遭之非议，守旧势力在19世纪到20世纪的关口还指望着把洋人赶走继续上古时期的统治方法。这是他们幼稚吗？不是，实在是千年务虚积疾过深，使得四万万国人人人为鸵鸟而不自知，大才如严复尚且崇尚科举，务实如李鸿章尚且惋惜自己一生没做成军机大臣。</p>
<p>在这种千年务虚观念深入骨髓的情况下，小修小补有用吗？剜肉补疮有用吗？我看把血全换了都未必有用。在这种情况下，将千年务虚积累下导致的癔病产生的痛苦全部归咎给李鸿章这种只会小医小补的郎中，合理吗？骂李是国贼，那必须带上当时满朝文武，带上当时被欺罔了数千年的四万万百姓，带上数千年政治文化风俗的方方面面。雪崩之时，没有一片雪花是无辜的，但作为压死骆驼的最后一根稻草，难道李鸿章留给历史的意义只是让后人怒斥痛骂吗？</p>
<p>十九世纪以前的英雄，配上了务虚思想引导下的务实，却成了日后人们眼中的国贼，应该感到悲哀吗？不应该感到悲哀吗？对着那个由务虚向务实转化的时代，是继续痛斥那务虚时代下的国贼或者说英雄，还是应该对我们19世纪以前的文化多做一些反思呢？</p>
<p>后者，我以为才是李鸿章这个历史车轮扭动间隙下产生的矛盾人物该给我们带来的意义。</p>
<center>后记</center>

<p>本文基本可以视为是《走向共和》电视剧前半段以及梁任公先生的传记《李鸿章》的观后感吧，写之前没想过要什么纲领也没有确定什么中心论点，写到现在洋洋洒洒有八千多字，也渐渐形成了一个很不清晰的脉络吧。</p>
<p>全文的中心其实也就是以李鸿章个人在通俗历史评价上的矛盾为引，引出对19世纪前中华传统文化的反思吧。一个代表着那段历史的人物，以两种文化的眼光看待，会得出英雄和国贼两个迥异的看法，这种激烈的矛盾也着实可以说明旧文化的一些荒谬之处了。</p>
<p>当然全文只是借用了务实与务虚这一对矛盾在19世纪末那个节点上所爆发出来的强弱态势，并没有对中西文化或者说中国传统文化与现代文化进行所谓优劣对比及形成原因说明。因为非要进行详细的对比说明的话，我认为恐怕得从先秦思想和古希腊哲学的迥异说起，那话题就大了，所以全文对这种矛盾在我国中世纪的表现仅仅以叙代议，所表达的仅仅只是矛盾本身而不是对矛盾产生原因的分析论证。</p>
<p>全文以李鸿章为引，但对李鸿章一生的事迹仅仅摘捡了其作为国贼原因的几个大点论述，如果对李鸿章或那个时代感兴趣，着实推荐任公先生的传记《李鸿章》（即《同光以来大事记》），其文作于1901年李鸿章死后不久，集合了那个时代的视角与梁公极其客观的评价，我认为堪称是了解李鸿章的第一手资料，也是了解那个时代的一个不错的POV。</p>
<p>再来谈谈文章的另一个引子孔融，也许以知人论世而言他该算是在文学上卓有成就（建安七子之首），气节上也不错（堪称魏晋风骨，虽然我以为孔融这种气节不要也罢）。我在文章中如此苛责他说实话与大众苛责李鸿章也许没有什么本质的区别吧，要说区别，其实也是因为孔融所代表的这种务虚做派着实让我disgusting吧（细细想来，古人会写字的不多，所以键盘侠才会如此弥足珍贵吧），之前读过一些孔融的史料，有机会会写写我为啥那么不喜欢孔融，在此不再说明了。</p>
<p>最后，谈谈为何我写着写着就以务虚作为一个主线了吧，这个原因说来惭愧，实在是自己的务虚行为所致，如今三月，还有三个月本科就该画上句号，但纵观自己这四年，基本没干成什么实在的事情（书读的好当然是实在的，游戏打出了名堂也是实在的啊，唯独什么都没做的像样倒是值得思考的一个点），遂作此文以自勉。</p>
<p>子夜，记于2020.3.4 九江。希望疫情退散武汉加油。</p>
]]></content>
      <categories>
        <category>瞎侃</category>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/page/ds-segment-tree.html</url>
    <content><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>线段树，也叫区间树，是一个完全二叉树，它在各个节点保存一条线段（即“子数组”），因而常用于解决<strong>数列维护问题</strong>，它基本能保证每个操作的复杂度为O(lgN)。</p>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>1、线段树是一棵高度平衡的二叉树，通常为完全二叉树（叶子节点不一定在同一层，但可以通过将最后一层非叶子节点的值视为null进行构造）</p>
<p>2、线段树的每一个结点都代表一个区间。父结点所代表的区间是两个子结点的和（或者其他操作，可以自己定义）。兄弟结点所代表的区间相互不重叠。根结点代表整个区间</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>线段树是一种基于分治算法的二叉树。每个结点维护一个区间，以及在该区间内的数据信息。在当前结点，它的区间是[left,right]，则它的两个子结点的区间分别为[left, mid]，[mid+1, right]。由于采用了分治的思想，在进行操作时每一层至多访问两个结点，极大优化了效率。</p>
<p>同时，根据完全二叉树的规律，<strong>如果原始数组有n个元素，则要使用数组对线段树进行存储的话，需要4n的空间</strong>。</p>
<h3 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h3><p>1、构造线段树</p>
<p>2、区间查询</p>
<p>3、区间修改</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="基本实现"><a href="#基本实现" class="headerlink" title="基本实现"></a>基本实现</h3><p>1、构造用于定义线段树计算方法的接口</p>
<pre><code>public interface Merger&lt;E&gt; {
    E merge(E a, E b);
}</code></pre><p>2、线段树类的基本实现</p>
<pre><code>public class SegmentTree&lt;E&gt; {

    private E[] tree;    // 存储线段树
    private E[] data;    // 存储原始数据
    private Merger&lt;E&gt; merger;    // 定义线段树计算方法

    public SegmentTree(E[] arr, Merger&lt;E&gt; merger) {

        this.merger = merger;

        data = (E[])new Object[arr.length];
        for (int i = 0; i&lt; arr.length; i++) {
            data[i] = arr[i];
        }

        tree = (E[])new Object[4 * arr.length];
        buildSegmentTree(0, 0, data.length-1);    // 构造线段树

    }

    // 获取左孩子索引
    private int leftChild(int index) {
        return 2 * index + 1;
    }

    // 获取右孩子索引
    private int rightChild(int index) {
        return 2 * index + 2;
    }

}</code></pre><h3 id="构造线段树"><a href="#构造线段树" class="headerlink" title="构造线段树"></a>构造线段树</h3><p>使用递归构造线段树，整个过程有点像使用一个有序数组构造二叉搜索树。</p>
<pre><code>private void buildSegmentTree(int treeIndex, int l, int r) {
    if(l == r) {
        tree[treeIndex] = data[l];
        return;
    }
    int leftTreeIndex = leftChild(treeIndex);
    int rightTreeIndex = rightChild(treeIndex);
    int mid = l + (r - l) / 2;
    buildSegmentTree(leftTreeIndex, l, mid);
    buildSegmentTree(rightTreeIndex, mid+1, r);
    tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]);
}</code></pre><h3 id="区间查询"><a href="#区间查询" class="headerlink" title="区间查询"></a>区间查询</h3><p>也是使用递归进行查询，分三种情况进行讨论。</p>
<pre><code>// 返回[queryL, queryR]的值
public E query(int queryL, int queryR) {
    if(queryL &lt; 0 || queryL &gt;= data.length ||
        queryR &lt; 0 || queryR &gt;= data.length || queryL &gt; queryR) {
        throw new IllegalArgumentException(&quot;Index is illegal&quot;);
    }
    return query(0, 0, data.length-1, queryL, queryR);
}

private E query(int treeIndex, int l, int r, int queryL, int queryR) {
    if(l == queryL &amp;&amp; r == queryR) {
        return tree[treeIndex];
    }
    int mid = l+(r-l)/2;
    int leftTreeIndex = leftChild(treeIndex);
    int rightTreeIndex = rightChild(treeIndex);
    if(queryL &gt;= mid + 1) {
        return query(rightTreeIndex, mid+1, r, queryL, queryR);
    }
    else if(queryR &lt;= mid) {
        return query(leftTreeIndex, l, mid, queryL, queryR);
    }
    E leftResult = query(leftTreeIndex, l, mid, queryL, mid);
    E rightResult = query(rightTreeIndex, mid+1, r, mid+1, queryR);
    return merger.merge(leftResult, rightResult);
}</code></pre><h3 id="区间修改"><a href="#区间修改" class="headerlink" title="区间修改"></a>区间修改</h3><pre><code>// 将index位置的值，更新为e
public void set(int index, E e) {
    if(index &lt; 0 || index &gt;= data.length)
        throw new IllegalArgumentException(&quot;Index is illegal&quot;);
    data[index] = e;
    set(0, 0, data.length-1, index, e);
}

// 在以treeIndex为根的线段树中更新index的值为e
private void set(int treeIndex, int l, int r, int index, E e) {
    if(l == r) {
        tree[treeIndex] = e;
        return;
    }
    int mid = l + (r-l)/2;
    int leftTreeIndex = leftChild(treeIndex);
    int rightTreeIndex = rightChild(treeIndex);
    if(index &gt;= mid+1)
        set(rightTreeIndex, mid+1, r, index, e);
    else
        set(leftTreeIndex, l, mid, index, e);
    tree[treeIndex] = merger.merge(tree[leftTreeIndex], tree[rightTreeIndex]);
}</code></pre>]]></content>
      <categories>
        <category>计算机基础</category>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
</search>
